// Decompiled with JetBrains decompiler
// Type: WindowsApplication1.HandyFunctionsclass
// Assembly: WindowsApplication1, Version=1.0.8020.28903, Culture=neutral, PublicKeyToken=null
// MVID: F52869E5-0850-48AD-BBBE-68E7A4900AFE
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Shadow Empire\ShadowEmpire.exe

// usingICSharpCode.SharpZipLib.Checksums;
// usingICSharpCode.SharpZipLib.Core;
// usingICSharpCode.SharpZipLib.Zip;
// usingMicrosoft.VisualBasic;
// usingMicrosoft.VisualBasic.CompilerServices;
// usingSystem;
// usingSystem.Diagnostics;
// usingSystem.Drawing;
// usingSystem.Drawing.Drawing2D;
// usingSystem.Drawing.Imaging;
// usingSystem.IO;
// usingSystem.Net;
// usingSystem.Runtime.CompilerServices;
// usingSystem.Runtime.InteropServices;
// usingSystem.Security.Cryptography;
// usingSystem.Text;
// usingSystem.Threading;
// usingSystem.Windows.Forms;

namespace WindowsApplication1
{
  pub class HandyFunctionsclass
  {
     game: GameClass;
     data: DataClass;
     bool[] htempb;
     byte[] tempTest;
     int[] tempStrlist;
     bool tempStrlistSet;
     tempHexLibVarSnowIsSet: i32;
     tempHexLibVarSnowValue: i32;
     tempstringlist: Vec<String>;

    [DllImport("kernel32", EntryPoint = "GetDiskFreeSpaceExA", CharSet = CharSet.Ansi, SetLastError = true)]
     static extern GetDiskFreeSpaceEx: i32(
      [MarshalAs(UnmanagedType.VBByRefStr)]  lpDirectoryName: String,
       long lpFreeBytesAvailableToMe,
       long lpTotalNumberOfBytes,
       long lpTotalNumberOfFreeBytes);

    pub HandyFunctionsclass(tgame: GameClass)
    {
      this.htempb = new bool[10000];
      this.tempTest = new byte[1];
      this.tempStrlist = new int[1];
      this.tempStrlistSet = false;
      this.tempHexLibVarSnowIsSet = -1;
      this.tempHexLibVarSnowValue = 0;
      this.game = tgame;
    }

    pub CovertNumberToLetter: String(numy: i32)
    {
      strArray: Vec<String> = new string[29]
      {
        null,
        "a",
        "b",
        "c",
        "d",
        "e",
        "f",
        "g",
        "h",
        "i",
        "j",
        "k",
        "l",
        "m",
        "n",
        "o",
        "p",
        "q",
        "r",
        "s",
        "t",
        "u",
        "v",
        "w",
        "x",
        "y",
        "z",
        null,
        null
      };
      letter: String;
      if (numy < 1)
        letter = "?";
      else if (numy <= 26)
      {
        letter = strArray[numy].ToUpper();
      }
      else
      {
        let mut index1: i32 =   Math.Round(Math.Floor( numy / 26.0));
        upper: String = strArray[index1].ToUpper();
        let mut index2: i32 =  numy - index1 * 26;
        letter = upper + strArray[index2];
      }
      return letter;
    }

    pub fn GetBattlegroupTemplate(regNr: i32) -> i32
    {
      let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
      for (let mut battlegroupTemplate: i32 =  0; battlegroupTemplate <= historicalUnitCounter; battlegroupTemplate += 1)
      {
        if (this.game.Data.HistoricalUnitObj[battlegroupTemplate].TempRegime == regNr)
        {
          if (battlegroupTemplate == 27)
            battlegroupTemplate = battlegroupTemplate;
          if (this.game.Data.HistoricalUnitObj[battlegroupTemplate].Model && this.game.Data.HistoricalUnitObj[battlegroupTemplate].SubParts[0] == -1 && this.game.Data.HistoricalUnitObj[battlegroupTemplate].SubParts[1] == -1 && this.game.Data.HistoricalUnitObj[battlegroupTemplate].SubParts[2] == -1 && this.game.Data.HistoricalUnitObj[battlegroupTemplate].BattleGroup > 0)
            return battlegroupTemplate;
        }
      }
      return -1;
    }

    pub CheckIsBattlegroup: bool(unr: i32)
    {
      let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
      if (historical > -1)
      {
        let mut modelMaster: i32 =  this.game.Data.HistoricalUnitObj[historical].ModelMaster;
        if (modelMaster > -1)
        {
          if (this.game.Data.HistoricalUnitObj[modelMaster].BattleGroup > 0)
            return true;
        }
        else if (this.game.Data.HistoricalUnitObj[historical].BattleGroup > 0)
          return true;
      }
      return false;
    }

    pub fn CheckAttachTransportValidity()
    {
      if (!( this.game.Data.RuleVar[474] > 0.0 & this.game.Data.Product >= 6))
        return;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
      {
        let mut index2: i32 =  index1;
        if (this.game.Data.UnitObj[index2].TransportCounter > -1)
        {
          for (let mut transportCounter: i32 =  this.game.Data.UnitObj[index2].TransportCounter; transportCounter >= 0; transportCounter += -1)
          {
            let mut transport: i32 =  this.game.Data.UnitObj[index2].TransportList[transportCounter];
            if (!(this.game.Data.UnitObj[transport].X == this.game.Data.UnitObj[index2].X & this.game.Data.UnitObj[transport].Y == this.game.Data.UnitObj[index2].Y))
              this.game.ProcessingObj.DetachUnit(transport, index2);
          }
          for (let mut transportCounter1: i32 =  this.game.Data.UnitObj[index2].TransportCounter; transportCounter1 >= 0; transportCounter1 += -1)
          {
            let mut num1: i32 =  this.game.HandyFunctionsObj.GiveTransporterMaxCarry(index2);
            let mut num2: i32 =  this.game.HandyFunctionsObj.GiveTransporterCurrentCarry(index2);
            let mut num3: i32 =  this.game.HandyFunctionsObj.GiveTransporterMaxManpowerCarry(index2);
            let mut num4: i32 =  this.game.HandyFunctionsObj.GiveTransporterCurrentManpowerCarry(index2);
            if (num2 > num1 & num4 > num3)
            {
              SimpleList simpleList = SimpleList::new();
              let mut transportCounter2: i32 =  this.game.Data.UnitObj[index2].TransportCounter;
              for (let mut index3: i32 =  0; index3 <= transportCounter2; index3 += 1)
              {
                let mut transport: i32 =  this.game.Data.UnitObj[index2].TransportList[index3];
                let mut tweight: i32 =  this.game.HandyFunctionsObj.GiveAttachablesWeight(transport);
                simpleList.Add(transport, tweight);
              }
              simpleList.ReverseSort();
              this.game.ProcessingObj.DetachUnit(simpleList.Id[0], index2);
            }
            else
              break;
          }
        }
      }
    }

    pub CanAttach: bool(unr: i32) => this.game.Data.UnitObj[unr].attachedTo <= -1 && this.game.Data.UnitObj[unr].TransportCounter <= -1 && this.game.Data.UnitObj[unr].OnBoard <= -1 && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && !this.game.HandyFunctionsObj.HasUnitAirSF(unr) && this.GiveAttachablesList(unr).Counter > -1;

    pub CanTransport: bool(unr: i32)
    {
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      if (this.game.Data.UnitObj[unr].IsHQ)
        return false;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        let mut powerPts: i32 =  this.game.Data.SFTypeObj[type].PowerPts;
        let mut num3: i32 =  this.game.Data.transportMovementType[this.game.Data.SFTypeObj[type].MoveType];
        num2 += powerPts * qty;
        if (num3 == 1)
          num1 += powerPts * qty;
      }
      return (num2 <= 0 ? 0.0 :   Math.Round( (100 * num1) /  num2)) >=  this.game.Data.RuleVar[474];
    }

    pub fn GiveTransporterMaxCarry(unr: i32) -> i32
    {
      let mut num: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        let mut powerPts: i32 =  this.game.Data.SFTypeObj[type].PowerPts;
        let mut moveType: i32 =  this.game.Data.SFTypeObj[type].MoveType;
        let mut carryCap: i32 =  this.game.Data.SFTypeObj[type].CarryCap;
        if (this.game.Data.transportMovementType[moveType] == 1)
          num += carryCap * qty;
      }
      return num;
    }

    pub fn GiveTransporterCurrentCarry(unr: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut transportCounter: i32 =  this.game.Data.UnitObj[unr].TransportCounter;
      for (let mut index: i32 =  0; index <= transportCounter; index += 1)
      {
        let mut num2: i32 =  this.GiveAttachablesWeight(this.game.Data.UnitObj[unr].TransportList[index]);
        num1 += num2;
      }
      return num1;
    }

    pub fn GiveAttachablesWeight(unr: i32) -> i32
    {
      SimpleList simpleList = this.GiveAttachablesList(unr);
      let mut num1: i32 =  0;
      let mut counter: i32 =  simpleList.Counter;
      for (let mut index: i32 =  0; index <= counter; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[simpleList.Id[index]].Type;
        let mut num2: i32 =  simpleList.Weight[index];
        let mut moveType: i32 =  this.game.Data.SFTypeObj[type].MoveType;
        let mut weight: i32 =  this.game.Data.SFTypeObj[type].Weight;
        num1 += num2 * weight;
      }
      return num1;
    }

    pub fn GiveTransporterMaxManpowerCarry(unr: i32) -> i32
    {
      let mut num: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        let mut powerPts: i32 =  this.game.Data.SFTypeObj[type].PowerPts;
        let mut moveType: i32 =  this.game.Data.SFTypeObj[type].MoveType;
        let mut manpowerCarry: i32 =  this.game.Data.SFTypeObj[type].manpowerCarry;
        if (this.game.Data.transportMovementType[moveType] == 1)
          num += manpowerCarry * qty;
      }
      return num;
    }

    pub fn GiveTransporterCurrentManpowerCarry(unr: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut transportCounter: i32 =  this.game.Data.UnitObj[unr].TransportCounter;
      for (let mut index: i32 =  0; index <= transportCounter; index += 1)
      {
        let mut num2: i32 =  this.GiveAttachablesManpowerWeight(this.game.Data.UnitObj[unr].TransportList[index]);
        num1 += num2;
      }
      return num1;
    }

    pub fn GiveAttachablesManpowerWeight(unr: i32) -> i32
    {
      SimpleList simpleList = this.GiveAttachablesList(unr);
      let mut num1: i32 =  0;
      let mut counter: i32 =  simpleList.Counter;
      for (let mut index: i32 =  0; index <= counter; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[simpleList.Id[index]].Type;
        let mut num2: i32 =  simpleList.Weight[index];
        let mut moveType: i32 =  this.game.Data.SFTypeObj[type].MoveType;
        let mut manpower: i32 =  this.game.Data.SFTypeObj[type].manpower;
        num1 += num2 * manpower;
      }
      return num1;
    }

    pub SimpleList GiveAttachablesList(unr: i32)
    {
      if (this.game.Data.UnitObj[unr].SFCount == -1)
        return SimpleList::new();
      int[] numArray1 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray2 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray3 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray4 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray5 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray6 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray7 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray8 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray9 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray10 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray11 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      if (this.game.Data.UnitObj[unr].IsHQ)
        unr = unr;
      let mut sfCount1: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount1; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut moveType: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].MoveType;
        if (this.game.Data.SFObj[sf].MoveType > -1)
          moveType = this.game.Data.SFObj[sf].MoveType;
        numArray2[index] = this.game.Data.LandscapeTypeObj[ Math.Round( this.game.Data.RuleVar[38])].MoveCost[moveType];
        if (numArray2[index] >= 999 & this.game.Data.RoadTypeCounter > -1)
          numArray2[index] = this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
        if (this.game.Data.Product >= 5 & this.game.Data.RoadTypeCounter > -1)
          numArray2[index] = this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
        numArray3[index] = this.game.Data.SFTypeObj[type].Weight * this.game.Data.SFObj[sf].Qty;
        numArray5[index] = this.game.Data.SFTypeObj[type].CarryCap * this.game.Data.SFObj[sf].Qty;
        numArray8[index] = this.game.Data.SFTypeObj[type].manpower;
        numArray9[index] = this.game.Data.SFTypeObj[type].Weight;
        numArray6[index] = this.game.Data.SFTypeObj[type].manpower * this.game.Data.SFObj[sf].Qty;
        numArray7[index] = this.game.Data.SFTypeObj[type].manpowerCarry * this.game.Data.SFObj[sf].Qty;
      }
      bool flag1;
      do
      {
        flag1 = false;
        let mut sfCount2: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index1: i32 =  0; index1 <= sfCount2; index1 += 1)
        {
          let mut index2: i32 =  -1;
          let mut num1: i32 =  0;
          let mut sfCount3: i32 =  this.game.Data.UnitObj[unr].SFCount;
          type: i32;
          for (let mut index3: i32 =  0; index3 <= sfCount3; index3 += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index3];
            if (numArray2[index3] > num1 && numArray4[index3] < numArray3[index3] | numArray10[index3] < numArray6[index3] && numArray1[index3] == 0)
            {
              num1 = numArray2[index3];
              let mut num2: i32 =  numArray3[index3];
              index2 = index3;
              type = this.game.Data.SFObj[sf].Type;
            }
          }
          if (index2 > -1)
          {
            let mut index4: i32 =  -1;
            let mut num3: i32 =  9999;
            let mut sfCount4: i32 =  this.game.Data.UnitObj[unr].SFCount;
            for (let mut index5: i32 =  0; index5 <= sfCount4; index5 += 1)
            {
              let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index5];
              if (numArray2[index5] < num3 && numArray5[index5] > 0 & numArray7[index5] >= numArray8[index2])
              {
                if (type > -1)
                {
                  if (this.CanBeCarriedBy(type, this.game.Data.SFObj[sf].Type))
                  {
                    num3 = numArray2[index5];
                    index4 = index5;
                  }
                }
                else
                {
                  num3 = numArray2[index5];
                  index4 = index5;
                }
              }
            }
            if (index4 > -1)
            {
              let mut num4: i32 =  numArray3[index2] - numArray4[index2];
              let mut val1: i32 =  numArray5[index4] <= num4 ? numArray5[index4] : num4;
              let mut num5: i32 =  0;
              if (numArray8[index2] > 0 & val1 > 0)
              {
                let mut num6: i32 =  numArray6[index2] - numArray10[index2];
                num5 = numArray7[index4] <= num6 ? numArray7[index4] : num6;
                let mut num7: i32 =   Math.Round( val1 /  numArray9[index2]);
                let mut num8: i32 =   Math.Round(Math.Ceiling( num5 /  numArray8[index2]));
                if (num8 < num7)
                {
                  val1 = Math.Min(val1, numArray9[index2] * num7);
                  num5 = num8 * numArray8[index2];
                }
              }
              if (val1 > 0)
              {
                flag1 = true;
                int[] numArray12 = numArray4;
                int[] numArray13 = numArray12;
                let mut index6: i32 =  index2;
                let mut index7: i32 =  index6;
                let mut num9: i32 =  numArray12[index6] + val1;
                numArray13[index7] = num9;
                int[] numArray14 = numArray5;
                int[] numArray15 = numArray14;
                let mut index8: i32 =  index4;
                let mut index9: i32 =  index8;
                let mut num10: i32 =  numArray14[index8] - val1;
                numArray15[index9] = num10;
                int[] numArray16 = numArray10;
                int[] numArray17 = numArray16;
                let mut index10: i32 =  index2;
                let mut index11: i32 =  index10;
                let mut num11: i32 =  numArray16[index10] + num5;
                numArray17[index11] = num11;
                int[] numArray18 = numArray7;
                int[] numArray19 = numArray18;
                let mut index12: i32 =  index4;
                let mut index13: i32 =  index12;
                let mut num12: i32 =  numArray18[index12] - num5;
                numArray19[index13] = num12;
                if (numArray2[index4] > numArray11[index2])
                  numArray11[index2] = numArray2[index4];
              }
              else if (index4 > -1 & index2 > -1)
              {
                let mut num13: i32 =  numArray6[index2] - numArray10[index2];
                let mut num14: i32 =  numArray7[index4] <= num13 ? numArray7[index4] : num13;
                if (num14 > 0 & num13 > 0)
                {
                  int[] numArray20 = numArray10;
                  int[] numArray21 = numArray20;
                  let mut index14: i32 =  index2;
                  let mut index15: i32 =  index14;
                  let mut num15: i32 =  numArray20[index14] + num14;
                  numArray21[index15] = num15;
                  int[] numArray22 = numArray7;
                  int[] numArray23 = numArray22;
                  let mut index16: i32 =  index4;
                  let mut index17: i32 =  index16;
                  let mut num16: i32 =  numArray22[index16] - num14;
                  numArray23[index17] = num16;
                  if (numArray2[index4] > numArray11[index2])
                    numArray11[index2] = numArray2[index4];
                }
                else
                  numArray1[index2] = 1;
              }
              else
                numArray1[index2] = 1;
            }
          }
        }
      }
      while (flag1);
      SimpleList simpleList = SimpleList::new();
      let mut sfCount5: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount5; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        let mut powerPts: i32 =  this.game.Data.SFTypeObj[type].PowerPts;
        let mut moveType: i32 =  this.game.Data.SFTypeObj[type].MoveType;
        let mut carryCap: i32 =  this.game.Data.SFTypeObj[type].CarryCap;
        let mut weight: i32 =  this.game.Data.SFTypeObj[type].Weight;
        let mut num: i32 =  this.game.Data.transportMovementType[moveType];
        bool flag2 = true;
        if (this.game.Data.SFTypeObj[type].FuelForMove > 0)
          flag2 = false;
        if (this.game.Data.SFTypeObj[type].CarryCap > 0)
          flag2 = false;
        if (flag2 && num == 2 && numArray4[index] < numArray3[index] | numArray10[index] < numArray6[index])
        {
          let mut tweight: i32 =   Math.Round( (numArray3[index] - numArray4[index]) /  weight);
          simpleList.Add(sf, tweight);
        }
      }
      return simpleList;
    }

    pub GetUDSmanagementTabName: String(tabnr: i32, bool forUDSRandomTab = false)
    {
      let mut id: i32 =   Math.Round( this.game.Data.RuleVar[441]);
      if (forUDSRandomTab)
        id =  Math.Round( this.game.Data.RuleVar[443]);
      if (id > 0)
      {
        SimpleList simpleList = SimpleList::new();
        let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(id);
        if (stringListById > -1)
        {
          let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
          for (let mut tid: i32 =  0; tid <= length; tid += 1)
          {
            if (Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 1]) == 1.0)
              simpleList.Add(tid, Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[tid, 3]));
          }
          simpleList.Sort();
          if (simpleList.Counter >= tabnr - 1)
          {
            let mut index: i32 =  simpleList.Id[tabnr - 1];
            return this.game.Data.StringListObj[stringListById].Data[index, 4];
          }
        }
      }
      return "";
    }

    pub fn GetUDSmanagementTabPageCount(tabnr: i32, bool forUDSRandomTab = false) -> i32
    {
      let mut smanagementTabPageCount: i32 =  0;
      let mut id: i32 =   Math.Round( this.game.Data.RuleVar[441]);
      if (forUDSRandomTab)
        id =  Math.Round( this.game.Data.RuleVar[443]);
      if (id > 0)
      {
        let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(id);
        if (stringListById > -1)
        {
          let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
          for (let mut index: i32 =  0; index <= length; index += 1)
          {
            if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 1])) == 3)
            {
              let mut idValue: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 2]));
              if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].GetData(0, idValue, 2))) == tabnr)
                smanagementTabPageCount += 1;
            }
          }
        }
      }
      return smanagementTabPageCount;
    }

    pub GetUDSmanagementSubTabName: String(tabnr: i32, subTabNr: i32, bool forUDSRandomTab = false)
    {
      let mut id: i32 =   Math.Round( this.game.Data.RuleVar[441]);
      if (forUDSRandomTab)
        id =  Math.Round( this.game.Data.RuleVar[443]);
      if (id > 0)
      {
        SimpleList simpleList1 = SimpleList::new();
        let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(id);
        if (stringListById > -1)
        {
          let mut length1: i32 =  this.game.Data.StringListObj[stringListById].Length;
          for (let mut tid: i32 =  0; tid <= length1; tid += 1)
          {
            if (Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 1]) == 1.0)
              simpleList1.Add(tid, Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[tid, 3]));
          }
          simpleList1.Sort();
          if (simpleList1.Counter >= tabnr - 1)
          {
            let mut index1: i32 =  simpleList1.Id[tabnr - 1];
            let mut integer: i32 =  Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index1, 0]);
            SimpleList simpleList2 = SimpleList::new();
            let mut length2: i32 =  this.game.Data.StringListObj[stringListById].Length;
            for (let mut tid: i32 =  0; tid <= length2; tid += 1)
            {
              if (Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 1]) == 2.0 & Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 2]) ==  integer)
                simpleList2.Add(tid, Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[tid, 3]));
            }
            simpleList2.Sort();
            if (simpleList2.Counter >= subTabNr - 1)
            {
              let mut index2: i32 =  simpleList2.Id[subTabNr - 1];
              return this.game.Data.StringListObj[stringListById].Data[index2, 4];
            }
          }
        }
      }
      return "";
    }

    pub GetUDSmanagementPageRow: String(
      tabnr: i32,
      subTabNr: i32,
      pageNr: i32,
      bool forUDSRandomTab = false)
    {
      let mut id: i32 =   Math.Round( this.game.Data.RuleVar[441]);
      if (forUDSRandomTab)
        id =  Math.Round( this.game.Data.RuleVar[443]);
      if (id > 0)
      {
        SimpleList simpleList1 = SimpleList::new();
        let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(id);
        if (stringListById > -1)
        {
          let mut length1: i32 =  this.game.Data.StringListObj[stringListById].Length;
          for (let mut tid: i32 =  0; tid <= length1; tid += 1)
          {
            if (Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 1]) == 1.0)
              simpleList1.Add(tid, Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[tid, 3]));
          }
          simpleList1.Sort();
          if (simpleList1.Counter >= tabnr - 1)
          {
            let mut index1: i32 =  simpleList1.Id[tabnr - 1];
            let mut integer1: i32 =  Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index1, 0]);
            SimpleList simpleList2 = SimpleList::new();
            let mut length2: i32 =  this.game.Data.StringListObj[stringListById].Length;
            for (let mut tid: i32 =  0; tid <= length2; tid += 1)
            {
              if (Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 1]) == 2.0 & Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 2]) ==  integer1)
                simpleList2.Add(tid, Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[tid, 3]));
            }
            simpleList2.Sort();
            if (simpleList2.Counter >= subTabNr - 1)
            {
              let mut index2: i32 =  simpleList2.Id[subTabNr - 1];
              let mut integer2: i32 =  Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 0]);
              SimpleList simpleList3 = SimpleList::new();
              let mut length3: i32 =  this.game.Data.StringListObj[stringListById].Length;
              for (let mut tid: i32 =  0; tid <= length3; tid += 1)
              {
                if (Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 1]) == 3.0 & Conversions.ToDouble(this.game.Data.StringListObj[stringListById].Data[tid, 2]) ==  integer2)
                  simpleList3.Add(tid, Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[tid, 3]));
              }
              simpleList3.Sort();
              if (simpleList3.Counter >= pageNr - 1)
                return Conversions.ToString(simpleList3.Id[pageNr - 1]);
            }
          }
        }
      }
      return Conversions.ToString(-1);
    }

    pub fn SwitchResolution( formref: Form1)
    {
      if (this.game.EditObj.DoubleSize)
      {
        this.game.FormRef.doubleSize = true;
        this.game.ScreenWidth = this.game.RealScreenWidth;
        this.game.ScreenHeight = this.game.RealScreenHeight;
        if (this.game.EditObj.DoubleSizePercentage == 125)
        {
          this.game.ScreenWidth =  Math.Round( (this.game.ScreenWidth * 7) / 8.0);
          this.game.ScreenHeight =  Math.Round( (this.game.ScreenHeight * 7) / 8.0);
        }
        else if (this.game.EditObj.DoubleSizePercentage == 150)
        {
          this.game.ScreenWidth =  Math.Round( (this.game.ScreenWidth * 6) / 8.0);
          this.game.ScreenHeight =  Math.Round( (this.game.ScreenHeight * 6) / 8.0);
        }
        else if (this.game.EditObj.DoubleSizePercentage == 175)
        {
          this.game.ScreenWidth =  Math.Round( (this.game.ScreenWidth * 5) / 8.0);
          this.game.ScreenHeight =  Math.Round( (this.game.ScreenHeight * 5) / 8.0);
        }
        else if (this.game.EditObj.DoubleSizePercentage == 200)
        {
          this.game.ScreenWidth =  Math.Round( this.game.ScreenWidth / 2.0);
          this.game.ScreenHeight =  Math.Round( this.game.ScreenHeight / 2.0);
        }
        else if (this.game.EditObj.DoubleSizePercentage == 75)
        {
          this.game.ScreenWidth =  Math.Round( (this.game.ScreenWidth * 5) / 4.0);
          this.game.ScreenHeight =  Math.Round( (this.game.ScreenHeight * 5) / 4.0);
        }
        else if (this.game.EditObj.DoubleSizePercentage == 50)
        {
          this.game.ScreenWidth *= 2;
          this.game.ScreenHeight *= 2;
        }
        if (this.game.ScreenWidth < 1024)
          this.game.ScreenWidth = 1024;
        if (this.game.ScreenHeight < 768)
          this.game.ScreenHeight = 768;
        formref.doubleModX =  this.game.ScreenWidth /  this.game.RealScreenWidth;
        formref.doubleModY =  this.game.ScreenHeight /  this.game.RealScreenHeight;
        if ( formref.doubleModX < 2.0 |  formref.doubleModY < 2.0)
        {
          if ( formref.doubleModY >  formref.doubleModX)
          {
            this.game.ScreenWidth =  Math.Round( ( this.game.RealScreenWidth * formref.doubleModY));
            formref.doubleModX = formref.doubleModY;
          }
          else if ( formref.doubleModX >  formref.doubleModY)
          {
            this.game.ScreenHeight =  Math.Round( ( this.game.RealScreenHeight * formref.doubleModX));
            formref.doubleModY = formref.doubleModX;
          }
        }
      }
      else
      {
        this.game.FormRef.doubleSize = false;
        this.game.ScreenWidth = this.game.RealScreenWidth;
        this.game.ScreenHeight = this.game.RealScreenHeight;
      }
      this.game.EditObj.Save(this.game.AppPath + "editobj.txt");
    }

    pub fn SwitchResolution2( formref: Form1, tWidth: i32, tHeight: i32, bool setToDesktop)
    {
      this.game.FormRef.doubleSize = false;
      this.game.ScreenWidth = this.game.RealScreenWidth;
      this.game.ScreenHeight = this.game.RealScreenHeight;
      DEVMODE1 lpDevMode1 = DEVMODE1::new();
      Form1.EnumDisplaySettings(0, -1,  lpDevMode1);
      DEVMODE1 lpDevMode2 = DEVMODE1::new();
      lpDevMode2.dmSize = (short) Marshal.SizeOf( lpDevMode2);
      if (Form1.EnumDisplaySettings(0, 0,  lpDevMode2))
      {
        lpDevMode2.dmDeviceName = new string(new char[33]);
        lpDevMode2.dmFormName = new string(new char[33]);
        lpDevMode2.dmSize = (short) Marshal.SizeOf( lpDevMode2);
        lpDevMode2.dmPelsWidth = tWidth;
        lpDevMode2.dmPelsHeight = tHeight;
        lpDevMode2.dmBitsPerPel = lpDevMode1.dmBitsPerPel;
        lpDevMode2.dmDisplayFrequency = lpDevMode1.dmDisplayFrequency;
        let mut num1: i32 =  Form1.ChangeDisplaySettings( lpDevMode2, 4);
        if (num1 == 0)
        {
          formref.Width = lpDevMode2.dmPelsWidth;
          formref.Height = lpDevMode2.dmPelsHeight;
          formref.Location = new Point(0, 0);
          formref.Visible = true;
          this.game.ScreenHeight = formref.Height;
          this.game.ScreenWidth = formref.Width;
          this.game.EditObj.overruleScreenResWidth = formref.Width;
          this.game.EditObj.overruleScreenResHeight = formref.Height;
          this.game.RealScreenWidth = this.game.ScreenWidth;
          this.game.RealScreenHeight = this.game.ScreenHeight;
        }
        else
        {
          let mut num2: i32 =   Interaction.MsgBox( ("Error code: " + num1.ToString()), Title: ( "Resolution change failed"));
        }
      }
      if (setToDesktop)
      {
        this.game.EditObj.overruleScreenResWidth = -1;
        this.game.EditObj.overruleScreenResHeight = -1;
      }
      this.game.EditObj.Save(this.game.AppPath + "editobj.txt");
    }

    pub EncyTextStringContainsId: bool(int[] ints)
    {
      let mut upperBound: i32 =  ints.GetUpperBound(0);
      for (let mut index: i32 =  1; index <= upperBound; index += 1)
      {
        if (ints[index] > 0)
          return true;
      }
      return false;
    }

    pub RecodeTextStringToEncyIdsNew: Vec<i32>(s: String,  StringListClass tStringList)
    {
      int[] encyIdsNew = new int[s.Length * 2 + 1];
      let mut length1: i32 =  s.Length;
      for (let mut index: i32 =  1; index <= length1; index += 1)
        encyIdsNew[index] = 0;
      if (Information.IsNothing( tStringList))
        return encyIdsNew;
      if (this.game.Data.Product >= 7)
      {
        s = Strings.LCase(s);
        let mut length2: i32 =  tStringList.Length;
        for (let mut index1: i32 =  0; index1 <= length2; index1 += 1)
        {
          str: String = Strings.LCase(tStringList.Data[index1, 0]);
          Left1: String = "";
          if (tStringList.Width >= 5)
            Left1 = Strings.LCase(tStringList.Data[index1, 5]);
          let mut Start: i32 =  1;
          if (Strings.InStr(str.ToLower(), "nano") > 0)
            str = str;
          num1: i32;
          length3: i32;
          if (str.Length > 0)
          {
            for (; Strings.InStr(Start, s, str) > 0; Start = num1 + length3)
            {
              num1 = Strings.InStr(Start, s, str);
              length3 = str.Length;
              bool flag = true;
              if (Strings.InStr(str, "?") < 1 & Operators.CompareString(Left1, "OVERRULE", false) != 0)
              {
                if (num1 > 1)
                {
                  Left2: String = Strings.Mid(s, num1 - 1, 1);
                  if (!(Operators.CompareString(Left2, "\r", false) == 0 | Operators.CompareString(Left2, "\n", false) == 0 | Operators.CompareString(Left2, "\r\n", false) == 0 | Operators.CompareString(Left2, " ", false) == 0 | Operators.CompareString(Left2, ".", false) == 0 | Operators.CompareString(Left2, ",", false) == 0))
                    flag = false;
                }
                if (num1 + length3 - 1 < s.Length)
                {
                  Left3: String = Strings.Mid(s, num1 + length3, 1);
                  if (!(Operators.CompareString(Left3, "\r", false) == 0 | Operators.CompareString(Left3, "\n", false) == 0 | Operators.CompareString(Left3, "\r\n", false) == 0 | Operators.CompareString(Left3, " ", false) == 0 | Operators.CompareString(Left3, ".", false) == 0 | Operators.CompareString(Left3, ",", false) == 0 | Operators.CompareString(Left3, ":", false) == 0))
                    flag = false;
                }
              }
              if (flag)
              {
                let mut num2: i32 =  num1;
                let mut num3: i32 =  num1 + length3 - 1;
                for (let mut index2: i32 =  num2; index2 <= num3; index2 += 1)
                  encyIdsNew[index2] = index1 + 1;
              }
            }
          }
        }
      }
      else
      {
        let mut length4: i32 =  tStringList.Length;
        for (let mut index3: i32 =  0; index3 <= length4; index3 += 1)
        {
          String2: String = tStringList.Data[index3, 0];
          let mut Start: i32 =  1;
          num4: i32;
          length5: i32;
          if (String2.Length > 0)
          {
            for (; Strings.InStr(Start, s, String2) > 0; Start = num4 + length5)
            {
              num4 = Strings.InStr(Start, s, String2);
              length5 = String2.Length;
              let mut num5: i32 =  num4;
              let mut num6: i32 =  num4 + length5 - 1;
              for (let mut index4: i32 =  num5; index4 <= num6; index4 += 1)
                encyIdsNew[index4] = index3 + 1;
            }
          }
        }
      }
      return encyIdsNew;
    }

    pub fn modlib_Import( xData: DataClass, libslot: i32)
    {
      SimpleList simpleList = SimpleList::new();
      let mut forSSIDType: i32 =  1;
      tid: i32;
      num1: i32;
      num2: i32;
      data: i32;
      do
      {
        SimpleList usedL = SimpleList::new();
        let mut num3: i32 =  1;
        do
        {
          let mut stringListCounter: i32 =  xData.StringListCounter;
          for (let mut index1: i32 =  0; index1 <= stringListCounter; index1 += 1)
          {
            if (xData.StringListObj[index1].LibId.libSlot == libslot)
            {
              let mut width: i32 =  xData.StringListObj[index1].Width;
              for (let mut index2: i32 =  0; index2 <= width; index2 += 1)
              {
                if (num3 == 1 & (xData.StringListObj[index1].SSID[index2] == forSSIDType | xData.StringListObj[index1].SSID[index2] == forSSIDType + 50))
                {
                  let mut length: i32 =  xData.StringListObj[index1].Length;
                  for (let mut index3: i32 =  0; index3 <= length; index3 += 1)
                  {
                    tid =  Math.Round(Conversion.Val(xData.StringListObj[index1].Data[index3, index2]));
                    if (tid > 0 & tid < 100)
                    {
                      if (tid > 50 & tid < 100)
                        tid -= 50;
                      num1 = usedL.FindData(tid, 1);
                      if (num1 > 0)
                      {
                        xData.StringListObj[index1].Data[index3, index2] = num1.ToString();
                      }
                      else
                      {
                        num2 = this.modlib_findFirstEmptyID(forSSIDType,  usedL);
                        usedL.AddWeight(tid, 1, num2);
                        xData.StringListObj[index1].Data[index3, index2] = num2.ToString();
                      }
                    }
                  }
                }
                else if (num3 == 2 & xData.StringListObj[index1].SSID[index2] == forSSIDType + 100)
                {
                  let mut length: i32 =  xData.StringListObj[index1].Length;
                  for (let mut index4: i32 =  0; index4 <= length; index4 += 1)
                  {
                    bool flag1 = true;
                    bool flag2 = false;
                    while (flag1)
                    {
                      flag1 = false;
                      str1: String = xData.StringListObj[index1].Data[index4, index2];
                      tid = Strings.InStr(str1, "[");
                      if (tid > 0)
                      {
                        num1 = Strings.InStr(tid + 1, str1, "]");
                        if (num1 > 0 & num1 > tid + 1)
                        {
                          str2: String = Strings.Mid(str1, tid + 1, num1 - (tid + 1));
                          num2 =  Math.Round(Conversion.Val(str2));
                          if (Operators.CompareString(num2.ToString(), str2, false) == 0)
                          {
                            data = simpleList.FindData(num2, 1);
                            str3: String = data.ToString();
                            str4: String = Strings.Left(str1, tid - 1) + "$£" + str3 + "$@" + Strings.Mid(str1, num1 + 1);
                            xData.StringListObj[index1].Data[index4, index2] = str4;
                            flag1 = true;
                            flag2 = true;
                          }
                          else
                            break;
                        }
                      }
                    }
                    if (flag2)
                    {
                      str: String = xData.StringListObj[index1].Data[index4, index2].Replace("$£", "[").Replace("$@", "]");
                      xData.StringListObj[index1].Data[index4, index2] = str;
                    }
                  }
                }
              }
            }
          }
          if (num3 == 1)
          {
            let mut counter: i32 =  usedL.Counter;
            for (let mut index: i32 =  0; index <= counter; index += 1)
              simpleList.AddWeight(usedL.Id[index], 1, usedL.Data1[index]);
          }
          num3 += 1;
        }
        while (num3 <= 2);
        forSSIDType += 1;
      }
      while (forSSIDType <= 7);
      let mut num4: i32 =  tid;
      let mut stringListCounter1: i32 =  xData.StringListCounter;
      for (let mut index5: i32 =  0; index5 <= stringListCounter1; index5 += 1)
      {
        if (xData.StringListObj[index5].LibId.libSlot == libslot)
        {
          let mut width: i32 =  xData.StringListObj[index5].Width;
          for (let mut index6: i32 =  0; index6 <= width; index6 += 1)
          {
            let mut length: i32 =  xData.StringListObj[index5].Length;
            for (let mut index7: i32 =  0; index7 <= length; index7 += 1)
            {
              if (Strings.InStr(xData.StringListObj[index5].Data[index7, index6], "$") > 0)
              {
                bool flag = true;
                while (flag)
                {
                  flag = false;
                  str5: String = xData.StringListObj[index5].Data[index7, index6];
                  num4 = Strings.InStr(str5, "$");
                  if (num4 > 0)
                  {
                    num1 = Strings.InStr(num4 + 1, str5, "$");
                    if (num1 > 0 & num1 > num4 + 1)
                    {
                      str6: String = Strings.Mid(str5, num4 + 1, num1 - (num4 + 1));
                      num2 =  Math.Round(Conversion.Val(str6));
                      str7: String;
                      if (Operators.CompareString(num2.ToString(), str6, false) == 0)
                      {
                        data = simpleList.FindData(num2, 1);
                        str7 = data.ToString();
                      }
                      else
                        str7 = xData.LibraryObj[0].name + "_" + str6;
                      flag = true;
                      str8: String = Strings.Left(str5, num4 - 1) + str7 + Strings.Mid(str5, num1 + 1);
                      xData.StringListObj[index5].Data[index7, index6] = str8;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    pub fn modlib_findFirstEmptyID(forSSIDType: i32,  SimpleList usedL) -> i32
    {
      SimpleList simpleList = SimpleList::new();
      simpleList.AddWeight(0, 1);
      if (forSSIDType == 2)
      {
        let mut tid: i32 =  1;
        do
        {
          simpleList.AddWeight(tid, 1);
          tid += 1;
        }
        while (tid <= 99);
      }
      let mut stringListCounter: i32 =  this.game.Data.StringListCounter;
      for (let mut index1: i32 =  0; index1 <= stringListCounter; index1 += 1)
      {
        let mut width: i32 =  this.game.Data.StringListObj[index1].Width;
        for (let mut index2: i32 =  0; index2 <= width; index2 += 1)
        {
          if (this.game.Data.StringListObj[index1].SSID[index2] == forSSIDType)
          {
            let mut length: i32 =  this.game.Data.StringListObj[index1].Length;
            for (let mut index3: i32 =  0; index3 <= length; index3 += 1)
            {
              let mut integer: i32 =  Conversions.ToInteger(this.game.Data.StringListObj[index1].Data[index3, index2]);
              simpleList.AddWeight(integer, 1);
            }
          }
        }
      }
      let mut counter1: i32 =  usedL.Counter;
      for (let mut index: i32 =  0; index <= counter1; index += 1)
      {
        simpleList.AddWeight(usedL.Data1[index], 1);
        simpleList.AddWeight(usedL.Id[index], 1);
      }
      let mut counter2: i32 =  simpleList.Counter;
      for (let mut index: i32 =  0; index <= counter2; index += 1)
        simpleList.Weight[index] = simpleList.Id[index];
      simpleList.SortHighSpeed();
      let mut firstEmptyId: i32 =  -1;
      let mut num: i32 =  simpleList.Counter - 1;
      for (let mut index: i32 =  0; index <= num; index += 1)
      {
        if (simpleList.Id[index] < simpleList.Id[index + 1] && simpleList.Id[index] + 1 < simpleList.Id[index + 1])
        {
          firstEmptyId = simpleList.Id[index] + 1;
          break;
        }
      }
      if (firstEmptyId == -1 & simpleList.Counter > -1)
        firstEmptyId = simpleList.Id[simpleList.Counter] + 1;
      else if (firstEmptyId == -1)
        firstEmptyId = 1;
      return firstEmptyId;
    }

    pub LoadLibrary: bool( tData: DataClass)
    {
      tempFileName: String = this.game.EditObj.TempFileName;
      if (!System.IO.File.Exists(tempFileName))
        return false;
      this.game.HandyFunctionsObj.Unzip(tempFileName);
      tData = new DataClass(DontLoadGraphics: true);
      tData = DataClass.deserialize(tempFileName);
      this.game.HandyFunctionsObj.ZipFile(tempFileName);
      GC.Collect();
      Application.DoEvents();
      return true;
    }

    pub ActuallyExportLib: DataClass(libSlot: i32)
    {
      SimpleStringList simpleStringList = SimpleStringList::new();
      tData: DataClass = this.game.Data.Clone();
      let mut index1: i32 =  999;
      index2: i32;
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers)
      {
        let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
        for (let mut index3: i32 =  0; index3 <= historicalUnitCounter; index3 += 1)
        {
          if (this.game.Data.HistoricalUnitObj[index3].LibId.libSlot == libSlot | this.game.Data.HistoricalUnitObj[index3].OffLibId.libSlot == libSlot && this.game.Data.HistoricalUnitObj[index3].DeckCardCounter > -1)
          {
            let mut deckCardCounter: i32 =  this.game.Data.HistoricalUnitObj[index3].DeckCardCounter;
            for (let mut index4: i32 =  0; index4 <= deckCardCounter; index4 += 1)
            {
              index2 = this.game.Data.HistoricalUnitObj[index3].DeckCard[index4];
              if (this.game.Data.ActionCardObj[index2].LibId.libSlot > -1)
              {
                let mut libSlot1: i32 =  this.game.Data.ActionCardObj[index2].LibId.libSlot;
                if (simpleStringList.FindNr(this.game.Data.LibraryObj[libSlot1].name) <= -1)
                {
                  simpleStringList.Add(this.game.Data.LibraryObj[libSlot1].name, -1);
                  if (libSlot1 < index1)
                    index1 = libSlot1;
                }
              }
            }
          }
        }
      }
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals)
      {
        for (let mut unitCounter: i32 =  tData.UnitCounter; unitCounter >= 0; unitCounter += -1)
        {
          if (tData.UnitObj[unitCounter].PreDef > -1)
          {
            if (tData.UnitObj[unitCounter].LibId.libSlot > -1)
              index2 = index2;
            if (tData.UnitObj[unitCounter].LibId.libSlot == libSlot)
            {
              let mut historical: i32 =  tData.UnitObj[unitCounter].Historical;
              let mut sfCount: i32 =  tData.UnitObj[unitCounter].SFCount;
              for (let mut index5: i32 =  0; index5 <= sfCount; index5 += 1)
              {
                index2 = tData.SFObj[tData.UnitObj[unitCounter].SFList[index5]].Type;
                if (tData.SFTypeObj[index2].LibId.libSlot > -1)
                {
                  let mut libSlot2: i32 =  tData.SFTypeObj[index2].LibId.libSlot;
                  if (simpleStringList.FindNr(this.game.Data.LibraryObj[libSlot2].name) <= -1)
                  {
                    simpleStringList.Add(this.game.Data.LibraryObj[libSlot2].name, -1);
                    if (libSlot2 < index1)
                      index1 = libSlot2;
                  }
                }
              }
            }
          }
        }
      }
      if (this.game.EditObj.TempFileType != NewEnums.LibFileType.LoadMap)
        simpleStringList.Add(this.game.Data.LibraryObj[libSlot].name, -1);
      if (index1 < libSlot & index1 < 999)
      {
        tData.ChangeLibraryNr(index1, 9999);
        tData.ChangeLibraryNr(libSlot, index1);
        tData.ChangeLibraryNr(9999, libSlot);
        LibraryClass libraryClass1 = tData.LibraryObj[libSlot].Clone();
        LibraryClass libraryClass2 = tData.LibraryObj[index1].Clone();
        tData.LibraryObj[libSlot] = libraryClass2;
        tData.LibraryObj[index1] = libraryClass1;
        libSlot = index1;
      }
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers)
      {
        for (let mut unitCounter: i32 =  tData.UnitCounter; unitCounter >= 0; unitCounter += -1)
        {
          if (tData.UnitObj[unitCounter].PreDef == -1)
          {
            if (tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].OffLibId.libSlot == libSlot & tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].LibId.libSlot == -1)
            {
              let mut tempRegime: i32 =  tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].TempRegime;
              LibIdClass libIdClass = tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].OffLibId.Clone();
              tData.AddHistoricalUnit();
              this.game.ProcessingObj.SwapOfficerOtherData(tData.UnitObj[unitCounter].Regime, tData.UnitObj[unitCounter].Historical, tData.HistoricalUnitCounter, unitCounter,  tData);
              tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].OffLibId = LibIdClass::new();
              tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].LibId = LibIdClass::new();
              tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].CommanderName = "";
              tData.HistoricalUnitObj[tData.HistoricalUnitCounter].LibId = libIdClass;
              tData.HistoricalUnitObj[tData.HistoricalUnitCounter].ID = libIdClass.id;
              tData.HistoricalUnitObj[tData.HistoricalUnitCounter].OffLibId = LibIdClass::new();
              tData.HistoricalUnitObj[tData.HistoricalUnitCounter].Pool = true;
              tData.HistoricalUnitObj[tData.HistoricalUnitCounter].TempRegime = 0;
              tData.HistoricalUnitObj[tData.HistoricalUnitCounter].People = 0;
            }
            else if (tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].LibId.libSlot == libSlot)
            {
              tData.HistoricalUnitObj[tData.HistoricalUnitCounter].Pool = true;
              tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].TempRegime = 0;
              tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].People = 0;
              tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].ID = tData.HistoricalUnitObj[tData.UnitObj[unitCounter].Historical].LibId.id;
            }
          }
        }
      }
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers)
      {
        for (let mut historicalUnitCounter: i32 =  tData.HistoricalUnitCounter; historicalUnitCounter >= 0; historicalUnitCounter += -1)
        {
          let mut libSlot3: i32 =  tData.HistoricalUnitObj[historicalUnitCounter].LibId.libSlot;
          if (libSlot3 > -1)
          {
            name: String = tData.LibraryObj[libSlot3].name;
            if (simpleStringList.FindNr(name) > -1)
            {
              if (tData.HistoricalUnitObj[historicalUnitCounter].CommanderName.Length > 0)
              {
                tData.HistoricalUnitObj[historicalUnitCounter].Pool = true;
                tData.HistoricalUnitObj[historicalUnitCounter].TempRegime = 0;
                tData.HistoricalUnitObj[historicalUnitCounter].People = 0;
                LibIdClass libIdClass = tData.HistoricalUnitObj[historicalUnitCounter].OffLibId.Clone();
                if (libIdClass.libSlot > -1)
                  tData.HistoricalUnitObj[historicalUnitCounter].LibId = libIdClass;
                if (tData.HistoricalUnitObj[historicalUnitCounter].LibId.libSlot > -1)
                  tData.HistoricalUnitObj[historicalUnitCounter].ID = tData.HistoricalUnitObj[historicalUnitCounter].LibId.id;
                tData.HistoricalUnitObj[historicalUnitCounter].OffLibId = LibIdClass::new();
              }
              else
                tData.HistoricalUnitObj[historicalUnitCounter].Pool = false;
            }
            else
              tData.HistoricalUnitObj[historicalUnitCounter].Pool = false;
          }
        }
      }
      for (let mut eventPicCounter: i32 =  tData.EventPicCounter; eventPicCounter >= 0; eventPicCounter += -1)
      {
        let mut libSlot4: i32 =  tData.eventPicLibId[eventPicCounter].libSlot;
        if (libSlot4 > -1)
        {
          name: String = tData.LibraryObj[libSlot4].name;
          if (simpleStringList.FindNr(name) <= -1)
            tData.RemoveEventPic(eventPicCounter);
        }
      }
      for (let mut smallPicCounter: i32 =  tData.SmallPicCounter; smallPicCounter >= 0; smallPicCounter += -1)
      {
        let mut libSlot5: i32 =  tData.SmallLibId[smallPicCounter].libSlot;
        if (libSlot5 > -1)
        {
          name: String = tData.LibraryObj[libSlot5].name;
          if (simpleStringList.FindNr(name) <= -1)
            tData.RemoveSmallPic(smallPicCounter);
        }
      }
      for (let mut reinfCounter: i32 =  tData.ReinfCounter; reinfCounter >= 0; reinfCounter += -1)
      {
        let mut libSlot6: i32 =  tData.ReinfLibId[reinfCounter].libSlot;
        if (libSlot6 > -1)
        {
          name: String = tData.LibraryObj[libSlot6].name;
          if (simpleStringList.FindNr(name) > -1)
            tData.ReinfId[reinfCounter] = tData.ReinfLibId[reinfCounter].id;
          else
            tData.RemoveReinf(reinfCounter);
        }
      }
      for (let mut stringListCounter: i32 =  tData.StringListCounter; stringListCounter >= 0; stringListCounter += -1)
      {
        let mut libSlot7: i32 =  tData.StringListObj[stringListCounter].LibId.libSlot;
        if (libSlot7 > -1)
        {
          name: String = tData.LibraryObj[libSlot7].name;
          if (simpleStringList.FindNr(name) <= -1)
            tData.RemoveStringList(stringListCounter);
        }
      }
      for (let mut eventCounter: i32 =  tData.EventCounter; eventCounter >= 0; eventCounter += -1)
      {
        let mut libSlot8: i32 =  tData.EventObj[eventCounter].LibId.libSlot;
        if (libSlot8 > -1)
        {
          name: String = tData.LibraryObj[libSlot8].name;
          if (simpleStringList.FindNr(name) <= -1)
            tData.RemoveEvent(eventCounter);
        }
      }
      for (let mut actionCardCounter: i32 =  tData.ActionCardCounter; actionCardCounter >= 0; actionCardCounter += -1)
      {
        let mut libSlot9: i32 =  tData.ActionCardObj[actionCardCounter].LibId.libSlot;
        if (libSlot9 > -1)
        {
          name: String = tData.LibraryObj[libSlot9].name;
          if (simpleStringList.FindNr(name) <= -1)
            tData.RemoveActionCard(actionCardCounter);
        }
      }
      historicalUnitCounter1: i32;
      for (historicalUnitCounter1 = tData.HistoricalUnitCounter; historicalUnitCounter1 >= 0; historicalUnitCounter1 += -1)
      {
        if (tData.HistoricalUnitObj[historicalUnitCounter1].Pool)
        {
          let mut libSlot10: i32 =  tData.HistoricalUnitObj[historicalUnitCounter1].LibId.libSlot;
          if (libSlot10 > -1)
          {
            name: String = tData.LibraryObj[libSlot10].name;
            if (simpleStringList.FindNr(name) > -1)
            {
              tData.HistoricalUnitObj[historicalUnitCounter1].ID = tData.HistoricalUnitObj[historicalUnitCounter1].LibId.id;
              if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals)
              {
                tData.HistoricalUnitObj[historicalUnitCounter1].OffLibId = LibIdClass::new();
                if (tData.HistoricalUnitObj[historicalUnitCounter1].CommanderName.Length > 0)
                {
                  tData.AddHistoricalUnit();
                  this.game.ProcessingObj.SwapOfficerOtherData(-1, historicalUnitCounter1, tData.HistoricalUnitCounter, -1,  tData);
                  tData.RemoveHistoricalUnit(tData.HistoricalUnitCounter);
                }
              }
            }
            else
              tData.RemoveHistoricalUnit(historicalUnitCounter1);
          }
          else
            tData.RemoveHistoricalUnit(historicalUnitCounter1);
        }
        else
          tData.RemoveHistoricalUnit(historicalUnitCounter1);
      }
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals)
      {
        let mut historicalUnitCounter2: i32 =  tData.HistoricalUnitCounter;
        for (let mut index6: i32 =  0; index6 <= historicalUnitCounter2; index6 += 1)
        {
          if (this.game.Data.HistoricalUnitObj[index6].NameCounterBackup > -1)
            this.game.Data.HistoricalUnitObj[index6].NameCounter = this.game.Data.HistoricalUnitObj[index6].NameCounterBackup;
          this.game.Data.HistoricalUnitObj[index6].NameCounterBackup = -1;
          if (this.game.Data.HistoricalUnitObj[index6].ModelMaster > -1)
          {
            let mut historicalUnitCounter3: i32 =  tData.HistoricalUnitCounter;
            for (let mut index7: i32 =  0; index7 <= historicalUnitCounter3; index7 += 1)
            {
              if (index7 == tData.HistoricalUnitObj[index6].ModelMaster)
              {
                let mut historical: i32 =  tData.FindHistorical( tData.HistoricalUnitObj[index7], this.game.Data.LibraryObj[tData.HistoricalUnitObj[index6].LibId.libSlot].name);
                tData.HistoricalUnitObj[index6].ModelMaster = historical;
                break;
              }
            }
          }
          if (this.game.Data.HistoricalUnitObj[index6].UseModelCounter > -1)
          {
            let mut historicalUnitCounter4: i32 =  tData.HistoricalUnitCounter;
            for (let mut index8: i32 =  0; index8 <= historicalUnitCounter4; index8 += 1)
            {
              if (tData.HistoricalUnitObj[index8].LibId.libSlot == historicalUnitCounter1 & index8 == this.game.Data.HistoricalUnitObj[index6].UseModelCounter)
              {
                let mut historical: i32 =  tData.FindHistorical( tData.HistoricalUnitObj[index8], tData.LibraryObj[tData.HistoricalUnitObj[index6].LibId.libSlot].name);
                tData.HistoricalUnitObj[index6].UseModelCounter = historical;
                break;
              }
            }
          }
        }
      }
      let mut num1: i32 =  1;
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals)
        num1 = 0;
      let mut peopleCounter: i32 =  tData.PeopleCounter;
      let mut num2: i32 =  num1;
      for (let mut nr: i32 =  peopleCounter; nr >= num2; nr += -1)
      {
        let mut libSlot11: i32 =  tData.PeopleObj[nr].LibId.libSlot;
        if (libSlot11 > -1)
        {
          name: String = tData.LibraryObj[libSlot11].name;
          if (simpleStringList.FindNr(name) > -1)
            tData.PeopleObj[nr].id = tData.PeopleObj[nr].LibId.id;
          else
            tData.RemovePeople(nr);
        }
        else if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals)
          tData.RemovePeople(nr);
      }
      if (this.game.EditObj.TempFileType != NewEnums.LibFileType.LoadMap)
      {
        for (let mut locCounter: i32 =  tData.LocCounter; locCounter >= 0; locCounter += -1)
          tData.RemoveLoc(locCounter);
      }
      if (this.game.EditObj.TempFileType != NewEnums.LibFileType.LoadHistoricals)
      {
        for (let mut unitCounter: i32 =  tData.UnitCounter; unitCounter >= 0; unitCounter += -1)
        {
          dataClass: DataClass = tData;
          let mut nr: i32 =  unitCounter;
          let mut gameClass: GameClass = (GameClass) null;
           let mut local: GameClass =  gameClass;
          dataClass.RemoveUnit(nr,  local);
        }
      }
      else
      {
        for (let mut unitCounter: i32 =  tData.UnitCounter; unitCounter >= 0; unitCounter += -1)
        {
          let mut libSlot12: i32 =  tData.UnitObj[unitCounter].LibId.libSlot;
          if (libSlot12 > -1)
          {
            name: String = tData.LibraryObj[libSlot12].name;
            if (simpleStringList.FindNr(name) > -1)
            {
              if (tData.UnitObj[unitCounter].PreDef == -1)
              {
                dataClass: DataClass = tData;
                let mut nr: i32 =  unitCounter;
                let mut gameClass: GameClass = (GameClass) null;
                 let mut local: GameClass =  gameClass;
                dataClass.RemoveUnit(nr,  local);
              }
              else
              {
                let mut num3: i32 =  0;
                let mut historicalUnitCounter5: i32 =  tData.HistoricalUnitCounter;
                for (let mut index9: i32 =  0; index9 <= historicalUnitCounter5; index9 += 1)
                {
                  if (tData.HistoricalUnitObj[index9].LibId.libSlot == libSlot)
                  {
                    let mut index10: i32 =  0;
                    do
                    {
                      if (tData.HistoricalUnitObj[index9].SubParts[index10] == tData.UnitObj[unitCounter].PreDef)
                        num3 = 1;
                      index10 += 1;
                    }
                    while (index10 <= 9);
                  }
                }
                if (num3 != 0)
                  ;
              }
            }
            else
            {
              dataClass: DataClass = tData;
              let mut nr: i32 =  unitCounter;
              let mut gameClass: GameClass = (GameClass) null;
               let mut local: GameClass =  gameClass;
              dataClass.RemoveUnit(nr,  local);
            }
          }
          else
          {
            dataClass: DataClass = tData;
            let mut nr: i32 =  unitCounter;
            let mut gameClass: GameClass = (GameClass) null;
             let mut local: GameClass =  gameClass;
            dataClass.RemoveUnit(nr,  local);
          }
        }
        SimpleList simpleList = SimpleList::new();
        for (let mut index11: i32 =  tData.UnitCounter; index11 >= 0; index11 += -1)
        {
          if (tData.UnitObj[index11].PreDef > -1)
          {
            if (index11 == 27)
              index11 = index11;
            simpleList.Add(tData.UnitObj[index11].PreDef, tData.UnitObj[index11].LibId.id, CheckExistence: false);
            tData.UnitObj[index11].PreDef = tData.UnitObj[index11].LibId.id;
            if (tData.UnitObj[index11].PreDef == -1)
              index11 = index11;
          }
        }
        bool[,] flagArray = new bool[tData.HistoricalUnitCounter + 1, 10];
        let mut counter: i32 =  simpleList.Counter;
        for (let mut index12: i32 =  0; index12 <= counter; index12 += 1)
        {
          let mut historicalUnitCounter6: i32 =  tData.HistoricalUnitCounter;
          for (let mut index13: i32 =  0; index13 <= historicalUnitCounter6; index13 += 1)
          {
            if (index13 == 6 & simpleList.Id[index12] == 70)
              index13 = index13;
            let mut index14: i32 =  0;
            do
            {
              if (tData.HistoricalUnitObj[index13].SubParts[index14] == simpleList.Id[index12] & !flagArray[index13, index14])
              {
                if (index13 == 6)
                  index13 = index13;
                flagArray[index13, index14] = true;
                tData.HistoricalUnitObj[index13].SubParts[index14] = simpleList.Weight[index12];
              }
              index14 += 1;
            }
            while (index14 <= 9);
          }
        }
      }
      for (let mut sfTypeCounter: i32 =  tData.SFTypeCounter; sfTypeCounter >= 0; sfTypeCounter += -1)
      {
        let mut libSlot13: i32 =  tData.SFTypeObj[sfTypeCounter].LibId.libSlot;
        if (libSlot13 > -1)
        {
          name: String = tData.LibraryObj[libSlot13].name;
          if (simpleStringList.FindNr(name) > -1)
          {
            tData.SFTypeObj[sfTypeCounter].Id = tData.SFTypeObj[sfTypeCounter].LibId.id;
            tData.SFTypeObj[sfTypeCounter].CopyDataFrom = tData.SFTypeObj[sfTypeCounter].CopyDataFromBackup;
            tData.SFTypeObj[sfTypeCounter].CopyDataFromBackup = -1;
          }
          else
            tData.RemoveSFType(sfTypeCounter);
        }
      }
      let mut unitCounter1: i32 =  tData.UnitCounter;
      for (let mut index15: i32 =  0; index15 <= unitCounter1; index15 += 1)
        tData.UnitObj[index15].Regime = 0;
      let mut historicalUnitCounter7: i32 =  tData.HistoricalUnitCounter;
      for (let mut index16: i32 =  0; index16 <= historicalUnitCounter7; index16 += 1)
        tData.HistoricalUnitObj[index16].TempRegime = 0;
      let mut num4: i32 =  0;
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers)
        num4 = 1;
      for (let mut regimeCounter: i32 =  tData.RegimeCounter; regimeCounter >= 1; regimeCounter += -1)
        tData.RemoveRegime(regimeCounter);
      if (this.game.EditObj.TempFileType != NewEnums.LibFileType.LoadMap)
      {
        let mut w: i32 =  1;
        let mut h: i32 =  1;
        tData.MapObj[0] = new MapClass(0, 0, w, h);
        tData.MapObj[0].MapWidth = w;
        tData.MapObj[0].MapHeight = h;
        tData.HexObj = new HexClass[w + 1, h + 1];
        let mut mapWidth: i32 =  tData.MapObj[0].MapWidth;
        for (let mut index17: i32 =  0; index17 <= mapWidth; index17 += 1)
        {
          let mut mapHeight: i32 =  tData.MapObj[0].MapHeight;
          for (let mut index18: i32 =  0; index18 <= mapHeight; index18 += 1)
            tData.MapObj[0].HexObj[index17, index18] = new HexClass(0, 0, 0);
        }
      }
      for (let mut libVarCounter: i32 =  tData.LibVarCounter; libVarCounter >= 0; libVarCounter += -1)
      {
        let mut libSlot14: i32 =  tData.LibVarObj[libVarCounter].libId.libSlot;
        if (libSlot14 > -1)
        {
          name: String = tData.LibraryObj[libSlot14].name;
          if (simpleStringList.FindNr(name) <= -1)
            tData.RemoveLibVar(libVarCounter);
        }
      }
      for (let mut libraryCounter: i32 =  tData.LibraryCounter; libraryCounter >= 0; libraryCounter += -1)
      {
        let mut index19: i32 =  libraryCounter;
        if (index19 > -1)
        {
          name: String = tData.LibraryObj[index19].name;
          if (simpleStringList.FindNr(name) <= -1)
            tData.RemoveLibrary(libraryCounter);
        }
      }
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers)
      {
        this.game.Data.RegimeObj[0].Name = "Placeholder Regime";
        this.game.Data.PeopleObj[0].Name = "Universals";
      }
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadTroops)
        this.game.Data.PeopleObj[0].Name = "Universals";
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadMap)
        this.game.Data.PeopleObj[0].Name = "Universals";
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals)
        this.game.Data.RegimeObj[0].Name = "Placeholder Regime";
      if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers)
      {
        let mut num5: i32 =  0;
        let mut historicalUnitCounter8: i32 =  tData.HistoricalUnitCounter;
        for (let mut index20: i32 =  0; index20 <= historicalUnitCounter8; index20 += 1)
        {
          if (tData.HistoricalUnitObj[index20].ID > num5)
            num5 = tData.HistoricalUnitObj[index20].ID;
        }
        if (tData.HistoricalIDCounter > num5)
          tData.HistoricalIDCounter = num5;
      }
      return tData;
    }

    pub void ActuallyImportLibs(
       TData: DataClass,
       bool[] import,
       int[] sublib,
       int[] subPpl,
       int[] subreg)
    {
      let mut libraryCounter1: i32 =  TData.LibraryCounter;
      for (let mut index1: i32 =  0; index1 <= libraryCounter1; index1 += 1)
      {
        if (import[index1])
        {
          libraryCounter2: i32;
          if (sublib[index1] == -1)
          {
            this.game.Data.AddLibrary();
            this.game.Data.LibraryObj[this.game.Data.LibraryCounter] = TData.LibraryObj[index1].Clone();
            libraryCounter2 = this.game.Data.LibraryCounter;
          }
          else
          {
            libraryCounter2 = sublib[index1];
            this.game.Data.LibraryObj[libraryCounter2] = TData.LibraryObj[index1].Clone();
          }
          bool[] flagArray = new bool[this.game.Data.LibVarCounter + 1];
          let mut libVarCounter: i32 =  TData.LibVarCounter;
          index2: i32;
          for (let mut index3: i32 =  0; index3 <= libVarCounter; index3 += 1)
          {
            if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadEvents | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficerCards | this.game.EditObj.TempFileType == NewEnums.LibFileType.ImportCardsInOfficerEditor && TData.LibVarObj[index3].libId.libSlot == index1 & TData.LibVarObj[index3].libId.id == -1)
            {
              bool flag = false;
              if (sublib[index1] > -1)
              {
                index2 = this.game.Data.FindLibVar( TData.LibVarObj[index3], this.game.Data.LibraryObj[sublib[index1]].name);
                if (index2 > -1)
                {
                  if (this.game.Data.LibVarObj[index2].type == TData.LibVarObj[index3].type & this.game.Data.LibVarObj[index2].valueType == TData.LibVarObj[index3].valueType)
                  {
                    this.game.Data.LibVarObj[index2].information = TData.LibVarObj[index3].information;
                    flag = true;
                    flagArray[index2] = true;
                  }
                  else
                    index2 = index2;
                }
              }
              if (!flag)
              {
                this.game.Data.AddLibVar(this.game.Data.LibraryCounter);
                this.game.Data.LibVarObj[this.game.Data.LibVarCounter] = TData.LibVarObj[index3].Clone();
                this.game.Data.LibVarObj[this.game.Data.LibVarCounter].libId.libSlot = libraryCounter2;
                this.game.Data.LibVarObj[this.game.Data.LibVarCounter].libId.id = -1;
              }
            }
          }
          if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadEvents | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficerCards | this.game.EditObj.TempFileType == NewEnums.LibFileType.ImportCardsInOfficerEditor)
          {
            let mut eventPicCounter: i32 =  TData.EventPicCounter;
            for (let mut eventPicOrigSlot: i32 =  0; eventPicOrigSlot <= eventPicCounter; eventPicOrigSlot += 1)
            {
              if (TData.eventPicLibId[eventPicOrigSlot].libSlot == index1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindEventPic(TData.EventPicName[eventPicOrigSlot], eventPicOrigSlot, this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1 && this.game.Data.eventPicLibId[index2].libSlot == sublib[index1])
                  {
                    flag = true;
                    this.game.Data.eventPicLibId[index2].libSlot = libraryCounter2;
                    this.game.Data.eventPicLibId[index2].id = eventPicOrigSlot;
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddEventPic(TData.EventPicName[eventPicOrigSlot]);
                  this.game.Data.eventPicLibId[this.game.Data.EventPicCounter].libSlot = libraryCounter2;
                  this.game.Data.eventPicLibId[this.game.Data.EventPicCounter].id = eventPicOrigSlot;
                }
              }
            }
          }
          if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadEvents | this.game.EditObj.TempFileType == NewEnums.LibFileType.ImportCardsInOfficerEditor | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficerCards | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals)
          {
            let mut smallPicCounter: i32 =  TData.SmallPicCounter;
            for (let mut smallId: i32 =  0; smallId <= smallPicCounter; smallId += 1)
            {
              if (TData.SmallLibId[smallId].libSlot == index1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindSmallPic(TData.SmallPicName[smallId], smallId, this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1 && this.game.Data.SmallLibId[index2].libSlot == sublib[index1])
                  {
                    flag = true;
                    this.game.Data.SmallLibId[index2].libSlot = libraryCounter2;
                    this.game.Data.SmallLibId[index2].id = smallId;
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddSmallPic(TData.SmallPicName[smallId]);
                  this.game.Data.SmallLibId[this.game.Data.SmallPicCounter].libSlot = libraryCounter2;
                  this.game.Data.SmallLibId[this.game.Data.SmallPicCounter].id = smallId;
                }
              }
            }
          }
          if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadEvents | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficerCards | this.game.EditObj.TempFileType == NewEnums.LibFileType.ImportCardsInOfficerEditor)
          {
            let mut eventCounter: i32 =  TData.EventCounter;
            for (let mut index4: i32 =  0; index4 <= eventCounter; index4 += 1)
            {
              if (TData.EventObj[index4].LibId.libSlot == index1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindEvent( TData.EventObj[index4], this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag = true;
                    let mut id: i32 =  this.game.Data.EventObj[index2].Id;
                    this.game.Data.EventObj[index2] = TData.EventObj[index4].Clone();
                    this.game.Data.EventObj[index2].Id = id;
                    this.game.Data.EventObj[index2].LibId.libSlot = libraryCounter2;
                    this.game.Data.EventObj[index2].LibId.id = TData.EventObj[index4].Id;
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddEvent();
                  this.game.Data.EventObj[this.game.Data.EventCounter] = TData.EventObj[index4].Clone();
                  this += 1.game.Data.EventIdCounter;
                  this.game.Data.EventObj[this.game.Data.EventCounter].Id = this.game.Data.EventIdCounter;
                  this.game.Data.EventObj[this.game.Data.EventCounter].LibId.libSlot = libraryCounter2;
                  this.game.Data.EventObj[this.game.Data.EventCounter].LibId.id = TData.EventObj[index4].Id;
                }
              }
            }
          }
          if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadEvents | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficerCards | this.game.EditObj.TempFileType == NewEnums.LibFileType.ImportCardsInOfficerEditor)
          {
            let mut actionCardCounter: i32 =  TData.ActionCardCounter;
            for (let mut origCardSlot: i32 =  0; origCardSlot <= actionCardCounter; origCardSlot += 1)
            {
              if (TData.ActionCardObj[origCardSlot].LibId.libSlot == index1)
              {
                bool flag1 = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindActionCard( TData.ActionCardObj[origCardSlot], origCardSlot, this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag1 = true;
                    this.game.Data.ActionCardObj[index2] = TData.ActionCardObj[origCardSlot].Clone();
                    this.game.Data.ActionCardObj[index2].LibId.libSlot = libraryCounter2;
                    this.game.Data.ActionCardObj[index2].LibId.id = origCardSlot;
                  }
                }
                if (!flag1)
                {
                  this.game.Data.AddActionCard();
                  this.game.Data.ActionCardObj[this.game.Data.ActionCardCounter] = TData.ActionCardObj[origCardSlot].Clone();
                  this.game.Data.ActionCardObj[this.game.Data.ActionCardCounter].LibId.libSlot = libraryCounter2;
                  this.game.Data.ActionCardObj[this.game.Data.ActionCardCounter].LibId.id = origCardSlot;
                  index2 = this.game.Data.ActionCardCounter;
                }
                if (this.game.Data.ActionCardObj[index2].PreExecuteEvent > -1)
                {
                  let mut eventCounter: i32 =  this.game.Data.EventCounter;
                  for (let mut index5: i32 =  0; index5 <= eventCounter; index5 += 1)
                  {
                    if (this.game.Data.EventObj[index5].LibId.libSlot == libraryCounter2 && this.game.Data.EventObj[index5].LibId.id == TData.EventObj[TData.ActionCardObj[origCardSlot].PreExecuteEvent].Id)
                    {
                      this.game.Data.ActionCardObj[index2].PreExecuteEvent = index5;
                      break;
                    }
                  }
                }
                if (this.game.Data.ActionCardObj[index2].ExecuteEvent > -1)
                {
                  let mut eventCounter: i32 =  this.game.Data.EventCounter;
                  for (let mut index6: i32 =  0; index6 <= eventCounter; index6 += 1)
                  {
                    if (this.game.Data.EventObj[index6].LibId.libSlot == libraryCounter2 && this.game.Data.EventObj[index6].LibId.id == TData.EventObj[TData.ActionCardObj[origCardSlot].ExecuteEvent].Id)
                    {
                      this.game.Data.ActionCardObj[index2].ExecuteEvent = index6;
                      break;
                    }
                  }
                }
                if (TData.ActionCardObj[origCardSlot].SmallGfx > -1)
                {
                  str: String = TData.SmallPicName[TData.ActionCardObj[origCardSlot].SmallGfx];
                  bool flag2 = false;
                  let mut smallPicCounter: i32 =  this.game.Data.SmallPicCounter;
                  for (let mut index7: i32 =  0; index7 <= smallPicCounter; index7 += 1)
                  {
                    if (Operators.CompareString(this.game.Data.SmallPicName[index7], str, false) == 0 & this.game.Data.SmallLibId[index7].libSlot == libraryCounter2)
                    {
                      this.game.Data.ActionCardObj[index2].SmallGfx = index7;
                      flag2 = true;
                    }
                  }
                  if (!flag2)
                  {
                    let mut num: i32 =   Interaction.MsgBox( "Error: Card uses smallgraphic not included in lib");
                    this.game.Data.AddSmallPic(str);
                    this.game.Data.ActionCardObj[index2].SmallGfx = this.game.Data.SmallPicCounter;
                  }
                }
                if (TData.ActionCardObj[origCardSlot].EventPicNr > -1)
                {
                  str: String = TData.EventPicName[TData.ActionCardObj[origCardSlot].EventPicNr];
                  bool flag3 = false;
                  let mut eventPicCounter: i32 =  this.game.Data.EventPicCounter;
                  for (let mut index8: i32 =  0; index8 <= eventPicCounter; index8 += 1)
                  {
                    if (Operators.CompareString(this.game.Data.EventPicName[index8], str, false) == 0 & this.game.Data.eventPicLibId[index8].libSlot == libraryCounter2)
                    {
                      this.game.Data.ActionCardObj[index2].EventPicNr = index8;
                      flag3 = true;
                    }
                  }
                  if (!flag3)
                  {
                    let mut num: i32 =   Interaction.MsgBox( "Error: Card uses graphic not included in lib");
                    this.game.Data.AddEventPic(str);
                    this.game.Data.ActionCardObj[index2].EventPicNr = this.game.Data.EventPicCounter;
                  }
                }
                if (TData.ActionCardObj[origCardSlot].AlternateEventPicNr > -1)
                {
                  str: String = TData.EventPicName[TData.ActionCardObj[origCardSlot].AlternateEventPicNr];
                  bool flag4 = false;
                  let mut eventPicCounter: i32 =  this.game.Data.EventPicCounter;
                  for (let mut index9: i32 =  0; index9 <= eventPicCounter; index9 += 1)
                  {
                    if (Operators.CompareString(this.game.Data.EventPicName[index9], str, false) == 0 & this.game.Data.eventPicLibId[index9].libSlot == libraryCounter2)
                    {
                      this.game.Data.ActionCardObj[index2].AlternateEventPicNr = index9;
                      flag4 = true;
                    }
                  }
                  if (!flag4)
                  {
                    let mut num: i32 =   Interaction.MsgBox( "Error: Card uses graphic not included in lib");
                    this.game.Data.AddEventPic(str);
                    this.game.Data.ActionCardObj[index2].AlternateEventPicNr = this.game.Data.EventPicCounter;
                  }
                }
              }
            }
          }
          if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadEvents | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficerCards | this.game.EditObj.TempFileType == NewEnums.LibFileType.ImportCardsInOfficerEditor)
          {
            let mut stringListCounter1: i32 =  TData.StringListCounter;
            for (let mut index10: i32 =  0; index10 <= stringListCounter1; index10 += 1)
            {
              if (TData.StringListObj[index10].LibId.libSlot == index1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindStringList( TData.StringListObj[index10], this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag = true;
                    StringListClass stringListClass = this.game.Data.StringListObj[index2].Clone();
                    this.game.Data.StringListObj[index2] = TData.StringListObj[index10].Clone();
                    this.game.Data.StringListObj[index2].LibId.libSlot = libraryCounter2;
                    this.game.Data.StringListObj[index2].LibId.id = TData.StringListObj[index10].ID;
                    this.game.Data.StringListObj[index2].ID = stringListClass.ID;
                    if (this.game.Data.Product > 5)
                    {
                      this.game.Data.StringListObj[index2].LookUpId = stringListClass.LookUpId;
                      this.game.Data.StringListObj[index2].LookUpLabel = stringListClass.LookUpLabel;
                    }
                    if (this.game.Data.StringListObj[index2].Editable)
                    {
                      let mut width: i32 =  stringListClass.Width;
                      for (let mut index11: i32 =  0; index11 <= width; index11 += 1)
                      {
                        let mut length: i32 =  stringListClass.Length;
                        for (let mut index12: i32 =  0; index12 <= length; index12 += 1)
                        {
                          if (index11 <= this.game.Data.StringListObj[index2].Width & index12 <= this.game.Data.StringListObj[index2].Length)
                            this.game.Data.StringListObj[index2].Data[index12, index11] = stringListClass.ColValueType[index11] != this.game.Data.StringListObj[index2].ColValueType[index11] ? "" : stringListClass.Data[index12, index11];
                          else if (index11 <= this.game.Data.StringListObj[index2].Width)
                          {
                            this.game.Data.StringListObj[index2].AddRow(this.game.Data.StringListObj[index2].Length);
                            this.game.Data.StringListObj[index2].Data[index12, index11] = stringListClass.ColValueType[index11] != this.game.Data.StringListObj[index2].ColValueType[index11] ? "" : stringListClass.Data[index12, index11];
                          }
                        }
                      }
                    }
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddStringList();
                  this.game.Data.StringListObj[this.game.Data.StringListCounter] = TData.StringListObj[index10].Clone();
                  this.game.Data.StringListObj[this.game.Data.StringListCounter].ID = this.game.Data.StringIDCounter;
                  this.game.Data.StringListObj[this.game.Data.StringListCounter].LibId.libSlot = libraryCounter2;
                  this.game.Data.StringListObj[this.game.Data.StringListCounter].LibId.id = TData.StringListObj[index10].ID;
                }
              }
            }
            let mut stringListCounter2: i32 =  this.game.Data.StringListCounter;
            for (let mut index13: i32 =  0; index13 <= stringListCounter2; index13 += 1)
            {
              if (this.game.Data.StringListObj[index13].LibId.libSlot == libraryCounter2)
              {
                let mut width: i32 =  this.game.Data.StringListObj[index13].Width;
                for (let mut index14: i32 =  0; index14 <= width; index14 += 1)
                {
                  if (this.game.Data.StringListObj[index13].LookUpCol[index14] > 0)
                  {
                    let mut stringListCounter3: i32 =  this.game.Data.StringListCounter;
                    for (let mut index15: i32 =  0; index15 <= stringListCounter3; index15 += 1)
                    {
                      if (this.game.Data.StringListObj[index15].LibId.libSlot == libraryCounter2 && this.game.Data.StringListObj[index15].LibId.id == this.game.Data.StringListObj[index13].LookUpCol[index14])
                      {
                        this.game.Data.StringListObj[index13].LookUpCol[index14] = this.game.Data.StringListObj[index15].ID;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadTroops | this.game.EditObj.TempFileType == NewEnums.LibFileType.ImportTroopsInHistoricalEditor)
          {
            let mut sfTypeCounter: i32 =  TData.SFTypeCounter;
            for (let mut index16: i32 =  0; index16 <= sfTypeCounter; index16 += 1)
            {
              if (TData.SFTypeObj[index16].LibId.libSlot == index1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindSFType( TData.SFTypeObj[index16], this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag = true;
                    let mut id: i32 =  this.game.Data.SFTypeObj[index2].Id;
                    this.game.Data.SFTypeObj[index2] = TData.SFTypeObj[index16].Clone();
                    this.game.Data.SFTypeObj[index2].Id = id;
                    this.game.Data.SFTypeObj[index2].LibId.libSlot = libraryCounter2;
                    this.game.Data.SFTypeObj[index2].LibId.id = TData.SFTypeObj[index16].Id;
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddSFType();
                  this.game.Data.SFTypeObj[this.game.Data.SFTypeCounter] = TData.SFTypeObj[index16].Clone();
                  this += 1.game.Data.SFTypeIdCounter;
                  this.game.Data.SFTypeObj[this.game.Data.SFTypeCounter].Id = this.game.Data.SFTypeIdCounter;
                  this.game.Data.SFTypeObj[this.game.Data.SFTypeCounter].LibId.libSlot = libraryCounter2;
                  this.game.Data.SFTypeObj[this.game.Data.SFTypeCounter].LibId.id = TData.SFTypeObj[index16].Id;
                  index2 = this.game.Data.SFTypeCounter;
                }
                this.game.Data.SFTypeObj[index2].CopyDataFromBackup = this.game.Data.SFTypeObj[index2].CopyDataFrom;
                this.game.Data.SFTypeObj[index2].CopyDataFrom = -1;
                let mut reinfCounter: i32 =  TData.ReinfCounter;
                for (let mut index17: i32 =  0; index17 <= reinfCounter; index17 += 1)
                {
                  if (TData.SFTypeObj[index16].ReinforcementType > -1)
                  {
                    let mut reinf: i32 =  this.game.Data.FindReinf(TData.ReinfName[TData.SFTypeObj[index16].ReinforcementType], TData.ReinfId[TData.SFTypeObj[index16].ReinforcementType], this.game.Data.LibraryObj[libraryCounter2].name);
                    if (reinf > -1)
                    {
                      this.game.Data.SFTypeObj[index2].ReinforcementType = reinf;
                      this.game.Data.ReinfRatio[reinf] = TData.ReinfRatio[TData.SFTypeObj[index16].ReinforcementType];
                    }
                    else
                    {
                      this.game.Data.AddReinf(TData.ReinfName[TData.SFTypeObj[index16].ReinforcementType]);
                      this.game.Data.ReinfRatio[this.game.Data.ReinfCounter] = TData.ReinfRatio[TData.SFTypeObj[index16].ReinforcementType];
                      this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].id = TData.ReinfId[TData.SFTypeObj[index16].ReinforcementType];
                      this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].libSlot = libraryCounter2;
                    }
                  }
                  if (TData.SFTypeObj[index16].ReinforcementType2 > -1)
                  {
                    let mut reinf: i32 =  this.game.Data.FindReinf(TData.ReinfName[TData.SFTypeObj[index16].ReinforcementType2], TData.ReinfId[TData.SFTypeObj[index16].ReinforcementType2], this.game.Data.LibraryObj[libraryCounter2].name);
                    if (reinf > -1)
                    {
                      this.game.Data.SFTypeObj[index2].ReinforcementType2 = reinf;
                      this.game.Data.ReinfRatio[reinf] = TData.ReinfRatio[TData.SFTypeObj[index16].ReinforcementType2];
                    }
                    else
                    {
                      this.game.Data.AddReinf(TData.ReinfName[TData.SFTypeObj[index16].ReinforcementType2]);
                      this.game.Data.ReinfRatio[this.game.Data.ReinfCounter] = TData.ReinfRatio[TData.SFTypeObj[index16].ReinforcementType2];
                      this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].id = TData.ReinfId[TData.SFTypeObj[index16].ReinforcementType2];
                      this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].libSlot = libraryCounter2;
                    }
                  }
                  if (TData.SFTypeObj[index16].ReinforcementType3 > -1)
                  {
                    let mut reinf: i32 =  this.game.Data.FindReinf(TData.ReinfName[TData.SFTypeObj[index16].ReinforcementType3], TData.ReinfId[TData.SFTypeObj[index16].ReinforcementType3], this.game.Data.LibraryObj[libraryCounter2].name);
                    if (reinf > -1)
                    {
                      this.game.Data.SFTypeObj[index2].ReinforcementType3 = reinf;
                      this.game.Data.ReinfRatio[reinf] = TData.ReinfRatio[TData.SFTypeObj[index16].ReinforcementType3];
                    }
                    else
                    {
                      this.game.Data.AddReinf(TData.ReinfName[TData.SFTypeObj[index16].ReinforcementType3]);
                      this.game.Data.ReinfRatio[this.game.Data.ReinfCounter] = TData.ReinfRatio[TData.SFTypeObj[index16].ReinforcementType3];
                      this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].id = TData.ReinfId[TData.SFTypeObj[index16].ReinforcementType3];
                      this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].libSlot = libraryCounter2;
                    }
                  }
                }
              }
            }
            let mut reinfCounter1: i32 =  TData.ReinfCounter;
            for (let mut index18: i32 =  0; index18 <= reinfCounter1; index18 += 1)
            {
              if (this.game.Data.FindReinf(TData.ReinfName[index18], TData.ReinfId[index18], this.game.Data.LibraryObj[libraryCounter2].name) <= -1)
              {
                this.game.Data.AddReinf(TData.ReinfName[index18]);
                this.game.Data.ReinfRatio[this.game.Data.ReinfCounter] = TData.ReinfRatio[index18];
                this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].id = TData.ReinfId[index18];
                this.game.Data.ReinfLibId[this.game.Data.ReinfCounter].libSlot = libraryCounter2;
              }
            }
          }
          if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals | this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers)
          {
            let mut peopleCounter1: i32 =  TData.PeopleCounter;
            for (let mut index19: i32 =  0; index19 <= peopleCounter1; index19 += 1)
            {
              if (TData.PeopleObj[index19].LibId.libSlot == index1 & subPpl[index19] == -1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindPeople( TData.PeopleObj[index19], this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag = true;
                    let mut id: i32 =  this.game.Data.PeopleObj[index2].id;
                    this.game.Data.PeopleObj[index2] = TData.PeopleObj[index19].Clone();
                    this.game.Data.PeopleObj[index2].id = id;
                    this.game.Data.PeopleObj[index2].LibId.libSlot = libraryCounter2;
                    this.game.Data.PeopleObj[index2].LibId.id = TData.PeopleObj[index19].id;
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddPeople();
                  this.game.Data.PeopleObj[this.game.Data.PeopleCounter] = TData.PeopleObj[index19].Clone();
                  this += 1.game.Data.PeopleIdCounter;
                  this.game.Data.PeopleObj[this.game.Data.PeopleCounter].id = this.game.Data.PeopleIdCounter;
                  this.game.Data.PeopleObj[this.game.Data.PeopleCounter].LibId.libSlot = libraryCounter2;
                  this.game.Data.PeopleObj[this.game.Data.PeopleCounter].LibId.id = TData.PeopleObj[index19].id;
                }
              }
              else if (TData.PeopleObj[index19].LibId.libSlot == index1 & subPpl[index19] > -1 && sublib[index1] > -1)
              {
                index2 = this.game.Data.FindPeople( TData.PeopleObj[index19], this.game.Data.LibraryObj[sublib[index1]].name);
                if (index2 > -1 & subPpl[index19] == index2)
                {
                  let mut id: i32 =  this.game.Data.PeopleObj[index2].id;
                  this.game.Data.PeopleObj[index2] = TData.PeopleObj[index19].Clone();
                  this.game.Data.PeopleObj[index2].id = id;
                  this.game.Data.PeopleObj[index2].LibId.libSlot = libraryCounter2;
                  this.game.Data.PeopleObj[index2].LibId.id = TData.PeopleObj[index19].id;
                }
              }
            }
            let mut unitCounter: i32 =  TData.UnitCounter;
            for (let mut index20: i32 =  0; index20 <= unitCounter; index20 += 1)
            {
              if (TData.UnitObj[index20].LibId.libSlot == index1 & TData.UnitObj[index20].PreDef > -1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindUnit( TData.UnitObj[index20], this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag = true;
                    let mut preDef: i32 =  this.game.Data.UnitObj[index2].PreDef;
                    this.game.Data.UnitObj[index2] = TData.UnitObj[index20].Clone();
                    this.game.Data.UnitObj[index2].PreDef = preDef;
                    this.game.Data.UnitObj[index2].LibId.libSlot = libraryCounter2;
                    this.game.Data.UnitObj[index2].LibId.id = TData.UnitObj[index20].PreDef;
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddUnit(-1, -1, -1);
                  this.game.Data.UnitObj[this.game.Data.UnitCounter] = TData.UnitObj[index20].Clone();
                  this.game.Data.UnitObj[this.game.Data.UnitCounter].PreDef = this.game.HandyFunctionsObj.GetNextPreDefNr();
                  this.game.Data.UnitObj[this.game.Data.UnitCounter].LibId.libSlot = libraryCounter2;
                  this.game.Data.UnitObj[this.game.Data.UnitCounter].LibId.id = TData.UnitObj[index20].PreDef;
                  this.game.Data.UnitObj[this.game.Data.UnitCounter].SFCount = -1;
                  index2 = this.game.Data.UnitCounter;
                }
                for (let mut sfCount: i32 =  this.game.Data.UnitObj[index2].SFCount; sfCount >= 0; sfCount += -1)
                  this.game.Data.UnitObj[index2].RemoveSF(this.game.Data.UnitObj[index2].SFList[sfCount]);
                let mut sfCount1: i32 =  TData.UnitObj[index20].SFCount;
                for (let mut index21: i32 =  0; index21 <= sfCount1; index21 += 1)
                {
                  this.game.Data.AddSF(index2);
                  this.game.Data.SFObj[this.game.Data.SFCounter] = TData.SFObj[TData.UnitObj[index20].SFList[index21]].Clone();
                  if (this.game.Data.SFObj[this.game.Data.SFCounter].Mor > 50)
                    index20 = index20;
                  this.game.Data.SFObj[this.game.Data.SFCounter].Type = this.game.Data.FindSFType( TData.SFTypeObj[TData.SFObj[TData.UnitObj[index20].SFList[index21]].Type], TData.LibraryObj[TData.SFTypeObj[TData.SFObj[TData.UnitObj[index20].SFList[index21]].Type].LibId.libSlot].name, true);
                  if (subPpl[TData.SFObj[TData.UnitObj[index20].SFList[index21]].People] > -1)
                  {
                    this.game.Data.SFObj[this.game.Data.SFCounter].People = subPpl[TData.SFObj[TData.UnitObj[index20].SFList[index21]].People];
                  }
                  else
                  {
                    let mut peopleCounter2: i32 =  this.game.Data.PeopleCounter;
                    for (let mut index22: i32 =  0; index22 <= peopleCounter2; index22 += 1)
                    {
                      if (this.game.Data.PeopleObj[index22].LibId.libSlot == libraryCounter2 && this.game.Data.PeopleObj[index22].LibId.id == TData.PeopleObj[TData.SFObj[TData.UnitObj[index20].SFList[index21]].People].id)
                        this.game.Data.SFObj[this.game.Data.SFCounter].People = index22;
                    }
                  }
                }
              }
            }
            let mut regimeCounter1: i32 =  TData.RegimeCounter;
            for (let mut index23: i32 =  0; index23 <= regimeCounter1; index23 += 1)
            {
              if (TData.RegimeObj[index23].libId.libSlot == index1 & subreg[index23] == -1)
              {
                bool flag = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindRegime( TData.RegimeObj[index23], this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag = true;
                    this.game.Data.RegimeObj[index2] = TData.RegimeObj[index23].Clone();
                    this += 1.game.Data.RegimeIdCounter;
                    this.game.Data.RegimeObj[index2].id = this.game.Data.RegimeIdCounter;
                    this.game.Data.RegimeObj[index2].libId.libSlot = libraryCounter2;
                    this.game.Data.RegimeObj[index2].libId.id = TData.RegimeObj[index23].id;
                  }
                }
                if (!flag)
                {
                  this.game.Data.AddRegime();
                  this.game.Data.RegimeObj[this.game.Data.RegimeCounter] = TData.RegimeObj[index23].Clone();
                  this += 1.game.Data.RegimeIdCounter;
                  this.game.Data.RegimeObj[this.game.Data.RegimeCounter].id = this.game.Data.RegimeIdCounter;
                  this.game.Data.RegimeObj[this.game.Data.RegimeCounter].libId.libSlot = libraryCounter2;
                  this.game.Data.RegimeObj[this.game.Data.RegimeCounter].libId.id = TData.RegimeObj[index23].id;
                  index2 = this.game.Data.RegimeCounter;
                }
                if (subPpl[TData.RegimeObj[index23].People] > -1)
                {
                  this.game.Data.RegimeObj[index2].People = subPpl[TData.RegimeObj[index23].People];
                }
                else
                {
                  let mut peopleCounter3: i32 =  this.game.Data.PeopleCounter;
                  for (let mut index24: i32 =  0; index24 <= peopleCounter3; index24 += 1)
                  {
                    if (this.game.Data.PeopleObj[index24].LibId.libSlot == libraryCounter2 && this.game.Data.PeopleObj[index24].LibId.id == TData.PeopleObj[TData.RegimeObj[index23].People].id)
                      this.game.Data.SFObj[index2].People = index24;
                  }
                }
              }
            }
            let mut historicalUnitCounter1: i32 =  TData.HistoricalUnitCounter;
            for (let mut index25: i32 =  0; index25 <= historicalUnitCounter1; index25 += 1)
            {
              if (TData.HistoricalUnitObj[index25].LibId.libSlot == index1 && TData.HistoricalUnitObj[index25].People > -1 & TData.HistoricalUnitObj[index25].TempRegime > -1)
              {
                bool flag5 = false;
                if (sublib[index1] > -1)
                {
                  index2 = this.game.Data.FindHistorical( TData.HistoricalUnitObj[index25], this.game.Data.LibraryObj[sublib[index1]].name);
                  if (index2 > -1)
                  {
                    flag5 = true;
                    if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers | TData.HistoricalUnitObj[index25].CommanderName.Length > 0)
                    {
                      bool pool = this.game.Data.HistoricalUnitObj[index2].Pool;
                      let mut id: i32 =  this.game.Data.HistoricalUnitObj[index2].ID;
                      this.game.Data.HistoricalUnitObj[index2] = TData.HistoricalUnitObj[index25].Clone();
                      this.game.Data.HistoricalUnitObj[index2].Pool = pool;
                      this.game.Data.HistoricalUnitObj[index2].ID = id;
                      this.game.Data.HistoricalUnitObj[index2].LibId.libSlot = libraryCounter2;
                      this.game.Data.HistoricalUnitObj[index2].LibId.id = TData.HistoricalUnitObj[index25].ID;
                    }
                    else
                    {
                      let mut num: i32 =  0;
                      if (this.game.Data.HistoricalUnitObj[index2].CommanderName.Length > 0 & TData.HistoricalUnitObj[index25].CommanderName.Length < 1)
                      {
                        num = 1;
                        this.game.Data.AddHistoricalUnit();
                        this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter] = this.game.Data.HistoricalUnitObj[index2].Clone();
                      }
                      let mut nameCounter: i32 =  this.game.Data.HistoricalUnitObj[index2].NameCounter;
                      bool pool = this.game.Data.HistoricalUnitObj[index2].Pool;
                      let mut id: i32 =  this.game.Data.HistoricalUnitObj[index2].ID;
                      this.game.Data.HistoricalUnitObj[index2] = TData.HistoricalUnitObj[index25].Clone();
                      this.game.Data.HistoricalUnitObj[index2].NameCounterBackup = this.game.Data.HistoricalUnitObj[index2].NameCounter;
                      if (nameCounter > this.game.Data.HistoricalUnitObj[index2].NameCounter)
                        this.game.Data.HistoricalUnitObj[index2].NameCounter = nameCounter;
                      this.game.Data.HistoricalUnitObj[index2].Pool = pool;
                      this.game.Data.HistoricalUnitObj[index2].ID = id;
                      this.game.Data.HistoricalUnitObj[index2].LibId.libSlot = libraryCounter2;
                      this.game.Data.HistoricalUnitObj[index2].LibId.id = TData.HistoricalUnitObj[index25].ID;
                      if (num == 1)
                      {
                        this.game.Data.HistoricalUnitObj[index2].OffLibId.libSlot = this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].OffLibId.libSlot;
                        this.game.Data.HistoricalUnitObj[index2].OffLibId.id = this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].OffLibId.id;
                        this.game.ProcessingObj.SwapOfficer(this.game.Data.HistoricalUnitObj[index2].TempRegime, index2, this.game.Data.HistoricalUnitCounter, -1);
                      }
                    }
                  }
                  else if (this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadOfficers | TData.HistoricalUnitObj[index25].CommanderName.Length > 0)
                  {
                    index2 = this.game.Data.FindOffHistorical( TData.HistoricalUnitObj[index25], this.game.Data.LibraryObj[sublib[index1]].name);
                    if (index2 > -1)
                    {
                      flag5 = true;
                      this.game.Data.AddHistoricalUnit();
                      this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter] = TData.HistoricalUnitObj[index25].Clone();
                      this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].LibId.libSlot = libraryCounter2;
                      this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].LibId.id = TData.HistoricalUnitObj[index25].ID;
                      this.game.ProcessingObj.SwapOfficer(this.game.Data.HistoricalUnitObj[index2].TempRegime, index2, this.game.Data.HistoricalUnitCounter, -1);
                      this.game.Data.RemoveHistoricalUnit(this.game.Data.HistoricalUnitCounter);
                    }
                  }
                }
                if (!flag5)
                {
                  this.game.Data.AddHistoricalUnit();
                  this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter] = TData.HistoricalUnitObj[index25].Clone();
                  this += 1.game.Data.HistoricalIDCounter;
                  this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].ID = this.game.Data.HistoricalIDCounter;
                  this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].LibId.libSlot = libraryCounter2;
                  this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].Pool = true;
                  this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].LibId.id = TData.HistoricalUnitObj[index25].ID;
                  index2 = this.game.Data.HistoricalUnitCounter;
                }
                let mut index26: i32 =  0;
                do
                {
                  this.game.Data.HistoricalUnitObj[index2].SubParts[index26] = -1;
                  if (TData.HistoricalUnitObj[index25].SubParts[index26] > -1)
                    this.game.Data.HistoricalUnitObj[index2].SubParts[index26] = this.game.Data.UnitObj[this.game.Data.FindUnit( TData.UnitObj[TData.FindPredef(TData.HistoricalUnitObj[index25].SubParts[index26])], this.game.Data.LibraryObj[libraryCounter2].name)].PreDef;
                  index26 += 1;
                }
                while (index26 <= 9);
                if (subPpl[TData.HistoricalUnitObj[index25].People] > -1)
                {
                  this.game.Data.HistoricalUnitObj[index2].People = subPpl[TData.HistoricalUnitObj[index25].People];
                }
                else
                {
                  let mut peopleCounter4: i32 =  this.game.Data.PeopleCounter;
                  for (let mut index27: i32 =  0; index27 <= peopleCounter4; index27 += 1)
                  {
                    if (this.game.Data.PeopleObj[index27].LibId.libSlot == libraryCounter2 && this.game.Data.PeopleObj[index27].LibId.id == TData.PeopleObj[TData.HistoricalUnitObj[index25].People].id)
                      this.game.Data.HistoricalUnitObj[index2].People = index27;
                  }
                }
                if (TData.HistoricalUnitObj[index25].UsePeopleGfx > -1)
                {
                  if (subPpl[TData.HistoricalUnitObj[index25].UsePeopleGfx] > -1)
                  {
                    this.game.Data.HistoricalUnitObj[index2].UsePeopleGfx = subPpl[TData.HistoricalUnitObj[index25].UsePeopleGfx];
                  }
                  else
                  {
                    let mut peopleCounter5: i32 =  this.game.Data.PeopleCounter;
                    for (let mut index28: i32 =  0; index28 <= peopleCounter5; index28 += 1)
                    {
                      if (this.game.Data.PeopleObj[index28].LibId.libSlot == libraryCounter2 && this.game.Data.PeopleObj[index28].LibId.id == TData.PeopleObj[TData.HistoricalUnitObj[index25].UsePeopleGfx].id)
                        this.game.Data.HistoricalUnitObj[index2].UsePeopleGfx = index28;
                    }
                  }
                }
                if (subreg[TData.HistoricalUnitObj[index25].TempRegime] > -1)
                {
                  this.game.Data.HistoricalUnitObj[index2].TempRegime = subreg[TData.HistoricalUnitObj[index25].TempRegime];
                }
                else
                {
                  let mut regimeCounter2: i32 =  this.game.Data.RegimeCounter;
                  for (let mut index29: i32 =  0; index29 <= regimeCounter2; index29 += 1)
                  {
                    if (this.game.Data.RegimeObj[index29].libId.libSlot == libraryCounter2 && this.game.Data.RegimeObj[index29].libId.id == TData.RegimeObj[TData.HistoricalUnitObj[index25].TempRegime].id)
                      this.game.Data.HistoricalUnitObj[index2].TempRegime = index29;
                  }
                }
                HistoricalUnitClass[] historicalUnitObj1 = this.game.Data.HistoricalUnitObj;
                HistoricalUnitClass[] historicalUnitClassArray1 = historicalUnitObj1;
                let mut index30: i32 =  index2;
                let mut index31: i32 =  index30;
                historicalUnitClassArray1[index31].AutoEventCounter = historicalUnitObj1[index30].AutoEventCounter - 1;
                this.game.Data.HistoricalUnitObj[index2].AutoEvent = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.HistoricalUnitObj[index2].AutoEvent, (Array) new int[1]);
                this.game.Data.HistoricalUnitObj[index2].AutoChance = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.HistoricalUnitObj[index2].AutoChance, (Array) new int[1]);
                if (!(this.game.EditObj.TempFileType == NewEnums.LibFileType.LoadHistoricals & this.game.Data.HistoricalUnitObj[index2].OffLibId.libSlot > -1))
                {
                  for (let mut deckCardCounter: i32 =  this.game.Data.HistoricalUnitObj[index2].DeckCardCounter; deckCardCounter >= 0; deckCardCounter += -1)
                  {
                    bool flag6 = false;
                    if (TData.ActionCardObj[TData.HistoricalUnitObj[index25].DeckCard[deckCardCounter]].LibId.libSlot > -1)
                    {
                      let mut actionCardCounter: i32 =  this.game.Data.ActionCardCounter;
                      for (let mut index32: i32 =  0; index32 <= actionCardCounter; index32 += 1)
                      {
                        if (this.game.Data.ActionCardObj[index32].LibId.libSlot > -1 && Operators.CompareString(this.game.Data.LibraryObj[this.game.Data.ActionCardObj[index32].LibId.libSlot].name, TData.LibraryObj[TData.ActionCardObj[TData.HistoricalUnitObj[index25].DeckCard[deckCardCounter]].LibId.libSlot].name, false) == 0 && this.game.Data.ActionCardObj[index32].LibId.id == TData.ActionCardObj[TData.HistoricalUnitObj[index25].DeckCard[deckCardCounter]].LibId.id)
                        {
                          this.game.Data.HistoricalUnitObj[index2].DeckCard[deckCardCounter] = index32;
                          flag6 = true;
                          break;
                        }
                      }
                    }
                    if (!flag6)
                    {
                      let mut num1: i32 =  deckCardCounter;
                      let mut num2: i32 =  deckCardCounter - 1;
                      for (let mut index33: i32 =  num1; index33 <= num2; index33 += 1)
                      {
                        this.game.Data.HistoricalUnitObj[index2].DeckCard[index33] = this.game.Data.HistoricalUnitObj[index2].DeckCard[index33 + 1];
                        this.game.Data.HistoricalUnitObj[index2].DeckChance[index33] = this.game.Data.HistoricalUnitObj[index2].DeckChance[index33 + 1];
                      }
                      HistoricalUnitClass[] historicalUnitObj2 = this.game.Data.HistoricalUnitObj;
                      HistoricalUnitClass[] historicalUnitClassArray2 = historicalUnitObj2;
                      let mut index34: i32 =  index2;
                      let mut index35: i32 =  index34;
                      historicalUnitClassArray2[index35].DeckCardCounter = historicalUnitObj2[index34].DeckCardCounter - 1;
                      if (this.game.Data.HistoricalUnitObj[index2].DeckCardCounter > -1)
                      {
                        this.game.Data.HistoricalUnitObj[index2].DeckCard = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.HistoricalUnitObj[index2].DeckCard, (Array) new int[this.game.Data.HistoricalUnitObj[index2].DeckCardCounter + 1]);
                        this.game.Data.HistoricalUnitObj[index2].DeckChance = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.HistoricalUnitObj[index2].DeckChance, (Array) new int[this.game.Data.HistoricalUnitObj[index2].DeckCardCounter + 1]);
                      }
                    }
                  }
                }
                if (TData.HistoricalUnitObj[index25].SmallGfx > -1)
                {
                  str: String = TData.SmallPicName[TData.HistoricalUnitObj[index25].SmallGfx];
                  bool flag7 = false;
                  let mut smallPicCounter: i32 =  this.game.Data.SmallPicCounter;
                  for (let mut index36: i32 =  0; index36 <= smallPicCounter; index36 += 1)
                  {
                    if (Operators.CompareString(this.game.Data.SmallPicName[index36], str, false) == 0 & this.game.Data.SmallLibId[index36].libSlot == libraryCounter2)
                    {
                      this.game.Data.HistoricalUnitObj[index2].SmallGfx = index36;
                      flag7 = true;
                    }
                  }
                  if (!flag7)
                  {
                    let mut num: i32 =   Interaction.MsgBox( "Error: His Unit uses graphic not included in lib");
                    this.game.Data.AddSmallPic(str);
                    this.game.Data.HistoricalUnitObj[index2].SmallGfx = this.game.Data.SmallPicCounter;
                  }
                }
                let mut hisVarCount: i32 =  TData.HistoricalUnitObj[index25].HisVarCount;
                for (let mut index37: i32 =  0; index37 <= hisVarCount; index37 += 1)
                {
                  if (TData.HistoricalUnitObj[index25].HisVarSmall[index37] > -1)
                  {
                    str: String = TData.SmallPicName[TData.HistoricalUnitObj[index25].HisVarSmall[index37]];
                    bool flag8 = false;
                    let mut smallPicCounter: i32 =  this.game.Data.SmallPicCounter;
                    for (let mut index38: i32 =  0; index38 <= smallPicCounter; index38 += 1)
                    {
                      if (Operators.CompareString(this.game.Data.SmallPicName[index38], str, false) == 0 & this.game.Data.SmallLibId[index38].id == -1)
                      {
                        this.game.Data.HistoricalUnitObj[index2].HisVarSmall[index37] = index38;
                        flag8 = true;
                      }
                    }
                    if (!flag8)
                    {
                      let mut num: i32 =   Interaction.MsgBox( "Error: His Unit uses graphic not included in lib");
                      this.game.Data.AddSmallPic(str);
                      this.game.Data.HistoricalUnitObj[index2].HisVarSmall[index37] = this.game.Data.SmallPicCounter;
                    }
                  }
                }
                let mut index39: i32 =  0;
                do
                {
                  if (TData.HistoricalUnitObj[index25].DesignationSmall[index39] > -1)
                  {
                    str: String = TData.SmallPicName[TData.HistoricalUnitObj[index25].DesignationSmall[index39]];
                    bool flag9 = false;
                    let mut smallPicCounter: i32 =  this.game.Data.SmallPicCounter;
                    for (let mut index40: i32 =  0; index40 <= smallPicCounter; index40 += 1)
                    {
                      if (Operators.CompareString(this.game.Data.SmallPicName[index40], str, false) == 0 & this.game.Data.SmallLibId[index40].libSlot == libraryCounter2)
                      {
                        this.game.Data.HistoricalUnitObj[index2].DesignationSmall[index39] = index40;
                        flag9 = true;
                      }
                    }
                    if (!flag9)
                    {
                      let mut num: i32 =   Interaction.MsgBox( "Error: His Unit uses graphic not included in lib");
                      this.game.Data.AddSmallPic(str);
                      this.game.Data.HistoricalUnitObj[index2].DesignationSmall[index39] = this.game.Data.SmallPicCounter;
                    }
                  }
                  index39 += 1;
                }
                while (index39 <= 9);
              }
            }
            let mut historicalUnitCounter2: i32 =  this.game.Data.HistoricalUnitCounter;
            for (let mut index41: i32 =  0; index41 <= historicalUnitCounter2; index41 += 1)
            {
              if (this.game.Data.HistoricalUnitObj[index41].LibId.libSlot == libraryCounter2)
              {
                if (this.game.Data.HistoricalUnitObj[index41].ModelMaster > -1)
                {
                  let mut historicalUnitCounter3: i32 =  TData.HistoricalUnitCounter;
                  for (let mut index42: i32 =  0; index42 <= historicalUnitCounter3; index42 += 1)
                  {
                    if (TData.HistoricalUnitObj[index42].LibId.libSlot == index1 & index42 == this.game.Data.HistoricalUnitObj[index41].ModelMaster)
                    {
                      let mut historical: i32 =  this.game.Data.FindHistorical( TData.HistoricalUnitObj[index42], this.game.Data.LibraryObj[libraryCounter2].name);
                      this.game.Data.HistoricalUnitObj[index41].ModelMaster = historical;
                      break;
                    }
                  }
                }
                if (this.game.Data.HistoricalUnitObj[index41].UseModelCounter > -1)
                {
                  let mut historicalUnitCounter4: i32 =  TData.HistoricalUnitCounter;
                  for (let mut index43: i32 =  0; index43 <= historicalUnitCounter4; index43 += 1)
                  {
                    if (TData.HistoricalUnitObj[index43].LibId.libSlot == index1 & index43 == this.game.Data.HistoricalUnitObj[index41].UseModelCounter)
                    {
                      let mut historical: i32 =  this.game.Data.FindHistorical( TData.HistoricalUnitObj[index43], this.game.Data.LibraryObj[libraryCounter2].name);
                      this.game.Data.HistoricalUnitObj[index41].UseModelCounter = historical;
                      break;
                    }
                  }
                }
              }
            }
          }
        }
      }
      let mut num3: i32 =  0;
      do
      {
        let mut libraryCounter3: i32 =  TData.LibraryCounter;
        for (let mut index44: i32 =  0; index44 <= libraryCounter3; index44 += 1)
        {
          let mut num4: i32 =  -1;
          let mut libraryCounter4: i32 =  this.game.Data.LibraryCounter;
          for (let mut index45: i32 =  0; index45 <= libraryCounter4; index45 += 1)
          {
            if (Operators.CompareString(TData.LibraryObj[index44].name, this.game.Data.LibraryObj[index45].name, false) == 0)
            {
              num4 = index45;
              break;
            }
          }
          if (import[index44] & num4 > -1)
          {
            for (let mut libVarCounter1: i32 =  this.game.Data.LibVarCounter; libVarCounter1 >= 0; libVarCounter1 += -1)
            {
              if (this.game.Data.LibVarObj[libVarCounter1].libId.libSlot == num4)
              {
                bool flag = false;
                let mut libVarCounter2: i32 =  TData.LibVarCounter;
                for (let mut index46: i32 =  0; index46 <= libVarCounter2; index46 += 1)
                {
                  if (this.game.Data.LibVarObj[libVarCounter1].type == TData.LibVarObj[index46].type & this.game.Data.LibVarObj[libVarCounter1].valueType == TData.LibVarObj[index46].valueType)
                    flag = true;
                }
                if (!flag)
                  this.game.Data.RemoveLibVar(libVarCounter1);
              }
            }
            for (let mut eventCounter1: i32 =  this.game.Data.EventCounter; eventCounter1 >= 0; eventCounter1 += -1)
            {
              if (this.game.Data.EventObj[eventCounter1].LibId.libSlot == num4)
              {
                bool flag = false;
                let mut eventCounter2: i32 =  TData.EventCounter;
                for (let mut index47: i32 =  0; index47 <= eventCounter2; index47 += 1)
                {
                  if (TData.EventObj[index47].LibId.libSlot > -1 && TData.EventObj[index47].Id == this.game.Data.EventObj[eventCounter1].LibId.id && Operators.CompareString(Strings.LCase(TData.EventObj[index47].Name), Strings.LCase(this.game.Data.EventObj[eventCounter1].Name), false) == 0)
                    flag = true;
                }
                if (!flag)
                  this.game.Data.RemoveEvent(eventCounter1);
              }
            }
            for (let mut actionCardCounter1: i32 =  this.game.Data.ActionCardCounter; actionCardCounter1 >= 0; actionCardCounter1 += -1)
            {
              if (this.game.Data.ActionCardObj[actionCardCounter1].LibId.libSlot == num4)
              {
                bool flag = false;
                let mut actionCardCounter2: i32 =  TData.ActionCardCounter;
                for (let mut index48: i32 =  0; index48 <= actionCardCounter2; index48 += 1)
                {
                  if (TData.ActionCardObj[index48].LibId.libSlot > -1 && index48 == this.game.Data.ActionCardObj[actionCardCounter1].LibId.id)
                    flag = true;
                }
                if (!flag)
                  this.game.Data.RemoveActionCard(actionCardCounter1);
              }
            }
            for (let mut eventPicCounter1: i32 =  this.game.Data.EventPicCounter; eventPicCounter1 >= 0; eventPicCounter1 += -1)
            {
              if (this.game.Data.eventPicLibId[eventPicCounter1].libSlot == num4)
              {
                bool flag = false;
                let mut eventPicCounter2: i32 =  TData.EventPicCounter;
                for (let mut index49: i32 =  0; index49 <= eventPicCounter2; index49 += 1)
                {
                  if (TData.eventPicLibId[index49].libSlot > -1 && index49 == this.game.Data.eventPicLibId[eventPicCounter1].id & Operators.CompareString(TData.EventPicName[index49], this.game.Data.EventPicName[eventPicCounter1], false) == 0)
                  {
                    flag = true;
                    for (let mut eventPicCounter3: i32 =  this.game.Data.EventPicCounter; eventPicCounter3 >= 0; eventPicCounter3 += -1)
                    {
                      if (eventPicCounter1 < eventPicCounter3 && this.game.Data.eventPicLibId[eventPicCounter3].libSlot == num4 && this.game.Data.eventPicLibId[eventPicCounter1].id == this.game.Data.eventPicLibId[eventPicCounter3].id & Operators.CompareString(this.game.Data.EventPicName[eventPicCounter3], this.game.Data.EventPicName[eventPicCounter1], false) == 0)
                        flag = false;
                    }
                  }
                }
                if (!flag)
                  this.game.Data.RemoveEventPic(eventPicCounter1);
              }
            }
            for (let mut smallPicCounter1: i32 =  this.game.Data.SmallPicCounter; smallPicCounter1 >= 0; smallPicCounter1 += -1)
            {
              if (this.game.Data.SmallLibId[smallPicCounter1].libSlot == num4)
              {
                bool flag = false;
                let mut smallPicCounter2: i32 =  TData.SmallPicCounter;
                for (let mut index50: i32 =  0; index50 <= smallPicCounter2; index50 += 1)
                {
                  if (TData.SmallLibId[index50].libSlot > -1 && index50 == this.game.Data.SmallLibId[smallPicCounter1].id & Operators.CompareString(TData.SmallPicName[index50], this.game.Data.SmallPicName[smallPicCounter1], false) == 0)
                  {
                    flag = true;
                    for (let mut smallPicCounter3: i32 =  this.game.Data.SmallPicCounter; smallPicCounter3 >= 0; smallPicCounter3 += -1)
                    {
                      if (smallPicCounter1 < smallPicCounter3 && this.game.Data.SmallLibId[smallPicCounter3].libSlot == num4 && this.game.Data.SmallLibId[smallPicCounter1].id == this.game.Data.SmallLibId[smallPicCounter3].id & Operators.CompareString(this.game.Data.SmallPicName[smallPicCounter3], this.game.Data.SmallPicName[smallPicCounter1], false) == 0)
                        flag = false;
                    }
                  }
                }
                if (!flag)
                  this.game.Data.RemoveSmallPic(smallPicCounter1);
              }
            }
            for (let mut stringListCounter4: i32 =  this.game.Data.StringListCounter; stringListCounter4 >= 0; stringListCounter4 += -1)
            {
              if (this.game.Data.StringListObj[stringListCounter4].LibId.libSlot == num4)
              {
                bool flag = false;
                let mut stringListCounter5: i32 =  TData.StringListCounter;
                for (let mut index51: i32 =  0; index51 <= stringListCounter5; index51 += 1)
                {
                  if (TData.StringListObj[index51].LibId.libSlot > -1 && TData.StringListObj[index51].ID == this.game.Data.StringListObj[stringListCounter4].LibId.id && Operators.CompareString(TData.StringListObj[index51].Name, this.game.Data.StringListObj[stringListCounter4].Name, false) == 0)
                    flag = true;
                }
                if (!flag)
                  this.game.Data.RemoveStringList(stringListCounter4);
              }
            }
            for (let mut sfTypeCounter1: i32 =  this.game.Data.SFTypeCounter; sfTypeCounter1 >= 0; sfTypeCounter1 += -1)
            {
              if (this.game.Data.SFTypeObj[sfTypeCounter1].LibId.libSlot == num4)
              {
                bool flag = false;
                let mut sfTypeCounter2: i32 =  TData.SFTypeCounter;
                for (let mut index52: i32 =  0; index52 <= sfTypeCounter2; index52 += 1)
                {
                  if (TData.SFTypeObj[index52].LibId.libSlot > -1)
                  {
                    if (TData.SFTypeObj[index52].Id == this.game.Data.SFTypeObj[sfTypeCounter1].LibId.id)
                      flag = true;
                    if (TData.SFTypeObj[index52].LibId.id == this.game.Data.SFTypeObj[sfTypeCounter1].LibId.id)
                      flag = true;
                  }
                }
                if (!flag)
                  this.game.Data.RemoveSFType(sfTypeCounter1);
              }
            }
            for (let mut reinfCounter2: i32 =  this.game.Data.ReinfCounter; reinfCounter2 >= 0; reinfCounter2 += -1)
            {
              if (this.game.Data.ReinfLibId[reinfCounter2].libSlot == num4)
              {
                bool flag = false;
                let mut reinfCounter3: i32 =  TData.ReinfCounter;
                for (let mut index53: i32 =  0; index53 <= reinfCounter3; index53 += 1)
                {
                  if (TData.ReinfLibId[index53].libSlot > -1 && Operators.CompareString(TData.ReinfName[index53], this.game.Data.ReinfName[reinfCounter2], false) == 0)
                  {
                    if (TData.ReinfId[index53] > -1 & TData.ReinfId[index53] == this.game.Data.ReinfLibId[reinfCounter2].id)
                      flag = true;
                    if (TData.ReinfLibId[index53].id > -1 & TData.ReinfLibId[index53].id == this.game.Data.ReinfLibId[reinfCounter2].id)
                      flag = true;
                  }
                }
                if (!flag)
                  this.game.Data.RemoveReinf(reinfCounter2);
              }
            }
            for (let mut peopleCounter6: i32 =  this.game.Data.PeopleCounter; peopleCounter6 >= 0; peopleCounter6 += -1)
            {
              if (this.game.Data.PeopleObj[peopleCounter6].LibId.libSlot == num4)
              {
                bool flag = false;
                let mut peopleCounter7: i32 =  TData.PeopleCounter;
                for (let mut index54: i32 =  0; index54 <= peopleCounter7; index54 += 1)
                {
                  if (TData.PeopleObj[index54].LibId.libSlot > -1 && TData.PeopleObj[index54].id == this.game.Data.PeopleObj[peopleCounter6].LibId.id)
                    flag = true;
                  if (subPpl[index54] > -1 && subPpl[index54] == peopleCounter6)
                    flag = true;
                }
                if (!flag)
                  this.game.Data.RemovePeople(peopleCounter6);
              }
            }
            for (let mut regimeCounter3: i32 =  this.game.Data.RegimeCounter; regimeCounter3 >= 0; regimeCounter3 += -1)
            {
              if (this.game.Data.RegimeObj[regimeCounter3].libId.libSlot == num4)
              {
                bool flag = false;
                let mut regimeCounter4: i32 =  TData.RegimeCounter;
                for (let mut index55: i32 =  0; index55 <= regimeCounter4; index55 += 1)
                {
                  if (TData.RegimeObj[index55].libId.libSlot > -1 && TData.RegimeObj[index55].id == this.game.Data.RegimeObj[regimeCounter3].libId.id)
                    flag = true;
                }
                if (!flag)
                  this.game.Data.RemoveRegime(regimeCounter3);
              }
            }
            for (let mut unitCounter1: i32 =  this.game.Data.UnitCounter; unitCounter1 >= 0; unitCounter1 += -1)
            {
              if (this.game.Data.UnitObj[unitCounter1].LibId.libSlot == num4 & this.game.Data.UnitObj[unitCounter1].PreDef > -1)
              {
                bool flag = false;
                let mut unitCounter2: i32 =  TData.UnitCounter;
                for (let mut index56: i32 =  0; index56 <= unitCounter2; index56 += 1)
                {
                  if (TData.UnitObj[index56].LibId.libSlot > -1 && TData.UnitObj[index56].PreDef == this.game.Data.UnitObj[unitCounter1].LibId.id)
                    flag = true;
                }
                if (!flag)
                {
                  data: DataClass = this.game.Data;
                  let mut nr: i32 =  unitCounter1;
                  let mut gameClass: GameClass = (GameClass) null;
                   let mut local: GameClass =  gameClass;
                  data.RemoveUnit(nr,  local);
                }
              }
            }
            for (let mut historicalUnitCounter5: i32 =  this.game.Data.HistoricalUnitCounter; historicalUnitCounter5 >= 0; historicalUnitCounter5 += -1)
            {
              if (this.game.Data.HistoricalUnitObj[historicalUnitCounter5].LibId.libSlot == num4)
              {
                bool flag = false;
                let mut historicalUnitCounter6: i32 =  TData.HistoricalUnitCounter;
                for (let mut index57: i32 =  0; index57 <= historicalUnitCounter6; index57 += 1)
                {
                  if (TData.HistoricalUnitObj[index57].LibId.libSlot > -1 && TData.HistoricalUnitObj[index57].ID == this.game.Data.HistoricalUnitObj[historicalUnitCounter5].LibId.id)
                    flag = true;
                }
                if (!flag)
                {
                  if (this.game.Data.HistoricalUnitObj[historicalUnitCounter5].CommanderName.Length > 0 & this.game.Data.HistoricalUnitObj[historicalUnitCounter5].SubParts[0] > -1 && this.game.Data.HistoricalUnitObj[historicalUnitCounter5].OffLibId.libSlot != num4 && this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitCounter5) > -1)
                  {
                    this.game.Data.AddHistoricalUnit();
                    LibIdClass libIdClass = this.game.Data.HistoricalUnitObj[historicalUnitCounter5].OffLibId.Clone();
                    this.game.ProcessingObj.SwapOfficer(this.game.Data.UnitObj[this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitCounter5)].Regime, historicalUnitCounter5, this.game.Data.HistoricalUnitCounter, this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitCounter5));
                    this.game.Data.HistoricalUnitObj[historicalUnitCounter5].OffLibId = LibIdClass::new();
                    this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].LibId = libIdClass;
                    this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].Pool = true;
                  }
                  this.game.Data.RemoveHistoricalUnit(historicalUnitCounter5);
                }
              }
            }
            for (let mut historicalUnitCounter7: i32 =  this.game.Data.HistoricalUnitCounter; historicalUnitCounter7 >= 0; historicalUnitCounter7 += -1)
            {
              if (this.game.Data.HistoricalUnitObj[historicalUnitCounter7].OffLibId.libSlot == num4)
              {
                bool flag = false;
                let mut historicalUnitCounter8: i32 =  TData.HistoricalUnitCounter;
                for (let mut index58: i32 =  0; index58 <= historicalUnitCounter8; index58 += 1)
                {
                  if (TData.HistoricalUnitObj[index58].LibId.libSlot > -1 && TData.HistoricalUnitObj[index58].ID == this.game.Data.HistoricalUnitObj[historicalUnitCounter7].OffLibId.id)
                    flag = true;
                }
                if (!flag)
                {
                  this.game.Data.AddHistoricalUnit();
                  LibIdClass libIdClass = this.game.Data.HistoricalUnitObj[historicalUnitCounter7].OffLibId.Clone();
                  this.game.ProcessingObj.SwapOfficer(this.game.Data.UnitObj[this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitCounter7)].Regime, historicalUnitCounter7, this.game.Data.HistoricalUnitCounter, this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitCounter7));
                  this.game.Data.HistoricalUnitObj[historicalUnitCounter7].OffLibId = LibIdClass::new();
                  this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].LibId = libIdClass;
                  this.game.Data.HistoricalUnitObj[this.game.Data.HistoricalUnitCounter].Pool = true;
                  this.game.Data.RemoveHistoricalUnit(this.game.Data.HistoricalUnitCounter);
                }
              }
            }
          }
        }
        num3 += 1;
      }
      while (num3 <= 1);
      this.game.HandyFunctionsObj.Libraries_ClearUpAllRemnants();
      for (let mut unitCounter: i32 =  this.game.Data.UnitCounter; unitCounter >= 0; unitCounter += -1)
      {
        if (this.game.Data.UnitObj[unitCounter].Historical > -1)
          this.game.Data.UnitObj[unitCounter].Name = this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unitCounter].Historical].Name;
      }
      this.game.Data.LoadGraphics(this.game.FormRef);
    }

    pub HasHexNavyUnit: bool(x: i32, y: i32)
    {
      let mut unitCounter: i32 =  this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        if (unit > -1 && this.game.HandyFunctionsObj.HasUnitNavySF(unit))
          return true;
      }
      return false;
    }

    pub fn SetPbemMiscString()
    {
      str1: String = this.game.EditObj.LoadFileName.Replace("/", "\\").Replace(this.game.AppPath + this.game.ModScenarioDir + "\\", "");
      if (Strings.Len(str1) > 32)
        str1 = Strings.Left(str1, 32);
      this.game.EditObj.PbemMiscString = str1 + Strings.Space(32 - Strings.Len(str1));
      str2: String = 110.ToString();
      if (Strings.Len(str2) > 8)
        str2 = Strings.Left(str2, 8);
      if (Strings.Len(str2) < 8)
        str2 = Strings.Space(8 - Strings.Len(str2)) + str2;
      this.game.EditObj.PbemMiscString += str2;
      if (this.game.Data.FOWOn)
        this.game.EditObj.PbemMiscString += "1";
      else
        this.game.EditObj.PbemMiscString += "0";
      if (this.game.Data.PasswordsOn)
        this.game.EditObj.PbemMiscString += "1";
      else
        this.game.EditObj.PbemMiscString += "0";
      if (this.game.Data.PBEM)
        this.game.EditObj.PbemMiscString += "1";
      else
        this.game.EditObj.PbemMiscString += "0";
      if (this.game.Data.DontShowAIMove)
        this.game.EditObj.PbemMiscString += "1";
      else
        this.game.EditObj.PbemMiscString += "0";
      let mut index1: i32 =  0;
      do
      {
        if (this.game.Data.Variants[index1] >= 0)
        {
          if (this.game.Data.GameSlot[this.game.Data.Variants[index1]] > 0)
            this.game.EditObj.PbemMiscString += "1";
          else
            this.game.EditObj.PbemMiscString += "0";
        }
        else
          this.game.EditObj.PbemMiscString += "0";
        index1 += 1;
      }
      while (index1 <= 11);
      let mut num1: i32 =  0;
      let mut num2: i32 =  Math.Min(7, this.game.Data.RegimeCounter);
      num3: i32;
      for (let mut index2: i32 =  0; index2 <= num2; index2 += 1)
      {
        if (this.game.Data.RegimeObj[index2].PbemPlayer > 0)
        {
          editObj: EditClass = this.game.EditObj;
          editClass: EditClass = editObj;
          pbemMiscString: String = editObj.PbemMiscString;
          num3 = this.game.Data.RegimeObj[index2].PbemPlayer + 1;
          str3: String = Strings.Trim(num3.ToString());
          str4: String = pbemMiscString + str3;
          editClass.PbemMiscString = str4;
        }
        else if (!this.game.Data.RegimeObj[index2].AI & !this.game.Data.RegimeObj[index2].Sleep)
        {
          num1 += 1;
          if (num1 > 2)
            num1 = 1;
          this.game.Data.RegimeObj[index2].PbemPlayer = num1;
          editObj: EditClass = this.game.EditObj;
          editClass: EditClass = editObj;
          pbemMiscString: String = editObj.PbemMiscString;
          num3 = this.game.Data.RegimeObj[index2].PbemPlayer + 1;
          str5: String = Strings.Trim(num3.ToString());
          str6: String = pbemMiscString + str5;
          editClass.PbemMiscString = str6;
        }
        else
          this.game.EditObj.PbemMiscString += "0";
      }
      for (let mut index3: i32 =  Math.Min(7, this.game.Data.RegimeCounter) + 1; index3 <= 7; index3 += 1)
        this.game.EditObj.PbemMiscString += "0";
    }

    pub fn SetUploadFile(s: String)
    {
      this.game.FormRef.Cursor = Cursors.WaitCursor;
      s = this.game.AppPath + s;
      this.game.EditObj.ServerUploadFile = System.IO.File.ReadAllBytes(s);
      this.game.FormRef.Cursor = Cursors.Default;
      s = s;
    }

    pub GetFileCRC: String(s: String)
    {
      if (Strings.InStr(s, this.game.AppPath) < 1)
        s = this.game.AppPath + s;
      this.game.EditObj.ServerUploadFile = System.IO.File.ReadAllBytes(s);
      s = this.GetCRC32();
      this.game.EditObj.ServerUploadFile = (byte[]) null;
      return s;
    }

    pub fn SaveDownloadedFile(path: String)
    {
      this.game.FormRef.Cursor = Cursors.WaitCursor;
      path = this.game.AppPath + path;
      path = path.Replace("\\", "/");
      System.IO.File.WriteAllBytes(path, this.game.EditObj.ServerDownloadFile);
      this.game.EditObj.ServerDownloadFile = new byte[1];
      this.game.FormRef.Cursor = Cursors.Default;
    }

    pub GetCRC32: String()
    {
      crC32: String;
      try
      {
        let mut num1: i32 =  -1;
        int[] numArray = new int[257];
        let mut num2: i32 =  -306674912;
        let mut index1: i32 =  0;
        do
        {
          let mut num3: i32 =  index1;
          let mut num4: i32 =  8;
          do
          {
            num3 = (uint) (num3 & 1) <= 0U ?  ((long) (num3 & -2) / 2L & (long) int.MaxValue) :  ((long) (num3 & -2) / 2L & (long) int.MaxValue) ^ num2;
            num4 += -1;
          }
          while (num4 >= 1);
          numArray[index1] = num3;
          index1 += 1;
        }
        while (index1 <=  byte.MaxValue);
        let mut upperBound: i32 =  this.game.EditObj.ServerUploadFile.GetUpperBound(0);
        for (let mut index2: i32 =  0; index2 <= upperBound; index2 += 1)
        {
          let mut index3: i32 =  num1 &  byte.MaxValue ^  this.game.EditObj.ServerUploadFile[index2];
          num1 = (num1 & -256) / 256 & 16777215 ^ numArray[index3];
        }
        crC32 = Conversion.Hex(~num1);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        crC32 = "";
        ProjectData.ClearProjectError();
      }
      return crC32;
    }

    pub fn SetMapLoopOnOrOff()
    {
      let mut zoom: i32 =  this.game.EditObj.Zoom;
      if (this.game.Data.Product >= 5 && this.game.EditObj.OrderType == 26 | this.game.EditObj.AIMoving)
        this.game.EditObj.Zoom = 0;
      if ( this.game.Data.RuleVar[329] == 0.0)
      {
        let mut num: i32 =  5;
        if (this.game.Data.Product >= 5)
          num = 0;
        if (this.game.EditObj.Zoom == 0)
        {
          if ( Math.Round( (this.game.ScreenWidth - 200) / 53.0) - num > this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth)
          {
            this.game.Data.RuleVar[329] = 1f;
            this.game.CornerX = 0;
          }
        }
        else if (this.game.EditObj.Zoom == 1)
        {
          if ( Math.Round( (this.game.ScreenWidth - 200) / 106.0) - num > this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth)
          {
            this.game.Data.RuleVar[329] = 1f;
            this.game.CornerX = 0;
          }
        }
        else if (this.game.EditObj.Zoom == -1 &&  Math.Round( (this.game.ScreenWidth - 200) / 27.0) - num > this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth)
        {
          this.game.Data.RuleVar[329] = 1f;
          this.game.CornerX = 0;
        }
      }
      else
      {
        let mut num: i32 =  5;
        if (this.game.Data.Product >= 5)
          num = 0;
        if (this.game.EditObj.Zoom == 0)
        {
          if ( Math.Round( (this.game.ScreenWidth - 200) / 53.0) - num <= this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth)
            this.game.Data.RuleVar[329] = 0.0f;
        }
        else if (this.game.EditObj.Zoom == 1)
        {
          if ( Math.Round( (this.game.ScreenWidth - 200) / 106.0) - num <= this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth)
            this.game.Data.RuleVar[329] = 0.0f;
        }
        else if (this.game.EditObj.Zoom == -1 &&  Math.Round( (this.game.ScreenWidth - 200) / 27.0) - num <= this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth)
          this.game.Data.RuleVar[329] = 0.0f;
      }
      if (this.game.Data.Product < 5)
        return;
      this.game.EditObj.Zoom = zoom;
    }

    pub Coordinate GetMoveTypeLogo(unr: i32,  Coordinate tcoord, bool SecondSymbol)
    {
      let mut turn: i32 =  this.game.Data.Turn;
      let mut index1: i32 =  -1;
      let mut index2: i32 =  -1;
      let mut num: i32 =  0;
      if (this.game.Data.Turn == this.game.Data.UnitObj[unr].Regime | !this.game.Data.FOWOn | this.game.Data.Round == 0 | tcoord.x >= 2)
      {
        num = 1;
        index1 = -1;
        index2 = this.game.HandyFunctionsObj.GetLowestSpeed(unr, -1, true);
        if (index2 > -1)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
          for (index1 = 0; index1 <= sfCount; index1 += 1)
          {
            if (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index1]].Type].SymbolGroup == this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].SymbolGroup && this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index1]].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index1]].Type].SymbolWeight > this.game.Data.SFObj[index2].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].SymbolWeight && this.game.Data.Product != 6 | this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index1]].Type].MoveType == this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].MoveType)
              index2 = this.game.Data.UnitObj[unr].SFList[index1];
          }
        }
        str: String = index2 <= -1 ? "Immobile" : (this.game.Data.SFObj[index2].MoveType != -1 ? Strings.Trim(this.game.Data.TempString[this.game.Data.SFObj[index2].MoveType]) : Strings.Trim(this.game.Data.TempString[this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].MoveType]));
        if (index2 == -2)
          index1 = this.game.SUPPLIESSYMBOL;
        else if (index2 > -1)
          index1 = SecondSymbol ? this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].SymbolSprite2ID : this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].SymbolSpriteID;
        let mut integer: i32 =  Conversions.ToInteger(this.game.HandyFunctionsObj.GetUnitPeople(unr));
        if (turn > -1 & index2 > -1)
        {
          if (this.game.Data.RegimeObj[turn].ExtraGraphicUse > -1)
          {
            let mut extraCounter: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraCounter;
            for (let mut index3: i32 =  0; index3 <= extraCounter; index3 += 1)
            {
              if (this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraCode[index3] == this.game.Data.RegimeObj[turn].ExtraGraphicUse)
                index1 = SecondSymbol ? this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraSymbolSprite2ID[index3] : this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraSymbolSpriteID[index3];
            }
          }
          else if (this.game.Data.PeopleObj[integer].ExtraGraphicUse > -1)
          {
            let mut extraCounter: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraCounter;
            for (let mut index4: i32 =  0; index4 <= extraCounter; index4 += 1)
            {
              if (this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraCode[index4] == this.game.Data.PeopleObj[integer].ExtraGraphicUse)
                index1 = SecondSymbol ? this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraSymbolSprite2ID[index4] : this.game.Data.SFTypeObj[this.game.Data.SFObj[index2].Type].ExtraSymbolSpriteID[index4];
            }
          }
        }
      }
      Coordinate moveTypeLogo;
      moveTypeLogo.x = index1;
      moveTypeLogo.y = index2;
      return moveTypeLogo;
    }

    pub fn GetMoveType(unr: i32) -> i32
    {
      Coordinate moveTypeLogo = this.GetMoveTypeLogo(unr,  Coordinate::new()
      {
        x = 3
      }, true);
      return moveTypeLogo.y > -1 ? this.game.Data.SFTypeObj[this.game.Data.SFObj[moveTypeLogo.y].Type].MoveType : -1;
    }

    pub fn SetGameColors()
    {
      pixel: Color = BitmapStore.GetBitmap(this.game.FRAME1).GetPixel(1, 8);
      let mut red: i32 =  Math.Min( byte.MaxValue,  pixel.R * 1);
      let mut green: i32 =  Math.Min( byte.MaxValue,  pixel.G * 1);
      let mut blue: i32 =  Math.Min( byte.MaxValue,  pixel.B * 1);
      this.game.MarcCol2 = Color.FromArgb(100, red, green, blue);
      this.game.MarcCol3 = Color.FromArgb( byte.MaxValue, red, green, blue);
    }

    pub HasAllies: bool(regnr: i32, bool IncludeUnterUber)
    {
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index: i32 =  0; index <= regimeCounter; index += 1)
      {
        if (index != regnr && this.game.Data.RegimeObj[index].UberRegime != regnr | IncludeUnterUber && this.game.Data.RegimeObj[index].RegimeRel[regnr] == 2)
          return true;
      }
      return false;
    }

    pub fn ResetFireListCache()
    {
      let mut index1: i32 =  0;
      if ( this.game.Data.RuleVar[485] < 1.0)
        return;
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID( Math.Round( this.game.Data.RuleVar[485]));
      if (stringListById == -1)
        return;
      let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
      for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
        for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
          this.game.Data.MapObj[0].HexObj[index2, index3].tempFireListEntry = false;
      }
      for (let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length; length >= 0; length += -1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[length, 0])) == this.game.Data.Turn)
        {
          let mut index4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[length, 1]));
          let mut index5: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[length, 2]));
          if (index4 >= 0 & index5 >= 0 && index4 <= this.game.Data.MapObj[0].MapWidth & index5 <= this.game.Data.MapObj[0].MapHeight)
            this.game.Data.MapObj[0].HexObj[index4, index5].tempFireListEntry = true;
        }
      }
      this.game.EditObj.TempFireListCacheSet = true;
    }

    pub fn ClearFireListRecent()
    {
      if ( this.game.Data.RuleVar[485] < 1.0)
        return;
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID( Math.Round( this.game.Data.RuleVar[485]));
      if (stringListById == -1)
        return;
      for (let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length; length >= 0; length += -1)
        this.game.Data.StringListObj[stringListById].Data[length, 6] = "";
    }

    pub fn ClearFireList(regnr: i32)
    {
      if ( this.game.Data.RuleVar[485] < 1.0)
        return;
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID( Math.Round( this.game.Data.RuleVar[485]));
      if (stringListById == -1)
        return;
      for (let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length; length >= 0; length += -1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[length, 0])) == regnr)
          this.game.Data.StringListObj[stringListById].RemoveRow(length);
      }
    }

    pub SimpleList GetSupplyReceivingHQ(x: i32, y: i32, map: i32, regnr: i32, pts: i32)
    {
      SimpleList supplyReceivingHq = SimpleList::new();
      if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea && !this.IsAlliedOrSelf(regnr, this.game.Data.MapObj[map].HexObj[x, y].Regime))
        return supplyReceivingHq;
      this.game.HandyFunctionsObj.MakeMovePrediction2(regnr,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), x, y, map, allowshoredrop: true);
      SimpleList simpleList = SimpleList::new();
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut tid: i32 =  0; tid <= unitCounter1; tid += 1)
      {
        if (this.game.Data.UnitObj[tid].X > -1 & this.game.Data.UnitObj[tid].PreDef == -1 & this.game.Data.UnitObj[tid].Regime > -1 && this.game.Data.UnitObj[tid].Regime == regnr | this.game.Data.RegimeObj[this.game.Data.UnitObj[tid].Regime].UberRegime == regnr && this.game.Data.UnitObj[tid].IsHQ && this.game.EditObj.TempValue[this.game.Data.UnitObj[tid].Map].Value[this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y] < 9999)
          simpleList.Add(tid, this.game.EditObj.TempValue[this.game.Data.UnitObj[tid].Map].Value[this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y]);
      }
      let mut num1: i32 =  0;
      if (simpleList.Counter > -1)
      {
        simpleList.Sort();
        let mut counter1: i32 =  simpleList.Counter;
        for (let mut index1: i32 =  0; index1 <= counter1; index1 += 1)
        {
          let mut index2: i32 =  simpleList.Id[index1];
          let mut num2: i32 =  1;
          while (num2 == 1)
          {
            num2 = 0;
            if (this.game.Data.UnitObj[index2].HQ > -1)
            {
              let mut hq: i32 =  this.game.Data.UnitObj[index2].HQ;
              if (this.game.Data.UnitObj[hq].X > -1 &&  this.game.EditObj.TempValue[this.game.Data.UnitObj[hq].Map].Value[this.game.Data.UnitObj[hq].X, this.game.Data.UnitObj[hq].Y] <=  this.game.Data.RuleVar[51])
              {
                index2 = hq;
                num2 = 1;
              }
            }
          }
          let mut tweight: i32 =  0;
          let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
          for (let mut unr: i32 =  0; unr <= unitCounter2; unr += 1)
          {
            if (this.game.HandyFunctionsObj.IsUnitInHQChain(unr, index2))
              tweight += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          }
          if (supplyReceivingHq.FindNr(index2) == -1)
          {
            num1 += tweight;
            supplyReceivingHq.Add(index2, tweight);
          }
        }
        if (supplyReceivingHq.Counter > -1)
        {
          supplyReceivingHq.Sort();
          let mut counter2: i32 =  supplyReceivingHq.Counter;
          for (let mut index: i32 =  0; index <= counter2; index += 1)
          {
            let mut num3: i32 =  supplyReceivingHq.Id[index];
            let mut num4: i32 =   Math.Round( pts * ( supplyReceivingHq.Weight[index] /  num1));
            supplyReceivingHq.Data1[index] = num4;
          }
        }
      }
      return supplyReceivingHq;
    }

    pub fn ExtraHQSwitchPPCost(unr: i32, bool wholehistoricalunit) -> i32
    {
      if (this.game.Data.UnitObj[unr].HQ == -1)
        return 0;
      let mut hq: i32 =  this.game.Data.UnitObj[unr].HQ;
      if (!this.HasUnitlandSF(unr) || this.game.Data.UnitObj[hq].Historical == -1 || this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].PP >= 0 || this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].PP == -9999)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut unr1: i32 =  0; unr1 <= unitCounter; unr1 += 1)
      {
        if (this.IsUnitInHQChain(unr1, hq) | unr1 == hq)
        {
          num1 += this.GetPowerPtsAbsolute(unr1);
          if (unr == unr1 | this.IsUnitInHQChain(unr1, unr) | wholehistoricalunit & this.game.Data.UnitObj[unr1].Historical == this.game.Data.UnitObj[unr].Historical)
            num2 += this.GetPowerPtsAbsolute(unr1);
        }
      }
      return num2 > 0 ?  Math.Round(Conversion.Int( num2 /  num1 *  Math.Abs(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].PP) + 0.99999)) : 0;
    }

    pub fn AddUnitToHQIsHowMuchPercentage(hq: i32, unr: i32, bool wholehistoricalunit) -> i32
    {
      if (this.game.Data.UnitObj[unr].HQ == -1)
        return 0;
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut unr1: i32 =  0; unr1 <= unitCounter1; unr1 += 1)
      {
        if (this.game.HandyFunctionsObj.IsUnitInHQChain(unr1, hq))
          num1 += this.GetPowerPtsAbsolute(unr1);
      }
      let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
      for (let mut unr2: i32 =  0; unr2 <= unitCounter2; unr2 += 1)
      {
        if (unr == unr2 | this.game.HandyFunctionsObj.IsUnitInHQChain(unr2, unr) | wholehistoricalunit & this.game.Data.UnitObj[unr2].Historical == this.game.Data.UnitObj[unr].Historical && this.game.Data.UnitObj[unr2].HQ != hq)
          num2 += this.GetPowerPtsAbsolute(unr2);
      }
      let mut howMuchPercentage: i32 =  0;
      if (num2 > 0)
        howMuchPercentage =  Math.Round(Conversion.Int(100.0 * ( num2 /  num1)));
      return howMuchPercentage;
    }

    pub fn AddMessageForAll(s: String, frontpic: i32, style: i32, note: String = "")
    {
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index1: i32 =  0; index1 <= regimeCounter; index1 += 1)
      {
        RegimeClass[] regimeObj = this.game.Data.RegimeObj;
        RegimeClass[] regimeClassArray = regimeObj;
        let mut index2: i32 =  index1;
        let mut index3: i32 =  index2;
        regimeClassArray[index3].MessCounter = regimeObj[index2].MessCounter + 1;
        let mut messCounter: i32 =  this.game.Data.RegimeObj[index1].MessCounter;
        this.game.Data.RegimeObj[index1].MessString = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessString, (Array) new string[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MessBackPic = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessBackPic, (Array) new int[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MessFrontPic = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessFrontPic, (Array) new int[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesStyle = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesStyle, (Array) new int[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesNote = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesNote, (Array) new string[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesNote2 = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesNote2, (Array) new string[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MessWav = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessWav, (Array) new string[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesGroup = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesGroup, (Array) new int[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesName = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesName, (Array) new string[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesChosen = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesChosen, (Array) new int[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesHideFromStart = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesHideFromStart, (Array) new bool[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MesHideFromTab = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesHideFromTab, (Array) new bool[messCounter + 1]);
        this.game.Data.RegimeObj[index1].MessString[messCounter] = s;
        this.game.Data.RegimeObj[index1].MessBackPic[messCounter] = -2;
        this.game.Data.RegimeObj[index1].MesStyle[messCounter] = style;
        this.game.Data.RegimeObj[index1].MesNote[messCounter] = note;
        this.game.Data.RegimeObj[index1].MessFrontPic[messCounter] = frontpic;
        this.game.Data.RegimeObj[index1].MesGroup[messCounter] = 0;
        this.game.Data.RegimeObj[index1].MesName[messCounter] = "";
        this.game.Data.RegimeObj[index1].MesChosen[messCounter] = 0;
        this.game.Data.RegimeObj[index1].MesHideFromStart[messCounter] = false;
        this.game.Data.RegimeObj[index1].MesHideFromTab[messCounter] = false;
      }
    }

    pub fn AddMessageForOne(s: String, too: i32, frontpic: i32, style: i32, note: String = "")
    {
      let mut index1: i32 =  too;
      RegimeClass[] regimeObj = this.game.Data.RegimeObj;
      RegimeClass[] regimeClassArray = regimeObj;
      let mut index2: i32 =  index1;
      let mut index3: i32 =  index2;
      regimeClassArray[index3].MessCounter = regimeObj[index2].MessCounter + 1;
      let mut messCounter: i32 =  this.game.Data.RegimeObj[index1].MessCounter;
      this.game.Data.RegimeObj[index1].MessString = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessString, (Array) new string[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MessBackPic = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessBackPic, (Array) new int[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MessFrontPic = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessFrontPic, (Array) new int[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesStyle = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesStyle, (Array) new int[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesNote = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesNote, (Array) new string[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesNote2 = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesNote2, (Array) new string[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MessWav = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MessWav, (Array) new string[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesGroup = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesGroup, (Array) new int[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesName = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesName, (Array) new string[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesChosen = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesChosen, (Array) new int[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesHideFromStart = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesHideFromStart, (Array) new bool[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MesHideFromTab = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].MesHideFromTab, (Array) new bool[messCounter + 1]);
      this.game.Data.RegimeObj[index1].MessString[messCounter] = s;
      this.game.Data.RegimeObj[index1].MessBackPic[messCounter] = -2;
      this.game.Data.RegimeObj[index1].MesStyle[messCounter] = style;
      this.game.Data.RegimeObj[index1].MesNote[messCounter] = note;
      this.game.Data.RegimeObj[index1].MesNote2[messCounter] = "";
      this.game.Data.RegimeObj[index1].MessFrontPic[messCounter] = frontpic;
      this.game.Data.RegimeObj[index1].MessFrontPic[messCounter] = frontpic;
      this.game.Data.RegimeObj[index1].MesGroup[messCounter] = 0;
      this.game.Data.RegimeObj[index1].MesName[messCounter] = "";
      this.game.Data.RegimeObj[index1].MesChosen[messCounter] = 0;
      this.game.Data.RegimeObj[index1].MesHideFromStart[messCounter] = false;
      this.game.Data.RegimeObj[index1].MesHideFromTab[messCounter] = false;
    }

    pub fn CheckDiskSpace(DriveOrFolder: String) -> i32
    {
      long lpFreeBytesAvailableToMe;
      long lpTotalNumberOfBytes;
      long lpTotalNumberOfFreeBytes;
      if (HandyFunctionsclass.GetDiskFreeSpaceEx( DriveOrFolder,  lpFreeBytesAvailableToMe,  lpTotalNumberOfBytes,  lpTotalNumberOfFreeBytes) == 0)
        return 999;
      str1: String = Strings.Format( lpTotalNumberOfFreeBytes, "###,###,##") + " bytes )";
      double num =  (lpTotalNumberOfFreeBytes / 1024L / 1024L);
      str2: String = Strings.Format( num, "###,###,##") + " MB free";
      return  Math.Round(Conversion.Int(num));
    }

    pub IsSleeping: bool(regnr: i32) => regnr != -1 && this.game.Data.RegimeObj[regnr].Sleep;

    pub IsHostileOrSelf: bool(regnr: i32, targetregnr: i32) => this.game.Data.Round != 0 && (targetregnr == -1 || regnr == -1 || regnr == targetregnr || this.game.Data.RegimeObj[regnr].RegimeRel[targetregnr] == 0 | this.game.Data.RegimeObj[regnr].RegimeRel[targetregnr] == 2);

    pub IsASleep: bool(regnr: i32) => this.game.Data.Round != 0 && regnr != -1 && this.game.Data.RegimeObj[regnr].Sleep;

    pub IsHostileNotSelf: bool(regnr: i32, targetregnr: i32) => targetregnr == -1 || regnr != targetregnr && (regnr == -1 || this.game.Data.RegimeObj[regnr].RegimeRel[targetregnr] == 0);

    pub HasUnitHQBelow: bool(unr: i32)
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].HQ == unr & this.game.Data.UnitObj[index].IsHQ)
          return true;
      }
      return false;
    }

    pub IsHostileNotSelf2: bool(regnr: i32, targetregnr: i32) => targetregnr == -1 || regnr != targetregnr && (regnr == -1 || this.game.Data.RegimeObj[regnr].RegimeRel[targetregnr] == 0);

    pub IsNeutral: bool(regnr: i32, targetregnr: i32) => targetregnr != -1 && regnr != targetregnr && regnr != -1 && this.game.Data.RegimeObj[regnr].RegimeRel[targetregnr] == 1;

    pub fn GetHexStackPts(x: i32, y: i32, map: i32) -> i32
    {
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      hexStackPts: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        hexStackPts += this.GetUnitStackPts(unit);
      }
      return hexStackPts;
    }

    pub fn GetHexStackPts(x: i32, y: i32, map: i32, regnr: i32) -> i32
    {
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      hexStackPts: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        if (this.game.Data.UnitObj[unit].Regime == regnr)
          hexStackPts += this.GetUnitStackPts(unit);
      }
      return hexStackPts;
    }

    pub fn GetHexStackPtsPrognosed(x: i32, y: i32, regnr: i32) -> i32
    {
      if (this.game.Data.MapObj[0].HexObj[x, y].UnitCounter < 0)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      stackPtsPrognosed: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].TempX == x & this.game.Data.UnitObj[index].TempY == y)
        {
          let mut unr: i32 =  index;
          let mut num: i32 =  1;
          if (this.game.Data.UnitObj[unr].TempSlot > 0 && this.game.NewAIObj.MoveMatrixUnit[this.game.Data.UnitObj[unr].TempSlot] == unr && this.game.Data.UnitObj[unr].TempCategory == 1 && this.game.NewAIObj.MoveMatrixUnitMarker[this.game.Data.UnitObj[unr].TempSlot] > 0 & this.game.NewAIObj.MoveMatrixUnitMarker[this.game.Data.UnitObj[unr].TempSlot] < this.game.NewAIObj.MarkerList.Counter && this.game.NewAIObj.MarkerList.Weight[this.game.NewAIObj.MoveMatrixUnitMarker[this.game.Data.UnitObj[unr].TempSlot]] == 1)
            num = 0;
          if (num == 1 && this.game.Data.UnitObj[unr].Regime == regnr)
            stackPtsPrognosed += this.GetUnitStackPts(unr);
        }
      }
      return stackPtsPrognosed;
    }

    pub fn GetStartPower(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].Historical == -1 | this.game.Data.UnitObj[unr].HistoricalSubPart == -1 ||  this.game.Data.RuleVar[884] < 1.0)
        return this.game.Data.UnitObj[unr].StartPower;
      let mut preDef: i32 =  this.game.HandyFunctionsObj.GetPreDef(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].SubParts[this.game.Data.UnitObj[unr].HistoricalSubPart]);
      return preDef == -1 ? this.game.Data.UnitObj[unr].StartPower : this.game.HandyFunctionsObj.GetPowerPtsAbsolute(preDef);
    }

    pub fn GetUnitStackPts(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitStackPts: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0)
          unitStackPts += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Frontage;
      }
      return unitStackPts;
    }

    pub fn GetUnitAirRangeInHex(unr: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 2 && this.game.Data.SFTypeObj[type].AirAPRule > num1)
        {
          num1 = this.game.Data.SFTypeObj[type].AirAPRule;
          if (this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Ap > num2)
            num2 = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Ap;
        }
      }
      return num1 < 1 ? -1 :  Math.Round(Conversion.Int( num2 /  num1));
    }

    pub fn GetUnitStackPtsArt(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitStackPtsArt: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ArtRange > 0)
          unitStackPtsArt += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Frontage;
      }
      return unitStackPtsArt;
    }

    pub fn GetUnitStackPtsAir(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitStackPtsAir: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2)
          unitStackPtsAir += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Frontage;
      }
      return unitStackPtsAir;
    }

    pub fn GetUnitartStackPts(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitartStackPts: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater < 2 & this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ArtRange > 0)
          unitartStackPts += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Frontage;
      }
      return unitartStackPts;
    }

    pub fn GetUnitairStackPts(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitairStackPts: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2)
          unitairStackPts += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Frontage;
      }
      return unitairStackPts;
    }

    pub fn GetUnitAS(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitAs: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        unitAs = unitAs + this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].AntiSupply + this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].AntiSupplySea;
      }
      return unitAs;
    }

    pub fn SetUnitAPToZero(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
        this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Ap = 0;
      zero: i32;
      return zero;
    }

    pub fn GetPowerPtsAbsoluteLandForRegime(regnr: i32) -> i32
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      absoluteLandForRegime: i32;
      for (let mut unr: i32 =  0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].Regime == regnr && this.game.Data.UnitObj[unr].PreDef == -1)
          absoluteLandForRegime += this.GetPowerPtsAbsolute(unr, true);
      }
      return absoluteLandForRegime;
    }

    pub fn GetSFObjStackPts(sfnr: i32, qty: i32) -> i32 => qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].Frontage;

    pub fn DoZOCConquest(x: i32, y: i32, map: i32, regnr: i32, let mut ox: i32 =  -1, let mut oy: i32 =  -1, let mut unr: i32 =  -1)
    {
      let mut num1: i32 =  0;
      if (regnr == 11 & x == 114 & y == 54)
        y = y;
      if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea && this.IsHostileOrSelf(regnr, this.game.Data.MapObj[map].HexObj[x, y].Regime))
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].Regime == -1)
        {
          if ( this.game.Data.MapObj[map].HexObj[x, y].get_ZocPts(regnr) >=  this.game.Data.RuleVar[10])
            num1 = 1;
        }
        else if (this.game.Data.MapObj[map].HexObj[x, y].Regime != regnr & this.game.Data.RegimeObj[regnr].RegimeRel[this.game.Data.MapObj[map].HexObj[x, y].Regime] != 2 &&  this.game.Data.MapObj[map].HexObj[x, y].get_ZocPts(regnr) >=  this.game.Data.RuleVar[9] &&  this.game.Data.MapObj[map].HexObj[x, y].get_ZocPts(regnr) >=  this.game.Data.RuleVar[40] *  this.game.Data.MapObj[map].HexObj[x, y].get_ZocPts(this.game.Data.MapObj[0].HexObj[x, y].Regime) && this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
          num1 = 1;
      }
      if (num1 == 1)
      {
        let mut num2: i32 =  0;
        let mut num3: i32 =  this.HexNeighbourCount(x, y, map);
        for (let mut tfacing: i32 =  1; tfacing <= num3; tfacing += 1)
        {
          Coordinate coordinate = this.HexNeighbour(x, y, map, tfacing);
          if (coordinate.onmap)
          {
            if (this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime == regnr)
              num2 = 1;
            if (this.game.Data.RegimeObj[regnr].UberRegime > -1 & this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime == this.game.Data.RegimeObj[regnr].UberRegime)
              num2 = 1;
          }
        }
        if (num2 == 0)
          num1 = 0;
      }
      if (this.game.Data.MapObj[map].HexObj[x, y].Regime == -1 &  this.game.Data.RuleVar[79] == 0.0)
        num1 = 0;
      if (this.game.Data.MapObj[map].HexObj[x, y].Location > -1 && this.game.Data.MapObj[map].HexObj[x, y].Regime != regnr && num1 == 1)
      {
        if ( this.game.Data.RuleVar[901] < 1.0)
        {
          this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].HQ = -1;
          if ( this.game.Data.RuleVar[898] > 0.0)
            this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].StructuralPts = 0;
          let mut index: i32 =  0;
          do
          {
            this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Production[index] = -1;
            this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].ProdPercent[index] = 0;
            this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].ProdPointRemainder[index] = 0;
            index += 1;
          }
          while (index <= 3);
        }
        else
          num1 = 0;
      }
      if (this.game.HandyFunctionsObj.HasHexRoad(x, y, 0) &  this.game.Data.RuleVar[901] == 2.0)
        num1 = 0;
      if (num1 != 1)
        return;
      if ( this.game.Data.RuleVar[840] == 1.0 & this.game.Data.MapObj[map].HexObj[x, y].OrigOwner > -1 & this.game.HandyFunctionsObj.IsAlliedOrSelf(regnr, this.game.Data.MapObj[map].HexObj[x, y].OrigOwner))
      {
        this.game.Data.MapObj[map].HexObj[x, y].set_LastReg(this.game.Data.MapObj[map].HexObj[x, y].Regime, this.game.Data.MapObj[map].HexObj[x, y].OrigOwner);
        this.game.Data.MapObj[map].HexObj[x, y].Regime = this.game.Data.MapObj[map].HexObj[x, y].OrigOwner;
      }
      else if (this.game.Data.RegimeObj[regnr].UberRegime > -1)
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].Regime > -1)
          this.game.Data.MapObj[map].HexObj[x, y].set_LastReg(this.game.Data.MapObj[map].HexObj[x, y].Regime, this.game.Data.RegimeObj[regnr].UberRegime);
        this.game.Data.MapObj[map].HexObj[x, y].Regime = this.game.Data.RegimeObj[regnr].UberRegime;
      }
      else
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].Regime > -1)
          this.game.Data.MapObj[map].HexObj[x, y].set_LastReg(this.game.Data.MapObj[map].HexObj[x, y].Regime, regnr);
        this.game.Data.MapObj[map].HexObj[x, y].Regime = regnr;
      }
      if (unr > -1)
        this.UnitCausesHexOwnershipChange(regnr, x, y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y);
      else
        this.UnitCausesHexOwnershipChange(regnr, x, y, ox, oy);
      this.game.Data.MapObj[map].HexObj[x, y].set_SeeNow(regnr, 1);
      this.game.Data.MapObj[map].HexObj[x, y].set_LastLT(regnr, this.game.Data.MapObj[map].HexObj[x, y].LandscapeType);
      this.game.Data.MapObj[map].HexObj[x, y].set_LastSpr(regnr, this.game.Data.MapObj[map].HexObj[x, y].SpriteNr);
      this.game.Data.MapObj[map].HexObj[x, y].set_LastReg(regnr, this.game.Data.MapObj[map].HexObj[x, y].Regime);
      this.HistoryAddHex(x, y, map, regnr, 1, 1);
    }

    pub fn GetEffectiveRecon(rawRecon: i32) => rawRecon < 1 ? 0 : (rawRecon <= 1 ? 1 :  Math.Round(Math.Ceiling(Math.Log10( rawRecon) * 30.0))) -> i32;

    pub void HistoryAddHex(
      x: i32,
      y: i32,
      map: i32,
      curreg: i32,
      let mut histyp: i32 =  -1,
      let mut hisdata: i32 =  -1,
      let mut hisdata2: i32 =  -1,
      Neighbours neighbour = null,
      let mut attacktype: i32 =  -1,
      infostring: String = "",
      let mut overruleownership: i32 =  -1,
      let mut onlyForReg: i32 =  -1,
      bool allowAddedForCurrentTurn = false,
      infostringunknown: String = "",
      infostringnotseen: String = "")
    {
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index1: i32 =  0; index1 <= regimeCounter; index1 += 1)
      {
        if (onlyForReg == -1 | onlyForReg == index1 && (index1 != curreg | allowAddedForCurrentTurn) & !(this.game.Data.RegimeObj[index1].AI | this.game.Data.RegimeObj[index1].Sleep) && this.game.Data.MapObj[map].HexObj[x, y].get_ReconPts(index1) > 0 | !this.game.Data.FOWOn | this.game.HandyFunctionsObj.IsAlliedOrSelf(index1, curreg, true))
        {
          let mut num: i32 =  1;
          Coordinate reconMinusHide;
          if (histyp == 2)
          {
            if (hisdata == 0 & this.CanWeSeeUnit(hisdata2, index1) < 1)
              num = 0;
            if (hisdata2 > -1)
            {
              if (this.CanWeSeeUnit(hisdata2, index1) < 1)
                infostring = infostringnotseen;
              reconMinusHide = this.game.HandyFunctionsObj.GetReconMinusHide(hisdata2, index1);
              if (reconMinusHide.x < 2)
                infostring = infostringunknown;
            }
          }
          else if ( this.game.Data.RuleVar[455] > 0.0)
          {
            num = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location2 > -1)
            {
              if (this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location2].Type].isSupplyBase)
                num = 1;
              if (this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location2].Type].isSupplySource)
                num = 1;
            }
            if (this.game.Data.MapObj[0].HexObj[x, y].VP > 0)
              num = 1;
            else if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[x, y].LandscapeType].FuzzyOwnerAssured)
              num = 1;
            else if (histyp == 4 | attacktype > -1)
              num = 1;
            else if (!this.game.Data.FOWOn)
            {
              num = 1;
            }
            else
            {
              if (hisdata == 0 & hisdata2 > -1 && this.CanWeSeeUnit(hisdata2, index1) < 1)
                num = 0;
              if (hisdata2 > -1)
              {
                if (this.CanWeSeeUnit(hisdata2, index1) < 1)
                  num = 0;
                reconMinusHide = this.game.HandyFunctionsObj.GetReconMinusHide(hisdata2, index1);
                if (reconMinusHide.x < 2)
                  num = 0;
              }
            }
          }
          if (num == 1)
          {
            RegimeClass[] regimeObj = this.game.Data.RegimeObj;
            RegimeClass[] regimeClassArray = regimeObj;
            let mut index2: i32 =  index1;
            let mut index3: i32 =  index2;
            regimeClassArray[index3].HistoryStepCounter = regimeObj[index2].HistoryStepCounter + 1;
            this.game.Data.RegimeObj[index1].HistoryStep = (HistoryStepClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index1].HistoryStep, (Array) new HistoryStepClass[this.game.Data.RegimeObj[index1].HistoryStepCounter + 1]);
            this.game.Data.RegimeObj[index1].HistoryStep[this.game.Data.RegimeObj[index1].HistoryStepCounter] = new HistoryStepClass(0);
            HistoryStepClass historyStepClass = this.game.Data.RegimeObj[index1].HistoryStep[this.game.Data.RegimeObj[index1].HistoryStepCounter];
            historyStepClass.X = x;
            historyStepClass.Y = y;
            historyStepClass.Map = map;
            historyStepClass.InfoString = infostring;
            historyStepClass.Regime = curreg;
            historyStepClass.Ownership = overruleownership <= -1 ? this.game.Data.MapObj[map].HexObj[x, y].Regime : overruleownership;
            historyStepClass.Force = this.game.HandyFunctionsObj.GetForceForHex(x, y, map, index1);
            historyStepClass.Depth = this.game.HandyFunctionsObj.GetDepthForHex(x, y, map, index1);
            historyStepClass.His = this.game.HandyFunctionsObj.GetHistoricalForHex(x, y, map, index1);
            historyStepClass.Ownership = this.game.Data.MapObj[map].HexObj[x, y].Regime != -1 ? (historyStepClass.Force <= -1 ? this.game.Data.MapObj[map].HexObj[x, y].Regime : this.game.HandyFunctionsObj.GetRegimeForForceForHex(x, y, map)) : this.game.HandyFunctionsObj.GetRegimeForForceForHex(x, y, map);
            historyStepClass.SFType = this.game.HandyFunctionsObj.GetDominantSfTypeForHex(x, y, map, index1);
            historyStepClass.StepNr = this.game.Data.StepNr;
            if (attacktype > -1)
            {
              let mut index4: i32 =  0;
              do
              {
                if (!Information.IsNothing( neighbour))
                  historyStepClass.AttackDirection[index4] = neighbour.data[index4];
                index4 += 1;
              }
              while (index4 <= 5);
              historyStepClass.AttackOtherType = attacktype;
            }
            if (histyp == 4)
            {
              historyStepClass.LossCounter = this.game.EditObj.HisLossCounter;
              historyStepClass.InfoString = infostring;
              if (historyStepClass.LossCounter > -1)
              {
                historyStepClass.LossAttacker = new int[historyStepClass.LossCounter + 1];
                historyStepClass.LossSFType = new int[historyStepClass.LossCounter + 1];
                historyStepClass.LossDEAD = new int[historyStepClass.LossCounter + 1];
                historyStepClass.LossOK = new int[historyStepClass.LossCounter + 1];
                historyStepClass.LossRegimeWin = this.game.EditObj.HisRegimeWon;
                historyStepClass.LossAttReg = this.game.EditObj.HisLossAttReg;
                historyStepClass.LossDefReg = this.game.EditObj.HisLossDefReg;
                let mut lossCounter: i32 =  historyStepClass.LossCounter;
                for (let mut index5: i32 =  0; index5 <= lossCounter; index5 += 1)
                {
                  historyStepClass.LossAttacker[index5] = this.game.EditObj.HisLossAttacker[index5];
                  historyStepClass.LossDEAD[index5] = this.game.EditObj.HisLossDEAD[index5];
                  historyStepClass.LossOK[index5] = this.game.EditObj.HisLossOK[index5];
                  historyStepClass.LossSFType[index5] = this.game.EditObj.HisLossSFType[index5];
                }
              }
            }
            else
              historyStepClass.LossCounter = -1;
          }
        }
      }
    }

    pub fn ResetRegimeLowData(object regnr)
    {
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut Left: i32 =  0; Left <= regimeCounter; Left += 1)
      {
        if (this.game.Data.RegimeObj[Left].minimumDataUsage)
        {
          if (Operators.ConditionalCompareObjectEqual( Left, regnr, false))
          {
            let mut mapCount: i32 =  this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MapCount;
            for (let mut index: i32 =  0; index <= mapCount; index += 1)
            {
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryOwner[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryForce[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistorySFType[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryHis[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryDepth[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].AIVP[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].Trafic[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].Trafic2[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].AIPower[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].AIDefense[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
            }
          }
          else
          {
            let mut mapCount: i32 =  this.game.Data.RegimeObj[Left].MapCount;
            for (let mut index: i32 =  0; index <= mapCount; index += 1)
            {
              this.game.Data.RegimeObj[Left].HistoryOwner[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].HistoryForce[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].HistorySFType[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].HistoryHis[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].HistoryDepth[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].AIVP[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].Trafic[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].Trafic2[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].AIPower[index] = (MapMatrix2) null;
              this.game.Data.RegimeObj[Left].AIDefense[index] = (MapMatrix2) null;
            }
          }
        }
      }
    }

    pub fn ClearHistory(object regnr)
    {
      if (this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryStepCounter > -1)
      {
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryStepCounter = -1;
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryStep = new HistoryStepClass[1];
      }
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter1; index += 1)
      {
        if (Operators.ConditionalCompareObjectEqual( this.game.Data.UnitObj[index].Regime, regnr, false))
          this.game.Data.UnitObj[index].txtLog = "";
      }
      if (this.game.Data.Product >= 7)
        this.ResetRegimeLowData(RuntimeHelpers.GetObjectValue(regnr));
      if (Operators.ConditionalCompareObjectEqual(regnr,  2, false))
        ;
      if (!this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].minimumDataUsage)
      {
        index: i32;
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryOwner[index].Value = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryForce[index].Value = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistorySFType[index].Value = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryHis[index].Value = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryDepth[index].Value = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      }
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut map: i32 =  0; map <= mapCounter; map += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[map].MapWidth;
        for (let mut x: i32 =  0; x <= mapWidth; x += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[map].MapHeight;
          for (let mut y: i32 =  0; y <= mapHeight; y += 1)
          {
            if (x == 104 & y == 28)
              x = x;
            this.game.Data.MapObj[0].HexObj[x, y].FuzzyBlock = 0;
            bool flag = false;
            if (this.game.Data.Product >= 6)
            {
              if (this.game.Data.MapObj[map].HexObj[x, y].get_ReconPts(Conversions.ToInteger(regnr)) >= 1)
                flag = true;
              if (Operators.ConditionalCompareObjectEqual( this.game.Data.Turn, regnr, false) && this.game.Data.MapObj[map].HexObj[x, y].MaxRecon >= 1)
                flag = true;
              if (!this.game.Data.FOWOn)
                flag = true;
            }
            else if (this.game.Data.MapObj[map].HexObj[x, y].get_SeeNow(Conversions.ToInteger(regnr)) == 1 | this.game.Data.MapObj[map].HexObj[x, y].get_ReconPts(Conversions.ToInteger(regnr)) >= 1)
              flag = true;
            if (flag)
            {
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryOwner[map].Value[x, y] = this.game.Data.MapObj[map].HexObj[x, y].Regime != -1 ? this.game.Data.MapObj[map].HexObj[x, y].Regime : this.GetRegimeForForceForHex(x, y, map);
              this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryForce[map].Value[x, y] = this.game.HandyFunctionsObj.GetForceForHex(x, y, map, Conversions.ToInteger(regnr));
              if (this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryForce[map].Value[x, y] > -1)
              {
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryOwner[map].Value[x, y] = this.game.HandyFunctionsObj.GetRegimeForForceForHex(x, y, map);
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistorySFType[map].Value[x, y] = this.game.HandyFunctionsObj.GetDominantSfTypeForHex(x, y, map, Conversions.ToInteger(regnr));
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryHis[map].Value[x, y] = this.game.HandyFunctionsObj.GetHistoricalForHex(x, y, map, Conversions.ToInteger(regnr));
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryDepth[map].Value[x, y] = this.game.HandyFunctionsObj.GetDepthForHex(x, y, map, Conversions.ToInteger(regnr));
              }
              else
              {
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryHis[map].Value[x, y] = this.game.HandyFunctionsObj.GetHistoricalForHex(x, y, map, Conversions.ToInteger(regnr));
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryDepth[map].Value[x, y] = this.game.HandyFunctionsObj.GetDepthForHex(x, y, map, Conversions.ToInteger(regnr));
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistorySFType[map].Value[x, y] = -1;
              }
            }
            else
            {
              if (x == 104 & y == 28)
                x = x;
              if (this.game.Data.ShrowdOn)
              {
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryOwner[map].Value[x, y] = -2;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryForce[map].Value[x, y] = -1;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistorySFType[map].Value[x, y] = -1;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryHis[map].Value[x, y] = -1;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryDepth[map].Value[x, y] = 0;
              }
              else
              {
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryOwner[map].Value[x, y] = this.game.Data.MapObj[map].HexObj[x, y].Regime;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryForce[map].Value[x, y] = -1;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistorySFType[map].Value[x, y] = -1;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryHis[map].Value[x, y] = -1;
                this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].HistoryDepth[map].Value[x, y] = 0;
              }
            }
            this.game.Data.MapObj[map].HexObj[x, y].set_SupplyKilled(Conversions.ToInteger(regnr), 0);
            this.game.Data.MapObj[map].HexObj[x, y].set_PowerPointsKilled(Conversions.ToInteger(regnr), 0);
            this.game.Data.MapObj[map].HexObj[x, y].set_SupplyLost(Conversions.ToInteger(regnr), 0);
            this.game.Data.MapObj[map].HexObj[x, y].set_PowerPointsLost(Conversions.ToInteger(regnr), 0);
          }
        }
      }
      this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SASKilled = new int[this.game.Data.SFTypeCounter + 1];
      try
      {
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SLoss = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SLoss, (Array) new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1]);
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SKills = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SKills, (Array) new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1]);
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SPresent = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SPresent, (Array) new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1]);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SLoss = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SKills = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SPresent = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
        ProjectData.ClearProjectError();
      }
      let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
      for (let mut index: i32 =  0; index <= sfTypeCounter; index += 1)
      {
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SASKilled[index] = 0;
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SLoss[index, 0] = 0;
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SKills[index, 0] = 0;
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SPresent[index, 0] = 0;
      }
      this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].SASSupplyKilled = 0;
      if (this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MessCounter > -1)
      {
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MessCounter = -1;
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MessString = new string[1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MessFrontPic = new int[1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MessBackPic = new int[1];
        this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MessWav = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[Conversions.ToInteger(regnr)].MessWav, (Array) new string[1]);
      }
      let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter2; index += 1)
      {
        if (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn & this.game.Data.Turn > -1 & this.game.Data.UnitObj[index].X > -1)
        {
          this.game.Data.UnitObj[index].FreeCombatX = -1;
          this.game.Data.UnitObj[index].FreeCombatY = -1;
          this.game.Data.UnitObj[index].FreeCombatMap = -1;
          this.game.Data.UnitObj[index].FuelUsedAtt = 0;
          this.game.Data.UnitObj[index].FuelUsedDef = 0;
          this.game.Data.UnitObj[index].FuelUsedMove = 0;
          if (this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime == -1 && this.game.Data.Product < 6)
          {
            this.game.Data.UnitObj[index].SupplyIn = 0;
            this.game.Data.UnitObj[index].SupplyOut = 0;
            this.game.Data.UnitObj[index].SupplyReq = 0;
            this.game.Data.UnitObj[index].SupplyLost = 0;
          }
        }
      }
      let mut landscapeTypeCounter: i32 =  this.game.Data.LandscapeTypeCounter;
      for (let mut index: i32 =  0; index <= landscapeTypeCounter; index += 1)
        this.game.Data.LandscapeTypeObj[index].TempHexBitmap = (Bitmap) null;
      let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
      for (let mut index: i32 =  0; index <= historicalUnitCounter; index += 1)
      {
        this.game.Data.HistoricalUnitObj[index].TempAttack = -1;
        this.game.Data.HistoricalUnitObj[index].TempDefend = -1;
        this.game.Data.HistoricalUnitObj[index].TempStance = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetX = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetY = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetAttackX = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetAttackY = -1;
      }
    }

    pub DoesUnitUseFuel: bool(id: i32)
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[id].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[id].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].FuelForAttack > 0 || this.game.Data.SFTypeObj[type].FuelForAttackDef > 0 || this.game.Data.SFTypeObj[type].FuelForMove > 0)
          return true;
      }
      return false;
    }

    pub fn GetHistoricalUnitByID(id: i32) -> i32
    {
      let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
      for (let mut historicalUnitById: i32 =  0; historicalUnitById <= historicalUnitCounter; historicalUnitById += 1)
      {
        if (this.game.Data.HistoricalUnitObj[historicalUnitById].ID == id)
          return historicalUnitById;
      }
      return -1;
    }

    pub fn GetSFTypeByID(id: i32) -> i32
    {
      let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
      for (let mut sfTypeById: i32 =  0; sfTypeById <= sfTypeCounter; sfTypeById += 1)
      {
        if (this.game.Data.SFTypeObj[sfTypeById].Id == id)
          return sfTypeById;
      }
      return -1;
    }

    pub fn GetReinfTypeByID(id: i32) -> i32
    {
      let mut reinfCounter: i32 =  this.game.Data.ReinfCounter;
      for (let mut reinfTypeById: i32 =  0; reinfTypeById <= reinfCounter; reinfTypeById += 1)
      {
        if (this.game.Data.ReinfId[reinfTypeById] == id)
          return reinfTypeById;
      }
      return -1;
    }

    pub fn GetEventByID(id: i32) -> i32
    {
      let mut eventCounter: i32 =  this.game.Data.EventCounter;
      for (let mut eventById: i32 =  0; eventById <= eventCounter; eventById += 1)
      {
        if (this.game.Data.EventObj[eventById].Id == id)
          return eventById;
      }
      return -1;
    }

    pub fn GetStringListByID(id: i32) -> i32
    {
      if (this.game.Data.Product < 7 | this.game.Data.Round < 1)
      {
        this.tempStrlistSet = false;
        let mut stringListCounter: i32 =  this.game.Data.StringListCounter;
        for (let mut stringListById: i32 =  0; stringListById <= stringListCounter; stringListById += 1)
        {
          if (this.game.Data.StringListObj[stringListById].ID == id)
            return stringListById;
        }
        return -1;
      }
      if (!this.tempStrlistSet)
      {
        this.tempStrlist = new int[this.game.Data.StringIDCounter + 1];
        let mut stringListCounter1: i32 =  this.game.Data.StringListCounter;
        for (let mut index: i32 =  0; index <= stringListCounter1; index += 1)
          this.tempStrlist[index] = -1;
        let mut stringListCounter2: i32 =  this.game.Data.StringListCounter;
        for (let mut index: i32 =  0; index <= stringListCounter2; index += 1)
        {
          if (this.game.Data.StringListObj[index].ID > 0)
            this.tempStrlist[this.game.Data.StringListObj[index].ID] = index;
        }
        this.tempStrlistSet = true;
      }
      if (id > 0 & id <= this.tempStrlist.GetUpperBound(0))
      {
        let mut stringListById: i32 =  this.tempStrlist[id];
        if (stringListById > -1)
          return stringListById;
      }
      let mut stringListCounter3: i32 =  this.game.Data.StringListCounter;
      for (let mut stringListById: i32 =  0; stringListById <= stringListCounter3; stringListById += 1)
      {
        if (this.game.Data.StringListObj[stringListById].ID == id)
          return stringListById;
      }
      return -1;
    }

    pub fn GetLocationByID(id: i32) -> i32
    {
      let mut locCounter: i32 =  this.game.Data.LocCounter;
      for (let mut locationById: i32 =  0; locationById <= locCounter; locationById += 1)
      {
        if (this.game.Data.LocObj[locationById].ID == id)
          return locationById;
      }
      return -1;
    }

    pub CardSelectHexTestPossible: bool(cardNr: i32, slot: i32, mustBeValue: i32)
    {
      if (!this.game.Data.ActionCardObj[cardNr].IgnorePopupIfNoSelect)
        return true;
      let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
        {
          if (this.game.Data.MapObj[0].HexObj[index1, index2].AreaCode[slot] == mustBeValue)
            return true;
        }
      }
      return false;
    }

    pub CardSelectUnitTestPossible: bool(cardNr: i32)
    {
      if (!this.game.Data.ActionCardObj[cardNr].IgnorePopupIfNoSelect)
        return true;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].TempUnitSelectable && this.game.Data.UnitObj[index].PreDef == -1)
          return true;
      }
      return false;
    }

    pub fn GetForceForHex(x: i32, y: i32, map: i32, regnr: i32) -> i32
    {
      let mut forceForHex: i32 =  -1;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      num: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        if (this.game.HandyFunctionsObj.CanWeSeeUnit(unit, regnr) > 0)
        {
          if (forceForHex == -1)
            forceForHex = 0;
          let mut power: i32 =  this.game.HandyFunctionsObj.GetPower(unit, regnr, true);
          if (power < 0)
            num += 1;
          forceForHex += power;
        }
      }
      if (num > 0 & forceForHex < 0)
        forceForHex = -9999;
      return forceForHex;
    }

    pub fn GetHistoricalForHex(x: i32, y: i32, map: i32, regnr: i32) -> i32
    {
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        if (this.game.HandyFunctionsObj.CanWeSeeUnit(unit, regnr) > 0 && this.game.Data.UnitObj[unit].Historical > -1)
          return this.game.Data.UnitObj[unit].Historical;
      }
      return -1;
    }

    pub fn GetDepthForHex(x: i32, y: i32, map: i32, regnr: i32) -> i32
    {
      let mut depthForHex: i32 =  0;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.HandyFunctionsObj.CanWeSeeUnit(this.game.Data.MapObj[map].HexObj[x, y].UnitList[index], regnr) > 0)
          depthForHex += 1;
      }
      return depthForHex;
    }

    pub fn GetRegimeForForceForHex(x: i32, y: i32, map: i32) -> i32 => this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0 ? -1 : this.game.Data.UnitObj[this.game.Data.MapObj[map].HexObj[x, y].UnitList[0]].Regime;

    pub fn GetDominantSfTypeForHex(x: i32, y: i32, map: i32, regnr: i32) -> i32
    {
      Coordinate coordinate = Coordinate::new();
      SizeF sizeF = SizeF::new();
      int[] numArray1 = new int[1];
      int[] numArray2 = this.game.Data.SFTypeCounter >= 101 ? new int[this.game.Data.SFTypeCounter + 1] : new int[101];
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return -1;
      let mut unitCounter1: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      num1: i32;
      for (let mut index1: i32 =  0; index1 <= unitCounter1; index1 += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index1];
        if (this.game.Data.UnitObj[unit].SFCount > -1 && this.game.HandyFunctionsObj.CanWeSeeUnit(unit, regnr) > 0 && this.GetReconMinusHide(unit, regnr).x > 1)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[unit].SFCount;
          for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index2];
            let mut type: i32 =  this.game.Data.SFObj[sf].Type;
            let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
            if (type > -1)
            {
              let mut symbolGroup: i32 =  this.game.Data.SFTypeObj[type].SymbolGroup;
              let mut symbolWeight: i32 =  this.game.Data.SFTypeObj[type].SymbolWeight;
              if (symbolGroup > -1)
              {
                numArray2[symbolGroup] = numArray2[symbolGroup] + symbolWeight * qty;
                num2: i32;
                if (numArray2[symbolGroup] > num2)
                {
                  num2 = numArray2[symbolGroup];
                  num1 = symbolGroup;
                }
              }
            }
          }
        }
      }
      if (num1 <= -1)
        return -1;
      let mut num3: i32 =  num1;
      let mut num4: i32 =  -1;
      let mut num5: i32 =  0;
      let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
      for (let mut index: i32 =  0; index <= sfTypeCounter; index += 1)
        numArray2[index] = 0;
      let mut unitCounter2: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index3: i32 =  0; index3 <= unitCounter2; index3 += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index3];
        if (this.game.HandyFunctionsObj.CanWeSeeUnit(unit, regnr) > 0 && this.game.Data.UnitObj[unit].SFCount > -1)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[unit].SFCount;
          for (let mut index4: i32 =  0; index4 <= sfCount; index4 += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index4];
            let mut type: i32 =  this.game.Data.SFObj[sf].Type;
            let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
            let mut symbolGroup: i32 =  this.game.Data.SFTypeObj[type].SymbolGroup;
            let mut symbolWeight: i32 =  this.game.Data.SFTypeObj[type].SymbolWeight;
            if (symbolGroup == num3)
            {
              numArray2[type] = numArray2[type] + symbolWeight * qty;
              if (numArray2[type] > num5)
              {
                num5 = numArray2[type];
                num4 = type;
              }
            }
          }
        }
      }
      return num4 > -1 ? num4 : -1;
    }

    pub fn SetCapForUnit(unr: i32)
    {
      this.game.Data.UnitObj[unr].LandCap = 0;
      this.game.Data.UnitObj[unr].AirCap = 0;
      this.game.Data.UnitObj[unr].NavyCap = 0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut theater: i32 =  this.game.Data.SFTypeObj[type].Theater;
          let mut num1: i32 =   Math.Round( (this.game.Data.SFTypeObj[type].Cap * qty) * ( this.game.Data.SFObj[sf].Rdn / 100.0));
          let mut num2: i32 =   Math.Round( (this.game.Data.SFTypeObj[type].RailCap * qty) * ( this.game.Data.SFObj[sf].Rdn / 100.0));
          if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpStrategic > 0)
          {
            num1 +=  Math.Round( num1 / 100.0 *  this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpStrategic);
            num2 +=  Math.Round( num2 / 100.0 *  this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpStrategic);
          }
          switch (theater)
          {
            case 0:
              this.game.Data.UnitObj[unr].LandCap += num1;
              this.game.Data.UnitObj[unr].AirCap += num2;
              break;
            case 1:
              this.game.Data.UnitObj[unr].NavyCap += num1;
              break;
          }
        }
      }
      this.game.Data.UnitObj[unr].LandStart = this.game.Data.UnitObj[unr].LandCap;
      this.game.Data.UnitObj[unr].NavyStart = this.game.Data.UnitObj[unr].NavyCap;
      this.game.Data.UnitObj[unr].AirStart = this.game.Data.UnitObj[unr].AirCap;
    }

    pub fn UnitSupplyNeed(unr: i32, bool deductcurrent, bool AlsoStockpile = true) -> i32
    {
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut num3: i32 =  0;
      if (this.game.Data.UnitObj[unr].X == -1 || this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType].IsSea && !this.game.Data.UnitObj[unr].IsHQ)
        return 0;
      if ( this.game.Data.RuleVar[471] > 0.0)
      {
        if (this.game.Data.UnitObj[unr].SFCount <= -1)
          return 0;
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
          let mut num4: i32 =  this.game.Data.SFTypeObj[type].SupplyMaxIn * qty;
          let mut num5: i32 =  this.game.Data.SFTypeObj[type].SupplyCarry * qty;
          let mut num6: i32 =  this.game.Data.SFTypeObj[type].BasicSupplyNeed * qty;
          num1 += num4;
          num2 += num5;
          num3 += num6;
        }
        let mut num7: i32 =  num2 + num3 - this.game.Data.UnitObj[unr].Supply;
        if (num7 > num1)
          num7 = num1;
        return num7;
      }
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        num8: i32;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
          let mut num9: i32 =  this.game.Data.SFTypeObj[type].SupplyCarry * qty;
          let mut num10: i32 =   Math.Round( this.game.Data.SFTypeObj[type].BasicSupplyNeed * 1.5 *  qty);
          num8 =  Math.Round( this.game.Data.SFTypeObj[type].BasicSupplyNeed / 2.0 *  qty);
          if (this.game.Data.SFTypeObj[type].Theater == 1)
            num10 = !(this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].Y > -1) ? 0 : (this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].Location <= -1 ? 0 : (!this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].Location].Type].IsPort ? 0 : this.game.Data.SFTypeObj[type].SupplyCarry * qty));
          num1 += num10;
          num2 += num9;
        }
        if (unr == 137)
          unr = unr;
        if (deductcurrent)
        {
          let mut num11: i32 =  num1 - this.UnitSupplyUse(unr) + this.game.Data.UnitObj[unr].Supply;
          if (num11 > num2)
            num1 -= num11 - num2;
        }
        if (0 > num1)
          num1 = 0;
        let mut num12: i32 =   this.game.Data.RuleVar[887] != 1.0 ? this.game.Data.UnitObj[unr].SOSupReqPercent : this.game.HandyFunctionsObj.GetAggregatedSupplyRequest(unr);
        num1 = num8 <= 0 ?  Math.Round(Conversion.Int( num1 * ( num12 / 100.0))) : (num8 >= num1 ? Conversion.Int(num1) :  Math.Round( (num8 + Conversion.Int(num1 - num8)) * ( num12 / 100.0)));
        if (unr == 815)
          unr = unr;
        if (Operators.ConditionalCompareObjectGreater( num1, this.game.HandyFunctionsObj.GetMaxSupplyRequest(unr), false))
          num1 = Conversions.ToInteger(this.game.HandyFunctionsObj.GetMaxSupplyRequest(unr));
        if (AlsoStockpile)
        {
          let mut num13: i32 =  num12 < 100 ? (num12 < 75 ? 0 : 50) : 100;
          if (num13 > 0)
          {
            let mut num14: i32 =   Math.Round(Conversion.Int( Conversions.ToInteger(this.game.HandyFunctionsObj.GetStockpileRequest(unr)) * ( num13 / 100.0)));
            num1 += num14;
          }
        }
      }
      return num1;
    }

    pub fn SFSupplyUse(sfnr: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut type: i32 =  this.game.Data.SFObj[sfnr].Type;
      let mut qty: i32 =  this.game.Data.SFObj[sfnr].Qty;
      let mut rdn: i32 =  this.game.Data.SFObj[sfnr].Rdn;
      num2: i32;
      if ( this.game.Data.RuleVar[434] > 0.0)
      {
        num2 = this.game.Data.SFTypeObj[type].BasicSupplyNeed * qty;
      }
      else
      {
        float num3 = 0.5f;
        if (rdn > 89 & rdn < 100)
          num3 +=  ( (100 - rdn) / 10.0 * 0.5);
        else if (rdn < 90)
          num3 += 0.5f;
        if (rdn < 90)
        {
          let mut num4: i32 =  90 - rdn;
          if ( num4 >  this.game.Data.RuleVar[59] - 10.0)
            num4 =  Math.Round( (this.game.Data.RuleVar[59] - 10f));
          num3 +=  ( num4 / 90.0 * 1.0);
        }
        let mut num5: i32 =   Math.Round( ( (this.game.Data.SFTypeObj[type].BasicSupplyNeed * qty) * num3));
        if (this.game.Data.SFTypeObj[type].BasicSupplyNeed > 0 & num5 == 0)
          num5 = 1;
        num2 = num1 + num5;
      }
      return num2;
    }

    pub fn GetAggregatedSupplyRequest(unr: i32, let mut overruleReqPercent: i32 =  -1) -> i32
    {
      let mut aggregatedSupplyRequest: i32 =  this.game.Data.UnitObj[unr].SOSupReqPercent;
      if (overruleReqPercent > -1)
        aggregatedSupplyRequest = overruleReqPercent;
      while (this.game.Data.UnitObj[unr].HQ > -1)
      {
        unr = this.game.Data.UnitObj[unr].HQ;
        num: i32;
        num += 1;
        aggregatedSupplyRequest =  Math.Round( aggregatedSupplyRequest * ( this.game.Data.UnitObj[unr].SOSupReqPercent / 100.0));
        if (num > 99)
          break;
      }
      return aggregatedSupplyRequest;
    }

    pub fn GetAggregatedReplacementRequest(unr: i32, let mut overruleReqPercent: i32 =  -1) -> i32
    {
      let mut replacementRequest: i32 =  this.game.Data.UnitObj[unr].SOReplacementPercent;
      if (overruleReqPercent > -1)
        replacementRequest = overruleReqPercent;
      while (this.game.Data.UnitObj[unr].HQ > -1)
      {
        unr = this.game.Data.UnitObj[unr].HQ;
        replacementRequest = this.game.Data.UnitObj[unr].SOReplacementPercent != 999 ?  Math.Round( replacementRequest * ( this.game.Data.UnitObj[unr].SOReplacementPercent / 100.0)) : 999;
        if (replacementRequest < 999 & replacementRequest > 100)
          replacementRequest = 100;
        num: i32;
        num += 1;
        if (num > 99)
          break;
      }
      return replacementRequest;
    }

    pub fn UnitSupplyUse(unr: i32, bool includepas = false, let mut onlytheater: i32 =  -1) -> i32
    {
      let mut num1: i32 =  0;
      if ( this.game.Data.RuleVar[814] == 1.0)
        return 0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
          let mut rdn: i32 =  this.game.Data.SFObj[sf].Rdn;
          if ( this.game.Data.RuleVar[434] > 0.0)
          {
            let mut num2: i32 =  this.game.Data.SFTypeObj[type].BasicSupplyNeed * qty;
            num1 += num2;
          }
          else
          {
            float num3 = 0.5f;
            if (onlytheater == -1 | onlytheater == this.game.Data.SFTypeObj[type].Theater)
            {
              if (rdn > 89 & rdn < 100)
                num3 +=  ( (100 - rdn) / 10.0 * 0.5);
              else if (rdn < 90)
                num3 += 0.5f;
              if (rdn < 90)
              {
                let mut num4: i32 =  90 - rdn;
                if ( num4 >  this.game.Data.RuleVar[59] - 10.0)
                  num4 =  Math.Round( (this.game.Data.RuleVar[59] - 10f));
                num3 +=  ( num4 / 90.0 * 1.0);
              }
              let mut num5: i32 =   Math.Round( ( (this.game.Data.SFTypeObj[type].BasicSupplyNeed * qty) * num3));
              num1 += num5;
            }
          }
        }
      }
      if (includepas && this.game.Data.UnitObj[unr].PassengerCounter > -1)
      {
        let mut passengerCounter: i32 =  this.game.Data.UnitObj[unr].PassengerCounter;
        for (let mut index: i32 =  0; index <= passengerCounter; index += 1)
        {
          let mut passenger: i32 =  this.game.Data.UnitObj[unr].PassengerList[index];
          num1 += this.UnitSupplyUse(passenger);
        }
      }
      return num1;
    }

    pub fn UnitMaximumFuelReserve(unr: i32) -> i32
    {
      let mut num1: i32 =  0;
      if ( this.game.Data.RuleVar[435] < 1.0)
        return 0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
          if (this.game.Data.SFTypeObj[type].FuelCarry > 0 && this.game.Data.SFTypeObj[type].FuelRegimeVar > -1)
          {
            let mut num2: i32 =  this.game.Data.SFTypeObj[type].FuelCarry * qty;
            num1 += num2;
          }
        }
      }
      return num1;
    }

    pub fn UnitSupplyStore(unr: i32, let mut theater: i32 =  -1) -> i32
    {
      let mut num: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (theater == -1 | theater == this.game.Data.SFTypeObj[type].Theater)
          {
            let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
            num += this.game.Data.SFTypeObj[type].SupplyCarry * qty;
          }
        }
      }
      return num;
    }

    pub object RandomizeForUnit(unr: i32, i: i32)
    {
      double num =  VBMath.Rnd(-1f);
      VBMath.Randomize( (this.game.Data.UnitObj[unr].Historical + this.game.Data.UnitObj[unr].X + this.game.Data.UnitObj[unr].Y + this.game.Data.Round + i + 10));
      object obj;
      return obj;
    }

    pub Coordinate GetReconMinusHide(unr: i32, player: i32, bool withoutIdentify = false)
    {
      if (this.game.Data.UnitObj[unr].X > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.Data.UnitObj[unr].Map].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          if (this.game.Data.UnitObj[this.game.Data.MapObj[this.game.Data.UnitObj[unr].Map].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].UnitList[index]].Regime == player)
          {
            Coordinate reconMinusHide;
            reconMinusHide.x = 3;
            return reconMinusHide;
          }
        }
      }
      if (this.game.Data.UnitObj[unr].Regime > -1 && this.game.Data.RegimeObj[player].RegimeRel[this.game.Data.UnitObj[unr].Regime] == 2)
      {
        Coordinate reconMinusHide;
        reconMinusHide.x = 3;
        return reconMinusHide;
      }
      if (this.game.Data.UnitObj[unr].X == -1 | this.game.Data.UnitObj[unr].OnBoard > -1)
      {
        Coordinate reconMinusHide;
        reconMinusHide.x = 1;
        reconMinusHide.y = -1;
        if (this.game.Data.UnitObj[unr].Regime == player)
          reconMinusHide.x = 3;
        if (!this.game.Data.FOWOn)
          reconMinusHide.x = 3;
        return reconMinusHide;
      }
      let mut rawRecon: i32 =  this.game.Data.Turn != player ? this.game.Data.MapObj[this.game.Data.UnitObj[unr].Map].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].get_ReconPts(player) : this.game.Data.MapObj[this.game.Data.UnitObj[unr].Map].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].MaxRecon;
      if ( this.game.Data.RuleVar[419] > 0.0)
        rawRecon = this.GetEffectiveRecon(rawRecon);
      let mut num1: i32 =  rawRecon;
      let mut unitHide: i32 =  this.GetUnitHide(unr, withoutIdentify);
      let mut num2: i32 =  num1 - unitHide;
      if ( this.game.Data.RuleVar[419] > 0.0 & !withoutIdentify && this.game.Data.UnitObj[unr].Spotted & !this.game.Data.UnitObj[unr].Identified &&  (num1 - unitHide * 2) <  this.game.Data.RuleVar[55])
        num2 =  Math.Round( (this.game.Data.RuleVar[55] - 1f));
      Coordinate reconMinusHide1;
      reconMinusHide1.x = num2 >= 1 ? ( num2 >=  this.game.Data.RuleVar[55] ? ( num2 >=  this.game.Data.RuleVar[56] ? 3 : 2) : 1) : 0;
      if ( this.game.Data.RuleVar[419] > 0.0 && !withoutIdentify)
      {
        if (reconMinusHide1.x < 1 & this.game.Data.UnitObj[unr].Spotted)
          reconMinusHide1.x = 1;
        if (reconMinusHide1.x < 2 & this.game.Data.UnitObj[unr].Identified)
          reconMinusHide1.x = 2;
      }
      if (!this.game.Data.FOWOn)
        reconMinusHide1.x = 3;
      if (this.game.Data.UnitObj[unr].Regime == player)
        reconMinusHide1.x = 3;
      if (num2 < 0)
        num2 = 0;
      reconMinusHide1.y = num2;
      return reconMinusHide1;
    }

    pub fn GetStackWithFOW(unr: i32, player: i32, bool FullRecon = false) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      stackWithFow: i32;
      for (let mut i: i32 =  0; i <= sfCount; i += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[i];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut frontage: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Frontage;
        let mut Number: i32 =  this.game.Data.SFObj[sf].Qty * frontage;
        let mut regime: i32 =  this.game.Data.UnitObj[unr].Regime;
        if (this.game.Data.SFTypeObj[type].Theater == 0)
        {
          if (!FullRecon && this.game.Data.FOWOn & this.game.Data.UnitObj[unr].Regime != player & this.game.Data.Round != 0)
          {
            this.RandomizeForUnit(unr, i);
            Coordinate reconMinusHide = this.GetReconMinusHide(unr, player);
            if (reconMinusHide.x == 1)
              Number = 0;
            if (reconMinusHide.x == 2)
            {
              float num1 =  reconMinusHide.y / (this.game.Data.RuleVar[56] - this.game.Data.RuleVar[55]);
              float num2 =  ((1.0 -  num1) * 2.0);
              Number =  Math.Round( ((VBMath.Rnd() * num2 + num1) *  Number));
            }
            VBMath.Randomize();
          }
          stackWithFow += Conversion.Int(Number);
        }
      }
      return stackWithFow;
    }

    pub GetPower: i32(
      unr: i32,
      player: i32,
      bool ishis = false,
      bool withoutrdnmod = false,
      bool withoutfullaiprog = true,
      let mut randomelement: i32 =  -1,
      bool FullRecon = false,
      bool AbsPower = false)
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      power: i32;
      for (let mut i: i32 =  0; i <= sfCount; i += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[i];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut powerPts: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
        let mut Number: i32 =  this.game.Data.SFObj[sf].Qty * powerPts;
        let mut regime: i32 =  this.game.Data.UnitObj[unr].Regime;
        if (!AbsPower)
        {
          let mut num: i32 =   Math.Round( ( Number * this.game.Data.PeopleObj[this.game.Data.SFObj[sf].People].BattleForMod[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regime].People].PeopleGroup]));
          if (!withoutrdnmod)
            num =  Math.Round( num * ( this.game.Data.SFObj[sf].Rdn / 100.0));
          if (!withoutfullaiprog)
            num =  Math.Round( (  Math.Round( num * (1.0 +  this.game.Data.SFObj[sf].CurrentEntrench / 100.0)) * this.game.Data.SFTypeObj[type].CombatModDef[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType]));
          Number =  Math.Round( num +  (1 * num) * ( this.game.Data.SFObj[sf].Xp / 100.0));
        }
        if (!FullRecon && this.game.Data.FOWOn & (this.game.Data.UnitObj[unr].Regime != player | ishis) & this.game.Data.Round != 0)
        {
          this.RandomizeForUnit(unr, i);
          Coordinate reconMinusHide = this.GetReconMinusHide(unr, player);
          if (reconMinusHide.x == 1)
            Number = -1;
          if (reconMinusHide.x == 2)
          {
            float num1 =  reconMinusHide.y / (this.game.Data.RuleVar[56] - this.game.Data.RuleVar[55]);
            float num2 =  ((1.0 -  num1) * 2.0);
            Number =  Math.Round( ((VBMath.Rnd() * num2 + num1) *  Number));
          }
          VBMath.Randomize();
        }
        power += Conversion.Int(Number);
      }
      return power;
    }

    pub fn GetAverageAirRdn(unr: i32, bool onlyfrontline = false) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2 && !onlyfrontline | !this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].BackBench)
        {
          num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFObj[sf].Rdn;
          num2 += this.game.Data.SFObj[sf].Qty;
        }
      }
      return num1 == 0 | num2 == 0 ? 0 :  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageAirRange(sftyp: i32, unr: i32) -> i32
    {
      let mut moveType: i32 =  this.game.Data.SFTypeObj[sftyp].MoveType;
      let mut num: i32 =   Math.Round(Conversion.Int( this.game.Data.LandscapeTypeObj[0].MoveCost[moveType] * ( this.game.Data.MoveTypePenalty[moveType] / 100.0)));
      if (this.game.Data.SFTypeObj[sftyp].MoveRedux != 0)
        num =  Math.Round(Conversion.Int( num * ( (100 - this.game.Data.SFTypeObj[sftyp].MoveRedux) / 100.0)));
      if (unr > -1 && this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
        num =  Math.Round(Conversion.Int( num * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
      return  Math.Round(Conversion.Int(100.0 /  num));
    }

    pub fn SetHexReconAndZOCAround(x: i32, y: i32, map: i32, regnr: i32)
    {
      let mut num1: i32 =  x - 5;
      let mut num2: i32 =  x + 5;
      for (let mut index: i32 =  num1; index <= num2; index += 1)
      {
        let mut x1: i32 =  index;
        if (this.game.Data.MapObj[map].MapLoop & x1 < 0)
          x1 = this.game.Data.MapObj[map].MapWidth + x1 + 1;
        if (this.game.Data.MapObj[map].MapLoop & x1 > this.game.Data.MapObj[map].MapWidth)
          x1 = x1 - this.game.Data.MapObj[map].MapWidth - 1;
        if (x1 >= 0 & x1 <= this.game.Data.MapObj[map].MapWidth)
        {
          let mut num3: i32 =  y - 5;
          let mut num4: i32 =  y + 5;
          for (let mut y1: i32 =  num3; y1 <= num4; y1 += 1)
          {
            if (y1 >= 0 & y1 <= this.game.Data.MapObj[map].MapHeight)
            {
              this.SetHexReconAndZOC(x1, y1, map, regnr);
              this.game.HandyFunctionsObj.DoZOCConquest(x1, y1, map, regnr);
            }
          }
        }
      }
    }

    pub fn CalculateSFDesignCosts()
    {
      let mut sfTypeCounter1: i32 =  this.game.Data.SFTypeCounter;
      for (let mut tv9: i32 =  0; tv9 <= sfTypeCounter1; tv9 += 1)
      {
        this.game.Data.SFTypeObj[tv9].TempUpgradeCost = -1;
        this.game.Data.SFTypeObj[tv9].TempImproveCost = -1;
        this.game.Data.SFTypeObj[tv9].TempNewCost = -1;
        this.game.Data.SFTypeObj[tv9].TempFieldCount = 0;
        this.game.Data.SFTypeObj[tv9].TempNewLevels = 0;
        this.game.Data.SFTypeObj[tv9].TempUpgradeLevels = 0;
        this.game.Data.SFTypeObj[tv9].TempImprovementFields = 0;
        this.game.Data.SFTypeObj[tv9].TempAlterationCost = -1;
        this.game.Data.SFTypeObj[tv9].TempAlterationCount = 0;
        let mut num1: i32 =  0;
        if (this.game.Data.SFTypeObj[tv9].ModelID > 0)
        {
          let mut sfTypeCounter2: i32 =  this.game.Data.SFTypeCounter;
          for (let mut index1: i32 =  0; index1 <= sfTypeCounter2; index1 += 1)
          {
            if (this.game.Data.SFTypeObj[tv9].ModelID == this.game.Data.SFTypeObj[index1].ModelID)
            {
              if (this.game.Data.SFTypeObj[index1].ModelItemType > -1)
              {
                let mut round: i32 =  this.game.Data.Round;
                for (let mut index2: i32 =  1; index2 <= round; index2 += 1)
                {
                  if (this.game.Data.RegimeObj[this.game.Data.Turn].SProd[this.game.Data.SFTypeObj[index1].ModelItemType, index2] > 0)
                    num1 += 1;
                }
              }
              let mut unitCounter: i32 =  this.game.Data.UnitCounter;
              for (let mut index3: i32 =  0; index3 <= unitCounter; index3 += 1)
              {
                if (this.game.Data.UnitObj[index3].PreDef == -1 & this.game.Data.UnitObj[index3].Regime == this.game.Data.Turn)
                {
                  let mut sfCount: i32 =  this.game.Data.UnitObj[index3].SFCount;
                  for (let mut index4: i32 =  0; index4 <= sfCount; index4 += 1)
                  {
                    if (this.game.Data.SFObj[this.game.Data.UnitObj[index3].SFList[index4]].Type == index1)
                      num1 += 1;
                  }
                }
              }
            }
          }
          this.game.Data.SFTypeObj[tv9].TempFieldCount = num1;
        }
        if (this.game.Data.SFTypeObj[tv9].ModelIsBase)
        {
          if (this.game.Data.SFTypeObj[tv9].ModelRegime == -1 | this.game.Data.SFTypeObj[tv9].ModelRegime == this.game.Data.Turn)
          {
            let mut num2: i32 =  this.game.Data.SFTypeObj[tv9].ModelCost;
            let mut num3: i32 =  0;
            let mut sfTypeCounter3: i32 =  this.game.Data.SFTypeCounter;
            for (let mut index: i32 =  0; index <= sfTypeCounter3; index += 1)
            {
              if (this.game.Data.SFTypeObj[index].ModelRegime == this.game.Data.Turn && this.game.Data.SFTypeObj[index].ModelMark == 1 & this.game.Data.SFTypeObj[index].ModelVersion == 1 && this.game.Data.SFTypeObj[index].ModelID > 0 && this.game.Data.SFTypeObj[index].ModelBaseModel == tv9)
                num3 += 1;
            }
            let mut num4: i32 =  num3;
            for (let mut index: i32 =  1; index <= num4; index += 1)
              num2 =  Math.Round( ( num2 * this.game.Data.SFTypeObj[tv9].ModelCostPerSameModel));
            let mut num5: i32 =  0;
            let mut index5: i32 =  1;
            do
            {
              let mut index6: i32 =  this.game.Data.SFTypeObj[tv9].ModelResearch[index5];
              if (index6 != -1 && this.game.Data.RegimeObj[this.game.Data.Turn].ResField[index6])
              {
                num5 += 1;
                index5 += 1;
              }
              else
                break;
            }
            while (index5 <= 9);
            let mut num6: i32 =  num5;
            for (let mut index7: i32 =  1; index7 <= num6; index7 += 1)
              num2 =  Math.Round( ( num2 * this.game.Data.SFTypeObj[tv9].ModelCostPerLevel));
            this.game.Data.SFTypeObj[tv9].TempNewLevels = num5;
            if (this.game.Data.SFTypeObj[tv9].ModelResearch[0] > -1 && !this.game.Data.RegimeObj[this.game.Data.Turn].ResField[this.game.Data.SFTypeObj[tv9].ModelResearch[0]])
              num2 = -1;
            if (this.game.Data.SFTypeObj[tv9].ModelExtraResearch > -1 && !this.game.Data.RegimeObj[this.game.Data.Turn].ResField[this.game.Data.SFTypeObj[tv9].ModelExtraResearch])
              num2 = -1;
            this.game.Data.SFTypeObj[tv9].TempNewCost = num2;
          }
        }
        else if (!this.game.Data.SFTypeObj[tv9].ModelIsBase & this.game.Data.SFTypeObj[tv9].ModelRegime == this.game.Data.Turn && this.game.Data.SFTypeObj[tv9].ModelID > 0)
        {
          let mut num7: i32 =  this.game.Data.SFTypeObj[tv9].ModelCost;
          let mut num8: i32 =  0;
          let mut index8: i32 =  1;
          do
          {
            let mut index9: i32 =  this.game.Data.SFTypeObj[tv9].ModelResearch[index8];
            if (index9 != -1 && this.game.Data.RegimeObj[this.game.Data.Turn].ResField[index9])
            {
              num8 += 1;
              index8 += 1;
            }
            else
              break;
          }
          while (index8 <= 9);
          let mut num9: i32 =  num8;
          for (let mut index10: i32 =  1; index10 <= num9; index10 += 1)
            num7 =  Math.Round( ( num7 * this.game.Data.SFTypeObj[tv9].ModelCostPerLevel));
          this.game.Data.SFTypeObj[tv9].TempUpgradeLevels = num8 - this.game.Data.SFTypeObj[tv9].ModelLevel;
          if (this.game.Data.SFTypeObj[tv9].TempUpgradeLevels < 1)
            num7 = -1;
          if (!this.game.Data.SFTypeObj[tv9].ModelAllowUpgrade)
            num7 = -1;
          let mut sfTypeCounter4: i32 =  this.game.Data.SFTypeCounter;
          for (let mut index11: i32 =  0; index11 <= sfTypeCounter4; index11 += 1)
          {
            if (tv9 != index11 & this.game.Data.SFTypeObj[tv9].ModelID == this.game.Data.SFTypeObj[index11].ModelID && this.game.Data.SFTypeObj[index11].ModelMark > this.game.Data.SFTypeObj[tv9].ModelMark)
              num7 = -1;
          }
          if (this.game.Data.SFTypeObj[tv9].ModelResearch[0] > -1 && !this.game.Data.RegimeObj[this.game.Data.Turn].ResField[this.game.Data.SFTypeObj[tv9].ModelResearch[0]])
            num7 = -1;
          if (this.game.Data.SFTypeObj[tv9].ModelExtraResearch > -1 && !this.game.Data.RegimeObj[this.game.Data.Turn].ResField[this.game.Data.SFTypeObj[tv9].ModelExtraResearch])
            num7 = -1;
          this.game.Data.SFTypeObj[tv9].TempUpgradeCost = num7;
        }
        if (!this.game.Data.SFTypeObj[tv9].ModelIsBase & this.game.Data.SFTypeObj[tv9].ModelAllowImprovements && this.game.Data.SFTypeObj[tv9].ModelID > 0)
        {
          let mut num10: i32 =  this.game.Data.SFTypeObj[tv9].ModelCost;
          let mut num11: i32 =  0;
          let mut sfTypeCounter5: i32 =  this.game.Data.SFTypeCounter;
          for (let mut index: i32 =  0; index <= sfTypeCounter5; index += 1)
          {
            if (this.game.Data.SFTypeObj[index].ModelRegime == this.game.Data.Turn && this.game.Data.SFTypeObj[index].ModelBaseModel == this.game.Data.SFTypeObj[tv9].ModelBaseModel && this.game.Data.SFTypeObj[index].ModelMark == this.game.Data.SFTypeObj[tv9].ModelMark & tv9 != index && this.game.Data.SFTypeObj[tv9].ModelID == this.game.Data.SFTypeObj[index].ModelID)
              num11 += 1;
          }
          let mut num12: i32 =  num11;
          for (let mut index: i32 =  1; index <= num12; index += 1)
            num10 =  Math.Round( ( num10 * this.game.Data.SFTypeObj[tv9].ModelCostPerSameModel));
          let mut num13: i32 =  0;
          if (this.game.Data.SFTypeObj[tv9].ModelAllowImprovements)
          {
            let mut researchCounter: i32 =  this.game.Data.ResearchCounter;
            for (let mut index: i32 =  0; index <= researchCounter; index += 1)
            {
              if (this.game.Data.SFTypeObj[tv9].ModelLastState[index] == 0 & this.game.Data.SFTypeObj[tv9].ModelImproveEvent[index] > 0 && this.game.Data.RegimeObj[this.game.Data.Turn].ResField[index])
                num13 += 1;
            }
          }
          this.game.Data.SFTypeObj[tv9].TempImprovementFields = num13;
          num14: i32;
          if (num13 > 0)
          {
            num14 =  Math.Round( ( num10 * this.game.Data.SFTypeObj[tv9].ModelImproveCostMod));
            let mut sfTypeCounter6: i32 =  this.game.Data.SFTypeCounter;
            for (let mut index: i32 =  0; index <= sfTypeCounter6; index += 1)
            {
              if (tv9 != index & this.game.Data.SFTypeObj[tv9].ModelID == this.game.Data.SFTypeObj[index].ModelID && this.game.Data.SFTypeObj[index].ModelMark == this.game.Data.SFTypeObj[tv9].ModelMark && this.game.Data.SFTypeObj[index].ModelVersion > this.game.Data.SFTypeObj[tv9].ModelVersion)
                num14 = -1;
            }
          }
          else
            num14 = -1;
          this.game.Data.SFTypeObj[tv9].TempImproveCost = num14;
        }
        if (this.game.Data.SFTypeObj[tv9].ModelVariantCounter > -1)
        {
          this.game.Data.SFTypeObj[tv9].TempAlterationPossible = new bool[this.game.Data.SFTypeObj[tv9].ModelVariantCounter + 1];
          let mut modelVariantCounter: i32 =  this.game.Data.SFTypeObj[tv9].ModelVariantCounter;
          for (let mut index12: i32 =  0; index12 <= modelVariantCounter; index12 += 1)
          {
            if (this.game.Data.SFTypeObj[tv9].ModelVariantCheck[index12] > 0 && this.game.Data.SFTypeObj[tv9].ModelRegime == this.game.Data.Turn)
            {
              this.game.EditObj.AreaX = -1;
              this.game.EventRelatedObj.DoCheckSpecificEvent(this.game.Data.SFTypeObj[tv9].ModelVariantCheck[index12], tv9: tv9);
              if (this.game.EditObj.AreaX == 1)
              {
                this.game.Data.SFTypeObj[tv9].TempAlterationCost = 1;
                SFTypeClass[] sfTypeObj = this.game.Data.SFTypeObj;
                SFTypeClass[] sfTypeClassArray = sfTypeObj;
                let mut index13: i32 =  tv9;
                let mut index14: i32 =  index13;
                sfTypeClassArray[index14].TempAlterationCount = sfTypeObj[index13].TempAlterationCount + 1;
                this.game.Data.SFTypeObj[tv9].TempAlterationPossible[index12] = true;
              }
            }
          }
        }
      }
    }

    pub object GetAlphabetLetter(nr: i32)
    {
      switch (nr)
      {
        case 1:
          return  "a";
        case 2:
          return  "b";
        case 3:
          return  "c";
        case 4:
          return  "d";
        case 5:
          return  "e";
        case 6:
          return  "f";
        case 7:
          return  "g";
        case 8:
          return  "h";
        case 9:
          return  "i";
        case 10:
          return  "j";
        case 11:
          return  "k";
        case 12:
          return  "l";
        case 13:
          return  "m";
        case 14:
          return  "n";
        case 15:
          return  "o";
        case 16:
          return  "p";
        default:
          object obj;
          return nr > 16 ?  ("p" + Strings.Trim(Conversion.Str( (nr - 16)))) : obj;
      }
    }

    pub fn SetOnlyReconAround(x: i32, y: i32, map: i32, regnr: i32, unr: i32)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[map].MapWidth + 1, this.game.Data.MapObj[map].MapHeight + 1];
      MapMatrix mapMatrix1 = this.checklandconnect(x, y, map, 4, true);
      MapMatrix mapMatrix2 = this.checkseaconnect(x, y, map, 4, true);
      let mut num1: i32 =  x - 5;
      let mut num2: i32 =  x + 5;
      for (let mut index1: i32 =  num1; index1 <= num2; index1 += 1)
      {
        let mut x2: i32 =  index1;
        if (this.game.Data.MapObj[map].MapLoop & x2 < 0)
          x2 = this.game.Data.MapObj[map].MapWidth + x2 + 1;
        if (this.game.Data.MapObj[map].MapLoop & x2 > this.game.Data.MapObj[map].MapWidth)
          x2 = x2 - this.game.Data.MapObj[map].MapWidth - 1;
        if (x2 >= 0 & x2 <= this.game.Data.MapObj[map].MapWidth)
        {
          let mut num3: i32 =  y - 5;
          let mut num4: i32 =  y + 5;
          for (let mut y2: i32 =  num3; y2 <= num4; y2 += 1)
          {
            if (y2 >= 0 & y2 <= this.game.Data.MapObj[map].MapHeight)
            {
              let mut num5: i32 =  0;
              let mut num6: i32 =  this.Distance(x, y, map, x2, y2, map);
              if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
              {
                if (mapMatrix2.TempValue[x2, y2] > 0 & mapMatrix2.TempValue[x2, y2] <= 4)
                  num5 =  Math.Round( ( this.GetUnitRecon(unr, 1) * this.game.Data.RuleVar[10 + mapMatrix2.TempValue[x2, y2]]));
                else if (mapMatrix2.TempValue[x2, y2] == 0)
                  num5 =  Math.Round( ( this.GetUnitRecon(unr, 1) * this.game.Data.RuleVar[11]));
              }
              else if (mapMatrix1.TempValue[x2, y2] > 0 & mapMatrix1.TempValue[x2, y2] <= 4)
                num5 =  Math.Round( ( this.GetUnitRecon(unr, 0) * this.game.Data.RuleVar[10 + mapMatrix1.TempValue[x2, y2]]));
              else if (mapMatrix1.TempValue[x2, y2] == 0)
                num5 =  Math.Round( ( this.GetUnitRecon(unr, 0) * this.game.Data.RuleVar[11]));
              if (num6 <= 1 & this.game.Data.MapObj[map].HexObj[x, y].Regime == regnr &&  this.game.Data.MapObj[map].HexObj[x2, y2].get_ReconPts(regnr) <  this.game.Data.RuleVar[8])
                this.game.Data.MapObj[map].HexObj[x2, y2].set_ReconPts(regnr,  Math.Round( (this.game.Data.RuleVar[8] -  this.game.Data.MapObj[0].HexObj[x2, y2].get_ReconPts(regnr))));
              if (num5 > 0)
              {
                HexClass[,] hexObj = this.game.Data.MapObj[map].HexObj;
                HexClass[,] hexClassArray = hexObj;
                let mut index2: i32 =  x2;
                let mut index3: i32 =  index2;
                let mut index4: i32 =  y2;
                let mut index5: i32 =  index4;
                HexClass hexClass = hexClassArray[index3, index5];
                let mut Index1: i32 =  regnr;
                let mut Index2: i32 =  Index1;
                let mut num7: i32 =  hexObj[index2, index4].get_ReconPts(Index1) + num5;
                hexClass.set_ReconPts(Index2, num7);
              }
              if (regnr == this.game.Data.Turn && this.game.Data.MapObj[map].HexObj[x2, y2].get_ReconPts(regnr) > this.game.Data.MapObj[map].HexObj[x2, y2].MaxRecon)
              {
                this.game.Data.MapObj[map].HexObj[x2, y2].MaxRecon = this.game.Data.MapObj[map].HexObj[x2, y2].get_ReconPts(regnr);
                let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
                for (let mut index6: i32 =  0; index6 <= regimeCounter; index6 += 1)
                {
                  if (index6 != regnr && this.game.HandyFunctionsObj.IsAlliedOrSelf(index6, this.game.Data.Turn, true) && this.game.Data.MapObj[map].HexObj[x2, y2].MaxRecon > this.game.Data.MapObj[map].HexObj[x2, y2].get_ReconPts(index6))
                    this.game.Data.MapObj[map].HexObj[x2, y2].set_ReconPts(index6, this.game.Data.MapObj[map].HexObj[x2, y2].MaxRecon);
                }
              }
              if (this.game.Data.MapObj[map].HexObj[x2, y2].get_ReconPts(regnr) >= 1 | !this.game.Data.ShrowdOn)
              {
                if (this.game.Data.MapObj[map].HexObj[x2, y2].get_ReconPts(regnr) >= 1)
                  this.game.Data.MapObj[map].HexObj[x2, y2].set_SeeNow(regnr, 1);
                this.game.Data.MapObj[map].HexObj[x2, y2].set_LastLT(regnr, this.game.Data.MapObj[map].HexObj[x2, y2].LandscapeType);
                this.game.Data.MapObj[map].HexObj[x2, y2].set_LastSpr(regnr, this.game.Data.MapObj[map].HexObj[x2, y2].SpriteNr);
                this.game.Data.MapObj[map].HexObj[x2, y2].set_LastReg(regnr, this.game.Data.MapObj[map].HexObj[x2, y2].Regime);
              }
            }
          }
        }
      }
    }

    pub fn SetOnlyZOCAround(x: i32, y: i32, map: i32, regnr: i32, unr: i32)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[map].MapWidth + 1, this.game.Data.MapObj[map].MapHeight + 1];
      MapMatrix mapMatrix = this.checklandconnect(x, y, map, 4, true);
      this.checkseaconnect(x, y, map, 4, true);
      let mut num1: i32 =  x - 5;
      let mut num2: i32 =  x + 5;
      for (let mut index1: i32 =  num1; index1 <= num2; index1 += 1)
      {
        let mut x2: i32 =  index1;
        if (this.game.Data.MapObj[map].MapLoop & x2 < 0)
          x2 = this.game.Data.MapObj[map].MapWidth + x2 + 1;
        if (this.game.Data.MapObj[map].MapLoop & x2 > this.game.Data.MapObj[map].MapWidth)
          x2 = x2 - this.game.Data.MapObj[map].MapWidth - 1;
        if (x2 >= 0 & x2 <= this.game.Data.MapObj[map].MapWidth)
        {
          let mut num3: i32 =  y - 5;
          let mut num4: i32 =  y + 5;
          for (let mut y2: i32 =  num3; y2 <= num4; y2 += 1)
          {
            if (y2 >= 0 & y2 <= this.game.Data.MapObj[map].MapHeight)
            {
              let mut num5: i32 =  0;
              this.Distance(x, y, map, x2, y2, map);
              if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
              {
                if (mapMatrix.TempValue[x2, y2] > 0 & mapMatrix.TempValue[x2, y2] <= 4)
                  num5 =  Math.Round( ( num5 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[20 + mapMatrix.TempValue[x2, y2]]));
                if (mapMatrix.TempValue[x2, y2] == 0)
                  num5 =  Math.Round( ( num5 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[21]));
              }
              HexClass[,] hexObj = this.game.Data.MapObj[map].HexObj;
              HexClass[,] hexClassArray = hexObj;
              let mut index2: i32 =  x2;
              let mut index3: i32 =  index2;
              let mut index4: i32 =  y2;
              let mut index5: i32 =  index4;
              HexClass hexClass = hexClassArray[index3, index5];
              let mut Index1: i32 =  regnr;
              let mut Index2: i32 =  Index1;
              let mut num6: i32 =  hexObj[index2, index4].get_ZocPts(Index1) + num5;
              hexClass.set_ZocPts(Index2, num6);
            }
          }
        }
      }
    }

    pub MapMatrix checklandconnect(
      x1: i32,
      y1: i32,
      map: i32,
      maxdist: i32,
      bool plusone)
    {
      MapMatrix mapMatrix = new MapMatrix(this.game.Data.MapObj[map].MapWidth, this.game.Data.MapObj[map].MapHeight);
      mapMatrix.TempValue[x1, y1] = 0;
      let mut num1: i32 =  maxdist - 1;
      Coordinate coordinate;
      for (let mut index1: i32 =  0; index1 <= num1; index1 += 1)
      {
        let mut num2: i32 =  x1 - (maxdist + 1);
        let mut num3: i32 =  x1 + (maxdist + 1);
        for (let mut index2: i32 =  num2; index2 <= num3; index2 += 1)
        {
          let mut cx: i32 =  index2;
          if (this.game.Data.MapObj[map].MapLoop & cx < 0)
            cx = this.game.Data.MapObj[map].MapWidth + cx + 1;
          if (this.game.Data.MapObj[map].MapLoop & cx > this.game.Data.MapObj[map].MapWidth)
            cx = cx - this.game.Data.MapObj[map].MapWidth - 1;
          if (cx >= 0 & cx <= this.game.Data.MapObj[map].MapWidth)
          {
            let mut num4: i32 =  y1 - (maxdist + 1);
            let mut num5: i32 =  y1 + (maxdist + 1);
            for (let mut cy: i32 =  num4; cy <= num5; cy += 1)
            {
              if (cy >= 0 & cy <= this.game.Data.MapObj[map].MapHeight && mapMatrix.TempValue[cx, cy] == index1)
              {
                let mut tfacing: i32 =  1;
                do
                {
                  coordinate = this.HexNeighbour(cx, cy, map, tfacing);
                  if (coordinate.onmap && mapMatrix.TempValue[coordinate.x, coordinate.y] == -1 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                    mapMatrix.TempValue[coordinate.x, coordinate.y] = index1 + 1;
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      if (plusone)
      {
        let mut num6: i32 =  x1 - (maxdist + 1);
        let mut num7: i32 =  x1 + (maxdist + 2);
        for (let mut index: i32 =  num6; index <= num7; index += 1)
        {
          let mut cx: i32 =  index;
          if (this.game.Data.MapObj[map].MapLoop & cx < 0)
            cx = this.game.Data.MapObj[map].MapWidth + cx + 1;
          if (this.game.Data.MapObj[map].MapLoop & cx > this.game.Data.MapObj[map].MapWidth)
            cx = cx - this.game.Data.MapObj[map].MapWidth - 1;
          if (cx >= 0 & cx <= this.game.Data.MapObj[map].MapWidth)
          {
            let mut num8: i32 =  y1 - (maxdist + 1);
            let mut num9: i32 =  y1 + (maxdist + 1);
            for (let mut cy: i32 =  num8; cy <= num9; cy += 1)
            {
              if (cy >= 0 & cy <= this.game.Data.MapObj[map].MapHeight && mapMatrix.TempValue[cx, cy] > -1 & mapMatrix.TempValue[cx, cy] < maxdist && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[cx, cy].LandscapeType].IsSea)
              {
                let mut tfacing: i32 =  1;
                do
                {
                  coordinate = this.HexNeighbour(cx, cy, map, tfacing);
                  if (coordinate.onmap && mapMatrix.TempValue[coordinate.x, coordinate.y] == -1 | mapMatrix.TempValue[coordinate.x, coordinate.y] > mapMatrix.TempValue[cx, cy] + 1 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                    mapMatrix.TempValue[coordinate.x, coordinate.y] = mapMatrix.TempValue[cx, cy] + 1;
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      return mapMatrix;
    }

    pub fn Uncertainty_RollLoadedDice(unr: i32) -> i32
    {
      let mut num1: i32 =  this.game.Data.UnitObj[unr].Historical <= -1 ? unr : this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].ID * 10 + this.game.Data.UnitObj[unr].HistoricalSubPart;
      Random random = new Random( Math.Round(Math.Floor( this.game.Data.GameID / 1000.0)) * num1);
      let mut num2: i32 =  random.Next(1, 7) + random.Next(1, 7);
      let mut num3: i32 =  DrawMod.RandyNumber.Next(1, 7);
      let mut averageXp: i32 =  this.game.HandyFunctionsObj.GetAverageXp(unr);
      DrawMod.RandyNumber.Next(0, averageXp + 1);
      if (averageXp < 10)
      {
        if (num2 == 2)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 6);
        if (num2 == 3)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 5);
        if (num2 == 4)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 4);
        if (num2 == 5)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 3);
        if (num2 == 11)
          num3 += DrawMod.RandyNumber.Next(1, 3) - 1;
        if (num2 == 12)
          num3 += DrawMod.RandyNumber.Next(1, 4) - 1;
      }
      else if (averageXp < 20)
      {
        if (num2 == 2)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 5);
        if (num2 == 3)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 4);
        if (num2 == 4)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 3);
        if (num2 == 10)
          num3 += DrawMod.RandyNumber.Next(1, 3) - 1;
        if (num2 == 11)
          num3 += DrawMod.RandyNumber.Next(1, 4) - 1;
        if (num2 == 12)
          num3 += DrawMod.RandyNumber.Next(1, 5) - 1;
      }
      else
      {
        if (num2 == 2)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 4);
        if (num2 == 3)
          num3 += 1 + DrawMod.RandyNumber.Next(1, 3);
        if (num2 == 9)
          num3 += DrawMod.RandyNumber.Next(1, 3) - 1;
        if (num2 == 10)
          num3 += DrawMod.RandyNumber.Next(1, 4) - 1;
        if (num2 == 11)
          num3 += DrawMod.RandyNumber.Next(1, 5) - 1;
        if (num2 == 12)
          num3 += DrawMod.RandyNumber.Next(1, 6) - 1;
      }
      if (1 > num3)
        num3 = 1;
      if (num3 > 6)
        num3 = 6;
      return num3;
    }

    pub MapMatrix checkseaconnect(x1: i32, y1: i32, map: i32, maxdist: i32, bool plusone)
    {
      MapMatrix mapMatrix = new MapMatrix(this.game.Data.MapObj[map].MapWidth, this.game.Data.MapObj[map].MapHeight);
      mapMatrix.TempValue[x1, y1] = 0;
      let mut num1: i32 =  maxdist - 1;
      Coordinate coordinate;
      for (let mut index1: i32 =  0; index1 <= num1; index1 += 1)
      {
        let mut num2: i32 =  x1 - (maxdist + 1);
        let mut num3: i32 =  x1 + (maxdist + 1);
        for (let mut index2: i32 =  num2; index2 <= num3; index2 += 1)
        {
          let mut cx: i32 =  index2;
          if (this.game.Data.MapObj[map].MapLoop & cx < 0)
            cx = this.game.Data.MapObj[map].MapWidth + cx + 1;
          if (this.game.Data.MapObj[map].MapLoop & cx > this.game.Data.MapObj[map].MapWidth)
            cx = cx - this.game.Data.MapObj[map].MapWidth - 1;
          if (cx >= 0 & cx <= this.game.Data.MapObj[map].MapWidth)
          {
            let mut num4: i32 =  y1 - (maxdist + 1);
            let mut num5: i32 =  y1 + (maxdist + 1);
            for (let mut cy: i32 =  num4; cy <= num5; cy += 1)
            {
              if (cy >= 0 & cy <= this.game.Data.MapObj[map].MapHeight && mapMatrix.TempValue[cx, cy] == index1)
              {
                let mut tfacing: i32 =  1;
                do
                {
                  coordinate = this.HexNeighbour(cx, cy, map, tfacing);
                  if (coordinate.onmap && mapMatrix.TempValue[coordinate.x, coordinate.y] == -1 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                    mapMatrix.TempValue[coordinate.x, coordinate.y] = index1 + 1;
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      if (plusone)
      {
        let mut num6: i32 =  x1 - (maxdist + 1);
        let mut num7: i32 =  x1 + (maxdist + 2);
        for (let mut index: i32 =  num6; index <= num7; index += 1)
        {
          let mut cx: i32 =  index;
          if (this.game.Data.MapObj[map].MapLoop & cx < 0)
            cx = this.game.Data.MapObj[map].MapWidth + cx + 1;
          if (this.game.Data.MapObj[map].MapLoop & cx > this.game.Data.MapObj[map].MapWidth)
            cx = cx - this.game.Data.MapObj[map].MapWidth - 1;
          if (cx >= 0 & cx <= this.game.Data.MapObj[map].MapWidth)
          {
            let mut num8: i32 =  y1 - (maxdist + 1);
            let mut num9: i32 =  y1 + (maxdist + 1);
            for (let mut cy: i32 =  num8; cy <= num9; cy += 1)
            {
              if (cy >= 0 & cy <= this.game.Data.MapObj[map].MapHeight && mapMatrix.TempValue[cx, cy] > -1 & mapMatrix.TempValue[cx, cy] < maxdist && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[cx, cy].LandscapeType].IsSea)
              {
                let mut tfacing: i32 =  1;
                do
                {
                  coordinate = this.HexNeighbour(cx, cy, map, tfacing);
                  if (coordinate.onmap && mapMatrix.TempValue[coordinate.x, coordinate.y] == -1 | mapMatrix.TempValue[coordinate.x, coordinate.y] > mapMatrix.TempValue[cx, cy] + 1 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                    mapMatrix.TempValue[coordinate.x, coordinate.y] = mapMatrix.TempValue[cx, cy] + 1;
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      return mapMatrix;
    }

    pub ViewFriendlyHexNeighbourOrSelf: bool(x: i32, y: i32, map: i32, regnr: i32)
    {
      num1: i32;
      if (this.game.Data.MapObj[map].HexObj[x, y].Regime == regnr)
      {
        num2: i32;
        num1 = num2 + 1;
      }
      let mut num3: i32 =  this.HexNeighbourCount(x, y, map);
      for (let mut tfacing: i32 =  1; tfacing <= num3; tfacing += 1)
      {
        Coordinate coordinate = this.HexNeighbour(x, y, map, tfacing);
        if (coordinate.onmap)
        {
          num4: i32;
          if (this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime > -1 && this.game.Data.RegimeObj[regnr].RegimeRel[this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime] == 2 &  this.game.Data.RuleVar[328] == 1.0)
            num4 = 1;
          if (this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime == regnr)
            num4 = 1;
          if (num4 == 1)
            num1 += 1;
        }
      }
      return num1 > 0;
    }

    pub fn RemoveZOCPts(ox: i32, oy: i32, omap: i32, zocpts: i32, regnr: i32)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (!(ox > -1 & oy > -1))
        return;
      MapMatrix mapMatrix = this.checklandconnect(ox, oy, omap, 4, true);
      this.checkseaconnect(ox, oy, omap, 4, true);
      let mut num1: i32 =  ox - 5;
      let mut num2: i32 =  ox + 5;
      for (let mut index1: i32 =  num1; index1 <= num2; index1 += 1)
      {
        let mut x2: i32 =  index1;
        if (this.game.Data.MapObj[omap].MapLoop & x2 < 0)
          x2 = this.game.Data.MapObj[omap].MapWidth + x2 + 1;
        if (this.game.Data.MapObj[omap].MapLoop & x2 > this.game.Data.MapObj[omap].MapWidth)
          x2 = x2 - this.game.Data.MapObj[omap].MapWidth - 1;
        if (x2 >= 0 & x2 <= this.game.Data.MapObj[omap].MapWidth)
        {
          let mut num3: i32 =  oy - 5;
          let mut num4: i32 =  oy + 5;
          for (let mut y2: i32 =  num3; y2 <= num4; y2 += 1)
          {
            if (y2 >= 0 & y2 <= this.game.Data.MapObj[omap].MapHeight)
            {
              let mut num5: i32 =  0;
              this.Distance(ox, oy, omap, x2, y2, omap);
              if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[omap].HexObj[ox, oy].LandscapeType].IsSea)
              {
                if (mapMatrix.TempValue[x2, y2] > 0 & mapMatrix.TempValue[x2, y2] <= 4)
                  num5 =  Math.Round( ( num5 +  zocpts * this.game.Data.RuleVar[20 + mapMatrix.TempValue[x2, y2]]));
                if (mapMatrix.TempValue[x2, y2] == 0)
                  num5 =  Math.Round( ( num5 +  zocpts * this.game.Data.RuleVar[21]));
              }
              HexClass[,] hexObj = this.game.Data.MapObj[omap].HexObj;
              HexClass[,] hexClassArray = hexObj;
              let mut index2: i32 =  x2;
              let mut index3: i32 =  index2;
              let mut index4: i32 =  y2;
              let mut index5: i32 =  index4;
              HexClass hexClass = hexClassArray[index3, index5];
              let mut Index1: i32 =  regnr;
              let mut Index2: i32 =  Index1;
              let mut num6: i32 =  hexObj[index2, index4].get_ZocPts(Index1) - num5;
              hexClass.set_ZocPts(Index2, num6);
            }
          }
        }
      }
    }

    pub void SetTempLos(
      x: i32,
      y: i32,
      maxDist: i32,
      bool setBestObstruct,
      bool applyReconDistModifier = true)
    {
      this.RedimTempLosValue(0);
      this.RedimTempObstructValue(0);
      object[,,] objArray1 = new object[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1, 10];
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      object[,] objArray2 = new object[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray3: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray4: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      CoordList coordList = CoordList::new();
      coordList.AddCoord(x, y, 0, 9, 0);
      let mut num1: i32 =  x - maxDist;
      let mut num2: i32 =  x + maxDist;
      let mut num3: i32 =  y - maxDist;
      let mut num4: i32 =  y + maxDist;
      if (num1 < 0)
        num1 = 0;
      if (num2 > this.game.Data.MapObj[0].MapWidth)
        num2 = this.game.Data.MapObj[0].MapWidth;
      if (num3 < 0)
        num3 = 0;
      if (num4 > this.game.Data.MapObj[0].MapHeight)
        num4 = this.game.Data.MapObj[0].MapHeight;
      let mut num5: i32 =  num1;
      let mut num6: i32 =  num2;
      for (let mut index1: i32 =  num5; index1 <= num6; index1 += 1)
      {
        let mut num7: i32 =  num3;
        let mut num8: i32 =  num4;
        for (let mut index2: i32 =  num7; index2 <= num8; index2 += 1)
        {
          let mut index3: i32 =  0;
          do
          {
            objArray1[index1, index2, index3] =  0;
            index3 += 1;
          }
          while (index3 <= 9);
          numArray2[index1, index2] = 0;
          objArray2[index1, index2] =  0;
          numArray1[index1, index2] = 0;
          numArray3[index1, index2] = 0;
          numArray4[index1, index2] = 0;
        }
      }
      while (coordList.counter > -1)
      {
        for (let mut counter: i32 =  coordList.counter; counter >= 0; counter += -1)
        {
          Coordinate coordinate1;
          if (coordList.coord[counter].data1 == 9)
          {
            numArray3[coordList.coord[counter].x, coordList.coord[counter].y] = 0;
            numArray1[coordList.coord[counter].x, coordList.coord[counter].y] = 1;
            let mut num9: i32 =  1;
            do
            {
              coordinate1 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, num9);
              if (coordinate1.onmap && coordList.FindSlot(coordinate1.x, coordinate1.y, 0) == -1)
                coordList.AddCoord(coordinate1.x, coordinate1.y, 0, num9, 1);
              num9 += 1;
            }
            while (num9 <= 6);
          }
          data2: i32;
          tfacing1: i32;
          if (coordList.coord[counter].data1 >= 1 & coordList.coord[counter].data1 <= 6)
          {
            let mut tfacing2: i32 =  coordList.coord[counter].data1 + 3;
            if (tfacing2 > 6)
              tfacing2 -= 6;
            coordinate1 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, tfacing2);
            let mut dat1: i32 =  0;
            do
            {
              objArray1[coordList.coord[counter].x, coordList.coord[counter].y, dat1] = RuntimeHelpers.GetObjectValue(objArray1[coordinate1.x, coordinate1.y, dat1]);
              if (Operators.ConditionalCompareObjectGreater(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, dat1],  0, false) && Operators.ConditionalCompareObjectLess(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, dat1],  999, false))
              {
                object[,,] objArray3 = objArray1;
                object[,,] objArray4 = objArray3;
                let mut x1: i32 =  coordList.coord[counter].x;
                let mut index4: i32 =  x1;
                let mut y1: i32 =  coordList.coord[counter].y;
                let mut index5: i32 =  y1;
                let mut index6: i32 =  dat1;
                let mut index7: i32 =  index6;
                object obj = Operators.SubtractObject(objArray3[x1, y1, index6],  1);
                objArray4[index4, index5, index7] = obj;
              }
              dat1 += 1;
            }
            while (dat1 <= 9);
            numArray3[coordList.coord[counter].x, coordList.coord[counter].y] = numArray3[coordinate1.x, coordinate1.y];
            if (data2 > 1 & coordinate1.onmap)
            {
              let mut num10: i32 =  numArray2[coordinate1.x, coordinate1.y];
              numArray5: Vec<i32> = numArray2;
              numArray6: Vec<i32> = numArray5;
              let mut x2: i32 =  coordList.coord[counter].x;
              let mut index8: i32 =  x2;
              let mut y2: i32 =  coordList.coord[counter].y;
              let mut index9: i32 =  y2;
              let mut num11: i32 =  numArray5[x2, y2] + num10;
              numArray6[index8, index9] = num11;
              let mut num12: i32 =  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].Obstruction;
              let mut num13: i32 =  1;
              if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].HeightLevel != this.game.Data.MapObj[0].HexObj[x, y].HeightLevel)
              {
                num12 = 0;
                --num13;
              }
              if (num13 > 0 & num12 > 0)
              {
                numArray7: Vec<i32> = numArray2;
                numArray8: Vec<i32> = numArray7;
                let mut x3: i32 =  coordList.coord[counter].x;
                let mut index10: i32 =  x3;
                let mut y3: i32 =  coordList.coord[counter].y;
                let mut index11: i32 =  y3;
                let mut num14: i32 =  numArray7[x3, y3] +  Math.Round(Math.Ceiling( ((100 - numArray2[coordList.coord[counter].x, coordList.coord[counter].y]) * num12) /  (num13 * 100)));
                numArray8[index10, index11] = num14;
              }
              if (this.game.Data.MapObj[0].HexObj[coordList.coord[counter].x, coordList.coord[counter].y].HeightLevel == this.game.Data.MapObj[0].HexObj[x, y].HeightLevel)
              {
                object[,] objArray5 = objArray2;
                let mut x4: i32 =  coordList.coord[counter].x;
                let mut y4: i32 =  coordList.coord[counter].y;
                System.Type Type = typeof (Math);
                object[] objArray6 = new object[2];
                object[] objArray7 = objArray6;
                numArray9: Vec<i32> = numArray2;
                numArray10: Vec<i32> = numArray9;
                let mut x5: i32 =  coordList.coord[counter].x;
                let mut index12: i32 =  x5;
                let mut y5: i32 =  coordList.coord[counter].y;
                let mut index13: i32 =  y5;
                // ISSUE: variable of a boxed type
                __Boxed<int> local = (ValueType) numArray10[index12, index13];
                objArray7[0] =  local;
                object[] objArray8 = objArray6;
                object[,] objArray9 = objArray2;
                object[,] objArray10 = objArray9;
                let mut x6: i32 =  coordinate1.x;
                let mut index14: i32 =  x6;
                let mut y6: i32 =  coordinate1.y;
                let mut index15: i32 =  y6;
                object objectValue1 = RuntimeHelpers.GetObjectValue(objArray10[index14, index15]);
                objArray8[1] = objectValue1;
                object[] objArray11 = objArray6;
                object[] Arguments = objArray11;
                bool[] flagArray = new bool[2]{ true, true };
                bool[] CopyBack = flagArray;
                object obj = NewLateBinding.LateGet( null, Type, "Max", Arguments, (string[]) null, (System.Type[]) null, CopyBack);
                if (flagArray[0])
                  numArray9[x5, y5] =  Conversions.ChangeType(RuntimeHelpers.GetObjectValue(objArray11[0]), typeof );
                if (flagArray[1])
                  objArray9[x6, y6] = RuntimeHelpers.GetObjectValue(objArray11[1]);
                object objectValue2 = RuntimeHelpers.GetObjectValue(obj);
                objArray5[x4, y4] = objectValue2;
              }
              else
                objArray2[coordList.coord[counter].x, coordList.coord[counter].y] = RuntimeHelpers.GetObjectValue(objArray2[coordinate1.x, coordinate1.y]);
            }
            let mut val2: i32 =  this.game.Data.MapObj[0].HexObj[coordList.coord[counter].x, coordList.coord[counter].y].HeightLevel;
            if (val2 > 9)
              val2 = 9;
            if (Operators.ConditionalCompareObjectEqual(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2],  999, false))
              numArray4[coordList.coord[counter].x, coordList.coord[counter].y] = 100;
            else if (Operators.ConditionalCompareObjectGreater(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2],  0, false))
              numArray4[coordList.coord[counter].x, coordList.coord[counter].y] = 100;
            if (numArray3[coordList.coord[counter].x, coordList.coord[counter].y] < 100)
            {
              data2 = coordList.coord[counter].data2;
              numArray1[coordList.coord[counter].x, coordList.coord[counter].y] = data2;
              let mut num15: i32 =  this.game.Data.MapObj[0].HexObj[coordList.coord[counter].x, coordList.coord[counter].y].HeightLevel - this.game.Data.MapObj[0].HexObj[x, y].HeightLevel;
              if (num15 > 0)
              {
                for (dat1 = Math.Min(9, val2); dat1 >= 0; dat1 += -1)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, dat1] =  999;
              }
              else if (num15 == 0)
              {
                for (dat1 = Math.Min(9, val2 - 1); dat1 >= 0; dat1 += -1)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, dat1] =  999;
              }
              else if (num15 < 0)
              {
                if (val2 - 1 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2 - 1] =  Math.Floor(new Decimal(1 * data2));
                if (val2 - 2 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2 - 2] =  (2 * data2);
                if (val2 - 3 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2 - 3] =  (3 * data2);
                if (val2 - 4 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2 - 4] =  (4 * data2);
                if (val2 - 5 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2 - 5] =  (5 * data2);
                if (val2 - 6 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, val2 - 6] =  (6 * data2);
              }
              if (data2 < maxDist)
              {
                coordinate1 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, coordList.coord[counter].data1);
                if (coordinate1.onmap && coordList.FindSlot(coordinate1.x, coordinate1.y, 0) == -1)
                  coordList.AddCoord(coordinate1.x, coordinate1.y, 0, coordList.coord[counter].data1, data2 + 1);
                if (data2 == 1)
                {
                  if (coordList.coord[counter].data1 == 1)
                  {
                    dat1 = 13;
                    tfacing1 = 6;
                  }
                  if (coordList.coord[counter].data1 == 2)
                  {
                    dat1 = 14;
                    tfacing1 = 1;
                  }
                  if (coordList.coord[counter].data1 == 3)
                  {
                    dat1 = 15;
                    tfacing1 = 2;
                  }
                  if (coordList.coord[counter].data1 == 4)
                  {
                    dat1 = 16;
                    tfacing1 = 3;
                  }
                  if (coordList.coord[counter].data1 == 5)
                  {
                    dat1 = 11;
                    tfacing1 = 4;
                  }
                  if (coordList.coord[counter].data1 == 6)
                  {
                    dat1 = 12;
                    tfacing1 = 5;
                  }
                  coordinate1 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, tfacing1);
                  if (coordinate1.onmap && coordList.FindSlot(coordinate1.x, coordinate1.y, 0) == -1)
                    coordList.AddCoord(coordinate1.x, coordinate1.y, 0, dat1, data2 + 1);
                }
              }
            }
          }
          if (coordList.coord[counter].data1 >= 11 & coordList.coord[counter].data1 <= 16)
          {
            tfacing3: i32;
            if (coordList.coord[counter].x == 10 & coordList.coord[counter].y == 7)
              tfacing3 = tfacing3;
            tfacing4: i32;
            if (coordList.coord[counter].data1 == 11)
            {
              tfacing3 = 1;
              tfacing4 = 2;
            }
            if (coordList.coord[counter].data1 == 12)
            {
              tfacing3 = 2;
              tfacing4 = 3;
            }
            if (coordList.coord[counter].data1 == 13)
            {
              tfacing3 = 3;
              tfacing4 = 4;
            }
            if (coordList.coord[counter].data1 == 14)
            {
              tfacing3 = 4;
              tfacing4 = 5;
            }
            if (coordList.coord[counter].data1 == 15)
            {
              tfacing3 = 5;
              tfacing4 = 6;
            }
            if (coordList.coord[counter].data1 == 16)
            {
              tfacing3 = 6;
              tfacing4 = 1;
            }
            let mut tfacing5: i32 =  tfacing3 + 3;
            tfacing1 = tfacing4 + 3;
            if (tfacing5 > 6)
              tfacing5 -= 6;
            if (tfacing1 > 6)
              tfacing1 -= 6;
            coordinate1 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, tfacing3);
            Coordinate coordinate2 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, tfacing4);
            if (!coordinate1.onmap)
            {
              coordinate1 = coordinate2;
              coordinate2.onmap = false;
            }
            if (coordinate2.onmap)
            {
              let mut index16: i32 =  0;
              do
              {
                let mut num16: i32 =  Conversions.ToInteger(objArray1[coordinate1.x, coordinate1.y, index16]);
                let mut num17: i32 =  Conversions.ToInteger(objArray1[coordinate2.x, coordinate2.y, index16]);
                if (numArray1[coordinate1.x, coordinate1.y] < 1)
                  num16 = 999;
                if (numArray1[coordinate2.x, coordinate2.y] < 1)
                  num17 = 999;
                if (num16 >= 999 & num17 < 999)
                  num16 = 0;
                if (num17 >= 999 & num16 < 999)
                  num17 = 0;
                objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index16] =   Math.Round(Math.Ceiling( (num16 + num17) / 2.0));
                if (Operators.ConditionalCompareObjectGreater(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index16],  0, false) && Operators.ConditionalCompareObjectLess(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index16],  999, false))
                {
                  object[,,] objArray12 = objArray1;
                  object[,,] objArray13 = objArray12;
                  let mut x7: i32 =  coordList.coord[counter].x;
                  let mut index17: i32 =  x7;
                  let mut y7: i32 =  coordList.coord[counter].y;
                  let mut index18: i32 =  y7;
                  let mut index19: i32 =  index16;
                  let mut index20: i32 =  index19;
                  object obj = Operators.SubtractObject(objArray12[x7, y7, index19],  1);
                  objArray13[index17, index18, index20] = obj;
                }
                index16 += 1;
              }
              while (index16 <= 9);
            }
            else
            {
              let mut index21: i32 =  0;
              do
              {
                let mut num18: i32 =  Conversions.ToInteger(objArray1[coordinate1.x, coordinate1.y, index21]);
                if (numArray1[coordinate1.x, coordinate1.y] < 1)
                  num18 = 999;
                objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index21] =  num18;
                if (Operators.ConditionalCompareObjectGreater(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index21],  0, false) && Operators.ConditionalCompareObjectLess(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index21],  999, false))
                {
                  object[,,] objArray14 = objArray1;
                  object[,,] objArray15 = objArray14;
                  let mut x8: i32 =  coordList.coord[counter].x;
                  let mut index22: i32 =  x8;
                  let mut y8: i32 =  coordList.coord[counter].y;
                  let mut index23: i32 =  y8;
                  let mut index24: i32 =  index21;
                  let mut index25: i32 =  index24;
                  object obj = Operators.SubtractObject(objArray14[x8, y8, index24],  1);
                  objArray15[index22, index23, index25] = obj;
                }
                index21 += 1;
              }
              while (index21 <= 9);
            }
            if (coordinate2.onmap)
            {
              let mut num19: i32 =  numArray3[coordinate1.x, coordinate1.y];
              let mut num20: i32 =  numArray3[coordinate2.x, coordinate2.y];
              if (numArray1[coordinate1.x, coordinate1.y] < 1)
                num19 = 100;
              if (numArray1[coordinate2.x, coordinate2.y] < 1)
                num20 = 100;
              numArray3[coordList.coord[counter].x, coordList.coord[counter].y] =  Math.Round(Math.Ceiling( (num19 + num20) / 2.0));
            }
            else
            {
              let mut num21: i32 =  numArray3[coordinate1.x, coordinate1.y];
              if (numArray1[coordinate1.x, coordinate1.y] < 1)
                num21 = 100;
              numArray3[coordList.coord[counter].x, coordList.coord[counter].y] = num21;
            }
            if (coordinate2.onmap)
            {
              let mut num22: i32 =  numArray2[coordinate1.x, coordinate1.y];
              let mut num23: i32 =  numArray2[coordinate2.x, coordinate2.y];
              if (Conversions.ToBoolean(Operators.AndObject( (num22 < num23), Operators.CompareObjectGreaterEqual(objArray1[coordinate1.x, coordinate1.y, this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].HeightLevel],  999, false))))
                num22 = num23;
              if (Conversions.ToBoolean(Operators.AndObject( (num23 < num22), Operators.CompareObjectGreaterEqual(objArray1[coordinate2.x, coordinate2.y, this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].HeightLevel],  999, false))))
                num23 = num22;
              numArray11: Vec<i32> = numArray2;
              numArray12: Vec<i32> = numArray11;
              let mut x9: i32 =  coordList.coord[counter].x;
              let mut index26: i32 =  x9;
              let mut y9: i32 =  coordList.coord[counter].y;
              let mut index27: i32 =  y9;
              let mut num24: i32 =  numArray11[x9, y9] +  Math.Round(Math.Ceiling( (num22 + num23) / 2.0));
              numArray12[index26, index27] = num24;
              let mut num25: i32 =  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].Obstruction;
              let mut num26: i32 =  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].Obstruction;
              let mut num27: i32 =  2;
              if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].HeightLevel != this.game.Data.MapObj[0].HexObj[x, y].HeightLevel)
              {
                num25 = 0;
                --num27;
              }
              if (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].HeightLevel != this.game.Data.MapObj[0].HexObj[x, y].HeightLevel)
              {
                num26 = 0;
                --num27;
              }
              if (num27 > 0 & num25 + num26 > 0)
              {
                numArray13: Vec<i32> = numArray2;
                numArray14: Vec<i32> = numArray13;
                let mut x10: i32 =  coordList.coord[counter].x;
                let mut index28: i32 =  x10;
                let mut y10: i32 =  coordList.coord[counter].y;
                let mut index29: i32 =  y10;
                let mut num28: i32 =  numArray13[x10, y10] +  Math.Round(Math.Ceiling( ((100 - numArray2[coordList.coord[counter].x, coordList.coord[counter].y]) * (num25 + num26)) /  (num27 * 100)));
                numArray14[index28, index29] = num28;
              }
              if (this.game.Data.MapObj[0].HexObj[coordList.coord[counter].x, coordList.coord[counter].y].HeightLevel == this.game.Data.MapObj[0].HexObj[x, y].HeightLevel)
              {
                object[,] objArray16 = objArray2;
                let mut x11: i32 =  coordList.coord[counter].x;
                let mut y11: i32 =  coordList.coord[counter].y;
                System.Type Type1 = typeof (Math);
                object[] objArray17 = new object[2];
                object[] objArray18 = objArray17;
                numArray15: Vec<i32> = numArray2;
                numArray16: Vec<i32> = numArray15;
                let mut x12: i32 =  coordList.coord[counter].x;
                let mut index30: i32 =  x12;
                let mut y12: i32 =  coordList.coord[counter].y;
                let mut index31: i32 =  y12;
                // ISSUE: variable of a boxed type
                __Boxed<int> local = (ValueType) numArray16[index30, index31];
                objArray18[0] =  local;
                object[] objArray19 = objArray17;
                System.Type Type2 = typeof (Math);
                object[] objArray20 = new object[2];
                object[] objArray21 = objArray20;
                object[,] objArray22 = objArray2;
                object[,] objArray23 = objArray22;
                let mut x13: i32 =  coordinate2.x;
                let mut index32: i32 =  x13;
                let mut y13: i32 =  coordinate2.y;
                let mut index33: i32 =  y13;
                object objectValue3 = RuntimeHelpers.GetObjectValue(objArray23[index32, index33]);
                objArray21[0] = objectValue3;
                object[] objArray24 = objArray20;
                object[,] objArray25 = objArray2;
                object[,] objArray26 = objArray25;
                let mut x14: i32 =  coordinate1.x;
                let mut index34: i32 =  x14;
                let mut y14: i32 =  coordinate1.y;
                let mut index35: i32 =  y14;
                object objectValue4 = RuntimeHelpers.GetObjectValue(objArray26[index34, index35]);
                objArray24[1] = objectValue4;
                object[] objArray27 = objArray20;
                object[] Arguments1 = objArray27;
                bool[] flagArray1 = new bool[2]
                {
                  true,
                  true
                };
                bool[] CopyBack1 = flagArray1;
                object obj1 = NewLateBinding.LateGet( null, Type2, "Min", Arguments1, (string[]) null, (System.Type[]) null, CopyBack1);
                if (flagArray1[0])
                  objArray22[x13, y13] = RuntimeHelpers.GetObjectValue(objArray27[0]);
                if (flagArray1[1])
                  objArray25[x14, y14] = RuntimeHelpers.GetObjectValue(objArray27[1]);
                object objectValue5 = RuntimeHelpers.GetObjectValue(obj1);
                objArray19[1] = objectValue5;
                object[] objArray28 = objArray17;
                object[] Arguments2 = objArray28;
                bool[] flagArray2 = new bool[2]
                {
                  true,
                  false
                };
                bool[] CopyBack2 = flagArray2;
                object obj2 = NewLateBinding.LateGet( null, Type1, "Max", Arguments2, (string[]) null, (System.Type[]) null, CopyBack2);
                if (flagArray2[0])
                  numArray15[x12, y12] =  Conversions.ChangeType(RuntimeHelpers.GetObjectValue(objArray28[0]), typeof );
                object objectValue6 = RuntimeHelpers.GetObjectValue(obj2);
                objArray16[x11, y11] = objectValue6;
              }
              else
              {
                object[,] objArray29 = objArray2;
                let mut x15: i32 =  coordList.coord[counter].x;
                let mut y15: i32 =  coordList.coord[counter].y;
                System.Type Type = typeof (Math);
                object[] objArray30 = new object[2];
                object[] objArray31 = objArray30;
                object[,] objArray32 = objArray2;
                object[,] objArray33 = objArray32;
                let mut x16: i32 =  coordinate2.x;
                let mut index36: i32 =  x16;
                let mut y16: i32 =  coordinate2.y;
                let mut index37: i32 =  y16;
                object objectValue7 = RuntimeHelpers.GetObjectValue(objArray33[index36, index37]);
                objArray31[0] = objectValue7;
                object[] objArray34 = objArray30;
                object[,] objArray35 = objArray2;
                object[,] objArray36 = objArray35;
                let mut x17: i32 =  coordinate1.x;
                let mut index38: i32 =  x17;
                let mut y17: i32 =  coordinate1.y;
                let mut index39: i32 =  y17;
                object objectValue8 = RuntimeHelpers.GetObjectValue(objArray36[index38, index39]);
                objArray34[1] = objectValue8;
                object[] objArray37 = objArray30;
                object[] Arguments = objArray37;
                bool[] flagArray = new bool[2]{ true, true };
                bool[] CopyBack = flagArray;
                object obj = NewLateBinding.LateGet( null, Type, "Min", Arguments, (string[]) null, (System.Type[]) null, CopyBack);
                if (flagArray[0])
                  objArray32[x16, y16] = RuntimeHelpers.GetObjectValue(objArray37[0]);
                if (flagArray[1])
                  objArray35[x17, y17] = RuntimeHelpers.GetObjectValue(objArray37[1]);
                object objectValue9 = RuntimeHelpers.GetObjectValue(obj);
                objArray29[x15, y15] = objectValue9;
              }
            }
            else
            {
              let mut num29: i32 =  numArray2[coordinate1.x, coordinate1.y];
              numArray17: Vec<i32> = numArray2;
              numArray18: Vec<i32> = numArray17;
              let mut x18: i32 =  coordList.coord[counter].x;
              let mut index40: i32 =  x18;
              let mut y18: i32 =  coordList.coord[counter].y;
              let mut index41: i32 =  y18;
              let mut num30: i32 =  numArray17[x18, y18] + num29;
              numArray18[index40, index41] = num30;
              let mut num31: i32 =  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].Obstruction;
              let mut num32: i32 =  1;
              if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].HeightLevel != this.game.Data.MapObj[0].HexObj[x, y].HeightLevel)
              {
                num31 = 0;
                --num32;
              }
              if (num32 > 0 & num31 > 0)
              {
                numArray19: Vec<i32> = numArray2;
                numArray20: Vec<i32> = numArray19;
                let mut x19: i32 =  coordList.coord[counter].x;
                let mut index42: i32 =  x19;
                let mut y19: i32 =  coordList.coord[counter].y;
                let mut index43: i32 =  y19;
                let mut num33: i32 =  numArray19[x19, y19] +  Math.Round(Math.Ceiling( ((100 - numArray2[coordList.coord[counter].x, coordList.coord[counter].y]) * num31) /  (num32 * 100)));
                numArray20[index42, index43] = num33;
              }
              if (this.game.Data.MapObj[0].HexObj[coordList.coord[counter].x, coordList.coord[counter].y].HeightLevel == this.game.Data.MapObj[0].HexObj[x, y].HeightLevel)
              {
                object[,] objArray38 = objArray2;
                let mut x20: i32 =  coordList.coord[counter].x;
                let mut y20: i32 =  coordList.coord[counter].y;
                System.Type Type = typeof (Math);
                object[] objArray39 = new object[2];
                object[] objArray40 = objArray39;
                numArray21: Vec<i32> = numArray2;
                numArray22: Vec<i32> = numArray21;
                let mut x21: i32 =  coordList.coord[counter].x;
                let mut index44: i32 =  x21;
                let mut y21: i32 =  coordList.coord[counter].y;
                let mut index45: i32 =  y21;
                // ISSUE: variable of a boxed type
                __Boxed<int> local = (ValueType) numArray22[index44, index45];
                objArray40[0] =  local;
                object[] objArray41 = objArray39;
                object[,] objArray42 = objArray2;
                object[,] objArray43 = objArray42;
                let mut x22: i32 =  coordinate1.x;
                let mut index46: i32 =  x22;
                let mut y22: i32 =  coordinate1.y;
                let mut index47: i32 =  y22;
                object objectValue10 = RuntimeHelpers.GetObjectValue(objArray43[index46, index47]);
                objArray41[1] = objectValue10;
                object[] objArray44 = objArray39;
                object[] Arguments = objArray44;
                bool[] flagArray = new bool[2]{ true, true };
                bool[] CopyBack = flagArray;
                object obj = NewLateBinding.LateGet( null, Type, "Max", Arguments, (string[]) null, (System.Type[]) null, CopyBack);
                if (flagArray[0])
                  numArray21[x21, y21] =  Conversions.ChangeType(RuntimeHelpers.GetObjectValue(objArray44[0]), typeof );
                if (flagArray[1])
                  objArray42[x22, y22] = RuntimeHelpers.GetObjectValue(objArray44[1]);
                object objectValue11 = RuntimeHelpers.GetObjectValue(obj);
                objArray38[x20, y20] = objectValue11;
              }
              else
                objArray2[coordList.coord[counter].x, coordList.coord[counter].y] = RuntimeHelpers.GetObjectValue(objArray2[coordinate1.x, coordinate1.y]);
            }
            let mut heightLevel: i32 =  this.game.Data.MapObj[0].HexObj[coordList.coord[counter].x, coordList.coord[counter].y].HeightLevel;
            if (Operators.ConditionalCompareObjectEqual(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel],  999, false))
              numArray4[coordList.coord[counter].x, coordList.coord[counter].y] = 100;
            else if (Operators.ConditionalCompareObjectGreater(objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel],  0, false))
              numArray4[coordList.coord[counter].x, coordList.coord[counter].y] = 100;
            if (numArray3[coordList.coord[counter].x, coordList.coord[counter].y] < 100)
            {
              data2 = coordList.coord[counter].data2;
              numArray1[coordList.coord[counter].x, coordList.coord[counter].y] = data2;
              let mut num34: i32 =  this.game.Data.MapObj[0].HexObj[coordList.coord[counter].x, coordList.coord[counter].y].HeightLevel - this.game.Data.MapObj[0].HexObj[x, y].HeightLevel;
              if (num34 > 0)
              {
                for (let mut index: i32 =  heightLevel; index >= 0; index += -1)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index] =  999;
              }
              else if (num34 == 0)
              {
                for (let mut index: i32 =  heightLevel - 1; index >= 0; index += -1)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, index] =  999;
              }
              else if (num34 < 0)
              {
                if (heightLevel - 1 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel - 1] =  Math.Floor(new Decimal(1 * data2));
                if (heightLevel - 2 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel - 2] =  (2 * data2);
                if (heightLevel - 3 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel - 3] =  (3 * data2);
                if (heightLevel - 4 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel - 4] =  (4 * data2);
                if (heightLevel - 5 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel - 5] =  (5 * data2);
                if (heightLevel - 6 >= 0)
                  objArray1[coordList.coord[counter].x, coordList.coord[counter].y, heightLevel - 6] =  (6 * data2);
              }
              if (data2 < maxDist)
              {
                coordinate1 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, tfacing5);
                if (coordinate1.onmap && coordList.FindSlot(coordinate1.x, coordinate1.y, 0) == -1)
                  coordList.AddCoord(coordinate1.x, coordinate1.y, 0, coordList.coord[counter].data1, data2 + 1);
                coordinate1 = this.HexNeighbour(coordList.coord[counter].x, coordList.coord[counter].y, 0, tfacing1);
                if (coordinate1.onmap && coordList.FindSlot(coordinate1.x, coordinate1.y, 0) == -1)
                  coordList.AddCoord(coordinate1.x, coordinate1.y, 0, coordList.coord[counter].data1, data2 + 1);
              }
            }
          }
          coordList.RemoveCoordQuick(counter);
        }
      }
      float[] numArray23 = new float[200];
      numArray23[0] = 1f;
      if ((1 | (applyReconDistModifier ? 1 : 0)) != 0)
      {
        numArray23[1] = 1f / this.game.Data.RuleVar[420];
        float num35 = this.game.Data.RuleVar[421];
        let mut index: i32 =  2;
        do
        {
          if ( index >  this.game.Data.RuleVar[422])
          {
            numArray23[index] = 0.0f;
          }
          else
          {
            numArray23[index] = numArray23[1] / num35;
            num35 *= this.game.Data.RuleVar[421];
          }
          index += 1;
        }
        while (index <= 199);
      }
      else
      {
        numArray23[1] = 1f;
        float num36 = this.game.Data.RuleVar[421];
        let mut index: i32 =  2;
        do
        {
          numArray23[index] =  index <=  this.game.Data.RuleVar[422] ? numArray23[1] : 0.0f;
          index += 1;
        }
        while (index <= 199);
      }
      let mut num37: i32 =  num1;
      let mut num38: i32 =  num2;
      for (let mut index48: i32 =  num37; index48 <= num38; index48 += 1)
      {
        let mut num39: i32 =  num3;
        let mut num40: i32 =  num4;
        for (let mut index49: i32 =  num39; index49 <= num40; index49 += 1)
        {
          this.game.EditObj.TempObstruct[0].Value[index48, index49] = numArray2[index48, index49];
          if (this.game.Data.MapObj[0].HexObj[x, y].HeightLevel < this.game.Data.MapObj[0].HexObj[index48, index49].HeightLevel)
            this.game.EditObj.TempObstruct[0].Value[index48, index49] = 0;
          else if (this.game.Data.MapObj[0].HexObj[x, y].HeightLevel > this.game.Data.MapObj[0].HexObj[index48, index49].HeightLevel)
            this.game.EditObj.TempObstruct[0].Value[index48, index49] = Conversions.ToInteger(objArray2[index48, index49]);
          if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index48, index49].LandscapeType].Obstruction > 0)
          {
            let mut obstruction: i32 =  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index48, index49].LandscapeType].Obstruction;
            numArray24: Vec<i32> = this.game.EditObj.TempObstruct[0].Value;
            numArray25: Vec<i32> = numArray24;
            let mut index50: i32 =  index48;
            let mut index51: i32 =  index50;
            let mut index52: i32 =  index49;
            let mut index53: i32 =  index52;
            let mut num41: i32 =  numArray24[index50, index52] +  Math.Round( ((100 - this.game.EditObj.TempObstruct[0].Value[index48, index49]) * obstruction) / 200.0);
            numArray25[index51, index53] = num41;
          }
          if (numArray1[index48, index49] > 0)
          {
            let mut num42: i32 =  100 - numArray3[index48, index49];
            let mut num43: i32 =   Math.Round( num42 - Math.Ceiling( (num42 * numArray4[index48, index49]) / 100.0));
            if (this.game.Data.MapObj[0].HexObj[x, y].HeightLevel == this.game.Data.MapObj[0].HexObj[index48, index49].HeightLevel && numArray2[index48, index49] > 0)
              num43 -=  Math.Round(Math.Ceiling( (num43 * numArray2[index48, index49]) / 100.0));
            let mut num44: i32 =  num43 -  Math.Round( (num43 * this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index48, index49].LandscapeType].Obstruction) / 200.0);
            if (index48 == 57 & index49 == 11)
              index48 = index48;
            if (x == index48 & y == index49)
            {
              let mut num45: i32 =  100;
              this.game.EditObj.TempLos[0].Value[index48, index49] =  Math.Round(Math.Floor( num45 * 1.0));
            }
            else
              this.game.EditObj.TempLos[0].Value[index48, index49] =  Math.Round(Math.Floor( num44 *  numArray23[numArray1[index48, index49]]));
            if (this.game.EditObj.TempLos[0].Value[index48, index49] > 100)
              index48 = index48;
            if (setBestObstruct)
            {
              let mut num46: i32 =  100 - numArray2[index48, index49];
              if (this.game.Data.MapObj[0].HexObj[index48, index49].MaxObstruct < num46)
                this.game.Data.MapObj[0].HexObj[index48, index49].MaxObstruct = num46;
            }
          }
        }
      }
    }

    pub void SetHexReconAndZOCUnitMoves_LosRules(
      ox: i32,
      oy: i32,
      omap: i32,
      x: i32,
      y: i32,
      map: i32,
      regnr: i32,
      unr: i32,
      bool ZOCConquest = true,
      bool dontcountair = false,
      bool changezoc = true,
      let mut overrulerecon: i32 =  0)
    {
      if (this.game.Data.Round == 0)
        return;
      let mut maxDist: i32 =  9;
      let mut unitRecon1: i32 =  this.GetUnitRecon(unr, 1, dontcountair);
      let mut unitRecon2: i32 =  this.GetUnitRecon(unr, 0, dontcountair);
      num1: i32;
      num2: i32;
      if (ox > -1 & oy > -1)
      {
        this.SetTempLos(ox, oy, maxDist, false);
        let mut num3: i32 =  ox - (maxDist + 1);
        let mut num4: i32 =  ox + (maxDist + 1);
        for (let mut index1: i32 =  num3; index1 <= num4; index1 += 1)
        {
          let mut index2: i32 =  index1;
          if (this.game.Data.MapObj[omap].MapLoop & index2 < 0)
            index2 = this.game.Data.MapObj[omap].MapWidth + index2 + 1;
          if (this.game.Data.MapObj[omap].MapLoop & index2 > this.game.Data.MapObj[omap].MapWidth)
            index2 = index2 - this.game.Data.MapObj[omap].MapWidth - 1;
          if (index2 >= 0 & index2 <= this.game.Data.MapObj[omap].MapWidth)
          {
            let mut num5: i32 =  oy - (maxDist + 1);
            let mut num6: i32 =  oy + (maxDist + 1);
            for (let mut index3: i32 =  num5; index3 <= num6; index3 += 1)
            {
              if (index3 >= 0 & index3 <= this.game.Data.MapObj[omap].MapHeight)
              {
                num1 = 0;
                let mut num7: i32 =  0;
                num2 = 0;
                let mut num8: i32 =  this.Distance(ox, oy, omap, index2, index3, omap);
                num9: i32;
                if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[omap].HexObj[ox, oy].LandscapeType].IsSea)
                {
                  num9 =  Math.Round(Math.Floor( (unitRecon1 * this.game.EditObj.TempLos[0].Value[index2, index3]) / 100.0));
                }
                else
                {
                  num9 =  Math.Round(Math.Floor( (unitRecon2 * this.game.EditObj.TempLos[0].Value[index2, index3]) / 100.0));
                  if (num8 > 0 & num8 <= 4)
                    num7 =  Math.Round( ( num7 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[20 + num8]));
                  if (num8 == 0)
                    num7 =  Math.Round( ( num7 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[21]));
                }
                if (changezoc)
                {
                  HexClass[,] hexObj = this.game.Data.MapObj[omap].HexObj;
                  HexClass[,] hexClassArray = hexObj;
                  let mut index4: i32 =  index2;
                  let mut index5: i32 =  index4;
                  let mut index6: i32 =  index3;
                  let mut index7: i32 =  index6;
                  HexClass hexClass = hexClassArray[index5, index7];
                  let mut Index1: i32 =  regnr;
                  let mut Index2: i32 =  Index1;
                  let mut num10: i32 =  hexObj[index4, index6].get_ZocPts(Index1) - num7;
                  hexClass.set_ZocPts(Index2, num10);
                }
                HexClass[,] hexObj1 = this.game.Data.MapObj[omap].HexObj;
                HexClass[,] hexClassArray1 = hexObj1;
                let mut index8: i32 =  index2;
                let mut index9: i32 =  index8;
                let mut index10: i32 =  index3;
                let mut index11: i32 =  index10;
                HexClass hexClass1 = hexClassArray1[index9, index11];
                let mut Index3: i32 =  regnr;
                let mut Index4: i32 =  Index3;
                let mut num11: i32 =  hexObj1[index8, index10].get_ReconPts(Index3) - num9;
                hexClass1.set_ReconPts(Index4, num11);
                if (this.game.Data.MapObj[omap].HexObj[index2, index3].get_ReconPts(regnr) < 0)
                  this.game.Data.MapObj[omap].HexObj[index2, index3].set_ReconPts(regnr, 0);
                if (this.ViewFriendlyHexNeighbourOrSelf(index2, index3, omap, regnr) &&  this.game.Data.MapObj[omap].HexObj[index2, index3].get_ReconPts(regnr) <  this.game.Data.RuleVar[8])
                  this.game.Data.MapObj[omap].HexObj[index2, index3].set_ReconPts(regnr,  Math.Round( this.game.Data.RuleVar[8]));
              }
            }
          }
        }
      }
      if (x > -1 & y > -1)
      {
        this.SetTempLos(x, y, maxDist, true);
        let mut num12: i32 =  x - (maxDist + 1);
        let mut num13: i32 =  x + (maxDist + 1);
        for (let mut index12: i32 =  num12; index12 <= num13; index12 += 1)
        {
          let mut index13: i32 =  index12;
          if (this.game.Data.MapObj[map].MapLoop & index13 < 0)
            index13 = this.game.Data.MapObj[map].MapWidth + index13 + 1;
          if (this.game.Data.MapObj[map].MapLoop & index13 > this.game.Data.MapObj[map].MapWidth)
            index13 = index13 - this.game.Data.MapObj[map].MapWidth - 1;
          if (index13 >= 0 & index13 <= this.game.Data.MapObj[map].MapWidth)
          {
            let mut num14: i32 =  y - (maxDist + 1);
            let mut num15: i32 =  y + (maxDist + 1);
            for (let mut index14: i32 =  num14; index14 <= num15; index14 += 1)
            {
              if (index14 >= 0 & index14 <= this.game.Data.MapObj[map].MapHeight && this.game.EditObj.TempLos[0].Value[index13, index14] > 0)
              {
                num1 = 0;
                let mut num16: i32 =  0;
                num2 = 0;
                if (index13 == 13 & index14 == 4)
                  index13 = index13;
                let mut num17: i32 =  this.Distance(x, y, map, index13, index14, map);
                if (num17 == 0)
                  x = x;
                num18: i32;
                if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
                {
                  num18 = overrulerecon <= 0 ?  Math.Round(Math.Floor( (unitRecon1 * this.game.EditObj.TempLos[0].Value[index13, index14]) / 100.0)) :  Math.Round(Math.Floor( (overrulerecon * this.game.EditObj.TempLos[0].Value[index13, index14]) / 100.0));
                }
                else
                {
                  num18 = overrulerecon <= 0 ?  Math.Round(Math.Floor( (unitRecon2 * this.game.EditObj.TempLos[0].Value[index13, index14]) / 100.0)) :  Math.Round(Math.Floor( (overrulerecon * this.game.EditObj.TempLos[0].Value[index13, index14]) / 100.0));
                  if (unr > -1)
                  {
                    if (num17 > 0 & num17 <= 4)
                      num16 =  Math.Round( ( num16 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[20 + num17]));
                    if (num17 == 0)
                      num16 =  Math.Round( ( num16 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[21]));
                  }
                }
                if (changezoc)
                {
                  HexClass[,] hexObj = this.game.Data.MapObj[map].HexObj;
                  HexClass[,] hexClassArray = hexObj;
                  let mut index15: i32 =  index13;
                  let mut index16: i32 =  index15;
                  let mut index17: i32 =  index14;
                  let mut index18: i32 =  index17;
                  HexClass hexClass = hexClassArray[index16, index18];
                  let mut Index5: i32 =  regnr;
                  let mut Index6: i32 =  Index5;
                  let mut num19: i32 =  hexObj[index15, index17].get_ZocPts(Index5) + num16;
                  hexClass.set_ZocPts(Index6, num19);
                }
                if (this.ViewFriendlyHexNeighbourOrSelf(index13, index14, map, regnr) &&  this.game.Data.MapObj[map].HexObj[index13, index14].get_ReconPts(regnr) <  this.game.Data.RuleVar[8])
                {
                  this.game.Data.MapObj[map].HexObj[index13, index14].set_ReconPts(regnr,  Math.Round( this.game.Data.RuleVar[8]));
                  this.game.Data.MapObj[map].CanSee = true;
                }
                if (num18 > 0)
                {
                  HexClass[,] hexObj = this.game.Data.MapObj[map].HexObj;
                  HexClass[,] hexClassArray = hexObj;
                  let mut index19: i32 =  index13;
                  let mut index20: i32 =  index19;
                  let mut index21: i32 =  index14;
                  let mut index22: i32 =  index21;
                  HexClass hexClass = hexClassArray[index20, index22];
                  let mut Index7: i32 =  regnr;
                  let mut Index8: i32 =  Index7;
                  let mut num20: i32 =  hexObj[index19, index21].get_ReconPts(Index7) + num18;
                  hexClass.set_ReconPts(Index8, num20);
                  this.game.Data.MapObj[map].CanSee = true;
                }
                if (this.game.Data.Turn > -1)
                {
                  if (this.game.EditObj.TempLos[0].Value[index13, index14] > this.game.Data.MapObj[map].HexObj[index13, index14].MaxLos)
                    this.game.Data.MapObj[map].HexObj[index13, index14].MaxLos = this.game.EditObj.TempLos[0].Value[index13, index14];
                  if (this.game.Data.MapObj[map].HexObj[index13, index14].get_ReconPts(this.game.Data.Turn) > this.game.Data.MapObj[map].HexObj[index13, index14].MaxRecon)
                  {
                    this.game.Data.MapObj[map].HexObj[index13, index14].MaxRecon = this.game.Data.MapObj[map].HexObj[index13, index14].get_ReconPts(this.game.Data.Turn);
                    let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
                    for (let mut index23: i32 =  0; index23 <= regimeCounter; index23 += 1)
                    {
                      if (index23 != regnr && this.game.HandyFunctionsObj.IsAlliedOrSelf(index23, this.game.Data.Turn, true) && this.game.Data.MapObj[map].HexObj[index13, index14].MaxRecon > this.game.Data.MapObj[map].HexObj[index13, index14].get_ReconPts(index23))
                        this.game.Data.MapObj[map].HexObj[index13, index14].set_ReconPts(index23, this.game.Data.MapObj[map].HexObj[index13, index14].MaxRecon);
                    }
                  }
                }
                if (this.game.Data.MapObj[map].HexObj[index13, index14].get_ReconPts(regnr) >= 1 | !this.game.Data.ShrowdOn)
                {
                  this.game.Data.MapObj[map].CanSee = true;
                  if (this.game.Data.MapObj[map].HexObj[index13, index14].get_ReconPts(regnr) >= 1)
                    this.game.Data.MapObj[map].HexObj[index13, index14].set_SeeNow(regnr, 1);
                  this.game.Data.MapObj[map].HexObj[index13, index14].set_LastLT(regnr, this.game.Data.MapObj[map].HexObj[index13, index14].LandscapeType);
                  this.game.Data.MapObj[map].HexObj[index13, index14].set_LastSpr(regnr, this.game.Data.MapObj[map].HexObj[index13, index14].SpriteNr);
                  this.game.Data.MapObj[map].HexObj[index13, index14].set_LastReg(regnr, this.game.Data.MapObj[map].HexObj[index13, index14].Regime);
                }
              }
            }
          }
        }
      }
      if (map > -1 & x > -1)
      {
        let mut num21: i32 =  0;
        do
        {
          let mut num22: i32 =  x - 5;
          let mut num23: i32 =  x + 5;
          for (let mut index: i32 =  num22; index <= num23; index += 1)
          {
            let mut x1: i32 =  index;
            if (this.game.Data.MapObj[map].MapLoop & x1 < 0)
              x1 = this.game.Data.MapObj[map].MapWidth + x1 + 1;
            if (this.game.Data.MapObj[map].MapLoop & x1 > this.game.Data.MapObj[map].MapWidth)
              x1 = x1 - this.game.Data.MapObj[map].MapWidth - 1;
            if (x1 >= 0 & x1 <= this.game.Data.MapObj[map].MapWidth)
            {
              let mut num24: i32 =  y - 5;
              let mut num25: i32 =  y + 5;
              for (let mut y1: i32 =  num24; y1 <= num25; y1 += 1)
              {
                if (y1 >= 0 & y1 <= this.game.Data.MapObj[map].MapHeight && ZOCConquest)
                  this.game.HandyFunctionsObj.DoZOCConquest(x1, y1, map, regnr, ox, oy, unr);
              }
            }
          }
          num21 += 1;
        }
        while (num21 <= 3);
      }
    }

    pub CheckIfIntercepted: bool(unr: i32, x: i32, y: i32)
    {
      if ( this.game.Data.RuleVar[428] < 1.0)
        return false;
      if (Information.IsNothing( this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList))
      {
        bool flag;
        return flag;
      }
      if (this.game.Data.UnitObj[unr].FreeCombatX == x & this.game.Data.UnitObj[unr].FreeCombatY == y)
        return false;
      let mut counter: i32 =  this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.counter;
      for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
      {
        let mut historicalUnitById: i32 =  this.game.HandyFunctionsObj.GetHistoricalUnitByID(this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.unr[index1]);
        if (historicalUnitById > -1)
        {
          let mut unitByHistorical: i32 =  this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitById, this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data2[index1]);
          if (unitByHistorical > -1 && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.UnitObj[unr].Regime) && (uint) this.CanWeSeeUnit(unr, this.game.Data.UnitObj[unitByHistorical].Regime) > 0U && this.game.HandyFunctionsObj.GetLowestAp(unitByHistorical, true) >=  Math.Round( (this.game.Data.RuleVar[428] * 10f)))
          {
            let mut Seed: i32 =  unr * (x * 500 + y);
            let mut num1: i32 =   Math.Round(Math.Floor( this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data[index1] * ( this.game.HandyFunctionsObj.GetAverageXp(unitByHistorical) / 30.0) *  this.game.HandyFunctionsObj.GetAverageRdn(unitByHistorical) / 100.0));
            Random random = new Random(Seed);
            if (random.Next(1, 100) < num1)
            {
              bool flag = true;
              if (this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data3[index1] < 1 && this.game.Data.TempString[748].Length > 0 & this.game.Data.TempString[749].Length > 0)
              {
                let mut num2: i32 =   Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarRegime(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.TempString[748], this.game.Data.TempString[749], 0)));
                if (num2 > 0)
                {
                  let mut num3: i32 =  this.game.HandyFunctionsObj.Distance(x, y, 0, this.game.Data.UnitObj[unitByHistorical].X, this.game.Data.UnitObj[unitByHistorical].Y, 0, 49);
                  let mut num4: i32 =  100;
                  let mut num5: i32 =  num3;
                  for (let mut index2: i32 =  1; index2 <= num5; index2 += 1)
                    num4 -=  Math.Round( (num4 * num2) / 100.0);
                  if (this.game.Data.TempString[726].Length > 0 & this.game.Data.TempString[727].Length > 0)
                  {
                    let mut num6: i32 =   Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarRegime(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.TempString[726], this.game.Data.TempString[727], 0)));
                    if (num6 > 0)
                      num4 -=  Math.Round( (num4 * num6) / 100.0);
                  }
                  if (random.Next(1, 101) > num4)
                    flag = false;
                }
              }
              if (flag)
                return true;
            }
          }
        }
      }
      return false;
    }

    pub UnitList GetInterceptFireUnits(unr: i32, x: i32, y: i32)
    {
      UnitList interceptFireUnits = UnitList::new();
      SimpleList simpleList = SimpleList::new();
      if ( this.game.Data.RuleVar[428] < 1.0 || Information.IsNothing( this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList))
        return interceptFireUnits;
      let mut counter1: i32 =  this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.counter;
      tweight: i32;
      for (let mut index1: i32 =  0; index1 <= counter1; index1 += 1)
      {
        let mut historicalUnitById: i32 =  this.game.HandyFunctionsObj.GetHistoricalUnitByID(this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.unr[index1]);
        if (historicalUnitById > -1)
        {
          let mut unitByHistorical: i32 =  this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitById, this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data2[index1]);
          if (unitByHistorical > -1)
          {
            if (unr > -1)
            {
              if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.UnitObj[unr].Regime) && (uint) this.CanWeSeeUnit(unr, this.game.Data.UnitObj[unitByHistorical].Regime) > 0U && this.game.HandyFunctionsObj.GetLowestAp(unitByHistorical, true) >=  Math.Round( (this.game.Data.RuleVar[428] * 10f)))
              {
                let mut Seed: i32 =  unr * (x * 500 + y);
                let mut num1: i32 =   Math.Round(Math.Floor( this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data[index1] * ( this.game.HandyFunctionsObj.GetAverageXp(unitByHistorical) / 30.0) *  this.game.HandyFunctionsObj.GetAverageRdn(unitByHistorical) / 100.0));
                Random random = new Random(Seed);
                if (random.Next(1, 100) < num1)
                {
                  bool flag = true;
                  if (this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data3[index1] < 1 && this.game.Data.TempString[748].Length > 0 & this.game.Data.TempString[749].Length > 0)
                  {
                    let mut num2: i32 =   Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarRegime(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.TempString[748], this.game.Data.TempString[749], 0)));
                    if (num2 > 0)
                    {
                      let mut num3: i32 =  this.game.HandyFunctionsObj.Distance(x, y, 0, this.game.Data.UnitObj[unitByHistorical].X, this.game.Data.UnitObj[unitByHistorical].Y, 0, 49);
                      let mut num4: i32 =  100;
                      let mut num5: i32 =  num3;
                      for (let mut index2: i32 =  1; index2 <= num5; index2 += 1)
                        num4 -=  Math.Round( (num4 * num2) / 100.0);
                      if (this.game.Data.TempString[726].Length > 0 & this.game.Data.TempString[727].Length > 0)
                      {
                        let mut num6: i32 =   Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarRegime(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.TempString[726], this.game.Data.TempString[727], 0)));
                        if (num6 > 0)
                          num4 -=  Math.Round( (num4 * num6) / 100.0);
                      }
                      if (random.Next(1, 101) > num4)
                        flag = false;
                    }
                  }
                  if (flag)
                  {
                    tweight =  Math.Round( (this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data[index1] * this.game.HandyFunctionsObj.GetLowestAp(unitByHistorical, true)) / 100.0);
                    simpleList.Add(unitByHistorical, tweight);
                  }
                }
              }
            }
            else if (this.game.HandyFunctionsObj.GetLowestAp(unitByHistorical, true) >=  Math.Round( (this.game.Data.RuleVar[428] * 10f)))
            {
              let mut Seed: i32 =  this.game.Data.Round * (x * 500 + y);
              let mut num7: i32 =   Math.Round(Math.Floor( this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data[index1] * ( this.game.HandyFunctionsObj.GetAverageXp(unitByHistorical) / 30.0) *  this.game.HandyFunctionsObj.GetAverageRdn(unitByHistorical) / 100.0));
              Random random = new Random(Seed);
              if (random.Next(1, 100) < num7)
              {
                bool flag = true;
                if (this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data3[index1] < 1 && this.game.Data.TempString[748].Length > 0 & this.game.Data.TempString[749].Length > 0)
                {
                  let mut num8: i32 =   Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarRegime(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.TempString[748], this.game.Data.TempString[749], 0)));
                  if (num8 > 0)
                  {
                    let mut num9: i32 =  this.game.HandyFunctionsObj.Distance(x, y, 0, this.game.Data.UnitObj[unitByHistorical].X, this.game.Data.UnitObj[unitByHistorical].Y, 0, 49);
                    let mut num10: i32 =  100;
                    let mut num11: i32 =  num9;
                    for (let mut index3: i32 =  1; index3 <= num11; index3 += 1)
                      num10 -=  Math.Round( (num10 * num8) / 100.0);
                    if (this.game.Data.TempString[726].Length > 0 & this.game.Data.TempString[727].Length > 0)
                    {
                      let mut num12: i32 =   Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarRegime(this.game.Data.UnitObj[unitByHistorical].Regime, this.game.Data.TempString[726], this.game.Data.TempString[727], 0)));
                      if (num12 > 0)
                        num10 -=  Math.Round( (num10 * num12) / 100.0);
                    }
                    if (random.Next(1, 101) > num10)
                      flag = false;
                  }
                }
                if (flag)
                {
                  tweight =  Math.Round( (this.game.Data.MapObj[0].HexObj[x, y].tempInterceptList.data[index1] * this.game.HandyFunctionsObj.GetLowestAp(unitByHistorical, true)) / 100.0);
                  simpleList.Add(unitByHistorical, tweight);
                }
              }
            }
          }
        }
      }
      simpleList.ReverseSort();
      for (let mut counter2: i32 =  simpleList.Counter; counter2 >= 1; counter2 += -1)
      {
        if (this.game.Data.UnitObj[simpleList.Id[counter2]].Regime != this.game.Data.UnitObj[simpleList.Id[0]].Regime)
          simpleList.RemoveNr(counter2);
      }
      if (simpleList.Counter == -1)
        return interceptFireUnits;
      let mut num13: i32 =  0;
      let mut num14: i32 =  0;
      let mut counter3: i32 =  simpleList.Counter;
      for (let mut index: i32 =  0; index <= counter3; index += 1)
      {
        let mut unr1: i32 =  simpleList.Id[index];
        num13 += this.game.HandyFunctionsObj.GetLowestAp(unr1, true);
        tweight += simpleList.Weight[index];
        num14 += 1;
      }
      let mut num15: i32 =   Math.Round( num13 /  num14);
      let mut num16: i32 =  tweight;
      let mut num17: i32 =  0;
      let mut num18: i32 =   Math.Round( num16 / (6.0 -  num15 / 20.0));
      let mut counter4: i32 =  simpleList.Counter;
      for (let mut index: i32 =  0; index <= counter4; index += 1)
      {
        interceptFireUnits.add(simpleList.Id[index]);
        num17 += simpleList.Weight[index];
        if (num17 > num18)
          break;
      }
      return interceptFireUnits;
    }

    pub fn ResetInterceptFireCache(regnr: i32)
    {
      let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
          this.game.Data.MapObj[0].HexObj[index1, index2].tempInterceptList = (UnitList) null;
      }
      if ( this.game.Data.RuleVar[428] < 1.0)
        return;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index3: i32 =  0; index3 <= unitCounter; index3 += 1)
      {
        if (this.game.Data.UnitObj[index3].PreDef == -1 && this.game.Data.UnitObj[index3].Regime != regnr & this.game.Data.UnitObj[index3].Historical > -1 && this.game.Data.UnitObj[index3].SOInterceptFire < 100)
        {
          let mut maxDist: i32 =  0;
          let mut num1: i32 =  0;
          let mut sfCount1: i32 =  this.game.Data.UnitObj[index3].SFCount;
          for (let mut index4: i32 =  0; index4 <= sfCount1; index4 += 1)
          {
            let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[index3].SFList[index4]].Type;
            if (this.game.Data.SFTypeObj[type].directRange > maxDist)
              maxDist = this.game.Data.SFTypeObj[type].directRange;
            if (this.game.Data.SFTypeObj[type].ArtRange > maxDist)
              maxDist = this.game.Data.SFTypeObj[type].ArtRange;
            if (this.game.Data.SFTypeObj[type].AutoDestroy)
              num1 = 1;
          }
          if (num1 == 1)
            maxDist = 0;
          if (index3 == 101)
            index3 = index3;
          if (maxDist > 0)
          {
            this.SetTempLos(this.game.Data.UnitObj[index3].X, this.game.Data.UnitObj[index3].Y, maxDist, false);
            let mut num2: i32 =  Math.Max(0, this.game.Data.UnitObj[index3].X - (maxDist + 1));
            let mut num3: i32 =  Math.Min(this.game.Data.MapObj[0].MapWidth, this.game.Data.UnitObj[index3].X + (maxDist + 1));
            let mut num4: i32 =  Math.Max(0, this.game.Data.UnitObj[index3].Y - (maxDist + 1));
            let mut num5: i32 =  Math.Min(this.game.Data.MapObj[0].MapHeight, this.game.Data.UnitObj[index3].Y + (maxDist + 1));
            let mut num6: i32 =  num2;
            let mut num7: i32 =  num3;
            for (let mut x2: i32 =  num6; x2 <= num7; x2 += 1)
            {
              let mut num8: i32 =  num4;
              let mut num9: i32 =  num5;
              for (let mut y2: i32 =  num8; y2 <= num9; y2 += 1)
              {
                let mut num10: i32 =  this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index3].X, this.game.Data.UnitObj[index3].Y, 0, x2, y2, 0);
                if (num10 <= maxDist)
                {
                  let mut tdata: i32 =  0;
                  let mut num11: i32 =  0;
                  let mut sfCount2: i32 =  this.game.Data.UnitObj[index3].SFCount;
                  for (let mut index5: i32 =  0; index5 <= sfCount2; index5 += 1)
                  {
                    let mut sf: i32 =  this.game.Data.UnitObj[index3].SFList[index5];
                    let mut type: i32 =  this.game.Data.SFObj[sf].Type;
                    if (this.game.Data.SFTypeObj[type].ArtRange >= num10)
                    {
                      let mut rawRecon: i32 =  this.game.Data.MapObj[0].HexObj[x2, y2].get_ReconPts(this.game.Data.UnitObj[index3].Regime);
                      if ( this.game.Data.RuleVar[419] > 0.0)
                        rawRecon = this.GetEffectiveRecon(rawRecon);
                      let mut num12: i32 =  rawRecon -  Math.Round( this.game.Data.RuleVar[55]);
                      if (num12 < 0)
                        num12 = 0;
                      let mut num13: i32 =   Math.Round( this.game.Data.RuleVar[55]) +  Math.Round( ( Math.Round( this.game.Data.RuleVar[56]) -  Math.Round( this.game.Data.RuleVar[55])) / 2.0);
                      if (x2 == 14 & y2 == 5)
                        x2 = x2;
                      if (num12 > num13)
                        num12 = num13;
                      let mut num14: i32 =   Math.Round( (num12 * 100) /  num13);
                      if (num14 > 100)
                        num14 = 100;
                      tdata += this.game.Data.SFObj[sf].Qty * num14 * 4;
                      num11 += this.game.Data.SFObj[sf].Qty * 4;
                    }
                    else if (this.game.Data.SFTypeObj[type].ArtRange > 0)
                    {
                      tdata += 0;
                      num11 += this.game.Data.SFObj[sf].Qty;
                    }
                    else if (this.game.Data.SFTypeObj[type].directRange >= num10)
                    {
                      let mut rawRecon: i32 =  this.game.Data.MapObj[0].HexObj[x2, y2].get_ReconPts(this.game.Data.UnitObj[index3].Regime);
                      if ( this.game.Data.RuleVar[419] > 0.0)
                        rawRecon = this.GetEffectiveRecon(rawRecon);
                      let mut num15: i32 =  rawRecon -  Math.Round( this.game.Data.RuleVar[55]);
                      if (num15 < 0)
                        num15 = 0;
                      let mut num16: i32 =   Math.Round( this.game.Data.RuleVar[55]) +  Math.Round( ( Math.Round( this.game.Data.RuleVar[56]) -  Math.Round( this.game.Data.RuleVar[55])) / 2.0);
                      if (x2 == 14 & y2 == 5)
                        x2 = x2;
                      if (num15 > num16)
                        num15 = num16;
                      let mut val1: i32 =   Math.Round( (num15 * 100) /  num16);
                      if (val1 > 100)
                        val1 = 100;
                      let mut num17: i32 =  Math.Min(val1, this.game.EditObj.TempLos[0].Value[x2, y2]);
                      let mut num18: i32 =  num10;
                      for (let mut index6: i32 =  2; index6 <= num18; index6 += 1)
                        num17 =  Math.Round( (num17 * this.game.Data.SFTypeObj[type].directModPerHex) / 100.0);
                      tdata += this.game.Data.SFObj[sf].Qty * num17 * 4;
                      num11 += this.game.Data.SFObj[sf].Qty * 4;
                    }
                    else if (this.game.Data.SFTypeObj[type].directRange > 0)
                    {
                      tdata += 0;
                      num11 += this.game.Data.SFObj[sf].Qty;
                    }
                  }
                  if (num11 > 0)
                    tdata =  Math.Round( tdata /  num11);
                  if (index3 == 152 & x2 == 9 & y2 == 16)
                    index3 = index3;
                  if (tdata >= 10 & tdata > this.game.Data.UnitObj[index3].SOInterceptFire)
                  {
                    if (x2 == 7 & y2 == 4)
                      index3 = index3;
                    if (Information.IsNothing( this.game.Data.MapObj[0].HexObj[x2, y2].tempInterceptList))
                      this.game.Data.MapObj[0].HexObj[x2, y2].tempInterceptList = UnitList::new();
                    this.game.Data.MapObj[0].HexObj[x2, y2].tempInterceptList.add(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index3].Historical].ID, tdata, this.game.Data.UnitObj[index3].HistoricalSubPart, this.game.EditObj.TempLos[0].Value[x2, y2]);
                  }
                }
              }
            }
          }
        }
      }
    }

    pub void SetHexReconAndZOCUnitMoves(
      ox: i32,
      oy: i32,
      omap: i32,
      x: i32,
      y: i32,
      map: i32,
      regnr: i32,
      unr: i32,
      bool ZOCConquest = true,
      bool dontcountair = false,
      bool changezoc = true,
      let mut overrulerecon: i32 =  0)
    {
      numArray: Vec<i32> = new int[1, 1];
      if (omap > -1)
        numArray = new int[this.game.Data.MapObj[omap].MapWidth + 1, this.game.Data.MapObj[omap].MapHeight + 1];
      if (this.game.Data.Round == 0)
        return;
      if ( Math.Round(Conversion.Val( this.game.Data.RuleVar[419])) == 1 & this.game.Data.Product >= 6)
      {
        this.SetHexReconAndZOCUnitMoves_LosRules(ox, oy, omap, x, y, map, regnr, unr, ZOCConquest, dontcountair, changezoc, overrulerecon);
      }
      else
      {
        num1: i32;
        Coordinate coordinate;
        if (ox > -1 & oy > -1)
        {
          let mut num2: i32 =  ox - 5;
          let mut num3: i32 =  ox + 5;
          for (let mut index1: i32 =  num2; index1 <= num3; index1 += 1)
          {
            let mut index2: i32 =  index1;
            if (this.game.Data.MapObj[omap].MapLoop & index2 < 0)
              index2 = this.game.Data.MapObj[omap].MapWidth + index2 + 1;
            if (this.game.Data.MapObj[omap].MapLoop & index2 > this.game.Data.MapObj[omap].MapWidth)
              index2 = index2 - this.game.Data.MapObj[omap].MapWidth - 1;
            if (index2 >= 0 & index2 <= this.game.Data.MapObj[omap].MapWidth)
            {
              let mut num4: i32 =  oy - 5;
              let mut num5: i32 =  oy + 5;
              for (let mut index3: i32 =  num4; index3 <= num5; index3 += 1)
              {
                if (index3 >= 0 & index3 <= this.game.Data.MapObj[omap].MapHeight)
                {
                  num1 = 0;
                  let mut num6: i32 =  0;
                  let mut num7: i32 =  0;
                  let mut num8: i32 =  this.Distance(ox, oy, omap, index2, index3, omap);
                  if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[omap].HexObj[ox, oy].LandscapeType].IsSea)
                  {
                    if (num8 > 0 & num8 <= 4)
                      num7 =  Math.Round( ( this.GetUnitRecon(unr, 1, dontcountair) * this.game.Data.RuleVar[10 + num8]));
                    else if (num8 == 0)
                      num7 =  Math.Round( ( this.GetUnitRecon(unr, 1, dontcountair) * this.game.Data.RuleVar[11]));
                  }
                  else
                  {
                    if (num8 > 0 & num8 <= 4)
                      num7 =  Math.Round( ( this.GetUnitRecon(unr, 0, dontcountair) * this.game.Data.RuleVar[10 + num8]));
                    else if (num8 == 0)
                      num7 =  Math.Round( ( this.GetUnitRecon(unr, 0, dontcountair) * this.game.Data.RuleVar[11]));
                    if (num8 > 0 & num8 <= 4)
                      num6 =  Math.Round( ( num6 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[20 + num8]));
                    if (num8 == 0)
                      num6 =  Math.Round( ( num6 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[21]));
                  }
                  if (changezoc)
                  {
                    HexClass[,] hexObj = this.game.Data.MapObj[omap].HexObj;
                    HexClass[,] hexClassArray = hexObj;
                    let mut index4: i32 =  index2;
                    let mut index5: i32 =  index4;
                    let mut index6: i32 =  index3;
                    let mut index7: i32 =  index6;
                    HexClass hexClass = hexClassArray[index5, index7];
                    let mut Index1: i32 =  regnr;
                    let mut Index2: i32 =  Index1;
                    let mut num9: i32 =  hexObj[index4, index6].get_ZocPts(Index1) - num6;
                    hexClass.set_ZocPts(Index2, num9);
                  }
                  HexClass[,] hexObj1 = this.game.Data.MapObj[omap].HexObj;
                  HexClass[,] hexClassArray1 = hexObj1;
                  let mut index8: i32 =  index2;
                  let mut index9: i32 =  index8;
                  let mut index10: i32 =  index3;
                  let mut index11: i32 =  index10;
                  HexClass hexClass1 = hexClassArray1[index9, index11];
                  let mut Index3: i32 =  regnr;
                  let mut Index4: i32 =  Index3;
                  let mut num10: i32 =  hexObj1[index8, index10].get_ReconPts(Index3) - num7;
                  hexClass1.set_ReconPts(Index4, num10);
                  if (this.ViewFriendlyHexNeighbourOrSelf(index2, index3, omap, regnr) &&  this.game.Data.MapObj[omap].HexObj[index2, index3].get_ReconPts(regnr) <  this.game.Data.RuleVar[8])
                    this.game.Data.MapObj[omap].HexObj[index2, index3].set_ReconPts(regnr,  Math.Round( this.game.Data.RuleVar[8]));
                  numArray[index2, index3] = num7;
                }
              }
            }
          }
          if (this.game.Data.MapObj[omap].HexObj[ox, oy].ConnectionCount > -1)
          {
            let mut num11: i32 =  this.HexNeighbourCount(ox, oy, omap);
            for (let mut tfacing: i32 =  7; tfacing <= num11; tfacing += 1)
            {
              coordinate = this.HexNeighbour(ox, oy, omap, tfacing);
              if (coordinate.onmap)
              {
                let mut unitExtraRecon: i32 =  this.GetUnitExtraRecon(unr, -1, this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LandscapeType, dontcountair);
                HexClass[,] hexObj = this.game.Data.MapObj[coordinate.map].HexObj;
                HexClass[,] hexClassArray = hexObj;
                let mut x1: i32 =  coordinate.x;
                let mut index12: i32 =  x1;
                let mut y1: i32 =  coordinate.y;
                let mut index13: i32 =  y1;
                HexClass hexClass = hexClassArray[index12, index13];
                let mut Index5: i32 =  regnr;
                let mut Index6: i32 =  Index5;
                let mut num12: i32 =  hexObj[x1, y1].get_ReconPts(Index5) - unitExtraRecon;
                hexClass.set_ReconPts(Index6, num12);
              }
            }
          }
        }
        if (x > -1 & y > -1)
        {
          let mut num13: i32 =  x - 5;
          let mut num14: i32 =  x + 5;
          for (let mut index14: i32 =  num13; index14 <= num14; index14 += 1)
          {
            let mut index15: i32 =  index14;
            if (this.game.Data.MapObj[map].MapLoop & index15 < 0)
              index15 = this.game.Data.MapObj[map].MapWidth + index15 + 1;
            if (this.game.Data.MapObj[map].MapLoop & index15 > this.game.Data.MapObj[map].MapWidth)
              index15 = index15 - this.game.Data.MapObj[map].MapWidth - 1;
            if (index15 >= 0 & index15 <= this.game.Data.MapObj[map].MapWidth)
            {
              let mut num15: i32 =  y - 5;
              let mut num16: i32 =  y + 5;
              for (let mut index16: i32 =  num15; index16 <= num16; index16 += 1)
              {
                if (index16 >= 0 & index16 <= this.game.Data.MapObj[map].MapHeight)
                {
                  num1 = 0;
                  let mut num17: i32 =  0;
                  let mut num18: i32 =  0;
                  let mut num19: i32 =  this.Distance(x, y, map, index15, index16, map);
                  if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
                  {
                    if (overrulerecon > 0)
                    {
                      if (num19 > 0 & num19 <= 4)
                        num18 =  Math.Round( ( overrulerecon * this.game.Data.RuleVar[10 + num19]));
                      else if (num19 == 0)
                        num18 =  Math.Round( ( overrulerecon * this.game.Data.RuleVar[11]));
                    }
                    else if (num19 > 0 & num19 <= 4)
                      num18 =  Math.Round( ( this.GetUnitRecon(unr, 1, dontcountair) * this.game.Data.RuleVar[10 + num19]));
                    else if (num19 == 0)
                      num18 =  Math.Round( ( this.GetUnitRecon(unr, 1, dontcountair) * this.game.Data.RuleVar[11]));
                  }
                  else
                  {
                    if (overrulerecon > 0)
                    {
                      if (num19 > 0 & num19 <= 4)
                        num18 =  Math.Round( ( overrulerecon * this.game.Data.RuleVar[10 + num19]));
                      else if (num19 == 0)
                        num18 =  Math.Round( ( overrulerecon * this.game.Data.RuleVar[11]));
                    }
                    else if (num19 > 0 & num19 <= 4)
                      num18 =  Math.Round( ( this.GetUnitRecon(unr, 0, dontcountair) * this.game.Data.RuleVar[10 + num19]));
                    else if (num19 == 0)
                      num18 =  Math.Round( ( this.GetUnitRecon(unr, 0, dontcountair) * this.game.Data.RuleVar[11]));
                    if (unr > -1)
                    {
                      if (num19 > 0 & num19 <= 4)
                        num17 =  Math.Round( ( num17 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[20 + num19]));
                      if (num19 == 0)
                        num17 =  Math.Round( ( num17 +  this.GetUnitZOC(unr) * this.game.Data.RuleVar[21]));
                    }
                  }
                  if (changezoc)
                  {
                    HexClass[,] hexObj = this.game.Data.MapObj[map].HexObj;
                    HexClass[,] hexClassArray = hexObj;
                    let mut index17: i32 =  index15;
                    let mut index18: i32 =  index17;
                    let mut index19: i32 =  index16;
                    let mut index20: i32 =  index19;
                    HexClass hexClass = hexClassArray[index18, index20];
                    let mut Index7: i32 =  regnr;
                    let mut Index8: i32 =  Index7;
                    let mut num20: i32 =  hexObj[index17, index19].get_ZocPts(Index7) + num17;
                    hexClass.set_ZocPts(Index8, num20);
                  }
                  if (this.ViewFriendlyHexNeighbourOrSelf(index15, index16, map, regnr) &&  this.game.Data.MapObj[map].HexObj[index15, index16].get_ReconPts(regnr) <  this.game.Data.RuleVar[8])
                  {
                    this.game.Data.MapObj[map].HexObj[index15, index16].set_ReconPts(regnr,  Math.Round( this.game.Data.RuleVar[8]));
                    this.game.Data.MapObj[map].CanSee = true;
                  }
                  if (num18 > 0)
                  {
                    HexClass[,] hexObj = this.game.Data.MapObj[map].HexObj;
                    HexClass[,] hexClassArray = hexObj;
                    let mut index21: i32 =  index15;
                    let mut index22: i32 =  index21;
                    let mut index23: i32 =  index16;
                    let mut index24: i32 =  index23;
                    HexClass hexClass = hexClassArray[index22, index24];
                    let mut Index9: i32 =  regnr;
                    let mut Index10: i32 =  Index9;
                    let mut num21: i32 =  hexObj[index21, index23].get_ReconPts(Index9) + num18;
                    hexClass.set_ReconPts(Index10, num21);
                    this.game.Data.MapObj[map].CanSee = true;
                  }
                  if (this.game.Data.Turn > -1 && this.game.Data.MapObj[map].HexObj[index15, index16].get_ReconPts(this.game.Data.Turn) > this.game.Data.MapObj[map].HexObj[index15, index16].MaxRecon)
                  {
                    this.game.Data.MapObj[map].HexObj[index15, index16].MaxRecon = this.game.Data.MapObj[map].HexObj[index15, index16].get_ReconPts(this.game.Data.Turn);
                    let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
                    for (let mut index25: i32 =  0; index25 <= regimeCounter; index25 += 1)
                    {
                      if (index25 != regnr && this.game.HandyFunctionsObj.IsAlliedOrSelf(index25, this.game.Data.Turn, true) && this.game.Data.MapObj[map].HexObj[index15, index16].MaxRecon > this.game.Data.MapObj[map].HexObj[index15, index16].get_ReconPts(index25))
                        this.game.Data.MapObj[map].HexObj[index15, index16].set_ReconPts(index25, this.game.Data.MapObj[map].HexObj[index15, index16].MaxRecon);
                    }
                  }
                  if (this.game.Data.MapObj[map].HexObj[index15, index16].get_ReconPts(regnr) >= 1 | !this.game.Data.ShrowdOn)
                  {
                    this.game.Data.MapObj[map].CanSee = true;
                    if (this.game.Data.MapObj[map].HexObj[index15, index16].get_ReconPts(regnr) >= 1)
                      this.game.Data.MapObj[map].HexObj[index15, index16].set_SeeNow(regnr, 1);
                    this.game.Data.MapObj[map].HexObj[index15, index16].set_LastLT(regnr, this.game.Data.MapObj[map].HexObj[index15, index16].LandscapeType);
                    this.game.Data.MapObj[map].HexObj[index15, index16].set_LastSpr(regnr, this.game.Data.MapObj[map].HexObj[index15, index16].SpriteNr);
                    this.game.Data.MapObj[map].HexObj[index15, index16].set_LastReg(regnr, this.game.Data.MapObj[map].HexObj[index15, index16].Regime);
                  }
                }
              }
            }
          }
          if (this.game.Data.MapObj[map].HexObj[x, y].ConnectionCount > -1)
          {
            let mut num22: i32 =  this.HexNeighbourCount(x, y, map);
            for (let mut tfacing: i32 =  7; tfacing <= num22; tfacing += 1)
            {
              coordinate = this.HexNeighbour(x, y, map, tfacing);
              if (coordinate.onmap)
              {
                let mut unitExtraRecon: i32 =  this.GetUnitExtraRecon(unr, -1, this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LandscapeType, dontcountair);
                if (unitExtraRecon > 0)
                  this.game.Data.MapObj[coordinate.map].CanSee = true;
                HexClass[,] hexObj = this.game.Data.MapObj[coordinate.map].HexObj;
                HexClass[,] hexClassArray = hexObj;
                let mut x2: i32 =  coordinate.x;
                let mut index26: i32 =  x2;
                let mut y2: i32 =  coordinate.y;
                let mut index27: i32 =  y2;
                HexClass hexClass = hexClassArray[index26, index27];
                let mut Index11: i32 =  regnr;
                let mut Index12: i32 =  Index11;
                let mut num23: i32 =  hexObj[x2, y2].get_ReconPts(Index11) + unitExtraRecon;
                hexClass.set_ReconPts(Index12, num23);
                if (this.game.Data.Turn > -1 && this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].get_ReconPts(this.game.Data.Turn) > this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].MaxRecon)
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].MaxRecon = this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].get_ReconPts(this.game.Data.Turn);
                if (this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].get_ReconPts(regnr) >= 1 | !this.game.Data.ShrowdOn)
                {
                  this.game.Data.MapObj[map].CanSee = true;
                  if (this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].get_ReconPts(regnr) >= 1)
                    this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].set_SeeNow(regnr, 1);
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].set_LastLT(regnr, this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LandscapeType);
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].set_LastSpr(regnr, this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].SpriteNr);
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].set_LastReg(regnr, this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime);
                }
              }
            }
          }
        }
        if (map > -1 & x > -1)
        {
          let mut num24: i32 =  0;
          do
          {
            let mut num25: i32 =  x - 5;
            let mut num26: i32 =  x + 5;
            for (let mut index: i32 =  num25; index <= num26; index += 1)
            {
              let mut x3: i32 =  index;
              if (this.game.Data.MapObj[map].MapLoop & x3 < 0)
                x3 = this.game.Data.MapObj[map].MapWidth + x3 + 1;
              if (this.game.Data.MapObj[map].MapLoop & x3 > this.game.Data.MapObj[map].MapWidth)
                x3 = x3 - this.game.Data.MapObj[map].MapWidth - 1;
              if (x3 >= 0 & x3 <= this.game.Data.MapObj[map].MapWidth)
              {
                let mut num27: i32 =  y - 5;
                let mut num28: i32 =  y + 5;
                for (let mut y3: i32 =  num27; y3 <= num28; y3 += 1)
                {
                  if (y3 >= 0 & y3 <= this.game.Data.MapObj[map].MapHeight && ZOCConquest)
                    this.game.HandyFunctionsObj.DoZOCConquest(x3, y3, map, regnr, ox, oy, unr);
                }
              }
            }
            num24 += 1;
          }
          while (num24 <= 3);
        }
      }
    }

    pub fn ClearTempCanSee()
    {
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index: i32 =  0; index <= mapCounter; index += 1)
        this.game.Data.MapObj[index].TempCanSee = false;
    }

    pub Coordinate SetTempCanSee(CoordList coordl)
    {
      this.ClearTempCanSee();
      let mut num1: i32 =  -1;
      let mut num2: i32 =  0;
      let mut counter: i32 =  coordl.counter;
      Coordinate coordinate;
      for (let mut index: i32 =  0; index <= counter; index += 1)
      {
        this.game.Data.MapObj[coordl.coord[index].map].TempCanSee = true;
        if (num1 == -1)
        {
          num1 = coordl.coord[index].map;
          coordinate = coordl.coord[index];
        }
        if (coordl.coord[index].map == this.game.EditObj.MapSelected)
          num2 = 1;
      }
      if (!(num2 == 1 | num1 == -1))
        return coordinate;
      coordinate.x = this.game.SelectX;
      coordinate.y = this.game.SelectY;
      coordinate.map = this.game.EditObj.MapSelected;
      coordinate.onmap = false;
      return coordinate;
    }

    pub fn MakeAutoLabels(usetype: i32, let mut onlyNameTypes: i32 =  -1)
    {
      Coordinate coordinate;
      if (onlyNameTypes == -1 | onlyNameTypes == 1)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
        {
          for (let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth; mapWidth >= 0; mapWidth += -1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
            {
              let mut num1: i32 =  0;
              str: String = "";
              let mut num2: i32 =  0;
              if (this.game.Data.MapObj[index1].HexObj[mapWidth, index2].Location > -1)
              {
                if (Strings.Len(this.game.Data.LocObj[this.game.Data.MapObj[index1].HexObj[mapWidth, index2].Location].Name) > 0)
                {
                  num1 = 1;
                  str = this.game.Data.LocObj[this.game.Data.MapObj[index1].HexObj[mapWidth, index2].Location].Name;
                }
                if (num1 == 1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[index1].HexObj[mapWidth, index2].Location].Type].useSmallLabel)
                  num1 = 2;
              }
              coordinate.onmap = true;
              coordinate.x = mapWidth;
              coordinate.y = index2;
              switch (num1)
              {
                case 1:
                  while (coordinate.onmap & Strings.Len(str) > 0)
                  {
                    if ((num2 + 10) % 2 == 0)
                    {
                      this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelType1 = usetype;
                      this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelText1 = Strings.Left(str, 5);
                      str = Strings.Mid(str, 6);
                      if (Strings.Len(str) > 0)
                      {
                        num2 += 1;
                        coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 2);
                      }
                    }
                    else
                    {
                      this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelType2 = usetype;
                      this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelText2 = Strings.Left(str, 5);
                      str = Strings.Mid(str, 6);
                      if (Strings.Len(str) > 0)
                      {
                        num2 += 1;
                        coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 3);
                      }
                    }
                  }
                  break;
                case 2:
                  this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].SmallLabel = str;
                  this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].SmallLabelType = 20;
                  break;
              }
            }
          }
        }
      }
      if (onlyNameTypes == -1 | onlyNameTypes == 2)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index: i32 =  0; index <= mapCounter; index += 1)
        {
          for (let mut mapWidth: i32 =  this.game.Data.MapObj[index].MapWidth; mapWidth >= 0; mapWidth += -1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index].MapHeight;
            for (let mut y: i32 =  0; y <= mapHeight; y += 1)
            {
              let mut num3: i32 =  0;
              str: String = "";
              let mut num4: i32 =  0;
              if (Strings.Len(this.game.Data.MapObj[index].HexObj[mapWidth, y].Name) > 0)
              {
                num3 = 1;
                str = this.game.Data.MapObj[index].HexObj[mapWidth, y].Name;
              }
              if (!this.game.HandyFunctionsObj.HasHexRiver(mapWidth, y, 0))
                num3 = 0;
              coordinate.onmap = true;
              coordinate.x = mapWidth;
              coordinate.y = y;
              if (num3 == 1)
              {
                while (coordinate.onmap & Strings.Len(str) > 0)
                {
                  if ((num4 + 10) % 2 == 0)
                  {
                    this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelType1 = usetype;
                    this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelText1 = Strings.Left(str, 5);
                    str = Strings.Mid(str, 6);
                    if (Strings.Len(str) > 0)
                    {
                      num4 += 1;
                      coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 2);
                    }
                  }
                  else
                  {
                    this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelType2 = usetype;
                    this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelText2 = Strings.Left(str, 5);
                    str = Strings.Mid(str, 6);
                    if (Strings.Len(str) > 0)
                    {
                      num4 += 1;
                      coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 3);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (!(onlyNameTypes == -1 | onlyNameTypes == 3))
        return;
      let mut mapCounter1: i32 =  this.game.Data.MapCounter;
      for (let mut index: i32 =  0; index <= mapCounter1; index += 1)
      {
        for (let mut mapWidth: i32 =  this.game.Data.MapObj[index].MapWidth; mapWidth >= 0; mapWidth += -1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index].MapHeight;
          for (let mut y: i32 =  0; y <= mapHeight; y += 1)
          {
            let mut num5: i32 =  0;
            str: String = "";
            let mut num6: i32 =  0;
            if (Strings.Len(this.game.Data.MapObj[index].HexObj[mapWidth, y].Name) > 0)
            {
              num5 = 1;
              str = this.game.Data.MapObj[index].HexObj[mapWidth, y].Name;
            }
            if (this.game.HandyFunctionsObj.HasHexRiver(mapWidth, y, 0))
              num5 = 0;
            coordinate.onmap = true;
            coordinate.x = mapWidth;
            coordinate.y = y;
            if (num5 == 1)
            {
              while (coordinate.onmap & Strings.Len(str) > 0)
              {
                if ((num6 + 10) % 2 == 0)
                {
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelType1 = usetype;
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelText1 = Strings.Left(str, 5);
                  str = Strings.Mid(str, 6);
                  if (Strings.Len(str) > 0)
                  {
                    num6 += 1;
                    coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 2);
                  }
                }
                else
                {
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelType2 = usetype;
                  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LabelText2 = Strings.Left(str, 5);
                  str = Strings.Mid(str, 6);
                  if (Strings.Len(str) > 0)
                  {
                    num6 += 1;
                    coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 3);
                  }
                }
              }
            }
          }
        }
      }
    }

    pub void MakeSpecificAutoLabels(
      ix: i32,
      iy: i32,
      imap: i32,
      usetype: i32,
      tempstr: String,
      bool OverwriteOK = false)
    {
      let mut num1: i32 =  0;
      let mut num2: i32 =  1;
      str: String = tempstr;
      if (Operators.CompareString(str, "", false) == 0)
        num2 = num2;
      Coordinate coordinate;
      coordinate.onmap = true;
      coordinate.x = ix;
      coordinate.y = iy;
      if (Strings.Len(str) < 1)
      {
        this.game.Data.MapObj[imap].HexObj[ix, iy].LabelType1 = 0;
        this.game.Data.MapObj[imap].HexObj[ix, iy].LabelText1 = "";
      }
      if (ix == 1 & iy == 31)
        ix = ix;
      if (num2 != 1)
        return;
      while (coordinate.onmap & Strings.Len(str) > 0)
      {
        if ((num1 + 10) % 2 == 0)
        {
          if (Strings.Len(this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelText1) < 1 | OverwriteOK)
          {
            this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelType1 = usetype;
            if (usetype <= 5)
            {
              this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelText1 = Strings.Left(str, 5);
              str = Strings.Mid(str, 6);
            }
            else
            {
              this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelText1 = Strings.Left(str, 1);
              str = Strings.Mid(str, 2);
            }
            if (Strings.Len(str) > 0)
            {
              num1 += 1;
              coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 2);
            }
          }
          else
            str = "";
        }
        else if (Strings.Len(this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelText2) < 1 | OverwriteOK)
        {
          this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelType2 = usetype;
          if (usetype <= 5)
          {
            this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelText2 = Strings.Left(str, 5);
            str = Strings.Mid(str, 6);
          }
          else
          {
            this.game.Data.MapObj[imap].HexObj[coordinate.x, coordinate.y].LabelText2 = Strings.Left(str, 1);
            str = Strings.Mid(str, 2);
          }
          if (Strings.Len(str) > 0)
          {
            num1 += 1;
            coordinate = this.game.HandyFunctionsObj.HexNeighbour(coordinate.x, coordinate.y, coordinate.map, 3);
          }
        }
        else
          str = "";
      }
    }

    pub fn SetHexReconAndZOC(x: i32, y: i32, map: i32, regnr: i32)
    {
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        let mut num: i32 =  0;
        if (this.game.Data.UnitObj[unit].Regime == regnr)
          num = 1;
        if (this.game.Data.RegimeObj[regnr].RegimeRel[this.game.Data.UnitObj[unit].Regime] == 2 &  this.game.Data.RuleVar[328] == 1.0)
          num = 1;
        if (num == 1 && this.game.Data.UnitObj[unit].PreDef == -1)
          this.SetHexReconAndZOCUnitMoves(-1, -1, -1, this.game.Data.UnitObj[unit].X, this.game.Data.UnitObj[unit].Y, this.game.Data.UnitObj[unit].Map, regnr, unit, false);
      }
    }

    pub fn CanWeSeeUnit(unr: i32, byregnr: i32) -> i32
    {
      if (this.game.Data.Round == 0 & !this.game.EditObj.firstroundcheck || !this.game.Data.FOWOn || this.game.Data.RegimeObj[byregnr].RegimeRel[this.game.Data.UnitObj[unr].Regime] == 2 &  this.game.Data.RuleVar[328] == 1.0)
        return 1000;
      if (byregnr == -1)
        return 0;
      let mut x: i32 =  this.game.Data.UnitObj[unr].X;
      let mut y: i32 =  this.game.Data.UnitObj[unr].Y;
      let mut map: i32 =  this.game.Data.UnitObj[unr].Map;
      let mut regime: i32 =  this.game.Data.UnitObj[unr].Regime;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[this.game.Data.MapObj[map].HexObj[x, y].UnitList[index]].Regime == byregnr)
          return 9999;
      }
      if (regime == byregnr)
        return 1000;
      let mut rawRecon: i32 =  byregnr != this.game.Data.Turn ? this.game.Data.MapObj[map].HexObj[x, y].get_ReconPts(byregnr) : this.game.Data.MapObj[map].HexObj[x, y].MaxRecon;
      let mut num1: i32 =   this.game.Data.RuleVar[419] <= 0.0 ?  Math.Round( ( this.game.HandyFunctionsObj.GetUnitHide(unr) + this.game.Data.RuleVar[9] +  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].HidePts)) : this.game.HandyFunctionsObj.GetUnitHide(unr);
      num2: i32;
      if ( this.game.Data.RuleVar[419] > 0.0 & rawRecon > 0)
      {
        let mut unitHide: i32 =  this.game.HandyFunctionsObj.GetUnitHide(unr);
        rawRecon = this.GetEffectiveRecon(rawRecon);
        num2 = rawRecon - unitHide;
        if (this.game.Data.UnitObj[unr].Spotted & !this.game.Data.UnitObj[unr].Identified &&  (rawRecon - unitHide * 2) <  this.game.Data.RuleVar[55])
          num2 =  Math.Round( (this.game.Data.RuleVar[55] - 1f));
        if (this.game.Data.UnitObj[unr].Spotted && rawRecon > 0 & num2 < 1)
          num2 = 1;
      }
      else
        num2 = rawRecon - num1 + 1;
      if (this.game.Data.Product >= 6 & rawRecon > 0)
      {
        if (this.game.Data.UnitObj[unr].Spotted && num2 < 1)
          num2 = 1;
        if (this.game.Data.UnitObj[unr].Identified && num2 < 1)
          num2 = 1;
      }
      if ( this.game.Data.RuleVar[816] == 1.0)
        num2 = 0;
      return num2;
    }

    pub fn GetUnitRecon(unr: i32, theater: i32, bool dontdoair = false) -> i32
    {
      if (unr == -1 || this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitRecon: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut theater1: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater;
        let mut num1: i32 =  0;
        if (theater == theater1 | theater1 == 2)
          num1 = 1;
        if (theater1 == 2 & dontdoair)
          num1 = 0;
        if (num1 == 1)
        {
          let mut num2: i32 =  this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ReconPts;
          if ( this.game.Data.RuleVar[419] > 0.0)
          {
            if ( this.game.Data.SFObj[sf].Xp >  this.game.Data.RuleVar[423])
              num2 +=  Math.Round(Math.Floor(0.5 *  num2 *  Math.Min(1f,  (( this.game.Data.SFObj[sf].Xp -  this.game.Data.RuleVar[423]) / (100.0 -  this.game.Data.RuleVar[423])))));
            else
              num2 =  Math.Round(Math.Ceiling(0.5 *  num2)) +  Math.Round(Math.Floor(0.5 *  num2 *  this.game.Data.SFObj[sf].Xp /  this.game.Data.RuleVar[423]));
          }
          unitRecon += num2;
        }
      }
      return unitRecon;
    }

    pub fn GetUnitExtraRecon(unr: i32, theater: i32, Lt: i32, bool dontdoair = false) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitExtraRecon: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut theater1: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater;
        let mut num1: i32 =  0;
        if (theater == theater1 | theater1 == 2 | theater == -1)
          num1 = 1;
        if (theater1 == 2 & dontdoair)
          num1 = 0;
        if (num1 == 1)
        {
          let mut num2: i32 =  this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ExtraRecon[Lt];
          if ( this.game.Data.RuleVar[419] > 0.0)
          {
            if ( this.game.Data.SFObj[sf].Xp >  this.game.Data.RuleVar[423])
              num2 +=  Math.Round(Math.Floor(0.5 *  num2 * ( this.game.Data.SFObj[sf].Xp -  this.game.Data.RuleVar[423]) / (100.0 -  this.game.Data.RuleVar[423])));
            else
              num2 =  Math.Round(Math.Ceiling(0.5 *  num2)) +  Math.Round(Math.Floor(0.5 *  num2 *  this.game.Data.SFObj[sf].Xp /  this.game.Data.RuleVar[423]));
          }
          unitExtraRecon += num2;
        }
      }
      return unitExtraRecon;
    }

    pub fn GetSfEPGrowth(sfnr: i32) -> i32
    {
      let mut index: i32 =  sfnr;
      num: i32;
      return num + this.game.Data.SFObj[index].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[index].Type].EP;
    }

    pub fn GetUnitEP(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitEp: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        unitEp += this.game.Data.SFObj[sf].EP;
      }
      return unitEp;
    }

    pub fn GetUnitEPGrowth(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitEpGrowth: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        unitEpGrowth += this.GetSfEPGrowth(sf);
      }
      return unitEpGrowth;
    }

    pub object GetUnitPeople(unr: i32)
    {
      object[] objArray1 = new object[this.game.Data.PeopleCounter + 1];
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index1: i32 =  0; index1 <= sfCount; index1 += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index1];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (type > -1)
          {
            object[] objArray2 = objArray1;
            object[] objArray3 = objArray2;
            let mut people: i32 =  this.game.Data.SFObj[sf].People;
            let mut index2: i32 =  people;
            object obj = Operators.AddObject(objArray2[people],  (this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty));
            objArray3[index2] = obj;
          }
        }
      }
      else if (this.game.Data.UnitObj[unr].Historical > -1 & this.game.Data.UnitObj[unr].HistoricalSubPart > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].SubParts[this.game.Data.UnitObj[unr].HistoricalSubPart] > -1)
      {
        let mut preDef: i32 =  this.game.HandyFunctionsObj.GetPreDef(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].SubParts[this.game.Data.UnitObj[unr].HistoricalSubPart]);
        if (preDef > -1)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[preDef].SFCount;
          for (let mut index3: i32 =  0; index3 <= sfCount; index3 += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[preDef].SFList[index3];
            let mut type: i32 =  this.game.Data.SFObj[sf].Type;
            if (type > -1)
            {
              object[] objArray4 = objArray1;
              object[] objArray5 = objArray4;
              let mut people: i32 =  this.game.Data.SFObj[sf].People;
              let mut index4: i32 =  people;
              object obj = Operators.AddObject(objArray4[people],  (this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty));
              objArray5[index4] = obj;
            }
          }
        }
      }
      let mut num: i32 =  -1;
      let mut Right: i32 =  0;
      let mut peopleCounter: i32 =  this.game.Data.PeopleCounter;
      for (let mut index: i32 =  0; index <= peopleCounter; index += 1)
      {
        if (Operators.ConditionalCompareObjectGreater(objArray1[index],  Right, false))
        {
          num = index;
          Right = Conversions.ToInteger(objArray1[index]);
        }
      }
      return num > -1 ?  num :  this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].People;
    }

    pub fn GetUnitHide(unr: i32, bool withoutIdentify = false) -> i32
    {
      let mut unitHide: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return  Math.Round( (0.0f + this.game.Data.RuleVar[9]));
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut hidePts: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].HidePts;
        if (hidePts < unitHide)
          unitHide = hidePts;
      }
      if (unitHide == 9999)
        unitHide = 0;
      if ( this.game.Data.RuleVar[419] > 0.0)
      {
        if (this.game.Data.UnitObj[unr].X > -1)
          unitHide += this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType].HidePts;
        let mut num1: i32 =  unitHide;
        let mut averageXp: i32 =  this.game.HandyFunctionsObj.GetAverageXp(unr);
        let mut num2: i32 =   averageXp <=  this.game.Data.RuleVar[423] ?  Math.Round(Math.Ceiling(0.6 *  num1)) +  Math.Round(Math.Floor(0.4 *  num1 *  averageXp /  this.game.Data.RuleVar[423])) : num1 +  Math.Round(Math.Floor(0.4 *  num1 *  Math.Min(1f,  (( averageXp -  this.game.Data.RuleVar[423]) / (80.0 -  this.game.Data.RuleVar[423])))));
        float num3 =  this.GetHexStackPts(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0) / this.game.Data.RuleVar[30];
        float num4 = 1f;
        if ( num3 < 0.333)
          num4 =  (1.39999997615814 - 0.4 * ( num3 / 0.333));
        else if ( num3 > 1.0)
        {
          num4 =  (1.0 - 0.5 * ( num3 - 1.0));
          if ( num4 < 0.0)
            num4 = 0.0f;
        }
        unitHide =  Math.Round( (  Math.Round( ( num2 * num4)) + this.game.Data.RuleVar[9]));
        if (!withoutIdentify)
        {
          if (this.game.Data.UnitObj[unr].Spotted)
            unitHide =  Math.Round( unitHide / 2.0);
          if (this.game.Data.UnitObj[unr].Identified)
            unitHide =  Math.Round( unitHide / 2.0);
        }
      }
      return unitHide;
    }

    pub fn GetUnitZOC(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0)
          num += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ZOCPts;
      }
      return  Math.Round( num * ( this.game.Data.UnitObj[unr].SupplyConsume / 100.0));
    }

    pub fn GetHighestSizeForAirBridge(unr: i32) -> i32
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      sizeForAirBridge: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].SFTypeVar[22] > sizeForAirBridge)
          sizeForAirBridge = this.game.Data.SFTypeObj[type].SFTypeVar[22];
      }
      return sizeForAirBridge;
    }

    pub fn GetUnitWeight(unr: i32, bool includeexcessweight = false, bool includeLisWeight = false) -> i32
    {
      if (unr < 0 | unr > this.game.Data.UnitCounter)
        return 0;
      Left: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          Left += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Weight;
        }
      }
      if (includeexcessweight)
        Left = Conversions.ToInteger(Operators.AddObject( Left, this.GetUnitExcessWeight(unr)));
      if (includeLisWeight)
      {
        let mut counter: i32 =  this.game.Data.UnitObj[unr].items.list.Counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut integer: i32 =  Conversions.ToInteger(this.game.Data.StringListObj[this.game.HandyFunctionsObj.GetStringListByID( Math.Round( this.game.Data.RuleVar[404]))].GetData(0, this.game.Data.UnitObj[unr].items.list.Id[index], 3));
          Left += integer * this.game.Data.UnitObj[unr].items.list.Weight[index];
        }
      }
      if ( this.game.Data.RuleVar[407] > 0.0 && Left < 1)
        Left = 1;
      return Left;
    }

    pub object GetUnitWeightWithoutLandCarryCap(unr: i32, bool includeexcessweight = false)
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      integer: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (!(this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].CarryCap > 0 & this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0) && !this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ConsiderCarry)
          integer += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Weight;
      }
      if (includeexcessweight)
        integer = Conversions.ToInteger(Operators.AddObject( integer, this.GetUnitExcessWeight(unr)));
      return  integer;
    }

    pub object GetUnitSpecialAIWeightWithoutLandCarryCap(unr: i32, bool includeexcessweight = false)
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      integer: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (!(this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].CarryCap > 0 & this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0))
        {
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].MoveType > -1)
          {
            let mut moveType: i32 =  this.game.Data.SFTypeObj[type].MoveType;
            if (this.game.Data.SFObj[sf].MoveType > -1)
              moveType = this.game.Data.SFObj[sf].MoveType;
            if ( moveType ==  this.game.Data.RuleVar[260] |  moveType ==  this.game.Data.RuleVar[261] |  moveType ==  this.game.Data.RuleVar[262])
              integer += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Weight;
          }
        }
      }
      if (includeexcessweight)
        integer = Conversions.ToInteger(Operators.AddObject( integer, this.GetUnitExcessWeight(unr)));
      return  integer;
    }

    pub object GetUnitNonSeaWeight(unr: i32, bool includingaircraft)
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      unitNonSeaWeight: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater != 1 && includingaircraft | !includingaircraft & this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0)
          unitNonSeaWeight += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Weight;
      }
      return  unitNonSeaWeight;
    }

    pub fn GetUnitCarryCap(unr: i32, theater: i32, bool withexcessweight = false) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount1: i32 =  this.game.Data.UnitObj[unr].SFCount;
      integer: i32;
      for (let mut index: i32 =  0; index <= sfCount1; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == theater)
          integer += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].CarryCap;
      }
      if (withexcessweight)
      {
        integer = Conversions.ToInteger(Operators.SubtractObject( integer, this.GetUnitExcessWeight(unr)));
        let mut sfCount2: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount2; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0 & theater == 1)
            integer -= this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Weight * this.game.Data.SFObj[sf].Qty;
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0 & theater == 0 && this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].CarryCap == 0 && !this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ConsiderCarry)
            integer -= this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Weight * this.game.Data.SFObj[sf].Qty;
        }
      }
      return integer;
    }

    pub fn GetUnitCarryCapType(unr: i32, theater: i32, bool withexcessweight = false) -> i32
    {
      SimpleList simpleList = SimpleList::new();
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == theater)
          {
            num: i32;
            num += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].CarryCap;
            if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].CarryCap > 0)
              simpleList.Add(this.game.Data.SFObj[sf].Type, this.game.Data.LandscapeTypeObj[ Math.Round( this.game.Data.RuleVar[38])].MoveCost[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].MoveType]);
          }
        }
        if (simpleList.Counter > -1)
        {
          simpleList.Sort();
          return simpleList.Id[0];
        }
      }
      return -1;
    }

    pub fn GetUnitNonCarryCapType(unr: i32, theater: i32, bool withexcessweight = false) -> i32
    {
      SimpleList simpleList = SimpleList::new();
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == theater)
            simpleList.Add(this.game.Data.SFObj[sf].Type, this.game.Data.LandscapeTypeObj[ Math.Round( this.game.Data.RuleVar[38])].MoveCost[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].MoveType]);
        }
        if (simpleList.Counter > -1)
        {
          simpleList.Sort();
          return simpleList.Id[simpleList.Counter];
        }
      }
      return -1;
    }

    pub fn GetAverageRdn(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Rdn;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageVigor(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Vigor;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn OBSOLETE_LIS_GetAmmoPercentageForAttack(unr: i32, minArtRange: i32, maxArtRange: i32) -> i32
    {
      ItemList itemList = ItemList::new();
      let mut index1: i32 =   Math.Round( this.game.Data.RuleVar[407]) + 2;
      let mut index2: i32 =   Math.Round( this.game.Data.RuleVar[407]) + 8;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index3: i32 =  0; index3 <= sfCount; index3 += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index3];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        let mut tid: i32 =  this.game.Data.SFTypeObj[type].SFTypeVar[index1];
        let mut tweight: i32 =  this.game.Data.SFTypeObj[type].SFTypeVar[index2] * qty;
        if (tid > 0 & tweight > 0)
          itemList.list.AddWeight(tid, tweight);
      }
      SimpleList simpleList = itemList.list.Clone();
      itemList.list.RemoveWeight( this.game.Data.UnitObj[unr].items.list);
      itemList.list.removeWeight0orLower();
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut counter: i32 =  simpleList.Counter;
      for (let mut index4: i32 =  0; index4 <= counter; index4 += 1)
      {
        if (simpleList.Weight[index4] > 0)
        {
          let mut num3: i32 =  simpleList.Weight[index4];
          let mut num4: i32 =  itemList.list.FindWeight(simpleList.Id[index4]);
          if (num4 < 0)
            num4 = 0;
          num1 += num3;
          num2 += num4;
        }
      }
      return 100 -  Math.Round( (100 * num2) /  num1);
    }

    pub HasLimitedCombatRoundArtillery: bool(unr: i32, minArtRange: i32, maxArtRange: i32)
    {
      ItemList itemList = ItemList::new();
      let mut num1: i32 =   Math.Round( this.game.Data.RuleVar[407]) + 2;
      let mut num2: i32 =   Math.Round( this.game.Data.RuleVar[407]) + 8;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        if (this.game.Data.SFTypeObj[type].ArtRange >= minArtRange && this.game.Data.SFTypeObj[type].ArtRange <= maxArtRange && this.game.Data.SFTypeObj[type].EndCombatRound > 0)
          return true;
      }
      return false;
    }

    pub fn GetAverageOffensiveMod_SupplyOnly(unr: i32, bool useSupply = true, bool useFuel = true) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      float num3;
      num4: i32;
      float num5;
      num6: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num7: i32 =   Math.Round(10.0 * 1.25);
        if (useSupply)
          num1 =  Math.Round( num1 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].SupplyForAttack * 10) /  num7 *  this.game.Data.SFObj[sf].Qty);
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttack > 0 && useFuel)
        {
          num2 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttack * num7 * this.game.Data.SFObj[sf].Qty;
          num3 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfFuelAttack *  this.game.Data.SFObj[sf].Qty;
          num4 += this.game.Data.SFObj[sf].Qty;
        }
        if (useSupply)
          num5 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfSupplyAttack *  this.game.Data.SFObj[sf].Qty;
        if (useSupply)
          num6 += this.game.Data.SFObj[sf].Qty;
      }
      if (num6 > 0)
        num5 /=  num6;
      if (num4 > 0)
        num3 /=  num4;
      let mut num8: i32 =  num1 <= 0 ? 100 :  Math.Round(100.0 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Supply /  num1));
      if (num8 < 100)
        num5 *=  (100 - num8) / 100f;
      float num9 = 0.0f;
      if (num6 > 0)
        num9 =  num4 /  num6;
      else if (num4 > 0)
        num9 = 1f;
      let mut num10: i32 =   Math.Round(100.0 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Fuel /  num2));
      let mut num11: i32 =  100;
      if (!(num8 >= 100 & num10 >= 100))
      {
        if (num8 < 100 & num10 >= 100)
          num11 = num8 +  Math.Round( num5 * 100.0 *  (100 - num8) / 100.0);
        else if (num10 < 100 & num8 >= 100)
        {
          let mut num12: i32 =  num10 +  Math.Round( num3 * 100.0 *  (100 - num10) / 100.0);
          num11 =  Math.Round(100.0 * (1.0 -  num9) +  num12 *  num9);
        }
        else
        {
          let mut num13: i32 =  num8 +  Math.Round( num5 * 100.0 *  (100 - num8) / 100.0);
          let mut num14: i32 =  num10 +  Math.Round( num3 * 100.0 *  (100 - num10) / 100.0);
          let mut num15: i32 =   Math.Round(100.0 * (1.0 -  num9) +  num14 *  num9);
          num11 =  Math.Round( (num13 * num15) / 100.0);
        }
      }
      return num11 - 100;
    }

    pub fn GetAverageDefensiveMod_SupplyOnly(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      float num3;
      num4: i32;
      float num5;
      num6: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num7: i32 =  10;
        num1 =  Math.Round( num1 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].SupplyForAttackDef * 20) /  num7 *  this.game.Data.SFObj[sf].Qty);
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttackDef > 0)
        {
          num2 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttackDef * num7 * this.game.Data.SFObj[sf].Qty;
          num3 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfFuelDefense *  this.game.Data.SFObj[sf].Qty;
          num4 += this.game.Data.SFObj[sf].Qty;
        }
        num5 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfSupplyDefense *  this.game.Data.SFObj[sf].Qty;
        num6 += this.game.Data.SFObj[sf].Qty;
      }
      if (num6 > 0)
        num5 /=  num6;
      if (num4 > 0)
        num3 /=  num4;
      let mut num8: i32 =  num1 <= 0 ? 100 :  Math.Round(100.0 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Supply /  num1));
      if (num8 < 100)
        num5 *=  (100 - num8) / 100f;
      float num9 = 0.0f;
      if (num6 > 0)
        num9 =  num4 /  num6;
      else if (num4 > 0)
        num9 = 1f;
      let mut num10: i32 =   Math.Round(100.0 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Fuel /  num2));
      let mut num11: i32 =  100;
      if (!(num8 >= 100 & num10 >= 100))
      {
        if (num8 < 100 & num10 >= 100)
          num11 = num8 +  Math.Round( num5 * 100.0 *  (100 - num8) / 100.0);
        else if (num10 < 100 & num8 >= 100)
        {
          let mut num12: i32 =  num10 +  Math.Round( num3 * 100.0 *  (100 - num10) / 100.0);
          num11 =  Math.Round(100.0 * (1.0 -  num9) +  num12 *  num9);
        }
        else
        {
          let mut num13: i32 =  num8 +  Math.Round( num5 * 100.0 *  (100 - num8) / 100.0);
          let mut num14: i32 =  num10 +  Math.Round( num3 * 100.0 *  (100 - num10) / 100.0);
          let mut num15: i32 =   Math.Round(100.0 * (1.0 -  num9) +  num14 *  num9);
          num11 =  Math.Round( (num13 * num15) / 100.0);
        }
      }
      return num11 - 100;
    }

    pub fn GetAverageOffensiveMod(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount1: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount1; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].OffMod;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      if ( this.game.Data.RuleVar[434] < 1.0 | this.game.Data.Product < 6)
        return  Math.Round(Conversion.Int( num1 /  num2));
      let mut sfCount2: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num3: i32;
      num4: i32;
      float num5;
      num6: i32;
      float num7;
      num8: i32;
      for (let mut index: i32 =  0; index <= sfCount2; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num9: i32 =   Math.Round(10.0 * 1.25);
        num3 =  Math.Round( num3 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].SupplyForAttack * 10) /  num9 *  this.game.Data.SFObj[sf].Qty);
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttack > 0)
        {
          num4 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttack * num9 * this.game.Data.SFObj[sf].Qty;
          num5 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfFuelAttack *  this.game.Data.SFObj[sf].Qty;
          num6 += this.game.Data.SFObj[sf].Qty;
        }
        num7 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfSupplyAttack *  this.game.Data.SFObj[sf].Qty;
        num8 += this.game.Data.SFObj[sf].Qty;
      }
      let mut num10: i32 =   Math.Round(Conversion.Int( num1 /  num2));
      if (num8 > 0)
        num7 /=  num8;
      if (num6 > 0)
        num5 /=  num6;
      let mut num11: i32 =  num3 <= 0 ? 100 :  Math.Round(100.0 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Supply /  num3));
      if (num11 < 100)
        num11 +=  Math.Round( ( (100 - num11) * num7));
      if ( this.game.Data.RuleVar[435] > 0.0 & num4 > 0)
      {
        if (num11 < 80 & num11 > 30)
          num11 = num11;
        float num12 =  num6 /  num8;
        if ( num12 < 1.0)
          num12 *= num5;
        let mut num13: i32 =  num11;
        num11 =  Math.Round( num12 *  num13 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Fuel /  num4)) +  Math.Round( ((1f - num12) *  num13));
      }
      return num10 + num11 - 100;
    }

    pub fn GetAverageDefensiveMod(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount1: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount1; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].DefMod;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      if ( this.game.Data.RuleVar[434] < 1.0 | this.game.Data.Product < 6)
        return  Math.Round(Conversion.Int( num1 /  num2));
      let mut sfCount2: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num3: i32;
      num4: i32;
      float num5;
      num6: i32;
      float num7;
      num8: i32;
      for (let mut index: i32 =  0; index <= sfCount2; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num9: i32 =  10;
        num3 =  Math.Round( num3 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].SupplyForAttackDef * 20) /  num9 *  this.game.Data.SFObj[sf].Qty);
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttackDef > 0)
        {
          num4 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].FuelForAttackDef * num9 * this.game.Data.SFObj[sf].Qty;
          num5 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfFuelDefense *  this.game.Data.SFObj[sf].Qty;
          num6 += this.game.Data.SFObj[sf].Qty;
        }
        num7 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].OutOfSupplyDefense *  this.game.Data.SFObj[sf].Qty;
        num8 += this.game.Data.SFObj[sf].Qty;
      }
      let mut num10: i32 =   Math.Round(Conversion.Int( num1 /  num2));
      if (num8 > 0)
        num7 /=  num8;
      if (num6 > 0)
        num5 /=  num6;
      let mut num11: i32 =  num3 <= 0 ? 100 :  Math.Round(100.0 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Supply /  num3));
      if (num11 < 100)
        num11 +=  Math.Round( ( (100 - num11) * num7));
      if ( this.game.Data.RuleVar[435] > 0.0 & num4 > 0)
      {
        float num12 =  num6 /  num8;
        if ( num12 < 1.0)
          num12 *= num5;
        let mut num13: i32 =  num11;
        num11 =  Math.Round( num12 *  num13 * Math.Min(1.0,  this.game.Data.UnitObj[unr].Fuel /  num4)) +  Math.Round( ((1f - num12) *  num13));
      }
      return num10 + num11 - 100;
    }

    pub fn GetAverageMor(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Mor;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageBaseMor(unr: i32) -> i32
    {
      let mut peopleGroup: i32 =  this.game.Data.PeopleObj[this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].People].PeopleGroup;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.PeopleObj[this.game.Data.SFObj[sf].People].BaseMorale[peopleGroup] * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub CanUnitBecomeHQfor: bool(unr: i32, forunr: i32)
    {
      if (unr == forunr)
        return false;
      let mut index: i32 =  unr;
      let mut num: i32 =  0;
      if ( this.game.Data.RuleVar[344] == 1.0 &  this.game.Data.RuleVar[348] == 1.0 && this.game.Data.UnitObj[unr].Historical > -1 & this.game.Data.UnitObj[forunr].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[forunr].Historical].Type >= this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].Type && !(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[forunr].Historical].Type == 8 & this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].Type == 8) || this.game.Data.UnitObj[unr].Regime != this.game.Data.UnitObj[forunr].Regime && this.game.Data.RegimeObj[this.game.Data.UnitObj[forunr].Regime].UberRegime != this.game.Data.UnitObj[unr].Regime && this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].UberRegime != this.game.Data.UnitObj[forunr].Regime && !(this.game.Data.Turn == this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].UberRegime & this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].UberRegime == this.game.Data.RegimeObj[this.game.Data.UnitObj[forunr].Regime].UberRegime))
        return false;
      for (; this.game.Data.UnitObj[index].HQ > -1; index = this.game.Data.UnitObj[index].HQ)
      {
        if (this.game.Data.UnitObj[index].HQ == forunr)
        {
          num = 1;
          break;
        }
      }
      return num != 1;
    }

    pub fn HowmanyHQsAbove(unr: i32) -> i32
    {
      let mut index: i32 =  unr;
      let mut num: i32 =  0;
      while (this.game.Data.UnitObj[index].HQ > -1)
      {
        index = this.game.Data.UnitObj[index].HQ;
        num += 1;
      }
      return num;
    }

    pub fn HowmanyHQsBelow(unr: i32) -> i32
    {
      let mut num1: i32 =  unr;
      let mut num2: i32 =  0;
      let mut num3: i32 =  0;
      while (num2 == 0)
      {
        num2 = 1;
        num4: i32;
        num4 += 1;
        let mut unitCounter: i32 =  this.game.Data.UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          if (this.game.Data.UnitObj[index].HQ == num1 & this.game.Data.UnitObj[index].IsHQ & this.game.Data.UnitObj[index].PreDef == -1)
          {
            num3 += 1;
            num1 = index;
            num2 = 0;
          }
          if (num4 > 19)
            goto label_8;
        }
      }
label_8:
      return num3;
    }

    pub CanUnitBecomeHQforLoc: bool(unr: i32, locnr: i32) => this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime == this.game.Data.UnitObj[unr].Regime && !(this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn & this.game.Data.Round > 0) && this.game.Data.UnitObj[unr].IsHQ;

    pub fn GetAverageEntrench(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].CurrentEntrench;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageEntrenchAboveAuto(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].X <= -1 || this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num3: i32 =  this.game.Data.SFObj[sf].CurrentEntrench -  Math.Round( this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType].DefBonus[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup]);
        if (num3 < 0)
          num3 = 0;
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * num3;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageAutoEntrench(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].X <= -1 || this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num3: i32 =   Math.Round( this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType].DefBonus[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup]);
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * num3;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageEntrenchPredict(unr: i32, bool StayOnHex) -> i32
    {
      if (this.game.Data.UnitObj[unr].TempX == -1)
        return 0;
      let mut landscapeType: i32 =  this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY].LandscapeType;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut unitGroup: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup;
        let mut num3: i32 =  0;
        if (StayOnHex)
          num3 = this.game.Data.SFObj[sf].CurrentEntrench;
        let mut minimumEntrench: i32 =  this.game.HandyFunctionsObj.GetMinimumEntrench(this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY, 0, unitGroup);
        if (num3 < minimumEntrench)
          num3 = minimumEntrench;
        if (StayOnHex)
          num3 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].EntrenchPower;
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * num3;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageXp(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Xp;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetStackPercent(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        num += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].SupplyCarry;
      }
      let mut supply: i32 =  this.game.Data.UnitObj[unr].Supply;
      return supply == 0 ? 0 :  Math.Round(Conversion.Int( supply /  num * 100.0));
    }

    pub Coordinate FindLandRetreat(
      unr: i32,
      Coordinate coord,
      Neighbours neighbour,
      let mut onlyMoveType: i32 =  -1,
      let mut forceDirection: i32 =  -1)
    {
      int[] numArray1 = new int[7];
      int[] numArray2 = new int[7];
      int[] numArray3 = new int[7];
      int[] numArray4 = new int[7];
      let mut regime: i32 =  this.game.Data.MapObj[coord.map].HexObj[coord.x, coord.y].Regime;
      Coordinate coordinate1 = Coordinate::new();
      coordinate1.onmap = false;
      let mut tfacing1: i32 =  1;
      Coordinate coordinate2;
      do
      {
        coordinate2 = this.HexNeighbourSameMap(coord.x, coord.y, coord.map, tfacing1);
        if (coordinate2.onmap)
        {
          if (this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime == this.game.Data.UnitObj[unr].Regime)
          {
            numArray1[tfacing1] = 1;
            if (this.game.Data.Product == 6)
            {
              let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
              for (let mut Index: i32 =  0; Index <= regimeCounter; Index += 1)
              {
                if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeRel[Index] < 2 & Index != this.game.Data.UnitObj[unr].Regime &&  this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].get_ZocPts(this.game.Data.UnitObj[unr].Regime) *  this.game.Data.RuleVar[40] <  this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].get_ZocPts(Index))
                  numArray1[tfacing1] = 0;
              }
            }
          }
          else
          {
            if (this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime > -1 && this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeRel[this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime] == 2)
              numArray1[tfacing1] = 1;
            if (this.game.Data.Product == 6)
            {
              let mut num: i32 =  0;
              if (this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitCounter == -1)
              {
                num = 1;
                if (this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime > -1)
                {
                  if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeRel[this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime] == 1)
                    num = 0;
                  if ( this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].get_ZocPts(this.game.Data.UnitObj[unr].Regime) *  this.game.Data.RuleVar[40] <  this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].get_ZocPts(this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime))
                    num = 0;
                }
              }
              if (num == 1)
                numArray1[tfacing1] = 1;
            }
          }
          if (this.game.Data.Product == 6 && this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitCounter > -1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitList[0];
            if (this.game.Data.UnitObj[unit].Regime != this.game.Data.UnitObj[unr].Regime && this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeRel[this.game.Data.UnitObj[unit].Regime] < 2)
              numArray1[tfacing1] = 0;
          }
          if (this.game.Data.Product >= 6 && this.game.Data.UnitObj[unr].supplyX > -1 && coordinate2.x == this.game.Data.UnitObj[unr].supplyX && coordinate2.y == this.game.Data.UnitObj[unr].supplyY)
          {
            int[] numArray5 = numArray3;
            int[] numArray6 = numArray5;
            let mut index1: i32 =  tfacing1;
            let mut index2: i32 =  index1;
            let mut num: i32 =  numArray5[index1] + 1;
            numArray6[index2] = num;
          }
        }
        tfacing1 += 1;
      }
      while (tfacing1 <= 6);
      if (this.game.Data.Product == 6 && !Information.IsNothing( neighbour))
      {
        let mut num1: i32 =  0;
        let mut num2: i32 =  1;
        do
        {
          if (neighbour.data[num2 - 1] == 1)
            num1 += 1;
          num2 += 1;
        }
        while (num2 <= 6);
        if (num1 < 5 & neighbour.data[0] == 1 & neighbour.data[1] == 0 & neighbour.data[2] == 1)
        {
          neighbour.data[1] = 1;
          num1 += 1;
        }
        if (num1 < 5 & neighbour.data[1] == 1 & neighbour.data[2] == 0 & neighbour.data[3] == 1)
        {
          neighbour.data[2] = 1;
          num1 += 1;
        }
        if (num1 < 5 & neighbour.data[2] == 1 & neighbour.data[3] == 0 & neighbour.data[4] == 1)
        {
          neighbour.data[3] = 1;
          num1 += 1;
        }
        if (num1 < 5 & neighbour.data[3] == 1 & neighbour.data[4] == 0 & neighbour.data[5] == 1)
        {
          neighbour.data[4] = 1;
          num1 += 1;
        }
        if (num1 < 5 & neighbour.data[4] == 1 & neighbour.data[5] == 0 & neighbour.data[0] == 1)
        {
          neighbour.data[5] = 1;
          num1 += 1;
        }
        if (num1 < 5 & neighbour.data[5] == 1 & neighbour.data[0] == 0 & neighbour.data[1] == 1)
        {
          neighbour.data[0] = 1;
          let mut num3: i32 =  num1 + 1;
        }
      }
      if (!Information.IsNothing( neighbour))
      {
        let mut num: i32 =  1;
        do
        {
          if (neighbour.data[num - 1] == 1)
          {
            let mut index: i32 =  num + 3;
            if (index > 6)
              index -= 6;
            numArray2[index] = -10000;
          }
          num += 1;
        }
        while (num <= 6);
      }
      int[] numArray7 = new int[7];
      let mut tfacing2: i32 =  1;
      do
      {
        coordinate2 = this.HexNeighbourSameMap(coord.x, coord.y, coord.map, tfacing2);
        if (coordinate2.onmap)
        {
          Coordinate coordinate3;
          x: i32;
          if (onlyMoveType > -1)
          {
            coordinate3 = this.MoveApCostPreview2(coord.x, coord.y, this.game.Data.UnitObj[unr].Regime, onlyMoveType, 0, coord.x, coord.y, coord.map, coordinate2.x, coordinate2.y, coordinate2.map);
            x = coordinate3.x;
          }
          else
          {
            coordinate3 = this.MoveApCostPreview(unr, coord.x, coord.y, coord.x, coord.y, coord.map, coordinate2.x, coordinate2.y, coordinate2.map, ignoreFuel: true);
            x = coordinate3.x;
          }
          numArray7[tfacing2] = x;
          int[] numArray8 = numArray2;
          int[] numArray9 = numArray8;
          let mut index3: i32 =  tfacing2;
          let mut index4: i32 =  index3;
          let mut num: i32 =  numArray8[index3] + x;
          numArray9[index4] = num;
          if (x > 999)
            numArray4[tfacing2] = 1;
          if ( this.game.Data.RuleVar[455] > 0.0 & this.game.Data.Product >= 6 && x > 100)
            numArray4[tfacing2] = 1;
          if (this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitCounter > 14 && this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime == -1 | this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime == this.game.Data.UnitObj[unr].Regime)
            numArray4[tfacing2] = 1;
        }
        tfacing2 += 1;
      }
      while (tfacing2 <= 6);
      let mut num4: i32 =  99999;
      let mut tfacing3: i32 =  0;
      if (this.game.Data.Product >= 6)
      {
        SimpleList simpleList = SimpleList::new();
        let mut tid: i32 =  1;
        do
        {
          if (forceDirection == -1 | forceDirection == tid && numArray1[tid] > 0 & numArray4[tid] < 1)
          {
            tweight: i32;
            if (numArray2[tid] < 0 & numArray3[tid] < 1)
              tweight = 4 * numArray7[tid];
            else if (numArray2[tid] < 0 & numArray3[tid] > 0)
              tweight = 1 * numArray7[tid];
            else if (numArray2[tid] >= 0 & numArray3[tid] < 1)
              tweight = 600 * numArray7[tid];
            else if (numArray2[tid] >= 0 & numArray3[tid] > 0)
              tweight = 200 * numArray7[tid];
            simpleList.Add(tid, tweight);
          }
          if (simpleList.Counter > -1)
          {
            simpleList.Sort();
            tfacing3 = simpleList.Id[0];
          }
          tid += 1;
        }
        while (tid <= 6);
      }
      else
      {
        let mut index: i32 =  1;
        do
        {
          if (forceDirection == -1 | forceDirection == index && numArray1[index] > 0 & numArray4[index] < 1 && num4 > numArray2[index])
          {
            num4 = numArray2[index];
            tfacing3 = index;
          }
          index += 1;
        }
        while (index <= 6);
      }
      return tfacing3 > 0 ? this.HexNeighbourSameMap(coord.x, coord.y, coord.map, tfacing3) : coordinate1;
    }

    pub Coordinate FindSeaRetreat(unr: i32, Coordinate coord, Neighbours neighbour)
    {
      int[] numArray1 = new int[7];
      int[] numArray2 = new int[7];
      int[] numArray3 = new int[7];
      let mut regime: i32 =  this.game.Data.MapObj[coord.map].HexObj[coord.x, coord.y].Regime;
      Coordinate coordinate1 = Coordinate::new();
      coordinate1.onmap = false;
      let mut tfacing1: i32 =  1;
      do
      {
        Coordinate coordinate2 = this.HexNeighbourSameMap(coord.x, coord.y, coord.map, tfacing1);
        if (coordinate2.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea)
        {
          if (!this.VisibleEnemyUnitsInHex(coordinate2.x, coordinate2.y, coordinate2.map, this.game.Data.UnitObj[unr].Regime, true))
            numArray1[tfacing1] = 1;
          if (this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitCounter > 14 && this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime == -1 | this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime == this.game.Data.UnitObj[unr].Regime)
            numArray1[tfacing1] = 0;
        }
        tfacing1 += 1;
      }
      while (tfacing1 <= 6);
      if (!Information.IsNothing( neighbour))
      {
        let mut num: i32 =  1;
        do
        {
          if (neighbour.data[num - 1] == 1)
          {
            let mut index: i32 =  num + 3;
            if (index > 6)
              index -= 6;
            numArray2[index] = -10000;
          }
          num += 1;
        }
        while (num <= 6);
      }
      let mut num1: i32 =  99999;
      let mut index1: i32 =  1;
      tfacing2: i32;
      do
      {
        if (numArray1[index1] > 0 && num1 > numArray2[index1])
        {
          num1 = numArray2[index1];
          tfacing2 = index1;
        }
        index1 += 1;
      }
      while (index1 <= 6);
      return tfacing2 > 0 ? this.HexNeighbourSameMap(coord.x, coord.y, coord.map, tfacing2) : coordinate1;
    }

    pub fn HexNeighbourCount(cx: i32, cy: i32, cmap: i32) -> i32
    {
      let mut num: i32 =  6;
      if (this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionCount > -1)
      {
        let mut connectionCount: i32 =  this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionCount;
        for (let mut index: i32 =  0; index <= connectionCount; index += 1)
        {
          if (this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionX[index] == -1)
            num += (this.game.Data.MapObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index]].MapWidth + 1) * (this.game.Data.MapObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index]].MapHeight + 1);
          else
            num += 1;
        }
      }
      return num;
    }

    pub fn HexNeighbourCountAir(cx: i32, cy: i32, cmap: i32) -> i32
    {
      let mut num: i32 =  6;
      if (!Information.IsNothing( this.game.Data.MapObj[cmap].HexObj[cx, cy].tempLISjumps))
      {
        let mut counter: i32 =  this.game.Data.MapObj[cmap].HexObj[cx, cy].tempLISjumps.Counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
          num += 1;
      }
      return num;
    }

    pub fn GetMinimumEntrench(x: i32, y: i32, map: i32, grp: i32) -> i32
    {
      let mut minimumEntrench: i32 =   Math.Round( this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].DefBonus[grp]);
      let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
      if (location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].PictureLT > -1)
        minimumEntrench =  Math.Round( ( minimumEntrench + this.game.Data.LandscapeTypeObj[this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].PictureLT].DefBonus[grp]));
      return minimumEntrench;
    }

    pub fn GetMaximumEntrench(x: i32, y: i32, map: i32, grp: i32) -> i32
    {
      let mut maximumEntrench: i32 =   Math.Round( this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].DefBonusMax[grp]);
      let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
      if (location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].PictureLT > -1)
        maximumEntrench =  Math.Round( ( maximumEntrench + this.game.Data.LandscapeTypeObj[this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].PictureLT].DefBonusMax[grp]));
      return maximumEntrench;
    }

    pub Coordinate HexNeighbour(cx: i32, cy: i32, cmap: i32, tfacing: i32)
    {
      Coordinate coordinate = Coordinate::new();
      num1: i32;
      num2: i32;
      num3: i32;
      if (tfacing == 1)
      {
        num1 = cx;
        num2 = cy - 1;
        num3 = cmap;
      }
      if (tfacing == 2)
      {
        num1 = cx + 1;
        num2 = cy;
        num3 = cmap;
      }
      if (tfacing == 3)
      {
        num1 = cx + 1;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 4)
      {
        num1 = cx;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 5)
      {
        num1 = cx - 1;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 6)
      {
        num1 = cx - 1;
        num2 = cy;
        num3 = cmap;
      }
      if (tfacing > 6)
      {
        let mut num4: i32 =  6;
        if (this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionCount > -1)
        {
          let mut connectionCount: i32 =  this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionCount;
          for (let mut index: i32 =  0; index <= connectionCount; index += 1)
          {
            if (this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionX[index] == -1)
            {
              let mut num5: i32 =  num4;
              num4 += (this.game.Data.MapObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index]].MapWidth + 1) * (this.game.Data.MapObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index]].MapHeight + 1);
              if (tfacing <= num4)
              {
                tfacing -= num5 + 1;
                let mut num6: i32 =  tfacing % (this.game.Data.MapObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index]].MapWidth + 1);
                let mut num7: i32 =   Math.Round(Conversion.Int( tfacing /  (this.game.Data.MapObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index]].MapWidth + 1)));
                let mut connection: i32 =  this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index];
                coordinate.onmap = true;
                coordinate.x = num6;
                coordinate.y = num7;
                coordinate.map = connection;
                return coordinate;
              }
            }
            else
            {
              num4 += 1;
              if (tfacing <= num4)
              {
                coordinate.onmap = true;
                coordinate.x = this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionX[index];
                coordinate.y = this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionY[index];
                coordinate.map = this.game.Data.MapObj[cmap].HexObj[cx, cy].ConnectionMap[index];
                return coordinate;
              }
            }
          }
        }
      }
      else
      {
        if (this.game.Data.MapObj[cmap].MapLoop)
        {
          if (num1 > this.game.Data.MapObj[cmap].MapWidth)
            num1 = 0;
          if (num1 < 0)
            num1 = this.game.Data.MapObj[cmap].MapWidth;
        }
        if ((cx + 10) % 2 == 0 & !(tfacing == 1 | tfacing == 4))
          --num2;
        if (num1 < 0 | num2 < 0 | num1 > this.game.Data.MapObj[cmap].MapWidth | num2 > this.game.Data.MapObj[cmap].MapHeight)
        {
          coordinate.onmap = false;
        }
        else
        {
          coordinate.onmap = true;
          coordinate.x = num1;
          coordinate.y = num2;
          coordinate.map = num3;
        }
      }
      return coordinate;
    }

    pub Coordinate HexNeighbourAir(cx: i32, cy: i32, cmap: i32, tfacing: i32)
    {
      Coordinate coordinate = Coordinate::new();
      num1: i32;
      num2: i32;
      num3: i32;
      if (tfacing == 1)
      {
        num1 = cx;
        num2 = cy - 1;
        num3 = cmap;
      }
      if (tfacing == 2)
      {
        num1 = cx + 1;
        num2 = cy;
        num3 = cmap;
      }
      if (tfacing == 3)
      {
        num1 = cx + 1;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 4)
      {
        num1 = cx;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 5)
      {
        num1 = cx - 1;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 6)
      {
        num1 = cx - 1;
        num2 = cy;
        num3 = cmap;
      }
      if (tfacing > 6)
      {
        let mut num4: i32 =  6;
        if (!Information.IsNothing( this.game.Data.MapObj[cmap].HexObj[cx, cy].tempLISjumps))
        {
          let mut counter: i32 =  this.game.Data.MapObj[cmap].HexObj[cx, cy].tempLISjumps.Counter;
          for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
          {
            num4 += 1;
            if (tfacing == num4)
            {
              let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(DrawMod.TGame.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
              let mut index2: i32 =  this.game.Data.MapObj[cmap].HexObj[cx, cy].tempLISjumps.Id[index1];
              coordinate.onmap = true;
              coordinate.x = Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 3].ToString());
              coordinate.y = Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 4].ToString());
              if (coordinate.x == cx & coordinate.y == cy)
              {
                coordinate.x = Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 1].ToString());
                coordinate.y = Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 2].ToString());
              }
              coordinate.data1 = Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 5].ToString());
              coordinate.data2 = Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 10].ToString());
              coordinate.penalty = Conversions.ToInteger(this.game.Data.StringListObj[stringListById].Data[index2, 7].ToString());
              if (coordinate.data1 < 1)
                coordinate.onmap = false;
              coordinate.map = 0;
              return coordinate;
            }
          }
        }
        coordinate.onmap = false;
        return coordinate;
      }
      if (this.game.Data.MapObj[cmap].MapLoop)
      {
        if (num1 > this.game.Data.MapObj[cmap].MapWidth)
          num1 = 0;
        if (num1 < 0)
          num1 = this.game.Data.MapObj[cmap].MapWidth;
      }
      if ((cx + 10) % 2 == 0 & !(tfacing == 1 | tfacing == 4))
        --num2;
      if (num1 < 0 | num2 < 0 | num1 > this.game.Data.MapObj[cmap].MapWidth | num2 > this.game.Data.MapObj[cmap].MapHeight)
      {
        coordinate.onmap = false;
      }
      else
      {
        coordinate.onmap = true;
        coordinate.data2 = 999;
        coordinate.x = num1;
        coordinate.y = num2;
        coordinate.map = num3;
      }
      return coordinate;
    }

    pub Coordinate HexNeighbourSameMap(cx: i32, cy: i32, cmap: i32, tfacing: i32)
    {
      Coordinate coordinate = Coordinate::new();
      if (this.game.Data.MapObj[cmap].MapLoop &  this.game.Data.RuleVar[329] == 0.0 & this.game.Data.Round > 0 && cx > this.game.Data.MapObj[cmap].MapWidth)
        cx -= this.game.Data.MapObj[cmap].MapWidth + 1;
      num1: i32;
      num2: i32;
      num3: i32;
      if (tfacing == 1)
      {
        num1 = cx;
        num2 = cy - 1;
        num3 = cmap;
      }
      if (tfacing == 2)
      {
        num1 = cx + 1;
        num2 = cy;
        num3 = cmap;
      }
      if (tfacing == 3)
      {
        num1 = cx + 1;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 4)
      {
        num1 = cx;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 5)
      {
        num1 = cx - 1;
        num2 = cy + 1;
        num3 = cmap;
      }
      if (tfacing == 6)
      {
        num1 = cx - 1;
        num2 = cy;
        num3 = cmap;
      }
      if (this.game.Data.MapObj[cmap].MapLoop)
      {
        if (num1 > this.game.Data.MapObj[cmap].MapWidth)
          num1 = 0;
        if (num1 < 0)
          num1 = this.game.Data.MapObj[cmap].MapWidth;
      }
      if ((cx + 10) % 2 == 0 & !(tfacing == 1 | tfacing == 4))
        --num2;
      if (num1 < 0 | num2 < 0 | num1 > this.game.Data.MapObj[cmap].MapWidth | num2 > this.game.Data.MapObj[cmap].MapHeight)
      {
        coordinate.onmap = false;
      }
      else
      {
        coordinate.onmap = true;
        coordinate.x = num1;
        coordinate.y = num2;
        coordinate.map = num3;
      }
      return coordinate;
    }

    pub fn Distance(x1: i32, y1: i32, map1: i32, x2: i32, y2: i32, map2: i32, let mut maxdistance: i32 =  9999) -> i32
    {
      if (this.game.Data.MapObj[0].MapLoop &&  Math.Abs(x2 - x1) > Conversion.Int( this.game.Data.MapObj[0].MapWidth / 2.0) + 1.0)
      {
        if (x1 < x2)
          x1 += this.game.Data.MapObj[0].MapWidth + 1;
        else
          x2 += this.game.Data.MapObj[0].MapWidth + 1;
      }
      let mut val1: i32 =  Math.Abs(x2 - x1);
      let mut num1: i32 =  y2 - y1;
      let mut num2: i32 =  Math.Abs(num1);
      return (x1 + 2) % 2 != 0 ? ((x2 + 2) % 2 != 0 ?  Math.Round(Math.Max( val1,  val1 + ( num2 -  val1 / 2.0))) : (num1 >= 0 ?  Math.Round(Math.Max( val1,  val1 + ( num2 - Math.Ceiling( val1 / 2.0)))) :  Math.Round(Math.Max( val1,  val1 + ( num2 - Math.Floor( val1 / 2.0)))))) : ((x2 + 2) % 2 != 0 ? (num1 <= 0 ?  Math.Round(Math.Max( val1,  val1 + ( num2 - Math.Ceiling( val1 / 2.0)))) :  Math.Round(Math.Max( val1,  val1 + ( num2 - Math.Floor( val1 / 2.0))))) :  Math.Round(Math.Max( val1,  val1 + ( num2 -  val1 / 2.0))));
    }

    pub fn GetMaxStaffIndividuals(unr: i32, int @this) -> i32
    {
      let mut num1: i32 =  unr <= -1 ? this.game.Data.HistoricalUnitObj[@this].StaffSize : this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].StaffSize;
      num2: i32;
      num3: i32;
      if (unr > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].StaffPts > 0)
          {
            num2 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].StaffPts * this.game.Data.SFObj[sf].Qty;
            num3 += this.game.Data.SFObj[sf].Qty;
          }
        }
      }
      if (num2 == 0)
      {
        let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
        for (let mut index: i32 =  0; index <= sfTypeCounter; index += 1)
        {
          if (this.game.Data.SFTypeObj[index].StaffPts > 0)
          {
            num2 += this.game.Data.SFTypeObj[index].StaffPts;
            num3 += 1;
          }
        }
      }
      if (num3 > 0)
        num2 =  Math.Round( num2 /  num3);
      if (num2 == 0)
        num2 = 1;
      return  Math.Round( num1 /  num2);
    }

    pub fn AirSupplyNeeded(targetx: i32, targety: i32, targetmap: i32) -> i32
    {
      let mut num1: i32 =  0;
      this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[857]), 99,  Math.Round( this.game.Data.RuleVar[858]), targetx, targety, targetmap, allowshoredrop: true, SeaBlock: true, BlockAllSea: true);
      index1: i32;
      if (Information.IsNothing( this.game.EditObj.TempValue3[index1]))
        this.game.EditObj.TempValue3[index1] = this.game.EditObj.TempValue[index1].Clone();
      let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
      for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
        for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
          this.game.EditObj.TempValue3[index1].Value[index2, index3] = this.game.EditObj.TempValue[index1].Value[index2, index3];
      }
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index4: i32 =  0; index4 <= unitCounter; index4 += 1)
      {
        if (this.game.Data.UnitObj[index4].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index4].PreDef == -1 & this.game.Data.UnitObj[index4].X > -1)
        {
          let mut x: i32 =  this.game.Data.UnitObj[index4].X;
          let mut y: i32 =  this.game.Data.UnitObj[index4].Y;
          let mut map: i32 =  this.game.Data.UnitObj[index4].Map;
          if ( this.game.EditObj.TempValue[map].Value[x, y] <=  this.game.Data.RuleVar[858])
          {
            let mut num2: i32 =  this.game.Data.UnitObj[index4].SupplyInReq - this.game.Data.UnitObj[index4].SupplyIn;
            if (this.game.Data.UnitObj[index4].IsHQ)
              num2 -= this.game.Data.UnitObj[index4].SupplyReq - this.game.Data.UnitObj[index4].SupplyOut;
            if (0 > num2)
              num2 = 0;
            if ( this.game.EditObj.TempValue[map].Value[x, y] >=  this.game.Data.RuleVar[858] * 0.25)
              num2 =  Math.Round( num2 * 0.75);
            else if ( this.game.EditObj.TempValue[map].Value[x, y] >=  this.game.Data.RuleVar[858] * 0.5)
              num2 =  Math.Round( num2 * 0.5);
            else if ( this.game.EditObj.TempValue[map].Value[x, y] >=  this.game.Data.RuleVar[858] * 0.75)
              num2 =  Math.Round( num2 * 0.25);
            num1 += num2;
          }
        }
      }
      return num1;
    }

    pub fn HexFacing(ox: i32, oy: i32, omap: i32, dx: i32, dy: i32, dmap: i32) -> i32
    {
      let mut num: i32 =  -1;
      if (ox == dx & oy - 1 == dy)
        num = 1;
      if (ox == dx & oy + 1 == dy)
        num = 4;
      if ((ox + 2) % 2 == 0)
      {
        if (ox + 1 == dx & oy - 1 == dy)
          num = 2;
        if (ox + 1 == dx & oy == dy)
          num = 3;
        if (ox - 1 == dx & oy - 1 == dy)
          num = 6;
        if (ox - 1 == dx & oy == dy)
          num = 5;
      }
      else
      {
        if (ox + 1 == dx & oy == dy)
          num = 2;
        if (ox + 1 == dx & oy + 1 == dy)
          num = 3;
        if (ox - 1 == dx & oy == dy)
          num = 6;
        if (ox - 1 == dx & oy + 1 == dy)
          num = 5;
      }
      if (ox == this.game.Data.MapObj[omap].MapWidth)
      {
        if (dx == 0)
        {
          if (oy == dy)
            num = 2;
          if (oy + 1 == dy)
            num = 3;
        }
      }
      else if (ox == 0 && dx == this.game.Data.MapObj[omap].MapWidth)
      {
        if (oy - 1 == dy)
          num = 6;
        if (oy == dy)
          num = 5;
      }
      return num;
    }

    pub VisibleEnemyUnitsInHex: bool(
      x: i32,
      y: i32,
      map: i32,
      regnr: i32,
      bool alsoinvisible = false,
      bool alwaysshowotherregime = false,
      bool testingforattack = false)
    {
      let mut num1: i32 =  0;
      if (this.game.Data.Round == 0)
        return false;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.game.Data.UnitObj[unit].Regime != regnr)
          {
            let mut num2: i32 =  0;
            if (this.game.Data.RegimeObj[regnr].RegimeRel[this.game.Data.UnitObj[unit].Regime] == 2)
              num2 = 1;
            if (this.game.Data.RegimeObj[regnr].RegimeRel[this.game.Data.UnitObj[unit].Regime] == 1 && this.game.Data.MapObj[map].HexObj[x, y].Regime == -1 &  this.game.Data.RuleVar[525] == 1.0)
              num2 = 1;
            if (num2 == 0)
            {
              if (this.IsHostileOrSelf(regnr, this.game.Data.UnitObj[unit].Regime) | this.IsHostileOrSelf(regnr, this.game.Data.MapObj[map].HexObj[x, y].Regime))
              {
                if (!alsoinvisible)
                {
                  if (this.CanWeSeeUnit(unit, regnr) > 0)
                    num1 += 1;
                }
                else
                  num1 += 1;
              }
              else if (!testingforattack)
              {
                if (!alsoinvisible)
                {
                  if (this.CanWeSeeUnit(unit, regnr) > 0 && regnr != this.game.Data.UnitObj[unit].Regime)
                    num1 += 1;
                }
                else if (alwaysshowotherregime && regnr != this.game.Data.UnitObj[unit].Regime)
                  num1 += 1;
              }
            }
          }
        }
      }
      return num1 > 0;
    }

    pub VisibleEnemyUnitsInOrAroundHEx: bool(
      x: i32,
      y: i32,
      map: i32,
      regnr: i32,
      bool alsoinvisible = false,
      bool alwaysshowotherregime = false,
      bool testingforattack = false)
    {
      if (this.VisibleEnemyUnitsInHex(x, y, map, regnr, alsoinvisible, alwaysshowotherregime, testingforattack))
        return true;
      let mut num: i32 =  this.HexNeighbourCount(x, y, map);
      for (let mut tfacing: i32 =  1; tfacing <= num; tfacing += 1)
      {
        Coordinate coordinate = this.HexNeighbour(x, y, map, tfacing);
        if (coordinate.onmap && this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime != regnr && this.VisibleEnemyUnitsInHex(coordinate.x, coordinate.y, coordinate.map, regnr, alsoinvisible, alwaysshowotherregime, testingforattack))
          return true;
      }
      return false;
    }

    pub NonRegimeXUnitsInHex: bool(x: i32, y: i32, map: i32, RegX: i32)
    {
      let mut num: i32 =  0;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          if (this.game.Data.UnitObj[this.game.Data.MapObj[map].HexObj[x, y].UnitList[index]].Regime != RegX)
            num += 1;
        }
      }
      return num > 0;
    }

    pub RegimeXUnitsInHex: bool(x: i32, y: i32, map: i32, RegX: i32)
    {
      let mut num: i32 =  0;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          if (this.game.Data.UnitObj[this.game.Data.MapObj[map].HexObj[x, y].UnitList[index]].Regime == RegX)
            num += 1;
        }
      }
      return num > 0;
    }

    pub Coordinate EPandPowerInHex(x: i32, y: i32, let mut onlyUnr: i32 =  -1)
    {
      let mut index1: i32 =  0;
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut num3: i32 =  0;
      let mut num4: i32 =  0;
      if (this.game.Data.MapObj[index1].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[index1].HexObj[x, y].UnitCounter;
        for (let mut index2: i32 =  0; index2 <= unitCounter; index2 += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[index1].HexObj[x, y].UnitList[index2];
          if (onlyUnr == -1 | unit == onlyUnr)
          {
            let mut sfCount: i32 =  this.game.Data.UnitObj[unit].SFCount;
            for (let mut index3: i32 =  0; index3 <= sfCount; index3 += 1)
            {
              let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index3];
              let mut type: i32 =  this.game.Data.SFObj[sf].Type;
              if (this.game.Data.SFTypeObj[type].EP > 0)
              {
                num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].EP;
                num4 += this.game.Data.SFObj[sf].EP;
                num3 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].EntrenchPower * this.game.Data.SFTypeObj[type].EP;
              }
              else
                num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
            }
          }
        }
      }
      Coordinate coordinate;
      coordinate.x = num1;
      coordinate.y = num2;
      if (num1 > 0)
        coordinate.data1 =  Math.Round( num3 /  num1);
      coordinate.data2 = num4;
      return coordinate;
    }

    pub object Get8Subformations(unr: i32, let mut lessSubs: i32 =  0, bool noLimit = false)
    {
      SimpleList simpleList1 = SimpleList::new();
      int[] numArray1 = new int[101];
      Coordinate reconMinusHide;
      if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn | !this.game.Data.FOWOn | this.game.Data.Round == 0)
        reconMinusHide.x = 3;
      else
        reconMinusHide = this.game.HandyFunctionsObj.GetReconMinusHide(unr, this.game.Data.Turn);
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      let mut num1: i32 =  this.game.Data.UnitObj[unr].PassengerCounter + 1 + lessSubs;
      let mut num2: i32 =  sfCount;
      for (let mut tdata1: i32 =  0; tdata1 <= num2; tdata1 += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[tdata1];
        simpleList1.Add(sf, 0, tdata1, 1);
      }
      let mut counter1: i32 =  simpleList1.Counter;
      bool flag = true;
      if (!noLimit)
      {
        while (counter1 > 7 - num1 & flag)
        {
          flag = false;
          SimpleList simpleList2 = SimpleList::new();
          SimpleList simpleList3 = SimpleList::new();
          let mut counter2: i32 =  simpleList1.Counter;
          for (let mut i: i32 =  0; i <= counter2; i += 1)
          {
            if (simpleList1.Data2[i] == 1 & simpleList1.Data3[i] <= 1)
            {
              let mut index1: i32 =  simpleList1.Id[i];
              let mut type: i32 =  this.game.Data.SFObj[index1].Type;
              let mut reinforcementType: i32 =  this.game.Data.SFTypeObj[type].ReinforcementType;
              let mut nr: i32 =  simpleList2.FindNr(reinforcementType);
              let mut num3: i32 =  this.game.Data.SFObj[index1].Qty;
              if (reconMinusHide.x < 3 && this.game.Data.FOWOn & this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn)
              {
                this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                if (reconMinusHide.x == 2)
                {
                  this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                  float num4 =  reconMinusHide.y / (this.game.Data.RuleVar[56] - this.game.Data.RuleVar[55]);
                  float num5 =  ((1.0 -  num4) * 2.0);
                  num3 =  Math.Round( Conversion.Int((VBMath.Rnd() * num5 + num4) *  num3));
                  if (num3 < 1)
                    num3 = 1;
                  VBMath.Randomize();
                }
              }
              if (nr == -1)
              {
                simpleList2.Add(this.game.Data.SFTypeObj[type].ReinforcementType, 100000 + num3 * this.game.Data.SFTypeObj[type].PowerPts);
              }
              else
              {
                int[] weight = simpleList2.Weight;
                int[] numArray2 = weight;
                let mut index2: i32 =  nr;
                let mut index3: i32 =  index2;
                let mut num6: i32 =  weight[index2] + (100000 + num3 * this.game.Data.SFTypeObj[type].PowerPts);
                numArray2[index3] = num6;
              }
            }
          }
          simpleList2.Sort();
          num7: i32;
          if (simpleList2.Counter <= 7 - num1 && simpleList2.Weight[simpleList2.Counter] > 100000)
          {
            let mut num8: i32 =  simpleList2.Id[simpleList2.Counter];
            SimpleList simpleList4 = SimpleList::new();
            let mut counter3: i32 =  simpleList1.Counter;
            for (let mut i: i32 =  0; i <= counter3; i += 1)
            {
              let mut tid: i32 =  simpleList1.Id[i];
              let mut type: i32 =  this.game.Data.SFObj[tid].Type;
              let mut num9: i32 =  this.game.Data.SFObj[tid].Qty;
              if (reconMinusHide.x < 3 && this.game.Data.FOWOn & this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn)
              {
                this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                if (reconMinusHide.x == 2)
                {
                  this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                  float num10 =  reconMinusHide.y / (this.game.Data.RuleVar[56] - this.game.Data.RuleVar[55]);
                  float num11 =  ((1.0 -  num10) * 2.0);
                  num9 =  Math.Round( Conversion.Int((VBMath.Rnd() * num11 + num10) *  num9));
                  if (num9 < 1)
                    num9 = 1;
                  VBMath.Randomize();
                }
              }
              if (simpleList1.Data2[simpleList1.FindNr(tid)] == 1 & simpleList1.Data3[simpleList1.FindNr(tid)] <= 1 && num8 == this.game.Data.SFTypeObj[type].ReinforcementType)
                simpleList4.Add(tid, num9 * this.game.Data.SFTypeObj[type].PowerPts);
            }
            simpleList4.Sort();
            if (simpleList4.Counter > 0)
            {
              let mut nr1: i32 =  simpleList1.FindNr(simpleList4.Id[0]);
              let mut counter4: i32 =  simpleList1.Counter;
              for (let mut index4: i32 =  0; index4 <= counter4; index4 += 1)
              {
                if (this.game.Data.SFTypeObj[this.game.Data.SFObj[simpleList1.Id[index4]].Type].ReinforcementType == num8 && simpleList1.Data2[index4] > 1)
                {
                  int[] data2 = simpleList1.Data2;
                  int[] numArray3 = data2;
                  let mut index5: i32 =  index4;
                  let mut index6: i32 =  index5;
                  let mut num12: i32 =  data2[index5] + 1;
                  numArray3[index6] = num12;
                }
              }
              num7 = -1;
              let mut tid: i32 =  simpleList4.Id[simpleList4.Counter];
              let mut num13: i32 =  simpleList1.Data1[simpleList1.FindNr(tid)];
              simpleList1.Data1[nr1] = num13;
              simpleList1.Data2[nr1] = 2;
              simpleList1.Data3[nr1] = 1;
              let mut nr2: i32 =  simpleList1.FindNr(simpleList4.Id[simpleList4.Counter]);
              simpleList1.Data3[nr2] = 1;
              --counter1;
              flag = true;
            }
          }
          if (!flag)
          {
            SimpleList simpleList5 = SimpleList::new();
            simpleList3 = SimpleList::new();
            let mut counter5: i32 =  simpleList1.Counter;
            for (let mut i: i32 =  0; i <= counter5; i += 1)
            {
              if (simpleList1.Data2[i] == 1)
              {
                let mut index7: i32 =  simpleList1.Id[i];
                let mut type: i32 =  this.game.Data.SFObj[index7].Type;
                let mut unitGroup: i32 =  this.game.Data.SFTypeObj[type].UnitGroup;
                let mut nr: i32 =  simpleList5.FindNr(unitGroup);
                let mut num14: i32 =  this.game.Data.SFObj[index7].Qty;
                if (reconMinusHide.x < 3 && this.game.Data.FOWOn & this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn)
                {
                  this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                  if (reconMinusHide.x == 2)
                  {
                    this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                    float num15 =  reconMinusHide.y / (this.game.Data.RuleVar[56] - this.game.Data.RuleVar[55]);
                    float num16 =  ((1.0 -  num15) * 2.0);
                    num14 =  Math.Round( Conversion.Int((VBMath.Rnd() * num16 + num15) *  num14));
                    if (num14 < 1)
                      num14 = 1;
                    VBMath.Randomize();
                  }
                }
                if (nr == -1)
                {
                  simpleList5.Add(this.game.Data.SFTypeObj[type].UnitGroup, 100000 + num14 * this.game.Data.SFTypeObj[type].PowerPts);
                }
                else
                {
                  int[] weight = simpleList5.Weight;
                  int[] numArray4 = weight;
                  let mut index8: i32 =  nr;
                  let mut index9: i32 =  index8;
                  let mut num17: i32 =  weight[index8] + (100000 + num14 * this.game.Data.SFTypeObj[type].PowerPts);
                  numArray4[index9] = num17;
                }
              }
            }
            if (simpleList5.Counter <= 7 - num1)
            {
              simpleList5.Sort();
              if (simpleList5.Weight[simpleList5.Counter] > 100000)
              {
                let mut num18: i32 =  simpleList5.Id[simpleList5.Counter];
                SimpleList simpleList6 = SimpleList::new();
                let mut counter6: i32 =  simpleList1.Counter;
                for (let mut i: i32 =  0; i <= counter6; i += 1)
                {
                  let mut tid: i32 =  simpleList1.Id[i];
                  let mut type: i32 =  this.game.Data.SFObj[tid].Type;
                  let mut num19: i32 =  this.game.Data.SFObj[tid].Qty;
                  if (reconMinusHide.x < 3 && this.game.Data.FOWOn & this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn)
                  {
                    this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                    if (reconMinusHide.x == 2)
                    {
                      this.game.HandyFunctionsObj.RandomizeForUnit(unr, i);
                      float num20 =  reconMinusHide.y / (this.game.Data.RuleVar[56] - this.game.Data.RuleVar[55]);
                      float num21 =  ((1.0 -  num20) * 2.0);
                      num19 =  Math.Round( Conversion.Int((VBMath.Rnd() * num21 + num20) *  num19));
                      if (num19 < 1)
                        num19 = 1;
                      VBMath.Randomize();
                    }
                  }
                  if (simpleList1.Data2[simpleList1.FindNr(tid)] == 1 && num18 == this.game.Data.SFTypeObj[type].UnitGroup)
                    simpleList6.Add(tid, num19 * this.game.Data.SFTypeObj[type].PowerPts);
                }
                simpleList6.Sort();
                if (simpleList6.Counter > 0)
                {
                  let mut nr3: i32 =  simpleList1.FindNr(simpleList6.Id[0]);
                  let mut counter7: i32 =  simpleList1.Counter;
                  for (let mut index10: i32 =  0; index10 <= counter7; index10 += 1)
                  {
                    if (this.game.Data.SFTypeObj[this.game.Data.SFObj[simpleList1.Id[index10]].Type].UnitGroup == num18 && simpleList1.Data2[index10] > 1)
                    {
                      int[] data2 = simpleList1.Data2;
                      int[] numArray5 = data2;
                      let mut index11: i32 =  index10;
                      let mut index12: i32 =  index11;
                      let mut num22: i32 =  data2[index11] + 1;
                      numArray5[index12] = num22;
                      simpleList1.Data3[index10] = 2;
                    }
                  }
                  num7 = -1;
                  let mut tid: i32 =  simpleList6.Id[simpleList6.Counter];
                  let mut num23: i32 =  simpleList1.Data1[simpleList1.FindNr(tid)];
                  simpleList1.Data1[nr3] = num23;
                  simpleList1.Data2[nr3] = 2;
                  simpleList1.Data3[nr3] = 2;
                  let mut nr4: i32 =  simpleList1.FindNr(simpleList6.Id[simpleList6.Counter]);
                  simpleList1.Data3[nr4] = 2;
                  --counter1;
                  flag = true;
                }
              }
            }
          }
        }
      }
      let mut counter8: i32 =  simpleList1.Counter;
      for (let mut index13: i32 =  0; index13 <= counter8; index13 += 1)
      {
        let mut num24: i32 =  0;
        let mut num25: i32 =  0;
        let mut counter9: i32 =  simpleList1.Counter;
        for (let mut index14: i32 =  0; index14 <= counter9; index14 += 1)
        {
          if (simpleList1.Data1[index14] == simpleList1.Data1[index13])
          {
            let mut num26: i32 =  this.game.Data.SFObj[simpleList1.Id[index14]].Qty;
            if (reconMinusHide.x < 3 && this.game.Data.FOWOn & this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn)
            {
              this.game.HandyFunctionsObj.RandomizeForUnit(unr, simpleList1.Id[index14]);
              if (reconMinusHide.x == 2)
              {
                this.game.HandyFunctionsObj.RandomizeForUnit(unr, simpleList1.Id[index14]);
                float num27 =  reconMinusHide.y / (this.game.Data.RuleVar[56] - this.game.Data.RuleVar[55]);
                float num28 =  ((1.0 -  num27) * 2.0);
                num26 =  Math.Round( Conversion.Int((VBMath.Rnd() * num28 + num27) *  num26));
                if (num26 < 1)
                  num26 = 1;
                VBMath.Randomize();
              }
            }
            if (this.game.Data.Product >= 6)
            {
              if ( this.game.Data.RuleVar[474] > 0.0)
              {
                let mut num29: i32 =  this.game.Data.transportMovementType[this.game.Data.SFTypeObj[this.game.Data.SFObj[simpleList1.Id[index14]].Type].MoveType];
                num24 += num26 * 1 * Math.Max(1,  Math.Round( this.game.Data.SFTypeObj[this.game.Data.SFObj[simpleList1.Id[index14]].Type].Ratio / 3.0));
              }
              else
                num24 += num26 * this.game.Data.SFTypeObj[this.game.Data.SFObj[simpleList1.Id[index14]].Type].Ratio;
            }
            else
              num24 += num26 * this.game.Data.SFTypeObj[this.game.Data.SFObj[simpleList1.Id[index14]].Type].Ratio;
            num25 += num26 * this.game.Data.SFTypeObj[this.game.Data.SFObj[simpleList1.Id[index14]].Type].Ratio;
          }
        }
        simpleList1.Data4[index13] = num25;
        simpleList1.Data5[index13] = num24;
      }
      SimpleList simpleList7 = SimpleList::new();
      let mut tdata1_1: i32 =  -1;
      while (simpleList1.Counter > -1)
      {
        let mut counter10: i32 =  simpleList1.Counter;
        for (let mut index: i32 =  0; index <= counter10; index += 1)
          simpleList1.Weight[index] = simpleList1.Data5[index];
        simpleList1.ReverseSort();
        let mut num30: i32 =  simpleList1.Data1[0];
        tdata1_1 += 1;
        for (let mut counter11: i32 =  simpleList1.Counter; counter11 >= 0; counter11 += -1)
        {
          if (simpleList1.Data1[counter11] == num30)
          {
            simpleList7.Add(simpleList1.Id[counter11], 0, tdata1_1, simpleList1.Data2[counter11], simpleList1.Data3[counter11], simpleList1.Data4[counter11], simpleList1.Data5[counter11]);
            simpleList1.RemoveNr(counter11);
          }
        }
      }
      return  simpleList7;
    }

    pub ClickOnHexGivesUnit: i32(
      x: i32,
      y: i32,
      map: i32,
      bool firstclick,
      b: i32,
      let mut remx: i32 =  0,
      let mut remy: i32 =  0,
      bool FixedMediumScale = false,
      bool isMainMap = false)
    {
      if (x < 0 | y < 0 | x > this.game.Data.MapObj[map].MapWidth | y > this.game.Data.MapObj[map].MapHeight)
        return -1;
      let mut num1: i32 =  0;
      let mut unitCounter1: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter1; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        if (this.CanWeSeeUnit(unit, this.game.Data.Turn) > 0 && this.game.Data.UnitObj[unit].attachedTo == -1 | this.game.Data.UnitObj[unit].Regime != this.game.Data.Turn)
          num1 += 1;
      }
      if (this.game.EditObj.Zoom == 1 & num1 > 0 & num1 <= 13 & this.game.EditObj.SpreadUnit & !FixedMediumScale && isMainMap | this.game.EditObj.DoCardSlot < 0 & this.game.EditObj.HandCard < 0)
      {
        num2: i32;
        switch (num1)
        {
          case 1:
            num2 = 1;
            break;
          case 2:
            num2 = remx >= 64 ? 1 : 2;
            break;
          case 3:
            num2 = remy <= 48 ? 3 : (remx >= 64 ? 1 : 2);
            break;
          case 4:
            num2 = remy <= 48 ? (remx >= 64 ? 3 : 4) : (remx >= 64 ? 1 : 2);
            break;
          case 5:
            num2 = remy <= 48 ? (remx >= 64 ? 4 : 5) : (remx >= 64 ? 2 : 3);
            if (remx >= 45 & remy >= 30 & remx <= 83 & remy <= 68)
            {
              num2 = 1;
              break;
            }
            break;
          case 6:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 3 : 6) : (remx >= 64 ? 2 : 5)) : (remx >= 64 ? 1 : 4);
            break;
          case 7:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 4 : 7) : (remx >= 64 ? 3 : 6)) : (remx >= 64 ? 2 : 5);
            if (remx >= 45 & remy >= 30 & remx <= 82 & remy <= 67)
            {
              num2 = 1;
              break;
            }
            break;
          case 8:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 5 : 8) : (remx >= 64 ? 4 : 7)) : (remx >= 64 ? 3 : 6);
            if (remx >= 45 & remy >= 19 & remx <= 83 & remy <= 57)
              num2 = 2;
            if (remx >= 45 & remy >= 40 & remx <= 83 & remy <= 78)
            {
              num2 = 1;
              break;
            }
            break;
          case 9:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 6 : 9) : (remx >= 64 ? 5 : 8)) : (remx >= 64 ? 4 : 7);
            if (remx >= 45 & remy >= 8 & remx <= 83 & remy <= 46)
              num2 = 3;
            if (remx >= 45 & remy >= 30 & remx <= 83 & remy <= 68)
              num2 = 2;
            if (remx >= 45 & remy >= 51 & remx <= 83 & remy <= 89)
            {
              num2 = 1;
              break;
            }
            break;
          case 10:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 7 : 10) : (remx >= 64 ? 6 : 9)) : (remx >= 64 ? 5 : 8);
            if (remx >= 45 & remy >= 8 & remx <= 83 & remy <= 46)
              num2 = 4;
            if (remx >= 45 & remy >= 51 & remx <= 83 & remy <= 89)
              num2 = 3;
            if (remx >= 35 & remy >= 19 & remx <= 73 & remy <= 57)
              num2 = 2;
            if (remx >= 56 & remy >= 19 & remx <= 94 & remy <= 57)
            {
              num2 = 1;
              break;
            }
            break;
          case 11:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 8 : 11) : (remx >= 64 ? 7 : 10)) : (remx >= 64 ? 6 : 9);
            if (remx >= 45 & remy >= 8 & remx <= 83 & remy <= 46)
              num2 = 5;
            if (remx >= 45 & remy >= 51 & remx <= 83 & remy <= 89)
              num2 = 4;
            if (remx >= 35 & remy >= 19 & remx <= 73 & remy <= 57)
              num2 = 3;
            if (remx >= 56 & remy >= 19 & remx <= 94 & remy <= 57)
              num2 = 2;
            if (remx >= 35 & remy >= 40 & remx <= 73 & remy <= 78)
            {
              num2 = 1;
              break;
            }
            break;
          case 12:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 9 : 12) : (remx >= 64 ? 8 : 11)) : (remx >= 64 ? 7 : 10);
            if (remx >= 45 & remy >= 8 & remx <= 83 & remy <= 46)
              num2 = 6;
            if (remx >= 45 & remy >= 51 & remx <= 83 & remy <= 89)
              num2 = 5;
            if (remx >= 35 & remy >= 19 & remx <= 73 & remy <= 57)
              num2 = 4;
            if (remx >= 56 & remy >= 19 & remx <= 94 & remy <= 57)
              num2 = 3;
            if (remx >= 35 & remy >= 40 & remx <= 73 & remy <= 78)
              num2 = 2;
            if (remx >= 56 & remy >= 40 & remx <= 94 & remy <= 78)
            {
              num2 = 1;
              break;
            }
            break;
          case 13:
            num2 = remy <= 50 ? (remy <= 30 ? (remx >= 64 ? 10 : 13) : (remx >= 64 ? 9 : 12)) : (remx >= 64 ? 8 : 11);
            if (remx >= 45 & remy >= 8 & remx <= 83 & remy <= 46)
              num2 = 7;
            if (remx >= 45 & remy >= 51 & remx <= 83 & remy <= 89)
              num2 = 6;
            if (remx >= 35 & remy >= 19 & remx <= 73 & remy <= 57)
              num2 = 5;
            if (remx >= 56 & remy >= 19 & remx <= 94 & remy <= 57)
              num2 = 4;
            if (remx >= 35 & remy >= 40 & remx <= 73 & remy <= 78)
              num2 = 3;
            if (remx >= 56 & remy >= 40 & remx <= 94 & remy <= 78)
              num2 = 2;
            if (remx >= 45 & remy >= 30 & remx <= 83 & remy <= 68)
            {
              num2 = 1;
              break;
            }
            break;
        }
        let mut num3: i32 =  0;
        if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
        {
          let mut unitCounter2: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter2; index += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
            if (this.CanWeSeeUnit(unit, this.game.Data.Turn) > 0 &&  this.game.Data.RuleVar[474] < 1.0 | this.game.Data.UnitObj[unit].Regime != this.game.Data.Turn | this.game.Data.UnitObj[unit].attachedTo == -1)
            {
              num3 += 1;
              if (num2 == num3)
                return unit;
            }
          }
          return -1;
        }
      }
      if (firstclick)
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter <= -1)
          return -1;
        let mut unitCounter3: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter3; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.CanWeSeeUnit(unit, this.game.Data.Turn) > 0 &&  this.game.Data.RuleVar[474] < 1.0 | this.game.Data.UnitObj[unit].Regime != this.game.Data.Turn | this.game.Data.UnitObj[unit].attachedTo == -1)
            return unit;
        }
        return -1;
      }
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter <= -1)
        return -1;
      if (b == 2)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[this.game.Data.MapObj[map].HexObj[x, y].UnitCounter];
        if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > 0)
        {
          for (let mut unitCounter4: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter; unitCounter4 >= 1; unitCounter4 += -1)
            this.game.Data.MapObj[map].HexObj[x, y].UnitList[unitCounter4] = this.game.Data.MapObj[map].HexObj[x, y].UnitList[unitCounter4 - 1];
        }
        this.game.Data.MapObj[map].HexObj[x, y].UnitList[0] = unit;
      }
      else
      {
        let mut unitCounter5: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index1: i32 =  0; index1 <= unitCounter5; index1 += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[0];
          if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > 0)
          {
            let mut num4: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter - 1;
            for (let mut index2: i32 =  0; index2 <= num4; index2 += 1)
              this.game.Data.MapObj[map].HexObj[x, y].UnitList[index2] = this.game.Data.MapObj[map].HexObj[x, y].UnitList[index2 + 1];
          }
          this.game.Data.MapObj[map].HexObj[x, y].UnitList[this.game.Data.MapObj[map].HexObj[x, y].UnitCounter] = unit;
          if (this.game.Data.UnitObj[this.game.Data.MapObj[map].HexObj[x, y].UnitList[0]].Regime != this.game.Data.Turn |  this.game.Data.RuleVar[474] < 1.0 | this.game.Data.UnitObj[this.game.Data.MapObj[map].HexObj[x, y].UnitList[0]].attachedTo == -1)
            break;
        }
      }
      return this.ClickOnHexGivesUnit(x, y, map, true, b, FixedMediumScale: FixedMediumScale);
    }

    pub fn RedimFuzzyPresumed(setvalue: i32)
    {
      if (this.game.EditObj.FuzzyPresumed.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.FuzzyPresumed = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.FuzzyPresumed[index1]) && this.game.EditObj.FuzzyPresumed[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.FuzzyPresumed[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.FuzzyPresumed[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.FuzzyPresumed[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.FuzzyPresumed[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimFuzzyReal(setvalue: i32)
    {
      if (this.game.EditObj.FuzzyReal.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.FuzzyReal = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.FuzzyReal[index1]) && this.game.EditObj.FuzzyReal[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.FuzzyReal[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.FuzzyReal[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.FuzzyReal[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.FuzzyReal[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempValue(setvalue: i32)
    {
      if (this.game.EditObj.TempValue.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.TempValue = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempValue[index1]) && this.game.EditObj.TempValue[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempValue[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempValue[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempValue[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempValue[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempLosValue(setvalue: i32)
    {
      if (this.game.EditObj.TempLos.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.TempLos = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempLos[index1]) && this.game.EditObj.TempLos[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempLos[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempLos[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempLos[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempLos[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempObstructValue(setvalue: i32)
    {
      if (this.game.EditObj.TempObstruct.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.TempObstruct = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempObstruct[index1]) && this.game.EditObj.TempObstruct[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempObstruct[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempObstruct[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempObstruct[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempObstruct[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempValueSpecial(setvalue: i32)
    {
      if (this.game.EditObj.TempValue.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.TempValueSpecial = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempValueSpecial[index1]) && this.game.EditObj.TempValueSpecial[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempValueSpecial[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempValueSpecial[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempValueSpecial[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempValueSpecial[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempValueSpecial2(setvalue: i32)
    {
      if (this.game.EditObj.TempValue.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.TempValueSpecial2 = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempValueSpecial2[index1]) && this.game.EditObj.TempValueSpecial2[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempValueSpecial2[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempValueSpecial2[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempValueSpecial2[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempValueSpecial2[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempValue2(setvalue: i32)
    {
      if (this.game.EditObj.TempValue2.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.TempValue2 = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempValue2[index1]) && this.game.EditObj.TempValue2[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempValue2[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempValue2[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempValue2[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempValue2[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempValue3(setvalue: i32)
    {
      this.game.EditObj.TempValue3 = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempValue3[index1]) && this.game.EditObj.TempValue3[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempValue3[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempValue3[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempValue3[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempValue3[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempValue4(setvalue: i32)
    {
      this.game.EditObj.TempValue4 = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempValue4[index1]) && this.game.EditObj.TempValue4[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempValue4[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
              this.game.EditObj.TempValue4[index1].Value[index2, index3] = setvalue;
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempValue4[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
              this.game.EditObj.TempValue4[index1].Value[index4, index5] = setvalue;
          }
        }
      }
    }

    pub fn RedimTempSup(setvalue: i32)
    {
      this.game.EditObj.TempSup = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        this.game.EditObj.TempSup[index1] = new MapMatrix2(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
            this.game.EditObj.TempSup[index1].Value[index2, index3] = setvalue;
        }
      }
    }

    pub float GetAirFieldStackModifier(x: i32, y: i32, let mut extraAirUnr: i32 =  -1)
    {
      let mut unitCounter: i32 =  this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      num1: i32;
      for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[0].HexObj[x, y].UnitList[index1];
        if (unit == extraAirUnr)
          extraAirUnr = -1;
        let mut sfCount: i32 =  this.game.Data.UnitObj[unit].SFCount;
        for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index2];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
            num1 += this.game.Data.SFTypeObj[type].Frontage * this.game.Data.SFObj[sf].Qty;
        }
      }
      if (extraAirUnr > -1)
      {
        let mut index3: i32 =  extraAirUnr;
        let mut sfCount: i32 =  this.game.Data.UnitObj[index3].SFCount;
        for (let mut index4: i32 =  0; index4 <= sfCount; index4 += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[index3].SFList[index4];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
            num1 += this.game.Data.SFTypeObj[type].Frontage * this.game.Data.SFObj[sf].Qty;
        }
      }
      let mut location: i32 =  this.game.Data.MapObj[0].HexObj[x, y].Location;
      if (location <= -1 || this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].TopAirStack <= 0)
        return 1f;
      float num2 =  this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].TopAirStack /  num1;
      return  num2 > 1.0 ? 1f : num2;
    }

    pub fn RedimTempSupCameFrom()
    {
      this.game.EditObj.TempSupCameFrom = new MapMatrix2Coordinate[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        this.game.EditObj.TempSupCameFrom[index1] = new MapMatrix2Coordinate(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
            this.game.EditObj.TempSupCameFrom[index1].Value[index2, index3].onmap = false;
        }
      }
    }

    pub fn BlowBridgeHexHighlight(x: i32, y: i32, map: i32)
    {
      this.RedimTempValue(9999);
      this.RedimTempValueSpecial(0);
      let mut tfacing: i32 =  1;
      do
      {
        Coordinate coordinate = this.HexNeighbourSameMap(x, y, map, tfacing);
        if (coordinate.onmap && this.game.Data.MapObj[map].HexObj[x, y].Bridge[tfacing - 1])
        {
          this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y] = 0;
          this.game.EditObj.TempCoordList.AddCoord(coordinate.x, coordinate.y, coordinate.map);
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
    }

    pub GetRoadOrBridgeBuildCostString: String(x1: i32, y1: i32, z1: i32, x2: i32, y2: i32, z2: i32)
    {
      let mut num1: i32 =  this.game.HandyFunctionsObj.HexFacing(x1, y1, z1, x2, y2, z2);
      bridgeBuildCostString: String;
      if (num1 > -1)
      {
        let mut num2: i32 =  !( this.game.Data.RuleVar[483] > 0.0 & this.game.Data.Product >= 6) ? this.game.HandyFunctionsObj.MoveApCostPreview(this.game.EditObj.OrderUnit, this.game.Data.UnitObj[this.game.EditObj.OrderUnit].X, this.game.Data.UnitObj[this.game.EditObj.OrderUnit].Y, x1, y1, z1, x2, y2, z2, EngineerTest: true).x : this.game.HandyFunctionsObj.MoveApCostPreview(this.game.EditObj.OrderUnit, this.game.Data.UnitObj[this.game.EditObj.OrderUnit].X, this.game.Data.UnitObj[this.game.EditObj.OrderUnit].Y, x1, y1, z1, x2, y2, z2, true, EngineerTest: true).x;
        if (num2 <= this.game.HandyFunctionsObj.GetLowestAp(this.game.EditObj.OrderUnit))
        {
          let mut facing: i32 =  num1 - 1;
          str: String;
          if ( this.game.Data.RuleVar[32] == -1.0)
          {
            if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing] > -1 & this.game.HandyFunctionsObj.CanConstructBridge(this.game.EditObj.OrderUnit, x1, y1, z1, facing))
            {
              if ( this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[823] +  this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.RuleVar[825])
              {
                str =  this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier >  this.game.HandyFunctionsObj.GetUnitEP(this.game.EditObj.OrderUnit) ? "Cannot build bridge here. Not enough EP. Bridge Cost: " + Conversion.Str(  ( this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP" : "Bridge Cost: " + Conversion.Str(  ( this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP";
              }
              else
              {
                str = "Cannot build bridge here. Not enough resources to build bridge.";
                if ( this.game.Data.RuleVar[822] > -1.0)
                  str = str + ". " + Conversion.Str(  ( this.game.Data.RuleVar[823] +  this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.RuleVar[825])) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
              }
            }
            else
              str = "Cannot build bridge here. Not a suitable location for a bridge.";
          }
          else if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing] > -1 & !this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].Bridge[facing])
          {
            if ( this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[823] +  this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.RuleVar[825])
            {
              if ( this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier <=  this.game.HandyFunctionsObj.GetUnitEP(this.game.EditObj.OrderUnit))
              {
                str = "Bridge Cost: " + Conversion.Str(  ( this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP";
                if ( this.game.Data.RuleVar[822] > -1.0)
                  str = str + ". " + Conversion.Str(  ( this.game.Data.RuleVar[823] +  this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.RuleVar[825])) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
              }
              else
                str = "Cannot build bridge here. Not enough EP. Bridge Cost: " + Conversion.Str(  ( this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP";
            }
            else
            {
              str = "Cannot build bridge here. Not enough resources to build bridge.";
              if ( this.game.Data.RuleVar[822] > -1.0)
                str = str + ". " + Conversion.Str(  ( this.game.Data.RuleVar[823] +  this.game.Data.RiverTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RiverType[facing]].BridgeCostModifier *  this.game.Data.RuleVar[825])) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
            }
          }
          else if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].CanBuildRoad)
            str = "You are not allowed to build roads on this landscape type";
          else if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RoadType[facing] == -1)
          {
            if ( this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[823])
            {
              if ( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier <=  this.game.HandyFunctionsObj.GetUnitEP(this.game.EditObj.OrderUnit))
              {
                str = "Road Cost: " + Conversion.Str(  ( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP";
                if ( this.game.Data.RuleVar[822] > -1.0)
                  str = str + ". " + Conversion.Str( this.game.Data.RuleVar[823]) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
              }
              else
                str = "Cannot build bridge here. Not enough EP. Road Cost: " + Conversion.Str(  ( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP";
            }
            else
            {
              str = "Cannot build bridge here. Not enough resources to construct road.";
              if ( this.game.Data.RuleVar[822] > -1.0)
                str = str + ". " + Conversion.Str( this.game.Data.RuleVar[823]) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
            }
          }
          else if ( this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RoadType[facing] ==  this.game.Data.RuleVar[821])
          {
            if ( this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[824])
            {
              if ( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[821])].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier <=  this.game.HandyFunctionsObj.GetUnitEP(this.game.EditObj.OrderUnit))
              {
                str = "Road Cost: " + Conversion.Str(  ( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[821])].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP";
                if ( this.game.Data.RuleVar[822] > -1.0)
                  str = str + ". " + Conversion.Str( this.game.Data.RuleVar[823]) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
              }
              else
                str = "Cannot build bridge here. Not enough EP. Road Cost: " + Conversion.Str(  ( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[821])].EPCost *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x2, y2].LandscapeType].RoadCostModifier)) + " EP";
            }
            else
            {
              str = "Cannot build bridge here. Not enough resources to construct road.";
              if ( this.game.Data.RuleVar[822] > -1.0)
                str = str + ". " + Conversion.Str( this.game.Data.RuleVar[823]) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
            }
          }
          else if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RoadType[facing] > -1 & !( this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[x1, y1].RoadType[facing] ==  this.game.Data.RuleVar[821] &  this.game.Data.RuleVar[820] > -1.0))
          {
            str = "Cannot build bridge here. Already road/bridge here.";
          }
          else
          {
            str = "Cannot build bridge here. Not enough resources to construct road.";
            if ( this.game.Data.RuleVar[822] > -1.0)
              str = str + ". " + Conversion.Str( this.game.Data.RuleVar[823]) + "x " + this.game.Data.RegimeSlotName[ Math.Round( this.game.Data.RuleVar[822])];
          }
          bridgeBuildCostString = str + " AP Cost = " + num2.ToString();
        }
        else
          bridgeBuildCostString = "Cannot build bridge here. Not enough AP. ";
      }
      else
        bridgeBuildCostString = "Cannot build bridge here. Not a neighbouring hex.";
      return bridgeBuildCostString;
    }

    pub fn InfraHexHighlight(x: i32, y: i32, map: i32, unr: i32)
    {
      this.RedimTempValue(9999);
      this.RedimTempValueSpecial(0);
      let mut tfacing: i32 =  1;
      do
      {
        Coordinate coordinate1 = this.HexNeighbour(x, y, map, tfacing);
        if (coordinate1.onmap)
        {
          let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[coordinate1.x, coordinate1.y].LandscapeType;
          if (this.game.Data.LandscapeTypeObj[landscapeType].CanBuildRoad && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[map].HexObj[coordinate1.x, coordinate1.y].Regime, this.game.Data.UnitObj[unr].Regime) |  this.game.Data.RuleVar[483] > 0.0 & this.game.Data.Product >= 6 && !this.HasUnitAirSF(unr) & !this.HasUnitNavySF(unr))
          {
            Coordinate coordinate2;
            x1: i32;
            if ( this.game.Data.RuleVar[483] > 0.0 & this.game.Data.Product >= 6)
            {
              coordinate2 = this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, x, y, map, coordinate1.x, coordinate1.y, map, true, EngineerTest: true);
              x1 = coordinate2.x;
            }
            else
            {
              coordinate2 = this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, x, y, map, coordinate1.x, coordinate1.y, map, EngineerTest: true);
              x1 = coordinate2.x;
            }
            if (x1 <= this.GetLowestAp(unr))
            {
              if (this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[map].HexObj[x, y].Bridge[tfacing - 1])
              {
                if ( this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
                {
                  let mut num: i32 =  0;
                  if ( this.game.Data.RuleVar[822] > -1.0)
                  {
                    if (this.game.Data.MapObj[map].HexObj[x, y].RoadType[tfacing - 1] == -1)
                    {
                      if ( this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[825] *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1]].BridgeCostModifier +  this.game.Data.RuleVar[823])
                        num = 1;
                    }
                    else if ( this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[825] *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1]].BridgeCostModifier)
                      num = 1;
                  }
                  else
                    num = 1;
                  if (num == 1 && this.CanConstructBridge(unr, x, y, map, tfacing - 1))
                  {
                    this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = 0;
                    this.game.EditObj.TempCoordList.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
                  }
                }
              }
              else if (this.game.Data.MapObj[map].HexObj[x, y].RoadType[tfacing - 1] == -1)
              {
                if ( this.game.Data.RuleVar[32] > -1.0 &&  this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[823] &&  this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier *  this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
                {
                  this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = 0;
                  this.game.EditObj.TempCoordList.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
                }
              }
              else if ( this.game.Data.RuleVar[820] > -1.0 &  this.game.Data.MapObj[map].HexObj[x, y].RoadType[tfacing - 1] ==  this.game.Data.RuleVar[821] &&  this.game.Data.RuleVar[32] > -1.0 &&  this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[824] &&  this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost *  this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
              {
                this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = 0;
                this.game.EditObj.TempCoordList.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
              }
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
    }

    pub CoordList InfraHexHighlight_getCoordList(x: i32, y: i32, map: i32, unr: i32)
    {
      CoordList coordList = CoordList::new();
      let mut tfacing: i32 =  1;
      do
      {
        Coordinate coordinate1 = this.HexNeighbour(x, y, map, tfacing);
        if (coordinate1.onmap)
        {
          let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[coordinate1.x, coordinate1.y].LandscapeType;
          if (this.game.Data.LandscapeTypeObj[landscapeType].CanBuildRoad && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[map].HexObj[coordinate1.x, coordinate1.y].Regime, this.game.Data.UnitObj[unr].Regime) |  this.game.Data.RuleVar[483] > 0.0 & this.game.Data.Product >= 6 && !this.HasUnitAirSF(unr) & !this.HasUnitNavySF(unr))
          {
            Coordinate coordinate2;
            x1: i32;
            if ( this.game.Data.RuleVar[483] > 0.0 & this.game.Data.Product >= 6)
            {
              coordinate2 = this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, x, y, map, coordinate1.x, coordinate1.y, map, true, EngineerTest: true);
              x1 = coordinate2.x;
            }
            else
            {
              coordinate2 = this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, x, y, map, coordinate1.x, coordinate1.y, map, EngineerTest: true);
              x1 = coordinate2.x;
            }
            if (x1 <= this.GetLowestAp(unr))
            {
              if (this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[map].HexObj[x, y].Bridge[tfacing - 1])
              {
                if ( this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
                {
                  let mut num: i32 =  0;
                  if ( this.game.Data.RuleVar[822] > -1.0)
                  {
                    if (this.game.Data.MapObj[map].HexObj[x, y].RoadType[tfacing - 1] == -1)
                    {
                      if ( this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[825] *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1]].BridgeCostModifier +  this.game.Data.RuleVar[823])
                        num = 1;
                    }
                    else if ( this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[825] *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1]].BridgeCostModifier)
                      num = 1;
                  }
                  else
                    num = 1;
                  if (num == 1 && this.CanConstructBridge(unr, x, y, map, tfacing - 1))
                    coordList.AddCoord(coordinate1.x, coordinate1.y, 0);
                }
              }
              else if (this.game.Data.MapObj[map].HexObj[x, y].RoadType[tfacing - 1] == -1)
              {
                if ( this.game.Data.RuleVar[32] > -1.0 &&  this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[823] &&  this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier *  this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
                  coordList.AddCoord(coordinate1.x, coordinate1.y, 0);
              }
              else if ( this.game.Data.RuleVar[820] > -1.0 &  this.game.Data.MapObj[map].HexObj[x, y].RoadType[tfacing - 1] ==  this.game.Data.RuleVar[821] &&  this.game.Data.RuleVar[32] > -1.0 &&  this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[824] &&  this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost *  this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
                coordList.AddCoord(coordinate1.x, coordinate1.y, 0);
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      return coordList;
    }

    pub CanUnitLoadaUnit: bool(unr: i32)
    {
      let mut x: i32 =  this.game.Data.UnitObj[unr].X;
      let mut y: i32 =  this.game.Data.UnitObj[unr].Y;
      let mut map: i32 =  this.game.Data.UnitObj[unr].Map;
      if (this.game.Data.UnitObj[unr].IsHQ)
        return false;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (unit != unr && !this.HasUnitAirSF(unit) & !this.HasUnitNavySF(unit))
            return true;
        }
      }
      let mut num: i32 =  this.HexNeighbourCount(x, y, map);
      for (let mut tfacing: i32 =  1; tfacing <= num; tfacing += 1)
      {
        Coordinate coordinate = this.HexNeighbour(x, y, map, tfacing);
        if (coordinate.onmap && this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].UnitCounter > -1)
        {
          let mut unitCounter: i32 =  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter; index += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].UnitList[index];
            if (unit != unr && !this.HasUnitAirSF(unit) & !this.HasUnitNavySF(unit))
              return true;
          }
        }
      }
      return false;
    }

    pub fn GetRegime(nr: i32) -> i32
    {
      if (nr == -1)
        return -1;
      return this.game.Data.RegimeObj[nr].UberRegime > -1 ? this.game.Data.RegimeObj[nr].UberRegime : nr;
    }

    pub CanWeBlowBridge: bool(x: i32, y: i32, map: i32)
    {
      let mut num: i32 =  0;
      let mut tfacing: i32 =  1;
      do
      {
        if (this.HexNeighbourSameMap(x, y, map, tfacing).onmap && this.game.Data.MapObj[map].HexObj[x, y].Bridge[tfacing - 1])
          num += 1;
        tfacing += 1;
      }
      while (tfacing <= 6);
      return num > 0;
    }

    pub fn RedimTempString(setvalue: String)
    {
      this.game.EditObj.TempString = new MapMatrix2String[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        this.game.EditObj.TempString[index1] = new MapMatrix2String(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
            this.game.EditObj.TempString[index1].Value[index2, index3] = setvalue;
        }
      }
    }

    pub fn RedimTempString2(setvalue: String)
    {
      this.game.EditObj.TempString2 = new MapMatrix2String[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        this.game.EditObj.TempString2[index1] = new MapMatrix2String(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
            this.game.EditObj.TempString2[index1].Value[index2, index3] = setvalue;
        }
      }
    }

    pub fn RedimTempAttack(bool setvalue)
    {
      this.game.EditObj.TempAttack = new MapMatrix2Plus6[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        this.game.EditObj.TempAttack[index1] = new MapMatrix2Plus6(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
        if (setvalue)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
            {
              let mut index4: i32 =  0;
              do
              {
                this.game.EditObj.TempAttack[index1].Value[index2, index3, index4] = setvalue;
                index4 += 1;
              }
              while (index4 <= 5);
            }
          }
        }
      }
    }

    pub fn RedimTempCameFrom()
    {
      if (this.game.EditObj.TempCameFrom.GetUpperBound(0) < this.game.Data.MapCounter)
        this.game.EditObj.TempCameFrom = new MapMatrix2Coordinate[this.game.Data.MapCounter + 1];
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        if (!Information.IsNothing( this.game.EditObj.TempCameFrom[index1]) && this.game.EditObj.TempCameFrom[index1].Width == this.game.Data.MapObj[index1].MapWidth && this.game.EditObj.TempCameFrom[index1].Height == this.game.Data.MapObj[index1].MapHeight)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
            {
              this.game.EditObj.TempCameFrom[index1].Value[index2, index3].onmap = false;
              this.game.EditObj.TempCameFrom[index1].Value[index2, index3].data1 = 0;
              this.game.EditObj.TempCameFrom[index1].Value[index2, index3].data2 = 0;
            }
          }
          num = 1;
        }
        if (num == 0)
        {
          this.game.EditObj.TempCameFrom[index1] = new MapMatrix2Coordinate(this.game.Data.MapObj[index1].MapWidth, this.game.Data.MapObj[index1].MapHeight);
          let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
          for (let mut index4: i32 =  0; index4 <= mapWidth; index4 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
            for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
            {
              this.game.EditObj.TempCameFrom[index1].Value[index4, index5].onmap = false;
              this.game.EditObj.TempCameFrom[index1].Value[index4, index5].data1 = 0;
              this.game.EditObj.TempCameFrom[index1].Value[index4, index5].data2 = 0;
            }
          }
        }
      }
    }

    pub CoordList MakeMovePredictionGroup(
      unr: i32,
      x: i32,
      y: i32,
      map: i32,
      bool airfieldcheck = true,
      bool OneHexFurther = false,
      bool PredictAirOnly = false,
      bool ClearSea = false,
      bool attack = false,
      let mut increaseap: i32 =  0,
      bool attackoptions = false,
      bool ismove = false,
      bool EngineerTest = false,
      bool NoAPPenalty = false,
      bool IsTransfer = false,
      bool OnlyFrontline = false,
      bool isparadrop = false,
      let mut gothroughenemy: i32 =  -1)
    {
      this.RedimTempValue3(0);
      let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
      if (this.game.Data.Product >= 6)
      {
        this.game.EditObj.tempGroupMoveCounter = -1;
        this.game.EditObj.tempGroupMovePath = new CoordList[30];
        this.game.EditObj.tempGroupMoveCameFrom = new CoordList[30];
        this.game.EditObj.tempGroupMoveUnr = new int[30];
      }
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut unr1: i32 =  0; unr1 <= unitCounter1; unr1 += 1)
      {
        bool flag = false;
        if ( this.game.Data.RuleVar[954] == 0.0)
        {
          if (this.game.Data.UnitObj[unr1].PreDef == -1 & this.game.Data.UnitObj[unr1].Historical == historical & (this.game.Data.UnitObj[unr1].Regime == this.game.Data.Turn | this.game.Data.Round == 0))
            flag = true;
        }
        else if (this.game.Data.UnitObj[unr1].PreDef == -1 & this.game.Data.UnitObj[unr1].X == this.game.Data.UnitObj[unr].X & this.game.Data.UnitObj[unr1].Y == this.game.Data.UnitObj[unr].Y & (this.game.Data.UnitObj[unr1].Regime == this.game.Data.Turn | this.game.Data.Round == 0))
          flag = true;
        if (this.game.Data.UnitObj[unr1].attachedTo > -1)
          flag = false;
        if (flag)
        {
          this.MakeMovePrediction(unr1, this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y, this.game.Data.UnitObj[unr1].Map, airfieldcheck, OneHexFurther, PredictAirOnly, ClearSea, attack, increaseap, attackoptions, ismove, EngineerTest, NoAPPenalty, IsTransfer, OnlyFrontline, isparadrop, gothroughenemy);
          if (this.game.Data.Product >= 6)
          {
            this += 1.game.EditObj.tempGroupMoveCounter;
            this.game.EditObj.tempGroupMovePath[this.game.EditObj.tempGroupMoveCounter] = CoordList::new();
            this.game.EditObj.tempGroupMoveCameFrom[this.game.EditObj.tempGroupMoveCounter] = CoordList::new();
            this.game.EditObj.tempGroupMoveUnr[this.game.EditObj.tempGroupMoveCounter] = unr1;
          }
          let mut mapCounter: i32 =  this.game.Data.MapCounter;
          for (let mut index: i32 =  0; index <= mapCounter; index += 1)
          {
            let mut mapWidth: i32 =  this.game.Data.MapObj[index].MapWidth;
            for (let mut x1: i32 =  0; x1 <= mapWidth; x1 += 1)
            {
              let mut mapHeight: i32 =  this.game.Data.MapObj[index].MapHeight;
              for (let mut y1: i32 =  0; y1 <= mapHeight; y1 += 1)
              {
                if (this.game.Data.Product >= 6 && this.game.EditObj.TempValue[index].Value[x1, y1] < 999)
                {
                  if (this.game.EditObj.TempCameFrom[index].Value[x1, y1].onmap)
                    this.game.EditObj.tempGroupMoveCameFrom[this.game.EditObj.tempGroupMoveCounter].AddCoord(x1, y1, 0, this.game.EditObj.TempCameFrom[index].Value[x1, y1].x, this.game.EditObj.TempCameFrom[index].Value[x1, y1].y);
                  else
                    this.game.EditObj.tempGroupMoveCameFrom[this.game.EditObj.tempGroupMoveCounter].AddCoord(x1, y1, 0, -1, -1);
                }
                if (this.game.EditObj.TempValue[index].Value[x1, y1] > this.game.EditObj.TempValue3[index].Value[x1, y1])
                  this.game.EditObj.TempValue3[index].Value[x1, y1] = this.game.EditObj.TempValue[index].Value[x1, y1];
              }
            }
          }
        }
      }
      CoordList coordList = CoordList::new();
      let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter2; index += 1)
      {
        bool flag = false;
        if ( this.game.Data.RuleVar[954] == 0.0)
        {
          if (this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].Historical == historical & (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn | this.game.Data.Round == 0))
            flag = true;
        }
        else if (this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].X == this.game.Data.UnitObj[unr].X & this.game.Data.UnitObj[index].Y == this.game.Data.UnitObj[unr].Y & (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn | this.game.Data.Round == 0))
          flag = true;
        if (flag)
        {
          let mut mapCounter: i32 =  this.game.Data.MapCounter;
          for (let mut map1: i32 =  0; map1 <= mapCounter; map1 += 1)
          {
            let mut mapWidth: i32 =  this.game.Data.MapObj[map1].MapWidth;
            for (let mut x2: i32 =  0; x2 <= mapWidth; x2 += 1)
            {
              let mut mapHeight: i32 =  this.game.Data.MapObj[map1].MapHeight;
              for (let mut y2: i32 =  0; y2 <= mapHeight; y2 += 1)
              {
                this.game.EditObj.TempValue[map1].Value[x2, y2] = this.game.EditObj.TempValue3[map1].Value[x2, y2];
                if (this.game.EditObj.TempValue3[map1].Value[x2, y2] < 9999)
                  coordList.AddCoord(x2, y2, map1);
              }
            }
          }
        }
      }
      return coordList;
    }

    pub fn SE1_GetUnitMinimumAirfieldLevel(unr: i32) -> i32
    {
      let mut minimumAirfieldLevel: i32 =  0;
      if (this.game.Data.Product == 7)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
          {
            let mut num: i32 =  this.game.Data.SFTypeObj[type].SFTypeVar[18];
            if (num > minimumAirfieldLevel)
              minimumAirfieldLevel = num;
          }
        }
      }
      return minimumAirfieldLevel;
    }

    pub CoordList MakeMovePrediction(
      unr: i32,
      x: i32,
      y: i32,
      map: i32,
      bool airfieldcheck = true,
      bool OneHexFurther = false,
      bool PredictAirOnly = false,
      bool ClearSea = false,
      bool attack = false,
      let mut increaseap: i32 =  0,
      bool attackoptions = false,
      bool ismove = false,
      bool EngineerTest = false,
      bool NoAPPenalty = false,
      bool IsTransfer = false,
      bool OnlyFrontline = false,
      bool isparadrop = false,
      let mut gothroughenemy: i32 =  -1,
      bool onlyThroughOneEnemyHex = false,
      bool dist1alwaysDirect = false)
    {
      Coordinate[] arySrc1 = new Coordinate[1];
      bool[] arySrc2 = new bool[1];
      CoordList coordList1 = CoordList::new();
      this.RedimTempString("");
      this.RedimTempValue(9999);
      this.RedimTempValueSpecial(0);
      this.RedimTempValueSpecial2(0);
      this.RedimTempValue2(0);
      this.RedimTempCameFrom();
      this.RedimTempAttack(false);
      if (unr == -1 || this.game.Data.UnitObj[unr].X == -1 | this.game.Data.UnitObj[unr].Y == -1 || x == -1 | y == -1)
      {
        CoordList coordList2;
        return coordList2;
      }
      let mut num1: i32 =  0;
      if (this.game.Data.Product == 7 && this.HasUnitAirSF(unr))
      {
        num1 = this.SE1_GetUnitMinimumAirfieldLevel(unr);
        if (num1 > 0)
        {
          if (this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].Location > -1)
          {
            if (this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].Location].tempAirfieldLevel < num1)
            {
              this.game.EditObj.TempValue[map].Value[x, y] = 0;
              coordList1.AddCoord(x, y, map);
              return coordList1;
            }
          }
          else
          {
            this.game.EditObj.TempValue[map].Value[x, y] = 0;
            coordList1.AddCoord(x, y, map);
            return coordList1;
          }
        }
      }
      let mut num2: i32 =  0;
      arySrc1[0].x = x;
      arySrc1[0].y = y;
      arySrc1[0].map = map;
      arySrc2[0] = true;
      this.game.EditObj.TempValue[map].Value[x, y] = 0;
      let mut num3: i32 =  1;
      coordList1.AddCoord(x, y, map);
      if (this.game.Data.UnitObj[unr].attachedTo > -1)
        this.game.EditObj.TempValue[map].Value[x, y] = 9999;
      let mut num4: i32 =  -1;
      if (this.game.HandyFunctionsObj.HasUnitAirSF(unr) && !this.game.HandyFunctionsObj.HasUnitlandSF(unr) | PredictAirOnly && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) | PredictAirOnly)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
          {
            if (this.game.Data.SFTypeObj[type].AirAPRule > num4)
            {
              num4 = this.game.Data.SFTypeObj[type].AirAPRule;
              if (this.game.Data.SFTypeObj[type].Theater == 2 && IsTransfer)
                num4 =  Math.Round(Conversion.Int( num4 / 2.0));
              if (this.game.Data.SFTypeObj[type].Theater == 2 & !IsTransfer & ismove)
                num4 =  Math.Round(Conversion.Int( num4 / 2.0));
            }
            if (this.game.Data.SFTypeObj[type].AirAPRule == -1)
            {
              num4 = -1;
              break;
            }
          }
        }
      }
      CoordList coordList3 = CoordList::new();
      Coordinate coordinate1;
      Coordinate coordinate2;
      while (num3 > 0)
      {
        num3 = 0;
        let mut num5: i32 =  num2;
        for (let mut index1: i32 =  0; index1 <= num5; index1 += 1)
        {
          if (arySrc2[index1])
          {
            let mut num6: i32 =  this.GetLowestAp(unr) + increaseap;
            if (this.game.Data.UnitObj[unr].TransportCounter > -1)
            {
              let mut transportCounter: i32 =  this.game.Data.UnitObj[unr].TransportCounter;
              for (let mut index2: i32 =  0; index2 <= transportCounter; index2 += 1)
              {
                let mut num7: i32 =  this.GetLowestAp(this.game.Data.UnitObj[unr].TransportList[index2]) + increaseap;
                if (num7 < num6)
                  num6 = num7;
              }
            }
            if (this.HasUnitNavySF(unr) & this.HasUnitAirSF(unr) & !PredictAirOnly)
              num6 = this.GetLowestAp(unr, true) + increaseap;
            if (this.HasUnitNavySF(unr) & this.HasUnitAirSF(unr) & PredictAirOnly)
              num6 = this.GetLowestAirAp(unr) + increaseap;
            if (!this.HasUnitNavySF(unr) & this.HasUnitAirSF(unr) & PredictAirOnly)
              num6 = this.GetLowestAirAp(unr) + increaseap;
            let mut num8: i32 =  this.HexNeighbourCount(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map);
            for (let mut tfacing: i32 =  1; tfacing <= num8; tfacing += 1)
            {
              coordinate1 = this.HexNeighbour(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, tfacing);
              if (dist1alwaysDirect & coordinate1.onmap)
              {
                let mut counter: i32 =  coordList3.counter;
                for (let mut index3: i32 =  0; index3 <= counter; index3 += 1)
                {
                  if (coordList3.coord[index3].x == coordinate1.x & coordList3.coord[index3].y == coordinate1.y)
                  {
                    coordinate1.onmap = false;
                    break;
                  }
                }
              }
              if (coordinate1.onmap)
              {
                let mut PreviousAPspent: i32 =  this.game.EditObj.TempValue[arySrc1[index1].map].Value[arySrc1[index1].x, arySrc1[index1].y];
                val2: i32;
                if ( this.game.Data.RuleVar[814] == 1.0)
                  val2 = PreviousAPspent + 0;
                else if (num4 == -1)
                {
                  let mut num9: i32 =  0;
                  if (this.game.Data.UnitObj[unr].TransportCounter > -1)
                  {
                    let mut transportCounter: i32 =  this.game.Data.UnitObj[unr].TransportCounter;
                    for (let mut index4: i32 =  0; index4 <= transportCounter; index4 += 1)
                    {
                      Coordinate coordinate3 = this.MoveApCostPreview(this.game.Data.UnitObj[unr].TransportList[index4], x, y, arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, coordinate1.x, coordinate1.y, coordinate1.map, attack, PredictAirOnly, ismove: ismove, EngineerTest: EngineerTest, NoAPPenalty: NoAPPenalty, IsTransfer: IsTransfer, Frontlineonly: OnlyFrontline, GoThroughEnemy: gothroughenemy, PreviousAPspent: PreviousAPspent);
                      if (coordinate3.x > num9)
                        num9 = coordinate3.x;
                    }
                  }
                  coordinate2 = this.MoveApCostPreview(unr, x, y, arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, coordinate1.x, coordinate1.y, coordinate1.map, attack, PredictAirOnly, ismove: ismove, EngineerTest: EngineerTest, NoAPPenalty: NoAPPenalty, IsTransfer: IsTransfer, Frontlineonly: OnlyFrontline, GoThroughEnemy: gothroughenemy, PreviousAPspent: PreviousAPspent);
                  if (this.game.Data.UnitObj[unr].TransportCounter > -1 & num9 > coordinate2.x)
                    coordinate2.x = num9;
                  val2 = PreviousAPspent + coordinate2.x;
                }
                else
                  val2 = PreviousAPspent + num4;
                this.game.EditObj.TempString[coordinate1.map].Value[coordinate1.x, coordinate1.y] = this.game.EditObj.ApTempString;
                if (onlyThroughOneEnemyHex && this.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].Regime, this.game.Data.Turn) && this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].UnitCounter > -1)
                  val2 = 999999;
                if (val2 <= num6 & val2 < this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y])
                {
                  let mut index5: i32 =  -1;
                  let mut num10: i32 =  num2;
                  for (let mut index6: i32 =  0; index6 <= num10; index6 += 1)
                  {
                    if (arySrc2[index6] && arySrc1[index6].map == coordinate1.map & arySrc1[index6].x == coordinate1.x & arySrc1[index6].y == coordinate1.y)
                    {
                      index5 = index6;
                      break;
                    }
                  }
                  if (index5 == -1)
                  {
                    let mut num11: i32 =  num2;
                    for (let mut index7: i32 =  0; index7 <= num11; index7 += 1)
                    {
                      if (!arySrc2[index7])
                      {
                        index5 = index7;
                        break;
                      }
                    }
                  }
                  if (index5 == -1)
                  {
                    num2 += 1;
                    arySrc1 = (Coordinate[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc1, (Array) new Coordinate[num2 + 1]);
                    arySrc2 = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc2, (Array) new bool[num2 + 1]);
                    index5 = num2;
                  }
                  arySrc1[index5].x = coordinate1.x;
                  arySrc1[index5].y = coordinate1.y;
                  arySrc1[index5].data1 = coordinate1.data1;
                  arySrc1[index5].map = coordinate1.map;
                  arySrc2[index5] = true;
                  if (dist1alwaysDirect && arySrc1[index1].x == x & arySrc1[index1].y == y)
                    coordList3.AddCoord(arySrc1[index5].x, arySrc1[index5].y, arySrc1[index5].map);
                  if (this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 9999)
                    coordList1.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
                  this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = val2;
                  this.game.EditObj.TempValueSpecial[coordinate1.map].Value[coordinate1.x, coordinate1.y] = coordinate2.y;
                  this.game.EditObj.TempValueSpecial2[coordinate1.map].Value[coordinate1.x, coordinate1.y] = coordinate2.data1;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].x = arySrc1[index1].x;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].y = arySrc1[index1].y;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].map = arySrc1[index1].map;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].onmap = true;
                  num3 += 1;
                }
                else if (Math.Min(9998, val2) < this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] && val2 < this.game.EditObj.TempValue2[coordinate1.map].Value[coordinate1.x, coordinate1.y] | this.game.EditObj.TempValue2[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 0)
                {
                  this.game.EditObj.TempValue2[coordinate1.map].Value[coordinate1.x, coordinate1.y] = val2;
                  this.game.EditObj.TempValueSpecial[coordinate1.map].Value[coordinate1.x, coordinate1.y] = coordinate2.y;
                  this.game.EditObj.TempValueSpecial2[coordinate1.map].Value[coordinate1.x, coordinate1.y] = coordinate2.data1;
                }
              }
            }
            arySrc2[index1] = false;
          }
        }
      }
      if (airfieldcheck)
      {
        num12: i32;
        if (this.game.HandyFunctionsObj.HasUnitAirSF(unr) & !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
          num12 = 1;
        if (this.game.HandyFunctionsObj.HasUnitAirSF(unr) & this.game.HandyFunctionsObj.HasUnitNavySF(unr))
        {
          let mut airCarryCapPts: i32 =  this.game.HandyFunctionsObj.GetAirCarryCapPts(unr);
          num12 = Conversions.ToInteger(Operators.SubtractObject(this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, true), this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, false))) > airCarryCapPts ? 1 : 0;
        }
        if (PredictAirOnly & this.game.HandyFunctionsObj.HasUnitAirSF(unr))
          num12 = 1;
        if (num12 == 1 && coordList1.counter > -1)
        {
          let mut counter: i32 =  coordList1.counter;
          for (let mut index: i32 =  0; index <= counter; index += 1)
          {
            let mut location: i32 =  this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].Location;
            let mut num13: i32 =  0;
            if (location > -1)
            {
              if (!this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsAirfield & !this.game.Data.LocObj[location].isAirfield)
              {
                num13 = 1;
              }
              else
              {
                if (this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime != this.game.Data.Turn)
                {
                  let mut num14: i32 =  0;
                  if (this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime > -1 & this.game.Data.Turn > -1 && this.game.Data.RegimeObj[this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime].RegimeRel[this.game.Data.Turn] == 2)
                    num14 = 1;
                  if (num14 == 0)
                    num13 = 1;
                }
                if (this.game.Data.Product == 7 && num1 > this.game.Data.LocObj[location].tempAirfieldLevel)
                  num13 = 1;
              }
            }
            else
              num13 = 1;
            if (this.game.Data.Product == 7 && num1 == 0 && this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].Regime == this.game.Data.Turn)
              num13 = 0;
            if (this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].UnitCounter > 14)
              num13 = 1;
            if (num13 == 1)
            {
              coordList1.coord[index].onmap = false;
              this.game.EditObj.TempValue[coordList1.coord[index].map].Value[coordList1.coord[index].x, coordList1.coord[index].y] = 9999;
            }
          }
        }
      }
      if (OneHexFurther)
      {
        let mut counter: i32 =  coordList1.counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut num15: i32 =  this.HexNeighbourCount(coordList1.coord[index].x, coordList1.coord[index].y, coordList1.coord[index].map);
          for (let mut tfacing: i32 =  1; tfacing <= num15; tfacing += 1)
          {
            coordinate1 = this.HexNeighbour(coordList1.coord[index].x, coordList1.coord[index].y, coordList1.coord[index].map, tfacing);
            if (coordinate1.onmap && this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] > 100)
              this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = 100;
          }
        }
      }
      if ( this.game.Data.RuleVar[701] > 0.0 & this.game.Data.Product >= 6)
      {
        let mut counter: i32 =  coordList1.counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut tfacing: i32 =  1;
          do
          {
            coordinate1 = this.HexNeighbour(coordList1.coord[index].x, coordList1.coord[index].y, coordList1.coord[index].map, tfacing);
            if (coordinate1.onmap && this.game.EditObj.TempValueSpecial[coordinate1.map].Value[coordinate1.x, coordinate1.y] > 0)
              coordList1.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
            tfacing += 1;
          }
          while (tfacing <= 6);
        }
      }
      if (ClearSea)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index8: i32 =  0; index8 <= mapCounter; index8 += 1)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index8].MapWidth;
          for (let mut index9: i32 =  0; index9 <= mapWidth; index9 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index8].MapHeight;
            for (let mut index10: i32 =  0; index10 <= mapHeight; index10 += 1)
            {
              if (this.game.EditObj.TempValue[index8].Value[index9, index10] < 9999 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[index8].HexObj[index9, index10].LandscapeType].IsSea)
                this.game.EditObj.TempValue[index8].Value[index9, index10] = 9999;
            }
          }
        }
      }
      if (!this.game.HandyFunctionsObj.HasUnitAirSF(unr) &&  this.game.Data.RuleVar[814] == 0.0 & attackoptions)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index11: i32 =  0; index11 <= mapCounter; index11 += 1)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index11].MapWidth;
          for (let mut index12: i32 =  0; index12 <= mapWidth; index12 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index11].MapHeight;
            for (let mut index13: i32 =  0; index13 <= mapHeight; index13 += 1)
            {
              if (this.game.EditObj.TempValue[index11].Value[index12, index13] < 9999)
              {
                let mut num16: i32 =  this.HexNeighbourCount(index12, index13, index11);
                for (let mut tfacing: i32 =  1; tfacing <= num16; tfacing += 1)
                {
                  Coordinate coordinate4 = this.HexNeighbour(index12, index13, index11, tfacing);
                  if (coordinate4.onmap && this.game.Data.MapObj[coordinate4.map].HexObj[coordinate4.x, coordinate4.y].Regime != this.game.Data.UnitObj[unr].Regime && this.VisibleEnemyUnitsInHex(coordinate4.x, coordinate4.y, coordinate4.map, this.game.Data.UnitObj[unr].Regime, testingforattack: true) | this.game.Data.RegimeObj[Math.Max(0, this.game.Data.Turn)].AI)
                  {
                    coordinate2 = this.MoveApCostPreview(unr, x, y, index12, index13, index11, coordinate4.x, coordinate4.y, coordinate4.map, true, apAlreadySpent: this.game.EditObj.TempValue[index11].Value[index12, index13]);
                    let mut x1: i32 =  coordinate2.x;
                    let mut index14: i32 =  this.HexFacing(coordinate4.x, coordinate4.y, coordinate4.map, index12, index13, index11) - 1;
                    let mut lowestAp: i32 =  this.GetLowestAp(unr);
                    if ( this.game.Data.RuleVar[493] > 0.0 & index14 >= 0 & x1 + this.game.EditObj.TempValue[index11].Value[index12, index13] > lowestAp)
                    {
                      if (x1 + this.game.EditObj.TempValue[index11].Value[index12, index13] <= this.GetLowestAp(unr) | coordinate2.data2 > 0)
                      {
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, index14] = true;
                        if (coordinate2.data2 < 100 & coordinate2.data2 > 0)
                        {
                          if (this.game.EditObj.TempAttack[coordinate4.map].Value2[coordinate4.x, coordinate4.y, index14] == 0)
                            this.game.EditObj.TempAttack[coordinate4.map].Value2[coordinate4.x, coordinate4.y, index14] = coordinate2.data2;
                        }
                        else
                          this.game.EditObj.TempAttack[coordinate4.map].Value2[coordinate4.x, coordinate4.y, index14] = 1;
                        this.game.EditObj.TempValueSpecial[coordinate1.map].Value[coordinate4.x, coordinate4.y] = coordinate2.y;
                        if (!coordList1.Exists(coordinate4.x, coordinate4.y, coordinate4.map))
                          coordList1.AddCoord(coordinate4.x, coordinate4.y, coordinate4.map);
                      }
                    }
                    else if (x1 + this.game.EditObj.TempValue[index11].Value[index12, index13] <= lowestAp)
                    {
                      if (index14 < 0)
                      {
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, 0] = true;
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, 1] = true;
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, 2] = true;
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, 3] = true;
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, 4] = true;
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, 5] = true;
                      }
                      else
                        this.game.EditObj.TempAttack[coordinate4.map].Value[coordinate4.x, coordinate4.y, index14] = true;
                      this.game.EditObj.TempValueSpecial[coordinate1.map].Value[coordinate4.x, coordinate4.y] = coordinate2.y;
                      if (!coordList1.Exists(coordinate4.x, coordinate4.y, coordinate4.map))
                        coordList1.AddCoord(coordinate4.x, coordinate4.y, coordinate4.map);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (isparadrop)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index15: i32 =  0; index15 <= mapCounter; index15 += 1)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index15].MapWidth;
          for (let mut index16: i32 =  0; index16 <= mapWidth; index16 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index15].MapHeight;
            for (let mut index17: i32 =  0; index17 <= mapHeight; index17 += 1)
            {
              if (this.game.EditObj.TempValue[index15].Value[index16, index17] < 9999 && isparadrop && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[index15].HexObj[index16, index17].LandscapeType].CanParadrop)
                this.game.EditObj.TempValue[index15].Value[index16, index17] = 9999;
            }
          }
        }
      }
      if ( this.game.Data.RuleVar[814] == 1.0)
      {
        let mut num17: i32 =  -1;
        if (this.game.Data.TempString[740].Length > 0 & unr > -1)
          num17 =  Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarHex(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.TempString[740], this.game.Data.TempString[741])));
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index: i32 =  0; index <= mapCounter; index += 1)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index].MapWidth;
          for (let mut x2: i32 =  0; x2 <= mapWidth; x2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index].MapHeight;
            for (let mut y1: i32 =  0; y1 <= mapHeight; y1 += 1)
            {
              if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[x2, y1].LandscapeType].IsSea)
                this.game.EditObj.TempValue[index].Value[x2, y1] = 9999;
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x2, y1].Regime) != this.GetRegime(this.game.Data.Turn))
                this.game.EditObj.TempValue[index].Value[x2, y1] = 9999;
              if (this.game.Data.TempString[740].Length > 0 & unr > -1)
              {
                let mut num18: i32 =   Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarHex(x2, y1, this.game.Data.TempString[740], this.game.Data.TempString[741])));
                if (num17 != num18)
                  this.game.EditObj.TempValue[index].Value[x2, y1] = 9999;
              }
            }
          }
        }
      }
      return coordList1;
    }

    pub CoordList MakeMovePrediction3(
      unr: i32,
      x: i32,
      y: i32,
      map: i32,
      bool airfieldcheck = true,
      bool OneHexFurther = false,
      bool PredictAirOnly = false,
      bool ClearSea = false,
      bool attack = false,
      let mut increaseap: i32 =  0,
      bool attackoptions = false,
      bool ismove = false,
      bool EngineerTest = false,
      bool NoAPPenalty = false,
      bool IsTransfer = false,
      bool OnlyFrontline = false,
      bool isparadrop = false,
      let mut gothroughenemy: i32 =  -1,
      let mut ExtraForEnemyHex: i32 =  0,
      MapMatrix2Boolean TempUnitsMatrix = null,
      let mut EnemyIsXAP: i32 =  9999,
       CustomDC2AICalls tcustomAi = null)
    {
      Coordinate[] arySrc1 = new Coordinate[1];
      bool[] arySrc2 = new bool[1];
      CoordList coordList1 = CoordList::new();
      this.RedimTempValue(9999);
      this.RedimTempAttack(false);
      this.RedimTempCameFrom();
      if (this.game.Data.UnitObj[unr].X == -1 | this.game.Data.UnitObj[unr].Y == -1 || x == -1 | y == -1)
      {
        CoordList coordList2;
        return coordList2;
      }
      let mut num1: i32 =  0;
      if (this.game.Data.Product == 7 && this.HasUnitAirSF(unr))
      {
        num1 = this.SE1_GetUnitMinimumAirfieldLevel(unr);
        if (num1 > 0)
        {
          if (this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].Location > -1)
          {
            if (this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].Location].tempAirfieldLevel < num1)
            {
              this.game.EditObj.TempValue[map].Value[x, y] = 0;
              coordList1.AddCoord(x, y, map);
              return coordList1;
            }
          }
          else
          {
            this.game.EditObj.TempValue[map].Value[x, y] = 0;
            coordList1.AddCoord(x, y, map);
            return coordList1;
          }
        }
      }
      let mut num2: i32 =  -1;
      if (this.game.HandyFunctionsObj.HasUnitAirSF(unr) && !this.game.HandyFunctionsObj.HasUnitlandSF(unr) | PredictAirOnly && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) | PredictAirOnly)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
          {
            if (this.game.Data.SFTypeObj[type].AirAPRule > num2)
              num2 = this.game.Data.SFTypeObj[type].AirAPRule;
            if (this.game.Data.SFTypeObj[type].AirAPRule == -1)
            {
              num2 = -1;
              break;
            }
          }
        }
      }
      let mut num3: i32 =  0;
      arySrc1[0].x = x;
      arySrc1[0].y = y;
      arySrc1[0].map = map;
      arySrc2[0] = true;
      this.game.EditObj.TempValue[map].Value[x, y] = 0;
      let mut num4: i32 =  1;
      coordList1.AddCoord(x, y, map);
      Coordinate coordinate1;
      while (num4 > 0)
      {
        num4 = 0;
        let mut num5: i32 =  num3;
        for (let mut index1: i32 =  0; index1 <= num5; index1 += 1)
        {
          if (arySrc2[index1])
          {
            let mut num6: i32 =  this.GetLowestAp(unr) + increaseap;
            if (this.HasUnitNavySF(unr) & this.HasUnitAirSF(unr) & !PredictAirOnly)
              num6 = this.GetLowestAp(unr, true) + increaseap;
            if (this.HasUnitNavySF(unr) & this.HasUnitAirSF(unr) & PredictAirOnly)
              num6 = this.GetLowestAirAp(unr) + increaseap;
            if (!this.HasUnitNavySF(unr) & this.HasUnitAirSF(unr) & PredictAirOnly)
              num6 = this.GetLowestAirAp(unr) + increaseap;
            let mut num7: i32 =  this.HexNeighbourCount(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map);
            for (let mut tfacing: i32 =  1; tfacing <= num7; tfacing += 1)
            {
              coordinate1 = this.HexNeighbour(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, tfacing);
              if (coordinate1.onmap)
              {
                let mut num8: i32 =  this.game.EditObj.TempValue[arySrc1[index1].map].Value[arySrc1[index1].x, arySrc1[index1].y];
                num9: i32;
                if (num2 == -1)
                {
                  let mut num10: i32 =  this.MoveApCostPreview3(unr, arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, coordinate1.x, coordinate1.y, coordinate1.map, attack, PredictAirOnly, ismove: ismove, EngineerTest: EngineerTest, NoAPPenalty: NoAPPenalty, IsTransfer: IsTransfer, Frontlineonly: OnlyFrontline, GoThroughEnemy: gothroughenemy, ExtraForEnemyHex: ExtraForEnemyHex, TempUnitsMatrix: TempUnitsMatrix, EnemyIsXAP: EnemyIsXAP, tcustomAi: ( tcustomAi));
                  if (this.game.Data.Product >= 6 && num10 > 100)
                    num10 = 9999;
                  num9 = num8 + num10;
                }
                else
                  num9 = num8 + num2;
                if (num9 <= num6 & num9 < this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y])
                {
                  let mut index2: i32 =  -1;
                  let mut num11: i32 =  num3;
                  for (let mut index3: i32 =  0; index3 <= num11; index3 += 1)
                  {
                    if (arySrc2[index3] && arySrc1[index3].x == coordinate1.x & arySrc1[index3].y == coordinate1.y & arySrc1[index3].map == coordinate1.map)
                    {
                      index2 = index3;
                      break;
                    }
                  }
                  if (index2 == -1)
                  {
                    let mut num12: i32 =  num3;
                    for (let mut index4: i32 =  0; index4 <= num12; index4 += 1)
                    {
                      if (!arySrc2[index4])
                      {
                        index2 = index4;
                        break;
                      }
                    }
                  }
                  if (index2 == -1)
                  {
                    num3 += 1;
                    arySrc1 = (Coordinate[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc1, (Array) new Coordinate[num3 + 1]);
                    arySrc2 = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc2, (Array) new bool[num3 + 1]);
                    index2 = num3;
                  }
                  arySrc1[index2].x = coordinate1.x;
                  arySrc1[index2].y = coordinate1.y;
                  arySrc1[index2].map = coordinate1.map;
                  arySrc1[index2].onmap = coordinate1.onmap;
                  arySrc2[index2] = true;
                  if (this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 9999)
                    coordList1.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
                  this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = num9;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].x = arySrc1[index1].x;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].y = arySrc1[index1].y;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].map = arySrc1[index1].map;
                  this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].onmap = true;
                  num4 += 1;
                }
                else if (num9 < this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] && num9 < this.game.EditObj.TempValue2[coordinate1.map].Value[coordinate1.x, coordinate1.y] | this.game.EditObj.TempValue2[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 0)
                  this.game.EditObj.TempValue2[coordinate1.map].Value[coordinate1.x, coordinate1.y] = num9;
              }
            }
            arySrc2[index1] = false;
          }
        }
      }
      if ( this.game.Data.RuleVar[814] == 0.0 & attackoptions)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index5: i32 =  0; index5 <= mapCounter; index5 += 1)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index5].MapWidth;
          for (let mut index6: i32 =  0; index6 <= mapWidth; index6 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index5].MapHeight;
            for (let mut index7: i32 =  0; index7 <= mapHeight; index7 += 1)
            {
              if (this.game.EditObj.TempValue[index5].Value[index6, index7] < 9999)
              {
                let mut num13: i32 =  this.HexNeighbourCount(index6, index7, index5);
                for (let mut tfacing: i32 =  1; tfacing <= num13; tfacing += 1)
                {
                  Coordinate coordinate2 = this.HexNeighbour(index6, index7, index5, tfacing);
                  if (coordinate2.onmap && this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].Regime != this.game.Data.UnitObj[unr].Regime && this.VisibleEnemyUnitsInHex(coordinate2.x, coordinate2.y, coordinate2.map, this.game.Data.UnitObj[unr].Regime, testingforattack: true) | this.game.Data.RegimeObj[this.game.Data.Turn].AI)
                  {
                    let mut unr1: i32 =  unr;
                    let mut x1: i32 =  index6;
                    let mut y1: i32 =  index7;
                    let mut map1: i32 =  index5;
                    let mut x2: i32 =  coordinate2.x;
                    let mut y2: i32 =  coordinate2.y;
                    let mut map2: i32 =  coordinate2.map;
                    CustomDC2AICalls customDc2AiCalls = (CustomDC2AICalls) null;
                     CustomDC2AICalls local =  customDc2AiCalls;
                    if (this.MoveApCostPreview3(unr1, x1, y1, map1, x2, y2, map2, true, tcustomAi: ( local)) + this.game.EditObj.TempValue[index5].Value[index6, index7] <= this.GetLowestAp(unr))
                    {
                      let mut index8: i32 =  this.HexFacing(coordinate2.x, coordinate2.y, coordinate2.map, index6, index7, index5) - 1;
                      if (index8 < 0)
                      {
                        this.game.EditObj.TempAttack[coordinate2.map].Value[coordinate2.x, coordinate2.y, 0] = true;
                        this.game.EditObj.TempAttack[coordinate2.map].Value[coordinate2.x, coordinate2.y, 1] = true;
                        this.game.EditObj.TempAttack[coordinate2.map].Value[coordinate2.x, coordinate2.y, 2] = true;
                        this.game.EditObj.TempAttack[coordinate2.map].Value[coordinate2.x, coordinate2.y, 3] = true;
                        this.game.EditObj.TempAttack[coordinate2.map].Value[coordinate2.x, coordinate2.y, 4] = true;
                        this.game.EditObj.TempAttack[coordinate2.map].Value[coordinate2.x, coordinate2.y, 5] = true;
                      }
                      else
                        this.game.EditObj.TempAttack[coordinate2.map].Value[coordinate2.x, coordinate2.y, index8] = true;
                      if (!coordList1.Exists(coordinate2.x, coordinate2.y, coordinate2.map))
                        coordList1.AddCoord(coordinate2.x, coordinate2.y, coordinate2.map);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (airfieldcheck)
      {
        num14: i32;
        if (this.game.HandyFunctionsObj.HasUnitAirSF(unr) & !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
          num14 = 1;
        if (this.game.HandyFunctionsObj.HasUnitAirSF(unr) & this.game.HandyFunctionsObj.HasUnitNavySF(unr))
        {
          let mut airCarryCapPts: i32 =  this.game.HandyFunctionsObj.GetAirCarryCapPts(unr);
          num14 = Conversions.ToInteger(Operators.SubtractObject(this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, true), this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, false))) > airCarryCapPts ? 1 : 0;
        }
        if (PredictAirOnly & this.game.HandyFunctionsObj.HasUnitAirSF(unr))
          num14 = 1;
        if (num14 == 1 && coordList1.counter > -1)
        {
          let mut counter: i32 =  coordList1.counter;
          for (let mut index: i32 =  0; index <= counter; index += 1)
          {
            let mut location: i32 =  this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].Location;
            let mut num15: i32 =  0;
            if (location > -1)
            {
              if (!this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsAirfield & !this.game.Data.LocObj[location].isAirfield)
                num15 = 1;
              else if (this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime != this.game.Data.UnitObj[unr].Regime)
                num15 = 1;
            }
            else
              num15 = 1;
            if (this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].UnitCounter > 14)
              num15 = 1;
            if (this.game.Data.Product == 7 && num1 == 0 && this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].Regime == this.game.Data.Turn)
              num15 = 0;
            if (num15 == 1)
            {
              coordList1.coord[index].onmap = false;
              this.game.EditObj.TempValue[coordList1.coord[index].map].Value[coordList1.coord[index].x, coordList1.coord[index].y] = 9999;
            }
          }
        }
      }
      if (OneHexFurther)
      {
        let mut counter: i32 =  coordList1.counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut num16: i32 =  this.HexNeighbourCount(coordList1.coord[index].x, coordList1.coord[index].y, coordList1.coord[index].map);
          for (let mut tfacing: i32 =  1; tfacing <= num16; tfacing += 1)
          {
            coordinate1 = this.HexNeighbour(coordList1.coord[index].x, coordList1.coord[index].y, coordList1.coord[index].map, tfacing);
            if (coordinate1.onmap && this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] > 100)
              this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = 100;
          }
        }
      }
      if (ClearSea)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index9: i32 =  0; index9 <= mapCounter; index9 += 1)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index9].MapWidth;
          for (let mut index10: i32 =  0; index10 <= mapWidth; index10 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index9].MapHeight;
            for (let mut index11: i32 =  0; index11 <= mapHeight; index11 += 1)
            {
              if (this.game.EditObj.TempValue[index9].Value[index10, index11] < 9999 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[index9].HexObj[index10, index11].LandscapeType].IsSea)
                this.game.EditObj.TempValue[index9].Value[index10, index11] = 9999;
            }
          }
        }
      }
      return coordList1;
    }

    pub void MakeMovePredictionLIS(
      x: i32,
      y: i32,
      map: i32,
      let mut dontGoUnder: i32 =  -1,
      bool useHistory = false,
      bool mustHaveRoad = false,
      bool useAirBridge = false,
      let mut weightSize: i32 =  0,
      let mut maxDam: i32 =  999,
      bool favorizeHighestSize = false,
      bool addHistoryToCurrent = false)
    {
      Coordinate[] arySrc1 = new Coordinate[1];
      bool[] arySrc2 = new bool[1];
      this.RedimTempValue(0);
      this.RedimTempCameFrom();
      if (x == -1 | y == -1)
        return;
      let mut num1: i32 =  0;
      arySrc1[0].x = x;
      arySrc1[0].y = y;
      arySrc1[0].map = map;
      arySrc1[0].data2 = 999;
      arySrc2[0] = true;
      this.game.EditObj.TempValue[map].Value[x, y] = !useHistory ? (!addHistoryToCurrent ? this.game.Data.MapObj[map].HexObj[x, y].LISpoints[6] : this.game.Data.MapObj[map].HexObj[x, y].LISpoints[6] + this.game.Data.MapObj[map].HexObj[x, y].LIStotalHistory[6]) : this.game.Data.MapObj[map].HexObj[x, y].LIStotalHistory[6];
      let mut num2: i32 =  1;
      if (useHistory)
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].LIStotalHistory[6] < 1)
          return;
      }
      else if (addHistoryToCurrent)
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].LISpoints[6] < 1 & this.game.Data.MapObj[map].HexObj[x, y].LIStotalHistory[6] < 1)
          return;
      }
      else if (this.game.Data.MapObj[map].HexObj[x, y].LISpoints[6] < 1)
        return;
      bool flag1 = false;
      if (this.game.EventRelatedObj.Helper_AirEnabled())
      {
        if (!useHistory & useAirBridge)
        {
          flag1 = true;
          this.game.HandyFunctionsObj.SetTempLisJumps(this.game.Data.Turn, weightSize);
        }
        else
          this.game.HandyFunctionsObj.ClearTempLisJumps();
      }
      if (!useAirBridge)
        flag1 = false;
      while (num2 > 0)
      {
        num2 = 0;
        let mut num3: i32 =  num1;
        for (let mut index1: i32 =  0; index1 <= num3; index1 += 1)
        {
          if (arySrc2[index1])
          {
            let mut num4: i32 =  !flag1 ? this.HexNeighbourCount(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map) : this.HexNeighbourCountAir(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map);
            for (let mut tfacing: i32 =  1; tfacing <= num4; tfacing += 1)
            {
              Coordinate coordinate;
              if (flag1)
              {
                coordinate = this.HexNeighbourAir(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, tfacing);
                if (weightSize > coordinate.data2 & tfacing > 6)
                  coordinate.onmap = false;
                if (maxDam < coordinate.penalty & tfacing > 6)
                  coordinate.onmap = false;
                if (coordinate.onmap & tfacing > 6 && this.game.EditObj.TempCameFrom[0].Value[arySrc1[index1].x, arySrc1[index1].y].onmap && this.game.EditObj.TempCameFrom[0].Value[arySrc1[index1].x, arySrc1[index1].y].x == coordinate.x && this.game.EditObj.TempCameFrom[0].Value[arySrc1[index1].x, arySrc1[index1].y].y == coordinate.y)
                  coordinate.onmap = false;
              }
              else
                coordinate = this.HexNeighbour(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, tfacing) with
                {
                  data2 = 999
                };
              if (coordinate.x == 14 & coordinate.y == 3)
                index1 = index1;
              if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime == this.game.Data.Turn | tfacing > 6)
              {
                let mut index2: i32 =  tfacing - 1;
                let mut index3: i32 =  index2 + 3;
                if (index3 > 5)
                  index3 -= 6;
                val2_1: i32;
                if (useHistory)
                {
                  let mut val2_2: i32 =  this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y];
                  let mut val2_3: i32 =  Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LIStotalHistory[6], val2_2);
                  let mut val2_4: i32 =  Math.Min(this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].LIStotalHistory[index2], val2_3);
                  val2_1 = Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LIStotalHistory[index3], val2_4);
                }
                else
                {
                  if (addHistoryToCurrent)
                  {
                    let mut val2_5: i32 =  this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y];
                    val2_1 = Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LISpoints[6] + this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LIStotalHistory[6], val2_5);
                    if (tfacing < 7)
                      val2_1 = Math.Min(this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].LISpoints[index2] + this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].LIStotalHistory[index2], val2_1);
                    if (tfacing < 7)
                      val2_1 = Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LISpoints[index3] + this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LIStotalHistory[index3], val2_1);
                  }
                  else
                  {
                    let mut val2_6: i32 =  this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y];
                    val2_1 = Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LISpoints[6], val2_6);
                    if (tfacing < 7)
                      val2_1 = Math.Min(this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].LISpoints[index2], val2_1);
                    if (tfacing < 7)
                      val2_1 = Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LISpoints[index3], val2_1);
                  }
                  if (tfacing > 6)
                    val2_1 = Math.Min(coordinate.data1, val2_1);
                }
                bool flag2 = true;
                if (dontGoUnder < this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y] & dontGoUnder > 0 && val2_1 > this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y])
                  val2_1 = this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y];
                if (dontGoUnder > val2_1)
                  flag2 = false;
                if (mustHaveRoad & tfacing <= 6)
                {
                  let mut num5: i32 =  this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].RoadType[index2];
                  if (num5 == -1 | num5 == 2)
                    flag2 = false;
                }
                if (coordinate.x == 62 & coordinate.y == 34)
                  index1 = index1;
                if (flag2)
                {
                  bool flag3 = false;
                  if (val2_1 > 0 & val2_1 > this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y] & (dontGoUnder < 1 | dontGoUnder > this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y]))
                    flag3 = true;
                  if (flag1)
                  {
                    if (val2_1 > 0 & !flag3 & val2_1 >= Math.Min(dontGoUnder, this.game.EditObj.TempValue[0].Value[coordinate.x, coordinate.y]) & this.game.EditObj.TempValue[0].Value[coordinate.x, coordinate.y] > 0 && !Information.IsNothing( this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y]) && this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data2 > 0 & this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data2 < 999 && this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data1 > 0 && arySrc1[index1].data2 <= 0 | arySrc1[index1].data2 == 999)
                      flag3 = true;
                    if (val2_1 > 0 & val2_1 > this.game.EditObj.TempValue[0].Value[coordinate.x, coordinate.y] & this.game.EditObj.TempValue[0].Value[coordinate.x, coordinate.y] > 0 && !Information.IsNothing( this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y]) && this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data2 < 1 | this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data2 >= 999 && arySrc1[index1].data2 > 0 | arySrc1[index1].data2 < 999)
                      flag3 = false;
                    if (!flag3 & favorizeHighestSize && val2_1 > 0 & !flag3 && !Information.IsNothing( this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y]) && this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data2 > 0 & this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data2 < 999 && coordinate.data2 > this.game.EditObj.TempCameFrom[0].Value[coordinate.x, coordinate.y].data2 & coordinate.data2 < 999)
                      flag3 = true;
                  }
                  if (flag3)
                  {
                    if (coordinate.x == 80 & coordinate.y == 18)
                      index1 = index1;
                    let mut index4: i32 =  -1;
                    let mut num6: i32 =  num1;
                    for (let mut index5: i32 =  0; index5 <= num6; index5 += 1)
                    {
                      if (arySrc2[index5] && arySrc1[index5].x == coordinate.x & arySrc1[index5].y == coordinate.y & arySrc1[index5].map == coordinate.map)
                      {
                        index4 = index5;
                        break;
                      }
                    }
                    if (index4 == -1)
                    {
                      let mut num7: i32 =  num1;
                      for (let mut index6: i32 =  0; index6 <= num7; index6 += 1)
                      {
                        if (!arySrc2[index6])
                        {
                          index4 = index6;
                          break;
                        }
                      }
                    }
                    if (index4 == -1)
                    {
                      num1 += 1;
                      arySrc1 = (Coordinate[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc1, (Array) new Coordinate[num1 + 1]);
                      arySrc2 = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc2, (Array) new bool[num1 + 1]);
                      index4 = num1;
                    }
                    arySrc1[index4].x = coordinate.x;
                    arySrc1[index4].y = coordinate.y;
                    arySrc1[index4].map = coordinate.map;
                    arySrc1[index4].onmap = coordinate.onmap;
                    arySrc1[index4].data1 = coordinate.data1;
                    arySrc1[index4].data2 = Math.Min(arySrc1[index1].data2, coordinate.data2);
                    arySrc2[index4] = true;
                    this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y] = val2_1;
                    this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].x = arySrc1[index1].x;
                    this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].y = arySrc1[index1].y;
                    this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].map = arySrc1[index1].map;
                    this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].onmap = true;
                    this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].data1 = coordinate.data1;
                    this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].data2 = Math.Min(arySrc1[index1].data2, coordinate.data2);
                    num2 += 1;
                  }
                }
              }
            }
            arySrc2[index1] = false;
          }
        }
      }
      if (!this.game.EventRelatedObj.Helper_AirEnabled())
        return;
      let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
      for (let mut index7: i32 =  0; index7 <= mapWidth; index7 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
        for (let mut index8: i32 =  0; index8 <= mapHeight; index8 += 1)
        {
          if (this.game.EditObj.TempCameFrom[0].Value[index7, index8].data2 == 999)
            this.game.EditObj.TempCameFrom[0].Value[index7, index8].data2 = 0;
        }
      }
    }

    pub fn MakeMovePredictionLIS_Preview(x: i32, y: i32, map: i32, let mut dontGoUnder: i32 =  -1)
    {
      Coordinate[] arySrc1 = new Coordinate[1];
      bool[] arySrc2 = new bool[1];
      this.RedimTempValue(0);
      this.RedimTempCameFrom();
      if (x == -1 | y == -1 || this.game.Data.MapObj[map].HexObj[x, y].tempPreviewLIS[6] < 1)
        return;
      let mut num1: i32 =  0;
      arySrc1[0].x = x;
      arySrc1[0].y = y;
      arySrc1[0].map = map;
      arySrc2[0] = true;
      this.game.EditObj.TempValue[map].Value[x, y] = this.game.Data.MapObj[map].HexObj[x, y].tempPreviewLIS[6];
      let mut num2: i32 =  1;
      while (num2 > 0)
      {
        num2 = 0;
        let mut num3: i32 =  num1;
        for (let mut index1: i32 =  0; index1 <= num3; index1 += 1)
        {
          if (arySrc2[index1])
          {
            let mut num4: i32 =  this.HexNeighbourCount(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map);
            for (let mut tfacing: i32 =  1; tfacing <= num4; tfacing += 1)
            {
              Coordinate coordinate = this.HexNeighbour(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, tfacing);
              if (coordinate.onmap)
              {
                let mut index2: i32 =  tfacing - 1;
                let mut index3: i32 =  index2 + 3;
                if (index3 > 5)
                  index3 -= 6;
                let mut val2_1: i32 =  this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y];
                let mut val2_2: i32 =  Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].tempPreviewLIS[6], val2_1);
                let mut val2_3: i32 =  Math.Min(this.game.Data.MapObj[0].HexObj[arySrc1[index1].x, arySrc1[index1].y].tempPreviewLIS[index2], val2_2);
                let mut num5: i32 =  Math.Min(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].tempPreviewLIS[index3], val2_3);
                bool flag = true;
                if (dontGoUnder < this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y] && num5 > this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y])
                  num5 = this.game.EditObj.TempValue[map].Value[arySrc1[index1].x, arySrc1[index1].y];
                if (dontGoUnder > num5)
                  flag = false;
                if (flag && num5 > 0 & num5 > this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y])
                {
                  let mut index4: i32 =  -1;
                  let mut num6: i32 =  num1;
                  for (let mut index5: i32 =  0; index5 <= num6; index5 += 1)
                  {
                    if (arySrc2[index5] && arySrc1[index5].x == coordinate.x & arySrc1[index5].y == coordinate.y & arySrc1[index5].map == coordinate.map)
                    {
                      index4 = index5;
                      break;
                    }
                  }
                  if (index4 == -1)
                  {
                    let mut num7: i32 =  num1;
                    for (let mut index6: i32 =  0; index6 <= num7; index6 += 1)
                    {
                      if (!arySrc2[index6])
                      {
                        index4 = index6;
                        break;
                      }
                    }
                  }
                  if (index4 == -1)
                  {
                    num1 += 1;
                    arySrc1 = (Coordinate[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc1, (Array) new Coordinate[num1 + 1]);
                    arySrc2 = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc2, (Array) new bool[num1 + 1]);
                    index4 = num1;
                  }
                  arySrc1[index4].x = coordinate.x;
                  arySrc1[index4].y = coordinate.y;
                  arySrc1[index4].map = coordinate.map;
                  arySrc1[index4].onmap = coordinate.onmap;
                  arySrc2[index4] = true;
                  this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y] = num5;
                  this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].x = arySrc1[index1].x;
                  this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].y = arySrc1[index1].y;
                  this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].map = arySrc1[index1].map;
                  this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].onmap = true;
                  num2 += 1;
                }
              }
            }
            arySrc2[index1] = false;
          }
        }
      }
    }

    pub Coordinate GetHistoricalAverageHex(his: i32)
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      num3: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].Historical == his)
        {
          num1 += this.game.Data.UnitObj[index].X;
          num2 += this.game.Data.UnitObj[index].Y;
          num3 += 1;
        }
      }
      if (num3 > 0)
      {
        Coordinate historicalAverageHex;
        historicalAverageHex.onmap = true;
        historicalAverageHex.x =  Math.Round( num1 /  num3);
        historicalAverageHex.y =  Math.Round( num2 /  num3);
        return historicalAverageHex;
      }
      Coordinate historicalAverageHex1;
      historicalAverageHex1.onmap = false;
      return historicalAverageHex1;
    }

    pub IsAlliedOrSelf: bool(reg1: i32, reg2: i32, bool ForReconPurpose = false)
    {
      if (reg1 == -1 | reg2 == -1 || reg1 == -2 | reg2 == -2 || reg1 > this.game.Data.RegimeCounter || reg2 > this.game.Data.RegimeCounter)
        return false;
      if (reg1 == reg2)
        return true;
      if (!ForReconPurpose)
      {
        if (this.game.Data.RegimeObj[reg1].RegimeRel[reg2] == 2)
          return true;
      }
      else if (this.game.Data.RegimeObj[reg1].UberRegime == reg2 || this.game.Data.RegimeObj[reg2].UberRegime == reg1 || this.game.Data.RegimeObj[reg1].UberRegime == this.game.Data.RegimeObj[reg2].UberRegime & this.game.Data.RegimeObj[reg1].UberRegime > -1 ||  this.game.Data.RuleVar[328] == 1.0 && this.game.Data.RegimeObj[reg1].RegimeRel[reg2] == 2)
        return true;
      return false;
    }

    pub object UnitFuelPrognosis(unr: i32, ap: i32)
    {
      let mut num1: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].FuelForMove > 0)
          {
            let mut num2: i32 =   Math.Round(Conversion.Int( (ap * this.game.Data.SFTypeObj[type].FuelForMove) / 10.0));
            if (this.game.Data.SFTypeObj[type].FuelForMove > num2 & ap > 0)
              num2 = this.game.Data.SFTypeObj[type].FuelForMove;
            let mut num3: i32 =  num2 * this.game.Data.SFObj[sf].Qty;
            num1 += num3;
          }
        }
      }
      return  num1;
    }

    pub CheckIfInCorrectFrontzone: bool(unr: i32, x: i32, y: i32)
    {
      bool flag = false;
      if ( this.game.Data.RuleVar[983] < 1.0)
        return true;
      num: i32;
      if ( this.game.Data.RuleVar[984] < 5.0)
      {
        if (!(this.game.Data.TempString[723].Length > 0 & this.game.Data.TempString[725].Length > 0 & this.game.Data.UnitObj[unr].Historical > -1))
          return true;
        str: String = this.game.EventRelatedObj.CheckLibVarHistorical(this.game.Data.UnitObj[unr].Historical, this.game.Data.TempString[725], this.game.Data.TempString[723], 0);
        if (Information.IsNothing( str) || Operators.CompareString(str, "", false) == 0)
          return true;
        num =  Math.Round(Conversion.Val(str));
        if (num == 0)
          return true;
        flag = true;
      }
      if (!flag)
      {
        if (this.game.Data.UnitObj[unr].Historical <= -1 ||  this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].Type >=  this.game.Data.RuleVar[984])
          return true;
        let mut hq: i32 =  this.game.Data.UnitObj[unr].HQ;
        if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1)
        {
          if ( this.game.Data.RuleVar[984] >= 6.0 & this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type <= 5)
            hq = this.game.Data.UnitObj[hq].HQ;
          if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1)
          {
            if ( this.game.Data.RuleVar[984] >= 7.0 & this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type <= 6)
              hq = this.game.Data.UnitObj[hq].HQ;
            if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1)
            {
              if ( this.game.Data.RuleVar[984] >= 8.0 & this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type <= 7)
                hq = this.game.Data.UnitObj[hq].HQ;
              if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1 &&  this.game.Data.RuleVar[984] >= 9.0 & this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type <= 8)
                hq = this.game.Data.UnitObj[hq].HQ;
            }
          }
        }
        return !(this.game.Data.TempString[721].Length > 0 & hq > -1) ||  Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarHex(x, y, this.game.Data.TempString[722], this.game.Data.TempString[721]))) ==  Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarHex(this.game.Data.UnitObj[hq].X, this.game.Data.UnitObj[hq].Y, this.game.Data.TempString[722], this.game.Data.TempString[721])));
      }
      return this.game.Data.TempString[721].Length <= 0 ||  Math.Round(Conversion.Val(this.game.EventRelatedObj.CheckLibVarHex(x, y, this.game.Data.TempString[722], this.game.Data.TempString[721]))) == num ||  num == Conversion.Val(this.game.Data.TempString[724]);
    }

    pub Coordinate MoveApCostPreview(
      unr: i32,
      ox1: i32,
      oy1: i32,
      x1: i32,
      y1: i32,
      map1: i32,
      x2: i32,
      y2: i32,
      map2: i32,
      bool attack = false,
      bool predictaironly = false,
      bool IgnoreBridges = false,
      bool ismove = false,
      bool EngineerTest = false,
      bool NoAPPenalty = false,
      bool IsTransfer = false,
      bool Frontlineonly = false,
      let mut GoThroughEnemy: i32 =  -1,
      let mut PreviousAPspent: i32 =  0,
      let mut OnlyEngineer: i32 =  0,
      bool ignoreFuel = false,
      let mut apAlreadySpent: i32 =  0,
      let mut onlySfNr: i32 =  -1,
      bool ignoreScrappable = false)
    {
      int[] numArray1 = new int[251];
      int[] numArray2 = new int[251];
      int[] numArray3 = new int[251];
      int[] numArray4 = new int[251];
      int[] numArray5 = new int[251];
      int[] numArray6 = new int[251];
      int[] numArray7 = new int[251];
      int[] numArray8 = new int[251];
      int[] numArray9 = new int[251];
      int[] numArray10 = new int[251];
      int[] numArray11 = new int[251];
      int[] numArray12 = new int[500];
      num1: i32;
      if ( this.game.Data.RuleVar[459] > 0.0)
        num1 =  Math.Round(Math.Ceiling( (this.game.HandyFunctionsObj.GetUnitWeight(unr, true) * 1) /  this.game.Data.RuleVar[33]));
      Coordinate tcoord;
      tcoord.y = 0;
      tcoord.data2 = 0;
      if (x2 == 25 & y2 == 33 & x1 == 24 & y1 == 33)
        x1 = x1;
      if (ox1 == -1 & x1 == -1)
      {
        x1 = x2;
        ox1 = ox1;
        y1 = y2;
        oy1 = y2;
      }
      if (x2 == -1 | y2 == -1)
      {
        tcoord.x = 9999;
        return tcoord;
      }
      SimpleList simpleList = SimpleList::new();
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (sf == onlySfNr | onlySfNr == -1)
          simpleList.Add(sf, this.game.Data.SFObj[sf].Qty);
      }
      if (onlySfNr == -1)
      {
        let mut transportCounter: i32 =  this.game.Data.UnitObj[unr].TransportCounter;
        for (let mut index: i32 =  0; index <= transportCounter; index += 1)
        {
          SimpleList SL = this.GiveAttachablesList(this.game.Data.UnitObj[unr].TransportList[index]);
          if (SL.Counter > -1)
            simpleList.AddWeight( SL);
        }
      }
      if (this.game.Data.UnitObj[unr].attachedTo > -1)
      {
        SimpleList SL = this.GiveAttachablesList(unr);
        if (SL.Counter <= -1)
          return tcoord;
        simpleList.RemoveWeight( SL);
        if (simpleList.totalWeight() <= 0)
          return tcoord;
      }
      index1: i32;
      if (!ignoreFuel && simpleList.Counter > -1)
      {
        let mut counter: i32 =  simpleList.Counter;
        for (let mut index2: i32 =  0; index2 <= counter; index2 += 1)
        {
          index1 = simpleList.Id[index2];
          let mut type: i32 =  this.game.Data.SFObj[index1].Type;
          if (this.game.Data.SFTypeObj[type].FuelForMove > 0 && this.game.Data.SFTypeObj[type].FuelRegimeVar > -1 & PreviousAPspent > 0)
          {
            let mut currentSlot: i32 =  this.game.Data.SFTypeObj[type].FuelRegimeVar;
            if ( this.game.Data.RuleVar[435] > 0.0)
            {
              let mut num2: i32 =   Math.Round( this.game.Data.RuleVar[435]);
              let mut num3: i32 =   Math.Round(Conversion.Int( (PreviousAPspent * this.game.Data.SFTypeObj[type].FuelForMove) / 10.0));
              if (this.game.Data.SFTypeObj[type].FuelForMove > num3)
                num3 = this.game.Data.SFTypeObj[type].FuelForMove;
              let mut num4: i32 =  num3 * simpleList.Weight[index2];
              if (this.game.Data.UnitObj[unr].moveMode == 1)
                num4 =  Math.Round(Math.Ceiling( num4 / 2.0));
              int[] numArray13 = numArray12;
              int[] numArray14 = numArray13;
              let mut index3: i32 =  num2;
              let mut index4: i32 =  index3;
              let mut num5: i32 =  numArray13[index3] + num4;
              numArray14[index4] = num5;
            }
            else
            {
              if ( this.game.Data.RuleVar[949] > 0.0)
                currentSlot = this.game.HandyFunctionsObj.GetFuelSlot949(currentSlot, ox1, oy1);
              let mut num6: i32 =   Math.Round(Conversion.Int( (PreviousAPspent * this.game.Data.SFTypeObj[type].FuelForMove) / 10.0));
              if (this.game.Data.SFTypeObj[type].FuelForMove > num6)
                num6 = this.game.Data.SFTypeObj[type].FuelForMove;
              let mut num7: i32 =  num6 * simpleList.Weight[index2];
              int[] numArray15 = numArray12;
              int[] numArray16 = numArray15;
              let mut index5: i32 =  currentSlot;
              let mut index6: i32 =  index5;
              let mut num8: i32 =  numArray15[index5] + num7;
              numArray16[index6] = num8;
            }
          }
        }
      }
      let mut num9: i32 =  0;
      this.game.EditObj.ApTempString = "";
      if (this.game.Data.UseAI == 0 && simpleList.Counter == -1 & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType].IsSea && this.game.Data.MapObj[map2].HexObj[x2, y2].Regime == this.game.Data.UnitObj[unr].Regime && this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AI)
      {
        tcoord.x = 0;
        return tcoord;
      }
      if (!predictaironly && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType].IsSea & this.game.Data.UnitObj[unr].IsHQ)
      {
        this.game.EditObj.ApTempString = "HQs can never move into a sea hex.";
        tcoord.x = 9999;
        return tcoord;
      }
      if (this.HasUnitNavySF(unr) && this.IsHexPort(x1, y1, map1) & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map1].HexObj[x1, y1].LandscapeType].IsSea && this.IsHexPort(x2, y2, map2) & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType].IsSea)
      {
        this.game.EditObj.ApTempString = "Naval troops cannot go from harbour to harbour.";
        tcoord.x = 9999;
        return tcoord;
      }
      if (this.game.Data.Turn > -1 && this.game.Data.Product < 7 | this.game.Data.RegimeObj[this.game.Data.Turn].AI && !this.IsHostileOrSelf(this.game.Data.UnitObj[unr].Regime, this.game.Data.MapObj[map2].HexObj[x2, y2].Regime))
      {
        tcoord.x = 9999;
        return tcoord;
      }
      let mut index7: i32 =  this.game.HandyFunctionsObj.HexFacing(x2, y2, map2, x1, y1, map1) - 1;
      let mut index8: i32 =  index7 + 3;
      if (index8 > 5)
        index8 -= 6;
      if ( this.game.Data.RuleVar[452] > 0.0 & index7 > -1 && this.game.Data.MapObj[0].HexObj[x2, y2].RoadType[index7] > -1)
        IgnoreBridges = true;
      let mut num10: i32 =  0;
      let mut num11: i32 =  0;
      if (simpleList.Counter > -1)
      {
        let mut counter1: i32 =  simpleList.Counter;
        landscapeType: i32;
        bool flag1;
        num12: i32;
        for (let mut index9: i32 =  0; index9 <= counter1; index9 += 1)
        {
          index1 = simpleList.Id[index9];
          if (index1 == onlySfNr | onlySfNr == -1)
          {
            let mut index10: i32 =  this.game.Data.SFObj[index1].Type;
            if (ignoreScrappable &&  this.game.Data.RuleVar[486] > 0.0 && this.game.Data.SFTypeObj[index10].scrapable > 1)
            {
              let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID( Math.Round( this.game.Data.RuleVar[486]));
              if (stringListById > -1)
              {
                let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
                for (let mut index11: i32 =  0; index11 <= length; index11 += 1)
                {
                  if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index11, 0])) == this.game.Data.SFObj[index1].People)
                    index10 =  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index11, 1]));
                }
              }
            }
            let mut moveType: i32 =  this.game.Data.SFTypeObj[index10].MoveType;
            if (this.game.Data.SFObj[index1].MoveType > -1)
              moveType = this.game.Data.SFObj[index1].MoveType;
            let mut theater: i32 =  this.game.Data.SFTypeObj[index10].Theater;
            landscapeType = this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType;
            let mut index12: i32 =  x1 <= -1 ? landscapeType : this.game.Data.MapObj[map1].HexObj[x1, y1].LandscapeType;
            let mut regime: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].Regime;
            let mut num13: i32 =  this.game.Data.SFTypeObj[index10].PowerPts * this.game.Data.SFObj[index1].Qty;
            num11 += num13;
            if (OnlyEngineer == 0 | OnlyEngineer == 1 & this.game.Data.SFTypeObj[index10].EP > 0 | OnlyEngineer == 2 & this.game.Data.SFTypeObj[index10].EP < 1)
            {
              if (this.game.Data.Turn > -1 && index7 < 0 & this.game.Data.RegimeObj[this.game.Data.Turn].AI & this.game.Data.UseAI <= 1)
              {
                tcoord.x = 9999;
                return tcoord;
              }
              let mut num14: i32 =  this.game.Data.LandscapeTypeObj[landscapeType].MoveCost[moveType];
              if (this.game.Data.LandscapeTypeObj[index12].MoveCost[moveType] >= 199 & index7 > -1 && this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index7] == -1)
                num14 = 9999;
              if (this.game.Data.MapObj[map2].HexObj[x2, y2].UnitCounter > 14 & this.game.Data.MapObj[map2].HexObj[x2, y2].Regime == this.game.Data.Turn & !predictaironly)
              {
                tcoord.x = 9999;
                return tcoord;
              }
              if (!Frontlineonly | Frontlineonly & !this.game.Data.SFTypeObj[index10].BackBench)
              {
                let mut num15: i32 =   Math.Round(Conversion.Int( num14 * ( this.game.Data.MoveTypePenalty[moveType] / 100.0)));
                if (this.game.Data.SFTypeObj[index10].MoveRedux != 0)
                  num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.SFTypeObj[index10].MoveRedux) / 100.0)));
                if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
                  num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
                if (this.game.Data.MapObj[map2].HexObj[x2, y2].get_SeeNow(this.game.Data.UnitObj[unr].Regime) == 0)
                {
                  if (this.game.EditObj.OrderType == 33 | this.game.EditObj.OrderType == 14 | this.game.EditObj.OrderType == 15 | this.game.EditObj.OrderType == 19 | this.game.EditObj.OrderType == 1 & this.game.Data.SFTypeObj[index10].Theater == 2)
                  {
                    if ( this.game.Data.RuleVar[100] == 1.0)
                    {
                      if (this.game.EditObj.OrderType == 15 | this.game.EditObj.OrderType == 19 | this.game.EditObj.OrderType == 14 && this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(this.game.Data.UnitObj[unr].Regime) == -1)
                      {
                        this.game.EditObj.ApTempString = "Is shrouded by darkness.";
                        tcoord.x = 9999;
                        return tcoord;
                      }
                    }
                    else
                    {
                      this.game.EditObj.ApTempString = "Is shrouded by darkness.";
                      tcoord.x = 9999;
                      return tcoord;
                    }
                  }
                  else
                  {
                    let mut num16: i32 =  1;
                    if (this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(this.game.Data.UnitObj[unr].Regime) > -1 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(this.game.Data.UnitObj[unr].Regime)].IsSea)
                      num16 = 0;
                    if (num16 == 1)
                    {
                      this.game.EditObj.ApTempString = "Is shrouded by darkness.";
                      tcoord.x = 9999;
                      return tcoord;
                    }
                  }
                }
                bool flag2 = false;
                bool flag3 = true;
                if (this.game.Data.Product >= 6)
                {
                  if (this.game.Data.LandscapeTypeObj[landscapeType].BlackedOut)
                    flag3 = false;
                  if (this.game.Data.LandscapeTypeObj[index12].BlackedOut)
                    flag3 = false;
                }
                if (theater == 0 & flag3)
                {
                  num17: i32;
                  if (index7 > -1)
                  {
                    if (this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index7] > -1)
                    {
                      let mut index13: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index7];
                      flag2 = true;
                      let mut num18: i32 =  this.game.Data.RoadTypeObj[index13].MoveCostOverrule[moveType];
                      if (this.game.Data.UnitObj[unr].moveMode == 1)
                      {
                        num18 =  Math.Round(Math.Floor( num18 / 2.0));
                        if (num18 < 1)
                          num18 = 1;
                      }
                      if (num18 < num15)
                      {
                        if ( this.game.Data.RuleVar[459] > 0.0 & this.game.Data.RoadTypeObj[index13].trafficPoints > 0)
                        {
                          let mut num19: i32 =  0;
                          if (this.game.EditObj.OrderType == 48)
                          {
                            let mut groupMoveCounter: i32 =  this.game.EditObj.tempGroupMoveCounter;
                            for (let mut index14: i32 =  0; index14 <= groupMoveCounter; index14 += 1)
                            {
                              if (this.game.EditObj.tempGroupMoveUnr[index14] != unr && !Information.IsNothing( this.game.EditObj.tempGroupMovePath[index14]))
                              {
                                let mut counter2: i32 =  this.game.EditObj.tempGroupMovePath[index14].counter;
                                for (let mut index15: i32 =  0; index15 <= counter2; index15 += 1)
                                {
                                  if (this.game.EditObj.tempGroupMovePath[index14].coord[index15].x == x1 & this.game.EditObj.tempGroupMovePath[index14].coord[index15].y == y1 && this.game.EditObj.tempGroupMovePath[index14].coord[index15].data1 == x2 & this.game.EditObj.tempGroupMovePath[index14].coord[index15].data2 == y2)
                                    num19 +=  Math.Round(Math.Ceiling( (this.game.HandyFunctionsObj.GetUnitWeight(this.game.EditObj.tempGroupMoveUnr[index14], true) * 1) /  this.game.Data.RuleVar[33]));
                                  if (this.game.EditObj.tempGroupMovePath[index14].coord[index15].x == x2 & this.game.EditObj.tempGroupMovePath[index14].coord[index15].y == y2 && this.game.EditObj.tempGroupMovePath[index14].coord[index15].data1 == x1 & this.game.EditObj.tempGroupMovePath[index14].coord[index15].data2 == y1)
                                    num19 +=  Math.Round(Math.Ceiling( (this.game.HandyFunctionsObj.GetUnitWeight(this.game.EditObj.tempGroupMoveUnr[index14], true) * 1) /  this.game.Data.RuleVar[33]));
                                }
                              }
                            }
                          }
                          let mut index16: i32 =  this.game.Data.MapObj[map2].HexObj[x1, y1].RoadType[index8];
                          let mut val1: i32 =   Math.Round(Math.Floor( ((this.game.Data.MapObj[0].HexObj[x2, y2].LISpoints[index7] + num1 + num19) * 100) /  this.game.Data.RoadTypeObj[index13].trafficPoints));
                          let mut val2: i32 =  0;
                          if (index16 > -1 && this.game.Data.RoadTypeObj[index16].trafficPoints > 0)
                            val2 =  Math.Round(Math.Floor( ((this.game.Data.MapObj[0].HexObj[x1, y1].LISpoints[index8] + num1 + num19) * 100) /  this.game.Data.RoadTypeObj[index16].trafficPoints));
                          let mut num20: i32 =  Math.Max(val1, val2);
                          if (num20 > 100)
                          {
                            if (num20 > 400)
                              num20 = 400;
                            let mut num21: i32 =  num20 - 100;
                            num15 =  Math.Round(Math.Ceiling( num15 * ( num21 / 300.0))) +  Math.Round(Math.Ceiling( num18 * ( (300 - num21) / 300.0)));
                          }
                          else
                            num15 = num18;
                        }
                        else
                          num15 = num18;
                      }
                      num15 =  Math.Round(Conversion.Int( num15 * ( this.game.Data.MoveTypePenalty[moveType] / 100.0)));
                      if (this.game.Data.SFTypeObj[index10].MoveRedux != 0)
                        num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.SFTypeObj[index10].MoveRedux) / 100.0)));
                      if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
                        num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
                    }
                    else if (EngineerTest)
                    {
                      num15 = Conversion.Int(this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].MoveCostOverrule[moveType]);
                      if (this.game.Data.SFTypeObj[index10].MoveRedux != 0)
                        num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.SFTypeObj[index10].MoveRedux) / 100.0)));
                      if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
                        num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
                    }
                    if (!IgnoreBridges && this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index7] > -1)
                    {
                      let mut index17: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index7];
                      if (!this.game.Data.MapObj[map2].HexObj[x2, y2].Bridge[index7])
                      {
                        if (!EngineerTest)
                        {
                          if ( this.game.Data.RuleVar[945] > 0.0 &  this.game.Data.RuleVar[945] ==  moveType & this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].FerryEffectivity > 0)
                          {
                            if (this.game.HandyFunctionsObj.IsHexPort(x1, y1, 0))
                              num15 +=  Math.Round((1.0 -  this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x1, y1].Location].StructuralPts /  this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x1, y1].Location].Type].StructuralPts * ( this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].FerryEffectivity / 100.0)) *  this.game.Data.RiverTypeObj[index17].MovePenalty[moveType]);
                            else
                              num15 += this.game.Data.RiverTypeObj[index17].MovePenalty[moveType];
                          }
                          else
                            num15 += this.game.Data.RiverTypeObj[index17].MovePenalty[moveType];
                          flag1 = true;
                        }
                        else
                          num15 = num15;
                      }
                      else if ( this.game.Data.RuleVar[459] > 0.0)
                      {
                        let mut num22: i32 =  0;
                        if (this.game.EditObj.OrderType == 48)
                        {
                          let mut groupMoveCounter: i32 =  this.game.EditObj.tempGroupMoveCounter;
                          for (let mut index18: i32 =  0; index18 <= groupMoveCounter; index18 += 1)
                          {
                            if (this.game.EditObj.tempGroupMoveUnr[index18] != unr && !Information.IsNothing( this.game.EditObj.tempGroupMovePath[index18]))
                            {
                              let mut counter3: i32 =  this.game.EditObj.tempGroupMovePath[index18].counter;
                              for (let mut index19: i32 =  0; index19 <= counter3; index19 += 1)
                              {
                                if (this.game.EditObj.tempGroupMovePath[index18].coord[index19].x == x1 & this.game.EditObj.tempGroupMovePath[index18].coord[index19].y == y1 && this.game.EditObj.tempGroupMovePath[index18].coord[index19].data1 == x2 & this.game.EditObj.tempGroupMovePath[index18].coord[index19].data2 == y2)
                                  num22 +=  Math.Round(Math.Ceiling( (this.game.HandyFunctionsObj.GetUnitWeight(this.game.EditObj.tempGroupMoveUnr[index18], true) * 1) /  this.game.Data.RuleVar[33]));
                                if (this.game.EditObj.tempGroupMovePath[index18].coord[index19].x == x2 & this.game.EditObj.tempGroupMovePath[index18].coord[index19].y == y2 && this.game.EditObj.tempGroupMovePath[index18].coord[index19].data1 == x1 & this.game.EditObj.tempGroupMovePath[index18].coord[index19].data2 == y1)
                                  num22 +=  Math.Round(Math.Ceiling( (this.game.HandyFunctionsObj.GetUnitWeight(this.game.EditObj.tempGroupMoveUnr[index18], true) * 1) /  this.game.Data.RuleVar[33]));
                              }
                            }
                          }
                        }
                        let mut index20: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index7];
                        let mut val1: i32 =  0;
                        let mut val2: i32 =  0;
                        if (index20 > -1)
                        {
                          if (this.game.Data.RoadTypeObj[index20].trafficPoints > 0)
                            val1 =  Math.Round(Math.Floor( ((this.game.Data.MapObj[0].HexObj[x2, y2].LISpoints[index7] + num1 + num22) * 100) /  this.game.Data.RoadTypeObj[index20].trafficPoints));
                          val2 = 0;
                          let mut index21: i32 =  this.game.Data.MapObj[map2].HexObj[x1, y1].RoadType[index8];
                          if (index21 > -1 && this.game.Data.RoadTypeObj[index21].trafficPoints > 0)
                            val2 =  Math.Round(Math.Floor( ((this.game.Data.MapObj[0].HexObj[x1, y1].LISpoints[index8] + num1 + num22) * 100) /  this.game.Data.RoadTypeObj[index21].trafficPoints));
                        }
                        let mut num23: i32 =  Math.Max(val1, val2);
                        if (num23 > 100)
                        {
                          if (num23 > 400)
                            num23 = 400;
                          let mut num24: i32 =  num23 - 100;
                          let mut num25: i32 =  this.game.Data.RiverTypeObj[index17].MovePenalty[moveType];
                          if (num25 >= 999 & num24 < 100)
                            num17 = 25;
                          else if (num25 >= 999 & num24 < 200)
                            num17 = 50;
                          else if (num25 >= 999 & num24 < 300)
                            num17 = 75;
                          else if (num25 >= 999)
                            num17 = 999;
                          let mut num26: i32 =   Math.Round(Math.Ceiling( num17 * ( num24 / 300.0))) +  Math.Round(Math.Ceiling(0.0 * ( (300 - num24) / 300.0)));
                          num15 += num26;
                        }
                      }
                    }
                  }
                  if (this.game.AllowHeightMap & num15 < 9999)
                  {
                    let mut num27: i32 =  this.game.Data.MapObj[0].HexObj[x2, y2].HeightLevel - this.game.Data.MapObj[0].HexObj[x1, y1].HeightLevel;
                    let mut num28: i32 =  0;
                    if (num27 > 0)
                    {
                      if (flag2)
                      {
                        if (num27 == 1)
                          num28 +=  Math.Round( (1f * this.game.Data.RuleVar[427]));
                        if (num27 == 2)
                          num28 +=  Math.Round( (2f * this.game.Data.RuleVar[427]));
                        if (num27 >= 3)
                          num28 +=  Math.Round( (5f * this.game.Data.RuleVar[427]));
                      }
                      else
                      {
                        if (num27 == 1)
                          num28 +=  Math.Round(1.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index10].heightLevelDiff / 100.0);
                        if (num27 == 2)
                          num28 +=  Math.Round(2.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index10].heightLevelDiff / 100.0);
                        if (num27 >= 3)
                          num28 +=  Math.Round(5.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index10].heightLevelDiff / 100.0);
                      }
                    }
                    else if (num27 < 0)
                    {
                      if (flag2)
                      {
                        if (num27 == -1)
                          num28 +=  Math.Round( (1f * this.game.Data.RuleVar[427]));
                        if (num27 == -2)
                          num28 +=  Math.Round( (2f * this.game.Data.RuleVar[427]));
                        if (num27 <= -3)
                          num28 +=  Math.Round( (5f * this.game.Data.RuleVar[427]));
                      }
                      else
                      {
                        if (num27 == -1)
                          num28 +=  Math.Round(0.5 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index10].heightLevelDiff / 100.0);
                        if (num27 == -2)
                          num28 +=  Math.Round(1.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index10].heightLevelDiff / 100.0);
                        if (num27 <= -3)
                          num28 +=  Math.Round(2.5 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index10].heightLevelDiff / 100.0);
                      }
                    }
                    if ( this.game.Data.RuleVar[495] > 0.0 & num28 > 0)
                    {
                      tSlotNr: i32;
                      if (this.tempHexLibVarSnowIsSet == this.game.Data.GameID)
                      {
                        tSlotNr = this.tempHexLibVarSnowValue;
                      }
                      else
                      {
                        data: DataClass = this.game.Data;
                        str: String = "Snow";
                         local: String =  str;
                        tSlotNr = data.FindLibVar( local, "");
                        this.tempHexLibVarSnowValue = tSlotNr;
                        this.tempHexLibVarSnowIsSet = this.game.Data.GameID;
                      }
                      num17 = this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].GetHexLibVarValue(tSlotNr);
                      if (num17 > 0)
                        num28 +=  Math.Round( num28 *  this.game.Data.RuleVar[495] / 100.0);
                    }
                    num15 += num28;
                    if ( this.game.Data.RuleVar[470] > 0.0)
                    {
                      if (flag2)
                        num15 += 5;
                      else
                        num15 += 10;
                    }
                  }
                  if (!NoAPPenalty)
                    num15 += this.game.Data.MapObj[map2].HexObj[x2, y2].get_APPenalty(this.game.Data.UnitObj[unr].Regime);
                  if (!NoAPPenalty)
                    num15 += this.game.Data.MapObj[map2].HexObj[x2, y2].get_BattlePenalty(this.game.Data.UnitObj[unr].Regime);
                  if (index7 > -1)
                  {
                    let mut num29: i32 =  0;
                    let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
                    for (let mut index22: i32 =  0; index22 <= regimeCounter; index22 += 1)
                    {
                      let mut num30: i32 =  0;
                      if (this.IsHostileNotSelf(this.game.Data.UnitObj[unr].Regime, index22) && this.game.Data.MapObj[map2].HexObj[x2, y2].get_ZocPts(index22) > 0 && this.VisibleEnemyUnitsInOrAroundHEx(x2, y2, map2, this.game.Data.UnitObj[unr].Regime))
                      {
                        num30 =  Math.Round( ( num30 + this.game.Data.RuleVar[323]));
                        if (this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index7] > -1 &&  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index7]].BridgeCostModifier > 0.0)
                          num30 =  Math.Round( ( num30 + this.game.Data.RuleVar[323]));
                      }
                      if (num30 > num29)
                        num29 = num30;
                    }
                    num15 += num29;
                  }
                }
                let mut location: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].Location;
                bool flag4 = this.game.HandyFunctionsObj.HasUnitNavySF(unr);
                if (flag4 & !this.game.Data.LandscapeTypeObj[landscapeType].IsSea & !predictaironly)
                {
                  this.game.EditObj.ApTempString = "Navy cannot move out of Sea.";
                  num15 = 9999;
                }
                if (location > -1 & flag4 & !predictaironly && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsPort && this.IsAlliedOrSelf(this.game.Data.UnitObj[unr].Regime, regime) | attack)
                {
                  num15 =  Math.Round(Conversion.Int( this.game.Data.LandscapeTypeObj[landscapeType].MoveCost[moveType] * ( this.game.Data.MoveTypePenalty[moveType] / 100.0)));
                  if (this.game.Data.SFTypeObj[index10].MoveRedux != 0)
                    num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.SFTypeObj[index10].MoveRedux) / 100.0)));
                  if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
                    num15 =  Math.Round(Conversion.Int( num15 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
                  this.game.EditObj.ApTempString = "";
                }
                if (this.game.Data.MapObj[map2].HexObj[x2, y2].Regime != this.game.Data.UnitObj[unr].Regime)
                {
                  let mut num31: i32 =  0;
                  if (this.game.Data.MapObj[map2].HexObj[x2, y2].Regime > -1)
                  {
                    if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeRel[this.game.Data.MapObj[map2].HexObj[x2, y2].Regime] == 2)
                      num31 = 1;
                    this.MovementSpecialCoordSet(this.game.Data.UnitObj[unr].Regime, x2, y2,  tcoord, false);
                  }
                  if (num31 == 0 &  this.game.Data.RuleVar[307] >  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) && !predictaironly && !this.game.Data.LandscapeTypeObj[landscapeType].IsSea)
                    num15 = 9999;
                }
                if (this.game.Data.Product >= 7 && !Information.IsNothing( this.game.EditObj.TempValueSpecial[0]) && this.game.EditObj.TempValueSpecial[0].Value[x1, y1] > 0)
                  num15 = 9999;
                if (this.VisibleEnemyUnitsInHex(x2, y2, map2, this.game.Data.UnitObj[unr].Regime) & !attack)
                {
                  if (GoThroughEnemy == -1)
                  {
                    num15 = 9999;
                    this.game.EditObj.ApTempString = "Visible enemy units in hex.";
                  }
                  else if (this.game.Data.UseAI == 1 && this.game.AIObj.GetHexForceLandStrength(x2, y2, (uint) map2 > 0U) > GoThroughEnemy)
                  {
                    num15 = 9999;
                    this.game.EditObj.ApTempString = "Enemy Strength in hex to high.";
                  }
                }
                if (this.game.Data.UnitObj[unr].FreeCombatX == x2 & this.game.Data.UnitObj[unr].FreeCombatY == y2 & this.game.Data.UnitObj[unr].FreeCombatMap == map2)
                {
                  num12 = 0;
                  tcoord.x = 0;
                  return tcoord;
                }
                if (this.game.Data.SFTypeObj[index10].Theater == 2 & this.HasUnitNavySF(unr) & !predictaironly && this.game.HandyFunctionsObj.GetAirCarryCapPts(unr) >= Conversions.ToInteger(Operators.SubtractObject(this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, true), this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, false))))
                  num15 = 0;
                if (theater == 2 && IsTransfer)
                  num15 =  Math.Round(Conversion.Int( num15 / 2.0));
                if (theater == 2 & ismove)
                  num15 =  Math.Round(Conversion.Int( num15 / 2.0));
                if (theater < 2 & predictaironly)
                  num15 = 0;
                if (!ignoreFuel && this.game.Data.SFTypeObj[index10].FuelForMove > 0 & num15 < 9999 && this.game.Data.SFTypeObj[index10].FuelRegimeVar > -1 |  this.game.Data.RuleVar[435] > 0.0 & this.game.Data.SFTypeObj[index10].FuelForMove > 0)
                {
                  let mut currentSlot: i32 =  this.game.Data.SFTypeObj[index10].FuelRegimeVar;
                  if ( this.game.Data.RuleVar[435] > 0.0)
                  {
                    if (num15 + PreviousAPspent <= this.game.HandyFunctionsObj.GetLowestAp(unr) + this.game.Data.UnitObj[unr].apReserve)
                    {
                      let mut num32: i32 =   Math.Round(Conversion.Int( (num15 * this.game.Data.SFTypeObj[index10].FuelForMove) / 10.0));
                      if (this.game.Data.SFTypeObj[index10].FuelForMove > num32)
                        num32 = this.game.Data.SFTypeObj[index10].FuelForMove;
                      let mut num33: i32 =  num32 * simpleList.Weight[index9];
                      if (this.game.Data.UnitObj[unr].moveMode == 1)
                        num33 =  Math.Round(Math.Ceiling( num33 / 2.0));
                      if (this.game.Data.UnitObj[unr].Fuel >= num33 + numArray12[currentSlot])
                      {
                        int[] numArray17 = numArray12;
                        int[] numArray18 = numArray17;
                        let mut index23: i32 =  currentSlot;
                        let mut index24: i32 =  index23;
                        let mut num34: i32 =  numArray17[index23] + num33;
                        numArray18[index24] = num34;
                        if (numArray12[currentSlot] > tcoord.data1)
                          tcoord.data1 = numArray12[currentSlot];
                      }
                      else
                      {
                        if (this.GetLowestAp(unr) + this.game.Data.UnitObj[unr].apReserve >= num15)
                          num15 =  Math.Round( ( num15 * this.game.Data.SFTypeObj[index10].OutOfFuelMove));
                        tcoord.y = tcoord.y != 2 ? 1 : 3;
                        int[] numArray19 = numArray12;
                        int[] numArray20 = numArray19;
                        let mut index25: i32 =  currentSlot;
                        let mut index26: i32 =  index25;
                        let mut num35: i32 =  numArray19[index25] + num33;
                        numArray20[index26] = num35;
                        if (numArray12[currentSlot] > tcoord.data1)
                          tcoord.data1 = numArray12[currentSlot];
                      }
                    }
                  }
                  else
                  {
                    if ( this.game.Data.RuleVar[949] > 0.0)
                      currentSlot = this.game.HandyFunctionsObj.GetFuelSlot949(currentSlot, ox1, oy1);
                    let mut num36: i32 =   Math.Round(Conversion.Int( (num15 * this.game.Data.SFTypeObj[index10].FuelForMove) / 10.0));
                    if (this.game.Data.SFTypeObj[index10].FuelForMove > num36)
                      num36 = this.game.Data.SFTypeObj[index10].FuelForMove;
                    let mut num37: i32 =  num36 * simpleList.Weight[index9];
                    if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeSlot[currentSlot] < num37 + numArray12[currentSlot])
                    {
                      num15 =  Math.Round( ( num15 * this.game.Data.SFTypeObj[index10].OutOfFuelMove));
                      tcoord.y = tcoord.y != 2 ? 1 : 3;
                    }
                    int[] numArray21 = numArray12;
                    int[] numArray22 = numArray21;
                    let mut index27: i32 =  currentSlot;
                    let mut index28: i32 =  index27;
                    let mut num38: i32 =  numArray21[index27] + num37;
                    numArray22[index28] = num38;
                    if (numArray12[currentSlot] > tcoord.data1)
                      tcoord.data1 = numArray12[currentSlot];
                  }
                }
                if (num15 > num9)
                  num9 = num15;
                numArray1[index9] = num15;
                numArray4[index9] = this.game.Data.SFTypeObj[index10].Weight * simpleList.Weight[index9];
                numArray5[index9] = this.game.Data.SFTypeObj[index10].CarryCap * simpleList.Weight[index9];
                numArray9[index9] = this.game.Data.SFTypeObj[index10].manpower;
                numArray10[index9] = this.game.Data.SFTypeObj[index10].Weight;
                numArray7[index9] = this.game.Data.SFTypeObj[index10].manpower * simpleList.Weight[index9];
                numArray8[index9] = this.game.Data.SFTypeObj[index10].manpowerCarry * simpleList.Weight[index9];
                if ( this.game.Data.RuleVar[490] > 0.0)
                {
                  let mut num39: i32 =  new Random(unr *  Math.Round( this.game.Data.GameID / 25000.0) * (this.game.Data.Round * 2)).Next(0,  Math.Round( this.game.Data.RuleVar[490]));
                  if (numArray5[index9] > 0)
                  {
                    int[] numArray23 = numArray5;
                    int[] numArray24 = numArray23;
                    let mut index29: i32 =  index9;
                    let mut index30: i32 =  index29;
                    let mut num40: i32 =  numArray23[index29] +  Math.Round(Math.Floor( (numArray5[index9] * num39) / 100.0));
                    numArray24[index30] = num40;
                  }
                  if (numArray8[index9] > 0)
                  {
                    int[] numArray25 = numArray8;
                    int[] numArray26 = numArray25;
                    let mut index31: i32 =  index9;
                    let mut index32: i32 =  index31;
                    let mut num41: i32 =  numArray25[index31] +  Math.Round(Math.Floor( (numArray8[index9] * num39) / 100.0));
                    numArray26[index32] = num41;
                  }
                }
              }
            }
          }
        }
        num42: i32;
        if (!predictaironly)
        {
          if (this.game.Data.UnitObj[unr].IsHQ)
          {
            num42 = Conversions.ToInteger(this.GetUnitExcessWeight(unr));
            if (num42 > 0)
            {
              numArray1[simpleList.Counter + 1] = this.game.Data.LandscapeTypeObj[landscapeType].MoveCost[ Math.Round( this.game.Data.RuleVar[41])];
              if (index7 > -1)
              {
                if (this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index7] > -1)
                {
                  let mut index33: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index7];
                  numArray1[simpleList.Counter + 1] = this.game.Data.RoadTypeObj[index33].MoveCostOverrule[ Math.Round( this.game.Data.RuleVar[41])];
                }
                if (this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index7] > -1)
                {
                  let mut index34: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index7];
                  if (!this.game.Data.MapObj[map2].HexObj[x2, y2].Bridge[index7])
                    numArray1[simpleList.Counter + 1] = numArray1[simpleList.Counter + 1] + this.game.Data.RiverTypeObj[index34].MovePenalty[ Math.Round( this.game.Data.RuleVar[41])];
                }
              }
              numArray1[simpleList.Counter + 1] = numArray1[simpleList.Counter + 1] + this.game.Data.MapObj[map2].HexObj[x2, y2].get_APPenalty(this.game.Data.UnitObj[unr].Regime);
              numArray4[simpleList.Counter + 1] = num42;
              numArray5[simpleList.Counter + 1] = 0;
              numArray9[simpleList.Counter + 1] = 0;
              numArray8[simpleList.Counter + 1] = 0;
              numArray10[simpleList.Counter + 1] = 1;
            }
          }
        }
        else
          num42 = 0;
        if (!predictaironly)
        {
          bool flag5;
          do
          {
            flag5 = false;
            let mut counter4: i32 =  simpleList.Counter;
            for (let mut index35: i32 =  0; index35 <= counter4; index35 += 1)
            {
              let mut index36: i32 =  -1;
              let mut num43: i32 =  0;
              let mut counter5: i32 =  simpleList.Counter;
              typ: i32;
              for (let mut index37: i32 =  0; index37 <= counter5; index37 += 1)
              {
                let mut index38: i32 =  simpleList.Id[index37];
                if (onlySfNr == -1 | index38 == onlySfNr)
                {
                  let mut index39: i32 =  this.game.Data.SFObj[index38].Type;
                  if (ignoreScrappable &&  this.game.Data.RuleVar[486] > 0.0 && this.game.Data.SFTypeObj[index39].scrapable > 1)
                  {
                    let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID( Math.Round( this.game.Data.RuleVar[486]));
                    if (stringListById > -1)
                    {
                      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
                      for (let mut index40: i32 =  0; index40 <= length; index40 += 1)
                      {
                        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index40, 0])) == this.game.Data.SFObj[index1].People)
                          index39 =  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index40, 1]));
                      }
                    }
                  }
                  if (OnlyEngineer == 0 | OnlyEngineer == 1 & this.game.Data.SFTypeObj[index39].EP > 0 | OnlyEngineer == 2 & this.game.Data.SFTypeObj[index39].EP < 1 && numArray1[index37] > num43 & !(flag1 & numArray1[index37] > 100) && numArray2[index37] < numArray4[index37] | numArray11[index37] < numArray7[index37] && numArray6[index37] == 0)
                  {
                    num43 = numArray1[index37];
                    index36 = index37;
                    typ = this.game.Data.SFObj[index38].Type;
                  }
                }
              }
              if (num42 > 0)
              {
                let mut index41: i32 =  simpleList.Counter + 1;
                if (numArray1[index41] > num43 && numArray2[index41] < numArray4[index41] && numArray6[index41] == 0)
                {
                  let mut num44: i32 =  numArray1[index41];
                  index36 = index41;
                  typ = -1;
                }
              }
              if (index36 > -1)
              {
                let mut index42: i32 =  -1;
                let mut num45: i32 =  9999;
                let mut counter6: i32 =  simpleList.Counter;
                for (let mut index43: i32 =  0; index43 <= counter6; index43 += 1)
                {
                  let mut index44: i32 =  simpleList.Id[index43];
                  let mut index45: i32 =  this.game.Data.SFObj[index44].Type;
                  if (ignoreScrappable &&  this.game.Data.RuleVar[486] > 0.0 && this.game.Data.SFTypeObj[index45].scrapable > 1)
                  {
                    let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID( Math.Round( this.game.Data.RuleVar[486]));
                    if (stringListById > -1)
                    {
                      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
                      for (let mut index46: i32 =  0; index46 <= length; index46 += 1)
                      {
                        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index46, 0])) == this.game.Data.SFObj[index1].People)
                          index45 =  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index46, 1]));
                      }
                    }
                  }
                  if (OnlyEngineer == 0 | OnlyEngineer == 1 & this.game.Data.SFTypeObj[index45].EP > 0 | OnlyEngineer == 2 & this.game.Data.SFTypeObj[index45].EP < 1 && numArray1[index43] < num45 && numArray5[index43] > 0 & numArray8[index43] >= numArray9[index36])
                  {
                    if (typ > -1)
                    {
                      if (this.CanBeCarriedBy(typ, this.game.Data.SFObj[index44].Type))
                      {
                        num45 = numArray1[index43];
                        index42 = index43;
                      }
                      else
                        index43 = index43;
                    }
                    else
                    {
                      num45 = numArray1[index43];
                      index42 = index43;
                    }
                  }
                }
                if (index42 > -1)
                {
                  let mut num46: i32 =  numArray4[index36] - numArray2[index36];
                  let mut val1: i32 =  numArray5[index42] <= num46 ? numArray5[index42] : num46;
                  let mut num47: i32 =  0;
                  if (numArray9[index36] > 0 & val1 > 0)
                  {
                    let mut num48: i32 =  numArray7[index36] - numArray11[index36];
                    num47 = numArray8[index42] <= num48 ? numArray8[index42] : num48;
                    let mut num49: i32 =   Math.Round( val1 /  numArray10[index36]);
                    let mut num50: i32 =   Math.Round(Math.Ceiling( num47 /  numArray9[index36]));
                    if (num50 < num49)
                    {
                      val1 = Math.Min(val1, numArray10[index36] * num49);
                      num47 = num50 * numArray9[index36];
                    }
                  }
                  if (val1 > 0)
                  {
                    flag5 = true;
                    int[] numArray27 = numArray2;
                    int[] numArray28 = numArray27;
                    let mut index47: i32 =  index36;
                    let mut index48: i32 =  index47;
                    let mut num51: i32 =  numArray27[index47] + val1;
                    numArray28[index48] = num51;
                    int[] numArray29 = numArray5;
                    int[] numArray30 = numArray29;
                    let mut index49: i32 =  index42;
                    let mut index50: i32 =  index49;
                    let mut num52: i32 =  numArray29[index49] - val1;
                    numArray30[index50] = num52;
                    int[] numArray31 = numArray11;
                    int[] numArray32 = numArray31;
                    let mut index51: i32 =  index36;
                    let mut index52: i32 =  index51;
                    let mut num53: i32 =  numArray31[index51] + num47;
                    numArray32[index52] = num53;
                    int[] numArray33 = numArray8;
                    int[] numArray34 = numArray33;
                    let mut index53: i32 =  index42;
                    let mut index54: i32 =  index53;
                    let mut num54: i32 =  numArray33[index53] - num47;
                    numArray34[index54] = num54;
                    if (numArray1[index42] > numArray3[index36])
                      numArray3[index36] = numArray1[index42];
                  }
                  else if (index42 > -1 & index36 > -1)
                  {
                    let mut num55: i32 =  numArray7[index36] - numArray11[index36];
                    let mut num56: i32 =  numArray8[index42] <= num55 ? numArray8[index42] : num55;
                    if (num56 > 0 & num55 > 0)
                    {
                      int[] numArray35 = numArray11;
                      int[] numArray36 = numArray35;
                      let mut index55: i32 =  index36;
                      let mut index56: i32 =  index55;
                      let mut num57: i32 =  numArray35[index55] + num56;
                      numArray36[index56] = num57;
                      int[] numArray37 = numArray8;
                      int[] numArray38 = numArray37;
                      let mut index57: i32 =  index42;
                      let mut index58: i32 =  index57;
                      let mut num58: i32 =  numArray37[index57] - num56;
                      numArray38[index58] = num58;
                      if (numArray1[index42] > numArray3[index36])
                        numArray3[index36] = numArray1[index42];
                    }
                    else
                      numArray6[index36] = 1;
                  }
                  else
                    numArray6[index36] = 1;
                }
              }
            }
          }
          while (flag5);
          let mut num59: i32 =  0;
          let mut num60: i32 =  simpleList.Counter + 1;
          for (let mut index59: i32 =  0; index59 <= num60; index59 += 1)
          {
            num12 = 0;
            let mut num61: i32 =  numArray1[index59];
            if ( this.game.Data.RuleVar[493] > 0.0 & index59 <= simpleList.Counter)
            {
              let mut index60: i32 =  simpleList.Id[index59];
              if (attack & num61 + apAlreadySpent <= this.game.Data.SFObj[index60].Ap)
              {
                let mut num62: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[index60].Type].PowerPts * this.game.Data.SFObj[index60].Qty;
                num10 += num62;
              }
            }
            if (numArray2[index59] >= numArray4[index59] & numArray11[index59] >= numArray7[index59] & numArray3[index59] > 0)
              num61 = numArray3[index59];
            else if (numArray4[index59] == 0)
            {
              num61 = 50;
              let mut counter7: i32 =  simpleList.Counter;
              for (let mut index61: i32 =  0; index61 <= counter7; index61 += 1)
              {
                if (numArray1[index61] < num61)
                  num61 = numArray1[index61];
              }
            }
            if (num61 > num59)
              num59 = num61;
          }
          if (num42 > 0)
          {
            let mut index62: i32 =  simpleList.Counter + 1;
            num12 = 0;
            let mut num63: i32 =  numArray1[index62];
            if (numArray2[index62] >= numArray4[index62] & numArray3[index62] > 0)
              num63 = numArray3[index62];
            if (num63 > num59)
              num59 = num63;
          }
          if ( this.game.Data.RuleVar[472] > 0.0 & this.game.Data.Product >= 6 && !this.game.Data.UnitObj[unr].DidMove & this.game.Data.UnitObj[unr].apReserve > 0 && x1 == this.game.Data.UnitObj[unr].X & y1 == this.game.Data.UnitObj[unr].Y)
          {
            let mut lowestAp: i32 =  this.game.HandyFunctionsObj.GetLowestAp(unr, true);
            if (lowestAp < num59 & num59 < 999 && lowestAp + this.game.Data.UnitObj[unr].apReserve >= num59)
              num59 = lowestAp;
          }
          if ( this.game.Data.RuleVar[493] > 0.0 & num11 > 0 & attack)
          {
            let mut num64: i32 =   Math.Round(Math.Floor( (num10 * 100) /  num11));
            tcoord.data2 = num64;
          }
          tcoord.x = num59;
          return tcoord;
        }
        tcoord.x = num9;
        return tcoord;
      }
      tcoord.x = 9999;
      return tcoord;
    }

    pub MoveApCostPreview3: i32(
      unr: i32,
      x1: i32,
      y1: i32,
      map1: i32,
      x2: i32,
      y2: i32,
      map2: i32,
      bool attack = false,
      bool predictaironly = false,
      bool IgnoreBridges = false,
      bool ismove = false,
      bool EngineerTest = false,
      bool NoAPPenalty = false,
      bool IsTransfer = false,
      bool Frontlineonly = false,
      let mut GoThroughEnemy: i32 =  -1,
      let mut ExtraForEnemyHex: i32 =  0,
      MapMatrix2Boolean TempUnitsMatrix = null,
      let mut EnemyIsXAP: i32 =  9999,
       CustomDC2AICalls tcustomAi = null)
    {
      bool flag1 = false;
      this.game.EditObj.ApTempString = "";
      if (x2 == 13 & y2 == 44)
        x1 = x1;
      if (Frontlineonly && this.IsHostileNotSelf(this.game.Data.UnitObj[unr].Regime, this.game.Data.MapObj[map1].HexObj[x1, y1].Regime) && this.game.Data.MapObj[map1].HexObj[x1, y1].UnitCounter > -1)
        return 9999;
      if (x2 == 81 & y2 == 36 & this.game.Data.Turn == 19)
        x2 = x2;
      if (!Information.IsNothing( tcustomAi) && this.game.Data.MapObj[map1].HexObj[x2, y2].Regime > -1)
      {
        if (this.game.Data.RegimeObj[this.game.Data.Turn].RegimeRel[this.game.Data.MapObj[map1].HexObj[x2, y2].Regime] == 0)
        {
          if (tcustomAi.tempActuallyNotAtWarForMove[this.game.Data.Turn, this.game.Data.MapObj[map1].HexObj[x2, y2].Regime] || tcustomAi.tempActuallyNotAtWarForAttack[this.game.Data.Turn, this.game.Data.MapObj[map1].HexObj[x2, y2].Regime] && (this.game.Data.MapObj[map1].HexObj[x2, y2].UnitCounter > -1 || this.game.Data.MapObj[map1].HexObj[x2, y2].Location > -1))
            return 9999;
        }
        else
        {
          let mut num1: i32 =  num1;
        }
      }
      if (!Information.IsNothing( TempUnitsMatrix) && TempUnitsMatrix.Value[x2, y2])
        return 9999;
      if (this.game.Data.UnitObj[unr].SFCount == -1 & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType].IsSea && this.game.Data.MapObj[map2].HexObj[x2, y2].Regime == this.game.Data.UnitObj[unr].Regime && this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AI)
        return 0;
      if (!predictaironly && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType].IsSea & this.game.Data.UnitObj[unr].IsHQ)
      {
        this.game.EditObj.ApTempString = "HQs can never move into a sea hex.";
        return 9999;
      }
      if (this.HasUnitNavySF(unr) && this.IsHexPort(x1, y1, map1) & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map1].HexObj[x1, y1].LandscapeType].IsSea && this.IsHexPort(x2, y2, map2) & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType].IsSea)
      {
        this.game.EditObj.ApTempString = "Naval troops cannot go from harbour to harbour.";
        return 9999;
      }
      if (!this.IsHostileOrSelf(this.game.Data.UnitObj[unr].Regime, this.game.Data.MapObj[map2].HexObj[x2, y2].Regime))
        return 9999;
      index1: i32;
      if (this.game.Data.UnitObj[unr].TempTypeRoad == -2)
        index1 =  Math.Round( this.game.Data.RuleVar[41]);
      else
        index1 = this.game.Data.SFTypeObj[this.game.Data.UnitObj[unr].TempTypeRoad].MoveType;
      let mut index2: i32 =  this.game.Data.UnitObj[unr].TempType;
      index3: i32;
      if (index2 == -2)
      {
        index2 = 0;
        index3 =  Math.Round( this.game.Data.RuleVar[41]);
      }
      else
        index3 = this.game.Data.SFTypeObj[this.game.Data.UnitObj[unr].TempType].MoveType;
      let mut tempTheater: i32 =  this.game.Data.UnitObj[unr].TempTheater;
      let mut landscapeType1: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType;
      let mut landscapeType2: i32 =  this.game.Data.MapObj[map1].HexObj[x1, y1].LandscapeType;
      let mut regime1: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].Regime;
      let mut index4: i32 =  this.game.HandyFunctionsObj.HexFacing(x2, y2, map2, x1, y1, map1) - 1;
      if (index4 < 0 & this.game.Data.RegimeObj[this.game.Data.Turn].AI & this.game.Data.UseAI <= 1 || this.game.Data.MapObj[map2].HexObj[x2, y2].UnitCounter > 14 & this.game.Data.MapObj[map2].HexObj[x2, y2].Regime == this.game.Data.Turn & !predictaironly)
        return 9999;
      let mut num2: i32 =  this.game.Data.LandscapeTypeObj[landscapeType1].MoveCost[index3];
      if (this.game.Data.LandscapeTypeObj[landscapeType2].MoveCost[index3] >= 199 && this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index4] == -1)
        num2 = 9999;
      let mut num3: i32 =   Math.Round(Conversion.Int( num2 * ( this.game.Data.MoveTypePenalty[index3] / 100.0)));
      if (this.game.Data.SFTypeObj[index2].MoveRedux != 0)
        num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.SFTypeObj[index2].MoveRedux) / 100.0)));
      if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
        num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
      if (this.game.Data.MapObj[map2].HexObj[x2, y2].get_SeeNow(this.game.Data.UnitObj[unr].Regime) == 0)
      {
        if (this.game.EditObj.OrderType == 33 | this.game.EditObj.OrderType == 15 | this.game.EditObj.OrderType == 19 | this.game.EditObj.OrderType == 1 & this.game.Data.SFTypeObj[index2].Theater == 2)
        {
          if ( this.game.Data.RuleVar[100] == 1.0)
          {
            if (this.game.EditObj.OrderType == 15 | this.game.EditObj.OrderType == 19 && this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(this.game.Data.UnitObj[unr].Regime) == -1)
            {
              this.game.EditObj.ApTempString = "Is shrouded by darkness.";
              return 9999;
            }
          }
          else
          {
            this.game.EditObj.ApTempString = "Is shrouded by darkness.";
            return 9999;
          }
        }
        else
        {
          let mut num4: i32 =  1;
          if (this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(this.game.Data.UnitObj[unr].Regime) > -1 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(this.game.Data.UnitObj[unr].Regime)].IsSea)
            num4 = 0;
          if (num4 == 1)
          {
            this.game.EditObj.ApTempString = "Is shrouded by darkness.";
            return 9999;
          }
        }
      }
      if ( this.game.Data.RuleVar[452] > 0.0 && this.game.Data.MapObj[0].HexObj[x2, y2].RoadType[index4] > -1)
        IgnoreBridges = true;
      bool flag2 = true;
      if (this.game.Data.Product >= 6)
      {
        if (this.game.Data.LandscapeTypeObj[landscapeType1].BlackedOut)
          flag2 = false;
        if (this.game.Data.LandscapeTypeObj[landscapeType2].BlackedOut)
          flag2 = false;
      }
      if (tempTheater == 0 & flag2)
      {
        if (index4 > -1)
        {
          if (this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index4] > -1)
          {
            let mut index5: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index4];
            flag1 = true;
            if (this.game.Data.RoadTypeObj[index5].MoveCostOverrule[index1] <= num3)
            {
              num3 = this.game.Data.RoadTypeObj[index5].MoveCostOverrule[index1];
              if (this.game.Data.UnitObj[unr].moveMode == 1)
              {
                num3 =  Math.Round(Math.Floor( num3 / 2.0));
                if (num3 < 1)
                  num3 = 1;
              }
            }
            num3 =  Math.Round(Conversion.Int( num3 * ( this.game.Data.MoveTypePenalty[index1] / 100.0)));
            if (this.game.Data.SFTypeObj[index2].MoveRedux != 0)
              num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.SFTypeObj[index2].MoveRedux) / 100.0)));
            if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
              num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
          }
          else if (EngineerTest)
          {
            num3 =  Math.Round(Conversion.Int( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].MoveCostOverrule[index1] * 1.5));
            if (this.game.Data.SFTypeObj[index2].MoveRedux != 0)
              num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.SFTypeObj[index2].MoveRedux) / 100.0)));
            if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
              num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
          }
          if (!IgnoreBridges && this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index4] > -1)
          {
            let mut index6: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index4];
            if (!this.game.Data.MapObj[map2].HexObj[x2, y2].Bridge[index4])
            {
              if (!EngineerTest)
              {
                if ( this.game.Data.RuleVar[945] > 0.0 &  this.game.Data.RuleVar[945] ==  index3 & this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].FerryEffectivity > 0)
                {
                  if (this.game.HandyFunctionsObj.IsHexPort(x1, y1, 0))
                    num3 +=  Math.Round((1.0 -  this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x1, y1].Location].StructuralPts /  this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x1, y1].Location].Type].StructuralPts * ( this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].FerryEffectivity / 100.0)) *  this.game.Data.RiverTypeObj[index6].MovePenalty[index3]);
                  else
                    num3 += this.game.Data.RiverTypeObj[index6].MovePenalty[index3];
                }
                else
                  num3 += this.game.Data.RiverTypeObj[index6].MovePenalty[index3];
              }
              else
                num3 += 20;
            }
          }
        }
        if (!NoAPPenalty)
          num3 += this.game.Data.MapObj[map2].HexObj[x2, y2].get_APPenalty(this.game.Data.UnitObj[unr].Regime);
        if (!NoAPPenalty)
          num3 += this.game.Data.MapObj[map2].HexObj[x2, y2].get_BattlePenalty(this.game.Data.UnitObj[unr].Regime);
        if (this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn && this.game.Data.MapObj[map2].HexObj[x2, y2].Regime != this.game.Data.UnitObj[unr].Regime)
        {
          num3 =  Math.Round( ( num3 + this.game.Data.RuleVar[4]));
          if (this.game.Data.MapObj[map2].HexObj[x2, y2].UnitCounter > -1)
            num3 =  Math.Round( ( num3 + this.game.Data.RuleVar[4]));
        }
        if (this.game.AllowHeightMap & num3 < 9999)
        {
          let mut num5: i32 =  this.game.Data.MapObj[0].HexObj[x2, y2].HeightLevel - this.game.Data.MapObj[0].HexObj[x1, y1].HeightLevel;
          let mut num6: i32 =  0;
          if (num5 > 0)
          {
            if (flag1)
            {
              if (num5 == 1)
                num6 +=  Math.Round( (1f * this.game.Data.RuleVar[427]));
              if (num5 == 2)
                num6 +=  Math.Round( (2f * this.game.Data.RuleVar[427]));
              if (num5 >= 3)
                num6 +=  Math.Round( (5f * this.game.Data.RuleVar[427]));
            }
            else
            {
              if (num5 == 1)
                num6 +=  Math.Round(1.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index2].heightLevelDiff / 100.0);
              if (num5 == 2)
                num6 +=  Math.Round(2.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index2].heightLevelDiff / 100.0);
              if (num5 >= 3)
                num6 +=  Math.Round(5.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index2].heightLevelDiff / 100.0);
            }
          }
          else if (num5 < 0)
          {
            if (flag1)
            {
              if (num5 == -1)
                num6 +=  Math.Round( (1f * this.game.Data.RuleVar[427]));
              if (num5 == -2)
                num6 +=  Math.Round( (2f * this.game.Data.RuleVar[427]));
              if (num5 <= -3)
                num6 +=  Math.Round( (5f * this.game.Data.RuleVar[427]));
            }
            else
            {
              if (num5 == -1)
                num6 +=  Math.Round(0.5 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index2].heightLevelDiff / 100.0);
              if (num5 == -2)
                num6 +=  Math.Round(1.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index2].heightLevelDiff / 100.0);
              if (num5 <= -3)
                num6 +=  Math.Round(2.5 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index2].heightLevelDiff / 100.0);
            }
          }
          if ( this.game.Data.RuleVar[495] > 0.0 & num6 > 0)
          {
            tSlotNr: i32;
            if (this.tempHexLibVarSnowIsSet == this.game.Data.GameID)
            {
              tSlotNr = this.tempHexLibVarSnowValue;
            }
            else
            {
              data: DataClass = this.game.Data;
              str: String = "Snow";
               local: String =  str;
              tSlotNr = data.FindLibVar( local, "");
              this.tempHexLibVarSnowValue = tSlotNr;
              this.tempHexLibVarSnowIsSet = this.game.Data.GameID;
            }
            if (this.game.Data.MapObj[0].HexObj[x1, y1].GetHexLibVarValue(tSlotNr) > 0)
              num6 +=  Math.Round( num6 *  this.game.Data.RuleVar[495] / 100.0);
          }
          num3 += num6;
          if ( this.game.Data.RuleVar[470] > 0.0)
          {
            if (flag1)
              num3 += 5;
            else
              num3 += 10;
          }
        }
        if (index4 > -1)
        {
          let mut num7: i32 =  0;
          if (this.game.Data.Product == 7)
          {
            let mut tfacing: i32 =  1;
            do
            {
              Coordinate coordinate = this.HexNeighbour(x2, y2, 0, tfacing);
              num8: i32;
              if (coordinate.onmap)
              {
                let mut regime2: i32 =  this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime;
                if (regime2 > -1 && this.IsHostileNotSelf(this.game.Data.UnitObj[unr].Regime, regime2) && this.game.Data.MapObj[map2].HexObj[x2, y2].get_ZocPts(regime2) > 0)
                {
                  num8 =  Math.Round( ( num8 + this.game.Data.RuleVar[323]));
                  if (this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index4] > -1)
                    num8 =  Math.Round( ( num8 + this.game.Data.RuleVar[323]));
                }
              }
              if (num8 > num7)
                num7 = num8;
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
          else
          {
            let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
            for (let mut index7: i32 =  0; index7 <= regimeCounter; index7 += 1)
            {
              let mut num9: i32 =  0;
              if (this.IsHostileNotSelf(this.game.Data.UnitObj[unr].Regime, index7) && this.game.Data.MapObj[map2].HexObj[x2, y2].get_ZocPts(index7) > 0)
              {
                num9 =  Math.Round( ( num9 + this.game.Data.RuleVar[323]));
                if (this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index4] > -1)
                  num9 =  Math.Round( ( num9 + this.game.Data.RuleVar[323]));
              }
              if (num9 > num7)
                num7 = num9;
            }
          }
          num3 += num7;
        }
        if (ExtraForEnemyHex > 0 & this.game.Data.MapObj[map2].HexObj[x2, y2].Regime != this.game.Data.UnitObj[unr].Regime)
          num3 += ExtraForEnemyHex;
      }
      let mut location: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].Location;
      bool flag3 = this.game.HandyFunctionsObj.HasUnitNavySF(unr);
      if (flag3 & !this.game.Data.LandscapeTypeObj[landscapeType1].IsSea & !predictaironly)
      {
        this.game.EditObj.ApTempString = "Navy cannot move out of Sea.";
        num3 = 9999;
      }
      if (location > -1 & flag3 & !predictaironly && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsPort && this.IsAlliedOrSelf(this.game.Data.UnitObj[unr].Regime, regime1) | attack)
      {
        num3 =  Math.Round(Conversion.Int( this.game.Data.LandscapeTypeObj[landscapeType1].MoveCost[index3] * ( this.game.Data.MoveTypePenalty[index3] / 100.0)));
        if (this.game.Data.SFTypeObj[index2].MoveRedux != 0)
          num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.SFTypeObj[index2].MoveRedux) / 100.0)));
        if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove > 0)
          num3 =  Math.Round(Conversion.Int( num3 * ( (100 - this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpMove) / 100.0)));
        this.game.EditObj.ApTempString = "";
      }
      if (this.game.Data.MapObj[map2].HexObj[x2, y2].Regime != this.game.Data.UnitObj[unr].Regime &&  this.game.Data.RuleVar[307] >  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) && !this.game.Data.LandscapeTypeObj[landscapeType1].IsSea)
        num3 = 9999;
      if (this.VisibleEnemyUnitsInHex(x2, y2, map2, this.game.Data.UnitObj[unr].Regime, true) & !attack)
      {
        if (GoThroughEnemy == -1)
        {
          if (EnemyIsXAP < 9999)
            num3 += EnemyIsXAP;
          else
            num3 = 9999;
          this.game.EditObj.ApTempString = "Visible enemy units in hex.";
        }
        else if (this.game.AIObj.GetHexForceLandStrength(x2, y2) > GoThroughEnemy)
        {
          num3 = 9999;
          this.game.EditObj.ApTempString = "Enemy Strength in hex to high.";
        }
      }
      if (this.game.Data.UnitObj[unr].FreeCombatX == x2 & this.game.Data.UnitObj[unr].FreeCombatY == y2 & this.game.Data.UnitObj[unr].FreeCombatMap == map2)
        return 0;
      if (this.game.Data.SFTypeObj[index2].Theater == 2 & this.HasUnitNavySF(unr) & !predictaironly && this.game.HandyFunctionsObj.GetAirCarryCapPts(unr) >= Conversions.ToInteger(Operators.SubtractObject(this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, true), this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, false))))
        num3 = 0;
      if (tempTheater == 2 && IsTransfer)
        num3 =  Math.Round(Conversion.Int( num3 / 2.0));
      if (tempTheater == 2 & ismove)
        num3 =  Math.Round(Conversion.Int( num3 / 2.0));
      if (tempTheater < 2 & predictaironly)
        num3 = 0;
      return num3;
    }

    pub fn GetLowestSpeedOnRoad(unr: i32, curtyp: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount == -1)
        return -1;
      int[] numArray1 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray2 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray3 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray4 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray5 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray6 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      if (this.game.Data.RoadTypeCounter == -1)
      {
        let mut num: i32 =   Interaction.MsgBox( "Error - No Road Types defined");
        lowestSpeedOnRoad: i32;
        return lowestSpeedOnRoad;
      }
      if (this.game.Data.UnitObj[unr].IsHQ)
        unr = unr;
      let mut sfCount1: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount1; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut moveType: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].MoveType;
        if (this.game.Data.SFObj[sf].MoveType > -1)
          moveType = this.game.Data.SFObj[sf].MoveType;
        numArray2[index] = this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
        numArray3[index] = this.game.Data.SFTypeObj[type].Weight * this.game.Data.SFObj[sf].Qty;
        numArray5[index] = this.game.Data.SFTypeObj[type].CarryCap * this.game.Data.SFObj[sf].Qty;
      }
      if ( this.game.Data.RuleVar[490] > 0.0)
      {
        let mut num1: i32 =  new Random(unr *  Math.Round( this.game.Data.GameID / 25000.0) * (this.game.Data.Round * 2)).Next(0,  Math.Round( this.game.Data.RuleVar[490]));
        let mut sfCount2: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index1: i32 =  0; index1 <= sfCount2; index1 += 1)
        {
          if (numArray5[index1] > 0)
          {
            int[] numArray7 = numArray5;
            int[] numArray8 = numArray7;
            let mut index2: i32 =  index1;
            let mut index3: i32 =  index2;
            let mut num2: i32 =  numArray7[index2] +  Math.Round(Math.Floor( (numArray5[index1] * num1) / 100.0));
            numArray8[index3] = num2;
          }
        }
      }
      integer: i32;
      if (this.game.Data.UnitObj[unr].IsHQ)
      {
        integer = Conversions.ToInteger(this.GetUnitExcessWeight(unr));
        if (integer > 0)
        {
          numArray2[this.game.Data.UnitObj[unr].SFCount + 1] = 9999;
          numArray3[this.game.Data.UnitObj[unr].SFCount + 1] = integer;
          numArray5[this.game.Data.UnitObj[unr].SFCount + 1] = 0;
        }
      }
      bool flag;
      do
      {
        flag = false;
        let mut sfCount3: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index4: i32 =  0; index4 <= sfCount3; index4 += 1)
        {
          let mut index5: i32 =  -1;
          let mut num3: i32 =  0;
          let mut sfCount4: i32 =  this.game.Data.UnitObj[unr].SFCount;
          typ: i32;
          for (let mut index6: i32 =  0; index6 <= sfCount4; index6 += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index6];
            if (numArray2[index6] > num3 && numArray4[index6] < numArray3[index6] && numArray1[index6] == 0)
            {
              num3 = numArray2[index6];
              index5 = index6;
              typ = this.game.Data.SFObj[sf].Type;
            }
          }
          if (integer > 0)
          {
            let mut index7: i32 =  this.game.Data.UnitObj[unr].SFCount + 1;
            if (numArray2[index7] > num3 && numArray4[index7] < numArray3[index7] && numArray1[index7] == 0)
            {
              let mut num4: i32 =  numArray2[index7];
              index5 = index7;
              typ = -1;
            }
          }
          if (index5 > -1)
          {
            let mut index8: i32 =  -1;
            let mut num5: i32 =  9999;
            let mut sfCount5: i32 =  this.game.Data.UnitObj[unr].SFCount;
            for (let mut index9: i32 =  0; index9 <= sfCount5; index9 += 1)
            {
              let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index9];
              if (numArray2[index9] < num5 && numArray5[index9] > 0)
              {
                if (typ > -1)
                {
                  if (this.CanBeCarriedBy(typ, this.game.Data.SFObj[sf].Type))
                  {
                    num5 = numArray2[index9];
                    index8 = index9;
                  }
                }
                else
                {
                  num5 = numArray2[index9];
                  index8 = index9;
                }
              }
            }
            if (index8 > -1)
            {
              flag = true;
              let mut num6: i32 =  numArray3[index5] - numArray4[index5];
              let mut num7: i32 =  numArray5[index8] <= num6 ? numArray5[index8] : num6;
              int[] numArray9 = numArray4;
              int[] numArray10 = numArray9;
              let mut index10: i32 =  index5;
              let mut index11: i32 =  index10;
              let mut num8: i32 =  numArray9[index10] + num7;
              numArray10[index11] = num8;
              int[] numArray11 = numArray5;
              int[] numArray12 = numArray11;
              let mut index12: i32 =  index8;
              let mut index13: i32 =  index12;
              let mut num9: i32 =  numArray11[index12] - num7;
              numArray12[index13] = num9;
              if (numArray2[index8] > numArray6[index5])
                numArray6[index5] = numArray2[index8];
            }
            else
              numArray1[index5] = 1;
          }
        }
      }
      while (flag);
      let mut num10: i32 =  0;
      let mut index14: i32 =  -1;
      let mut sfCount6: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num11: i32;
      for (let mut index15: i32 =  0; index15 <= sfCount6; index15 += 1)
      {
        num11 = 0;
        let mut num12: i32 =  numArray2[index15];
        if (numArray4[index15] >= numArray3[index15])
        {
          if (numArray6[index15] < numArray2[index15])
            num12 = -1;
          if (num12 > num10)
          {
            num10 = num12;
            index14 = index15;
          }
        }
        else
        {
          if (num12 > num10)
          {
            num10 = num12;
            index14 = index15;
          }
          if (num12 == num10 & curtyp == this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index15]].Type)
          {
            num10 = num12;
            index14 = index15;
          }
        }
      }
      if (integer > 0)
      {
        let mut index16: i32 =  this.game.Data.UnitObj[unr].SFCount + 1;
        num11 = 0;
        let mut num13: i32 =  numArray2[index16];
        if (numArray4[index16] >= numArray3[index16])
          num13 = numArray6[index16];
        if (num13 > num10)
          index14 = -2;
      }
      return index14 > -1 ? this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index14]].Type : index14;
    }

    pub fn GetLowestSpeed(unr: i32, curtyp: i32, bool returnsfnr = false) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount == -1)
        return -1;
      int[] numArray1 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray2 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray3 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray4 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray5 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray6 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray7 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray8 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray9 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray10 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      int[] numArray11 = new int[this.game.Data.UnitObj[unr].SFCount + 1 + 1];
      if (this.game.Data.UnitObj[unr].IsHQ)
        unr = unr;
      let mut sfCount1: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount1; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut moveType: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].MoveType;
        if (this.game.Data.SFObj[sf].MoveType > -1)
          moveType = this.game.Data.SFObj[sf].MoveType;
        numArray2[index] = this.game.Data.LandscapeTypeObj[ Math.Round( this.game.Data.RuleVar[38])].MoveCost[moveType];
        if (numArray2[index] >= 999 & this.game.Data.RoadTypeCounter > -1)
          numArray2[index] = this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
        if (this.game.Data.Product >= 5 & this.game.Data.RoadTypeCounter > -1)
          numArray2[index] = this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
        numArray3[index] = this.game.Data.SFTypeObj[type].Weight * this.game.Data.SFObj[sf].Qty;
        numArray5[index] = this.game.Data.SFTypeObj[type].CarryCap * this.game.Data.SFObj[sf].Qty;
        numArray8[index] = this.game.Data.SFTypeObj[type].manpower;
        numArray9[index] = this.game.Data.SFTypeObj[type].Weight;
        numArray6[index] = this.game.Data.SFTypeObj[type].manpower * this.game.Data.SFObj[sf].Qty;
        numArray7[index] = this.game.Data.SFTypeObj[type].manpowerCarry * this.game.Data.SFObj[sf].Qty;
      }
      if ( this.game.Data.RuleVar[490] > 0.0)
      {
        let mut num1: i32 =  new Random(unr *  Math.Round( this.game.Data.GameID / 25000.0) * (this.game.Data.Round * 2)).Next(0,  Math.Round( this.game.Data.RuleVar[490]));
        let mut sfCount2: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index1: i32 =  0; index1 <= sfCount2; index1 += 1)
        {
          if (numArray5[index1] > 0)
          {
            int[] numArray12 = numArray5;
            int[] numArray13 = numArray12;
            let mut index2: i32 =  index1;
            let mut index3: i32 =  index2;
            let mut num2: i32 =  numArray12[index2] +  Math.Round(Math.Floor( (numArray5[index1] * num1) / 100.0));
            numArray13[index3] = num2;
          }
          if (numArray7[index1] > 0)
          {
            int[] numArray14 = numArray7;
            int[] numArray15 = numArray14;
            let mut index4: i32 =  index1;
            let mut index5: i32 =  index4;
            let mut num3: i32 =  numArray14[index4] +  Math.Round(Math.Floor( (numArray7[index1] * num1) / 100.0));
            numArray15[index5] = num3;
          }
        }
      }
      integer: i32;
      if (this.game.Data.UnitObj[unr].IsHQ)
      {
        integer = Conversions.ToInteger(this.GetUnitExcessWeight(unr));
        if (integer > 0)
        {
          numArray2[this.game.Data.UnitObj[unr].SFCount + 1] = 9999;
          numArray3[this.game.Data.UnitObj[unr].SFCount + 1] = integer;
          numArray5[this.game.Data.UnitObj[unr].SFCount + 1] = 0;
          numArray7[this.game.Data.UnitObj[unr].SFCount + 1] = 0;
          numArray6[this.game.Data.UnitObj[unr].SFCount + 1] = 0;
        }
      }
      bool flag;
      do
      {
        flag = false;
        let mut sfCount3: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index6: i32 =  0; index6 <= sfCount3; index6 += 1)
        {
          let mut index7: i32 =  -1;
          let mut num4: i32 =  0;
          let mut sfCount4: i32 =  this.game.Data.UnitObj[unr].SFCount;
          typ: i32;
          for (let mut index8: i32 =  0; index8 <= sfCount4; index8 += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index8];
            if (numArray2[index8] > num4 && numArray4[index8] < numArray3[index8] | numArray10[index8] < numArray6[index8] && numArray1[index8] == 0)
            {
              num4 = numArray2[index8];
              let mut num5: i32 =  numArray3[index8];
              index7 = index8;
              typ = this.game.Data.SFObj[sf].Type;
            }
          }
          if (integer > 0)
          {
            let mut index9: i32 =  this.game.Data.UnitObj[unr].SFCount + 1;
            if (numArray2[index9] > num4 && numArray4[index9] < numArray3[index9] && numArray1[index9] == 0)
            {
              num4 = numArray2[index9];
              index7 = index9;
              typ = -1;
            }
          }
          if (index7 > -1)
          {
            let mut index10: i32 =  -1;
            let mut num6: i32 =  9999;
            let mut sfCount5: i32 =  this.game.Data.UnitObj[unr].SFCount;
            for (let mut index11: i32 =  0; index11 <= sfCount5; index11 += 1)
            {
              let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index11];
              if (numArray2[index11] < num6 && numArray5[index11] > 0)
              {
                if (typ > -1)
                {
                  if (this.CanBeCarriedBy(typ, this.game.Data.SFObj[sf].Type) & numArray7[index11] >= numArray8[index7])
                  {
                    num6 = numArray2[index11];
                    index10 = index11;
                  }
                }
                else
                {
                  num6 = numArray2[index11];
                  index10 = index11;
                }
              }
            }
            if (index10 > -1 & num4 > num6)
            {
              let mut num7: i32 =  numArray3[index7] - numArray4[index7];
              let mut val1: i32 =  numArray5[index10] <= num7 ? numArray5[index10] : num7;
              let mut num8: i32 =  0;
              if (numArray8[index7] > 0 & val1 > 0)
              {
                let mut num9: i32 =  numArray6[index7] - numArray10[index7];
                num8 = numArray7[index10] <= num9 ? numArray7[index10] : num9;
                let mut num10: i32 =   Math.Round( val1 /  numArray9[index7]);
                let mut num11: i32 =   Math.Round(Math.Ceiling( num8 /  numArray8[index7]));
                if (num11 < num10)
                {
                  val1 = Math.Min(val1, numArray9[index7] * num10);
                  num8 = num11 * numArray8[index7];
                }
              }
              if (val1 > 0)
              {
                flag = true;
                int[] numArray16 = numArray4;
                int[] numArray17 = numArray16;
                let mut index12: i32 =  index7;
                let mut index13: i32 =  index12;
                let mut num12: i32 =  numArray16[index12] + val1;
                numArray17[index13] = num12;
                int[] numArray18 = numArray5;
                int[] numArray19 = numArray18;
                let mut index14: i32 =  index10;
                let mut index15: i32 =  index14;
                let mut num13: i32 =  numArray18[index14] - val1;
                numArray19[index15] = num13;
                int[] numArray20 = numArray10;
                int[] numArray21 = numArray20;
                let mut index16: i32 =  index7;
                let mut index17: i32 =  index16;
                let mut num14: i32 =  numArray20[index16] + num8;
                numArray21[index17] = num14;
                int[] numArray22 = numArray7;
                int[] numArray23 = numArray22;
                let mut index18: i32 =  index10;
                let mut index19: i32 =  index18;
                let mut num15: i32 =  numArray22[index18] - num8;
                numArray23[index19] = num15;
                if (numArray2[index10] > numArray11[index7])
                  numArray11[index7] = numArray2[index10];
              }
              else if (index10 > -1 & index7 > -1)
              {
                let mut num16: i32 =  numArray6[index7] - numArray10[index7];
                let mut num17: i32 =  numArray7[index10] <= num16 ? numArray7[index10] : num16;
                if (num17 > 0 & num16 > 0)
                {
                  int[] numArray24 = numArray10;
                  int[] numArray25 = numArray24;
                  let mut index20: i32 =  index7;
                  let mut index21: i32 =  index20;
                  let mut num18: i32 =  numArray24[index20] + num17;
                  numArray25[index21] = num18;
                  int[] numArray26 = numArray7;
                  int[] numArray27 = numArray26;
                  let mut index22: i32 =  index10;
                  let mut index23: i32 =  index22;
                  let mut num19: i32 =  numArray26[index22] - num17;
                  numArray27[index23] = num19;
                  if (numArray2[index10] > numArray11[index7])
                    numArray11[index7] = numArray2[index10];
                }
                else
                  numArray1[index7] = 1;
              }
              else
                numArray1[index7] = 1;
            }
          }
        }
      }
      while (flag);
      let mut num20: i32 =  0;
      let mut lowestSpeed: i32 =  -1;
      let mut sfCount6: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num21: i32;
      for (let mut index: i32 =  0; index <= sfCount6; index += 1)
      {
        num21 = 0;
        let mut num22: i32 =  numArray2[index];
        if (numArray4[index] >= numArray3[index] & numArray10[index] >= numArray6[index])
        {
          if (numArray11[index] < numArray2[index])
            num22 = -1;
          if (num22 > num20)
          {
            num20 = num22;
            lowestSpeed = index;
          }
        }
        else
        {
          if (num22 > num20)
          {
            num20 = num22;
            lowestSpeed = index;
          }
          if (num22 == num20 & curtyp == this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type)
          {
            num20 = num22;
            lowestSpeed = index;
          }
        }
      }
      if (integer > 0)
      {
        let mut index: i32 =  this.game.Data.UnitObj[unr].SFCount + 1;
        num21 = 0;
        let mut num23: i32 =  numArray2[index];
        if (numArray4[index] >= numArray3[index])
          num23 = numArray11[index];
        if (num23 > num20 | num20 == 9999)
          lowestSpeed = -2;
      }
      if (lowestSpeed <= -1)
        return lowestSpeed;
      return returnsfnr ? this.game.Data.UnitObj[unr].SFList[lowestSpeed] : this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[lowestSpeed]].Type;
    }

    pub object GetUnitExcessWeight(unr: i32)
    {
      let mut num1: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          num1 += this.game.Data.SFTypeObj[type].SupplyCarry * this.game.Data.SFObj[sf].Qty;
        }
      }
      num2: i32;
      if (num1 < this.game.Data.UnitObj[unr].Supply)
        num2 =  Math.Round( Conversion.Int(this.game.Data.RuleVar[33] *  (this.game.Data.UnitObj[unr].Supply - num1)));
      integer: i32;
      if (this.game.Data.UnitObj[unr].PassengerCounter > -1)
      {
        let mut passengerCounter: i32 =  this.game.Data.UnitObj[unr].PassengerCounter;
        for (let mut index: i32 =  0; index <= passengerCounter; index += 1)
        {
          let mut passenger: i32 =  this.game.Data.UnitObj[unr].PassengerList[index];
          integer = Conversions.ToInteger(Operators.AddObject( integer, Operators.AddObject( this.GetUnitWeight(passenger), this.GetUnitExcessWeight(passenger))));
        }
      }
      return  (num2 + integer);
    }

    pub CanBeCarriedBy: bool(typ: i32, bytyp: i32)
    {
      if (typ == bytyp)
        return false;
      bool flag = true;
      let mut theater1: i32 =  this.game.Data.SFTypeObj[typ].Theater;
      let mut theater2: i32 =  this.game.Data.SFTypeObj[bytyp].Theater;
      if (this.game.Data.SFTypeObj[typ].Weight > this.game.Data.SFTypeObj[bytyp].CarryCap)
        flag = false;
      if (theater1 > 0 & theater2 == 0)
        flag = false;
      if (theater1 > 0 & theater2 == 2)
        flag = false;
      return flag;
    }

    pub EnemyNavyAround: bool(x: i32, y: i32, map: i32, regnr: i32)
    {
      bool flag = false;
      let mut tfacing1: i32 =  1;
      do
      {
        Coordinate coordinate1 = this.HexNeighbour(x, y, map, tfacing1);
        if (coordinate1.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[coordinate1.map].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
        {
          if (this.game.Data.MapObj[coordinate1.map].HexObj[coordinate1.x, coordinate1.y].UnitCounter > -1)
          {
            let mut unitCounter: i32 =  this.game.Data.MapObj[coordinate1.map].HexObj[coordinate1.x, coordinate1.y].UnitCounter;
            for (let mut index: i32 =  0; index <= unitCounter; index += 1)
            {
              let mut unit: i32 =  this.game.Data.MapObj[coordinate1.map].HexObj[coordinate1.x, coordinate1.y].UnitList[index];
              if (this.IsHostileNotSelf(regnr, this.game.Data.UnitObj[unit].Regime))
                flag = true;
            }
          }
          let mut num: i32 =  this.HexNeighbourCount(coordinate1.x, coordinate1.y, coordinate1.map);
          for (let mut tfacing2: i32 =  1; tfacing2 <= num; tfacing2 += 1)
          {
            Coordinate coordinate2 = this.HexNeighbour(coordinate1.x, coordinate1.y, coordinate1.map, tfacing2);
            if (coordinate2.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitCounter > -1)
            {
              let mut unitCounter: i32 =  this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitCounter;
              for (let mut index: i32 =  0; index <= unitCounter; index += 1)
              {
                let mut unit: i32 =  this.game.Data.MapObj[coordinate2.map].HexObj[coordinate2.x, coordinate2.y].UnitList[index];
                if (this.IsHostileNotSelf(regnr, this.game.Data.UnitObj[unit].Regime))
                  flag = true;
              }
            }
          }
        }
        tfacing1 += 1;
      }
      while (tfacing1 <= 6);
      return flag;
    }

    pub Coordinate MoveApCostPreview2(
      ox1: i32,
      oy1: i32,
      byregnr: i32,
      movetype: i32,
      theater: i32,
      x1: i32,
      y1: i32,
      map1: i32,
      x2: i32,
      y2: i32,
      map2: i32,
      bool dontenterenemy = true,
      bool AllowShoreDrop = false,
      bool NoAPPenalties = false,
      bool SeaBlock = false,
      bool BlockAllSea = false,
      bool istransfer = false,
      bool EngineerTest = false,
      bool EnemyPenalty = false,
      bool IsForSupplyLayer = false,
      let mut redux: i32 =  0,
      bool DontCountEnemyRoads = false,
      bool nobridgepenalty = false,
      bool UseCounterOwner = false,
      bool UseTempOwner = false,
      let mut OverruleRoadType: i32 =  -1,
      let mut BridgeAP: i32 =  0,
      let mut SFTypeX: i32 =  -1,
      let mut PreviousAPspent: i32 =  0,
      let mut SFTypeQty: i32 =  0,
      let mut FacingPreview: i32 =  -1,
      bool roadsOnly = false,
      bool alwaysUseLogisticalBonus = false,
      bool useTrafficRules = false,
      bool blockLogisticalBonus = false,
      let mut lisMode: i32 =  0,
      float trafficPointMod = 1f,
      let mut specialRuleNumber: i32 =  0,
      let mut specialRuleNumber2: i32 =  0)
    {
      let mut index1: i32 =  movetype;
      let mut landscapeType1: i32 =  this.game.Data.MapObj[map1].HexObj[x1, y1].LandscapeType;
      let mut landscapeType2: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType;
      if (x2 == 107 & y2 == 62)
        x2 = x2;
      let mut val1_1: i32 =   Math.Round(Conversion.Int( this.game.Data.LandscapeTypeObj[landscapeType2].MoveCost[index1] * ( this.game.Data.MoveTypePenalty[index1] / 100.0)));
      if (redux != 0)
        val1_1 =  Math.Round(Conversion.Int( val1_1 * ( (100 - redux) / 100.0)));
      if (BlockAllSea & this.game.Data.LandscapeTypeObj[landscapeType2].IsSea)
      {
        Coordinate coordinate;
        coordinate.x = 9999;
        coordinate.y = 0;
        return coordinate;
      }
      if (this.game.Data.UseAI < 1 & this.game.Data.Turn > -1 && this.game.Data.RegimeObj[this.game.Data.Turn].AI)
        AllowShoreDrop = true;
      regime1: i32;
      regime2: i32;
      if (UseCounterOwner)
      {
        regime1 = this.game.NewAIObj.TempCounterOwner[x2, y2];
        regime2 = this.game.NewAIObj.TempCounterOwner[x1, y1];
      }
      else if (UseTempOwner)
      {
        regime1 = this.game.NewAIObj.TempOwner[x2, y2];
        regime2 = this.game.NewAIObj.TempOwner[x1, y1];
      }
      else
      {
        regime1 = this.game.Data.MapObj[map2].HexObj[x2, y2].Regime;
        regime2 = this.game.Data.MapObj[map1].HexObj[x1, y1].Regime;
      }
      bool flag1;
      if (regime1 > -1 & regime2 > -1 && regime1 != regime2 && this.game.Data.RegimeObj[regime1].RegimeRel[regime2] == 2)
      {
        DontCountEnemyRoads = false;
        flag1 = true;
      }
      let mut location1: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].Location;
      let mut location2: i32 =  this.game.Data.MapObj[map1].HexObj[x1, y1].Location;
      index2: i32;
      if (FacingPreview == -1)
      {
        index2 = this.game.HandyFunctionsObj.HexFacing(x2, y2, map2, x1, y1, map1) - 1 + 3;
        if (index2 > 5)
          index2 -= 6;
      }
      else
      {
        let mut num1: i32 =  FacingPreview + 3;
        if (num1 > 5)
        {
          let mut num2: i32 =  num1 - 6;
        }
        index2 = FacingPreview;
      }
      let mut index3: i32 =  this.game.HandyFunctionsObj.HexFacing(x2, y2, map2, x1, y1, map1) - 1;
      bool flag2;
      if ( this.game.Data.RuleVar[452] > 0.0 && this.game.Data.MapObj[0].HexObj[x1, y1].RoadType[index2] > -1)
        flag2 = true;
      if (roadsOnly)
      {
        if (this.game.Data.MapObj[0].HexObj[x1, y1].RoadType[index2] == -1)
        {
          Coordinate coordinate;
          coordinate.x = 9999;
          coordinate.y = 0;
          return coordinate;
        }
        if (this.game.Data.MapObj[0].HexObj[x2, y2].RoadType[index3] == -1)
        {
          Coordinate coordinate;
          coordinate.x = 9999;
          coordinate.y = 0;
          return coordinate;
        }
      }
      if (this.game.Data.Round > 0 && index3 < 0 & this.game.Data.RegimeObj[this.game.Data.Turn].AI & this.game.Data.UseAI <= 1)
      {
        Coordinate coordinate;
        coordinate.x = 9999;
        coordinate.y = 0;
        return coordinate;
      }
      if ( movetype ==  this.game.Data.RuleVar[1] && this.IsHexPort(x1, y1, map1) & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map1].HexObj[x1, y1].LandscapeType].IsSea && this.IsHexPort(x2, y2, map2) & !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].LandscapeType].IsSea)
      {
        this.game.EditObj.ApTempString = "Naval transfer cannot go from harbour to harbour.";
        Coordinate coordinate;
        coordinate.x = 9999;
        coordinate.y = 0;
        return coordinate;
      }
      if (byregnr > -1 && this.game.Data.MapObj[map2].HexObj[x2, y2].get_SeeNow(byregnr) == 0 & this.game.Data.Round > 0)
      {
        let mut num: i32 =  1;
        if (this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(byregnr) > -1 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map2].HexObj[x2, y2].get_LastLT(byregnr)].IsSea)
          num = 0;
        if (num == 1)
        {
          Coordinate coordinate;
          coordinate.x = 9999;
          coordinate.y = 0;
          return coordinate;
        }
      }
      bool flag3 = false;
      bool flag4 = true;
      if (this.game.Data.Product >= 6)
      {
        if (this.game.Data.LandscapeTypeObj[landscapeType2].BlackedOut)
          flag4 = false;
        if (this.game.Data.LandscapeTypeObj[landscapeType1].BlackedOut)
          flag4 = false;
      }
      if (flag4 & (theater == 0 | theater == 99))
      {
        if (index3 > -1 && this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index3] > -1)
        {
          if (!(!dontenterenemy & DontCountEnemyRoads & regime1 != byregnr & !flag1))
          {
            let mut index4: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index3];
            flag3 = true;
            if (this.game.Data.RoadTypeObj[index4].MoveCostOverrule[index1] < val1_1)
            {
              num3: i32;
              if (useTrafficRules &  this.game.Data.RuleVar[459] > 0.0 & this.game.Data.RoadTypeObj[index4].trafficPoints > 0)
              {
                let mut index5: i32 =  this.game.Data.MapObj[map2].HexObj[x1, y1].RoadType[index2];
                let mut val1_2: i32 =   Math.Round(Math.Floor( ( Math.Round( ( this.game.Data.MapObj[0].HexObj[x2, y2].LISpoints[index3] * trafficPointMod)) * 100) /  this.game.Data.RoadTypeObj[index4].trafficPoints));
                let mut val2: i32 =  0;
                if (index5 > -1 && this.game.Data.RoadTypeObj[index5].trafficPoints > 0)
                  val2 =  Math.Round(Math.Floor( ( Math.Round( ( this.game.Data.MapObj[0].HexObj[x1, y1].LISpoints[index2] * trafficPointMod)) * 100) /  this.game.Data.RoadTypeObj[index5].trafficPoints));
                let mut num4: i32 =  Math.Max(val1_2, val2);
                if (num4 >= 100)
                {
                  if (num4 >= 400)
                    num4 = 400;
                  else if (num4 >= 300)
                    num4 = 300;
                  else if (num4 >= 200)
                    num4 = 200;
                  else if (num4 >= 100)
                    num4 = 100;
                  num3 =  Math.Round(Math.Ceiling( val1_1 * ( num4 / 400.0))) +  Math.Round(Math.Ceiling( this.game.Data.RoadTypeObj[index4].MoveCostOverrule[index1] * ( (400 - num4) / 400.0)));
                }
                else
                  num3 = this.game.Data.RoadTypeObj[index4].MoveCostOverrule[index1];
              }
              else
                num3 = this.game.Data.RoadTypeObj[index4].MoveCostOverrule[index1];
              val1_1 =  Math.Round(Conversion.Int( num3 * ( this.game.Data.MoveTypePenalty[index1] / 100.0)));
              if (redux != 0)
                val1_1 =  Math.Round(Conversion.Int( val1_1 * ( (100 - redux) / 100.0)));
            }
          }
          else if (OverruleRoadType > -1 & !this.game.Data.LandscapeTypeObj[landscapeType2].IsSea & !this.game.Data.LandscapeTypeObj[landscapeType1].IsSea)
          {
            if (!(!dontenterenemy & DontCountEnemyRoads & regime1 != byregnr & !flag1))
            {
              let mut index6: i32 =  OverruleRoadType;
              flag3 = true;
              if (this.game.Data.RoadTypeObj[index6].MoveCostOverrule[index1] < val1_1)
                val1_1 = this.game.Data.RoadTypeObj[index6].MoveCostOverrule[index1];
              val1_1 =  Math.Round(Conversion.Int( val1_1 * ( this.game.Data.MoveTypePenalty[index1] / 100.0)));
              if (redux != 0)
                val1_1 =  Math.Round(Conversion.Int( val1_1 * ( (100 - redux) / 100.0)));
              if (BridgeAP > 0)
                val1_1 =  Math.Round(Math.Max( val1_1,  BridgeAP / 4.0));
            }
          }
          else if (EngineerTest &  this.game.Data.RuleVar[32] > -1.0)
          {
            val1_1 =  Math.Round( Conversion.Int( this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].MoveCostOverrule[index1] * this.game.Data.RuleVar[213]));
            if (!this.game.Data.LandscapeTypeObj[landscapeType2].CanBuildRoad)
              val1_1 = 9999;
          }
        }
        if (index3 > -1 & !flag2 && this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index3] > -1)
        {
          let mut index7: i32 =  this.game.Data.MapObj[map2].HexObj[x2, y2].RiverType[index3];
          if (!this.game.Data.MapObj[map2].HexObj[x2, y2].Bridge[index3] | !dontenterenemy & DontCountEnemyRoads & regime1 != byregnr & !flag1)
          {
            if (!EngineerTest)
            {
              if (byregnr > -1)
              {
                if (!this.game.Data.RegimeObj[byregnr].AI | this.game.Data.UseAI >= 1 |  this.game.Data.RuleVar[257] > 0.0 |  this.game.Data.RuleVar[865] < 1.0)
                {
                  if (!nobridgepenalty)
                  {
                    if ( this.game.Data.RuleVar[945] > 0.0 &  this.game.Data.RuleVar[945] ==  index1 & this.game.Data.RegimeObj[byregnr].FerryEffectivity > 0)
                    {
                      if (this.game.HandyFunctionsObj.IsHexPort(x1, y1, 0))
                        val1_1 +=  Math.Round((1.0 -  this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x1, y1].Location].StructuralPts /  this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x1, y1].Location].Type].StructuralPts * ( this.game.Data.RegimeObj[byregnr].FerryEffectivity / 100.0)) *  this.game.Data.RiverTypeObj[index7].MovePenalty[index1]);
                      else
                        val1_1 += this.game.Data.RiverTypeObj[index7].MovePenalty[index1];
                    }
                    else
                      val1_1 += this.game.Data.RiverTypeObj[index7].MovePenalty[index1];
                  }
                  else if ( this.game.Data.RuleVar[320] == 1.0 && this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index3] == -1)
                    val1_1 += this.game.Data.RiverTypeObj[index7].MovePenalty[index1];
                }
                else
                  val1_1 = val1_1;
              }
              else if (!nobridgepenalty)
                val1_1 += this.game.Data.RiverTypeObj[index7].MovePenalty[index1];
              else if ( this.game.Data.RuleVar[320] == 1.0 && this.game.Data.MapObj[map2].HexObj[x2, y2].RoadType[index3] == -1)
                val1_1 += this.game.Data.RiverTypeObj[index7].MovePenalty[index1];
            }
            else
              val1_1 =  Math.Round( ( val1_1 + this.game.Data.RuleVar[212]));
            if (BridgeAP > 0)
              val1_1 += BridgeAP;
          }
        }
        if (byregnr == this.game.Data.Turn & byregnr > -1 && !NoAPPenalties)
          val1_1 += this.game.Data.MapObj[map2].HexObj[x2, y2].get_APPenalty(byregnr);
        if (this.game.AllowHeightMap & val1_1 < 9999)
        {
          let mut num: i32 =  this.game.Data.MapObj[0].HexObj[x2, y2].HeightLevel - this.game.Data.MapObj[0].HexObj[x1, y1].HeightLevel;
          index8: i32;
          if (num > 0)
          {
            if (!flag3)
            {
              if (num == 1)
                val1_1 +=  Math.Round(1.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index8].heightLevelDiff / 100.0);
              if (num == 2)
                val1_1 +=  Math.Round(2.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index8].heightLevelDiff / 100.0);
              if (num >= 3)
                val1_1 +=  Math.Round(5.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index8].heightLevelDiff / 100.0);
            }
          }
          else if (num < 0 && !flag3)
          {
            if (num == -1)
              val1_1 +=  Math.Round(0.5 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index8].heightLevelDiff / 100.0);
            if (num == -2)
              val1_1 +=  Math.Round(1.0 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index8].heightLevelDiff / 100.0);
            if (num <= -3)
              val1_1 +=  Math.Round(2.5 *  this.game.Data.RuleVar[426] *  this.game.Data.SFTypeObj[index8].heightLevelDiff / 100.0);
          }
        }
      }
      bool flag5 = theater == 1;
      if (theater == 99 & (this.game.Data.LandscapeTypeObj[landscapeType2].IsSea | this.game.Data.LandscapeTypeObj[landscapeType1].IsSea))
        flag5 = true;
      else if (theater == 99)
        flag5 = false;
      if (theater == 2 && istransfer)
        val1_1 =  Math.Round(Conversion.Int( val1_1 / 2.0));
      if (x2 == 10 & y2 == 46)
        x2 = x2;
      if (flag5)
      {
        if (theater != 99)
        {
          if (!AllowShoreDrop)
          {
            if (flag5 & !this.game.Data.LandscapeTypeObj[landscapeType2].IsSea)
              val1_1 = 9999;
          }
          else if (flag5 & !this.game.Data.LandscapeTypeObj[landscapeType2].IsSea && !this.game.Data.LandscapeTypeObj[landscapeType1].IsSea)
            val1_1 = 9999;
          if (location1 > -1 & flag5 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location1].Type].IsPort && this.game.HandyFunctionsObj.IsAlliedOrSelf(byregnr, regime1))
          {
            val1_1 =  Math.Round(Conversion.Int( this.game.Data.LandscapeTypeObj[landscapeType2].MoveCost[index1] * ( this.game.Data.MoveTypePenalty[index1] / 100.0)));
            if (redux != 0)
              val1_1 =  Math.Round(Conversion.Int( val1_1 * ( (100 - redux) / 100.0)));
          }
        }
        else
        {
          if (!AllowShoreDrop)
          {
            if (!this.game.Data.LandscapeTypeObj[landscapeType1].NoPortReq && flag5 & !this.game.Data.LandscapeTypeObj[landscapeType2].IsSea)
              val1_1 = 9999;
          }
          else if (flag5 & !this.game.Data.LandscapeTypeObj[landscapeType2].IsSea)
          {
            if (!this.game.Data.LandscapeTypeObj[landscapeType1].IsSea)
              val1_1 = 9999;
            else if (!this.game.Data.RegimeObj[byregnr].AI | this.game.Data.UseAI >= 1 |  this.game.Data.RuleVar[257] > 0.0 && !this.game.Data.LandscapeTypeObj[landscapeType1].NoPortReq)
              val1_1 =  Math.Round( ( val1_1 + this.game.Data.RuleVar[82]));
          }
          if (!this.game.Data.LandscapeTypeObj[landscapeType1].IsSea)
          {
            if (!this.game.Data.LandscapeTypeObj[landscapeType2].NoPortReq)
              val1_1 = 9999;
            if (location2 > -1 & flag5)
            {
              let mut type: i32 =  this.game.Data.LocObj[location2].Type;
              if (this.game.Data.LocTypeObj[type].IsPort && this.game.HandyFunctionsObj.IsAlliedOrSelf(byregnr, regime2))
              {
                val1_1 = this.game.Data.LandscapeTypeObj[landscapeType2].MoveCost[index1];
                if ( this.game.Data.LocObj[location2].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts < 1.0 && !this.game.Data.LandscapeTypeObj[landscapeType2].NoPortReq)
                  val1_1 =  Math.Round( val1_1 + ( this.game.Data.RuleVar[82] -  this.game.Data.RuleVar[82] * ( this.game.Data.LocObj[location2].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts)));
              }
            }
          }
          if (location1 > -1 & flag5)
          {
            let mut type: i32 =  this.game.Data.LocObj[location1].Type;
            if (this.game.Data.LocTypeObj[type].IsPort && this.game.HandyFunctionsObj.IsAlliedOrSelf(byregnr, regime1))
            {
              val1_1 = this.game.Data.LandscapeTypeObj[landscapeType2].MoveCost[index1];
              if ( this.game.Data.LocObj[location1].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts < 1.0 && !this.game.Data.LandscapeTypeObj[landscapeType1].NoPortReq)
                val1_1 =  Math.Round( val1_1 + ( this.game.Data.RuleVar[82] -  this.game.Data.RuleVar[82] * ( this.game.Data.LocObj[location1].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts)));
            }
          }
        }
      }
      if (EnemyPenalty && regime1 != byregnr && !this.game.Data.LandscapeTypeObj[landscapeType2].IsSea & !flag1)
        val1_1 =  Math.Round( ( val1_1 + this.game.Data.RuleVar[4]));
      if (dontenterenemy & this.game.Data.Product >= 6 | dontenterenemy & !EnemyPenalty & this.game.Data.Product < 6 && theater != 2 && regime1 != byregnr && !this.game.Data.LandscapeTypeObj[landscapeType2].IsSea)
      {
        let mut num: i32 =  0;
        if (regime1 > -1 & byregnr > -1)
        {
          if (this.game.Data.RegimeObj[byregnr].RegimeRel[regime1] == 2)
            num = 1;
        }
        else if (byregnr == -1)
          num = 1;
        if (num == 0)
          val1_1 = 9999;
      }
      if (BlockAllSea && this.game.Data.LandscapeTypeObj[landscapeType2].IsSea)
        val1_1 = 9999;
      Coordinate coordinate1;
      if (SFTypeX > -1 & SFTypeQty > 0 && this.game.Data.SFTypeObj[SFTypeX].FuelForMove > 0 && this.game.Data.SFTypeObj[SFTypeX].FuelRegimeVar > -1)
      {
        let mut currentSlot: i32 =  this.game.Data.SFTypeObj[SFTypeX].FuelRegimeVar;
        if ( this.game.Data.RuleVar[949] > 0.0)
          currentSlot = this.game.HandyFunctionsObj.GetFuelSlot949(currentSlot, ox1, oy1);
        let mut num5: i32 =   Math.Round(Conversion.Int( ((val1_1 + PreviousAPspent) * this.game.Data.SFTypeObj[SFTypeX].FuelForMove) / 10.0));
        if (this.game.Data.SFTypeObj[SFTypeX].FuelForMove > num5)
          num5 = this.game.Data.SFTypeObj[SFTypeX].FuelForMove;
        let mut num6: i32 =  num5 * SFTypeQty;
        if (this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[currentSlot] < num6)
        {
          val1_1 =  Math.Round( ( val1_1 * this.game.Data.SFTypeObj[SFTypeX].OutOfFuelMove));
          coordinate1.y = 1;
        }
      }
      if (lisMode > 1000 & lisMode < 9999)
      {
        let mut num7: i32 =  lisMode - 1000;
        if (this.game.Data.MapObj[0].HexObj[x2, y2].LISpoints[6] < 1)
        {
          val1_1 = 9999;
        }
        else
        {
          let mut num8: i32 =   Math.Round(Math.Floor( this.game.Data.MapObj[0].HexObj[x2, y2].LISpoints[6] / 100.0));
          if (num8 < 1)
            num8 = 1;
          if (num8 > 100)
            num8 = 100;
          if (num8 > 10 & num8 < 50)
            num8 = num8;
          val1_1 +=  Math.Round( (val1_1 * 2 * (100 - num8)) / 100.0);
        }
      }
      if (lisMode > 100000 & lisMode < 199999)
      {
        let mut num9: i32 =  lisMode - 100000;
        if (num9 > 0)
        {
          let mut num10: i32 =   Math.Round(Math.Floor( this.game.Data.MapObj[0].HexObj[x2, y2].LIStotalHistory[6] /  num9));
          if (num10 < 1)
            num10 = 0;
          if (num10 > 100)
            num10 = 100;
          val1_1 +=  Math.Round( (50 * (100 - num10)) / 100.0);
        }
      }
      if (x1 == 22 & y1 == 13 & index2 == 1)
        x1 = x1;
      if (specialRuleNumber == 1 && val1_1 > 10 & val1_1 < 9999)
      {
        val1_1 +=  Math.Round( (val1_1 - 10) * Math.Ceiling( val1_1 / 100.0));
        if (val1_1 > 9999)
          val1_1 = 9999;
      }
      if (specialRuleNumber == 2)
      {
        NeighboursExtra lisTraffic = this.game.HandyFunctionsObj.GetLisTraffic(x1, y1);
        if (lisTraffic.data[index2] > 0 & lisTraffic.rail)
        {
          if (lisTraffic.data[index2] == 1)
            val1_1 += 40;
          if (lisTraffic.data[index2] == 2)
            val1_1 += 80;
          if (lisTraffic.data[index2] == 3)
            val1_1 += 120;
          if (lisTraffic.data[index2] == 4)
            val1_1 += 160;
          if (lisTraffic.data[index2] == 5)
            val1_1 += 180;
          if (lisTraffic.data[index2] == 6)
            val1_1 += 190;
          if (lisTraffic.data[index2] == 7)
            val1_1 += 200;
        }
      }
      if (specialRuleNumber == 3)
      {
        NeighboursExtra lisTraffic = this.game.HandyFunctionsObj.GetLisTraffic(x1, y1);
        if (x1 == 97 & y1 == 51)
          x1 = x1;
        if (lisTraffic.pull)
        {
          if (lisTraffic.data[index2] >= 7 & lisTraffic.pull)
            val1_1 = 9999;
          else if (lisTraffic.data[index2] > 0 & lisTraffic.pull)
          {
            if (lisTraffic.data[index2] == 1)
              val1_1 += 40;
            if (lisTraffic.data[index2] == 2)
              val1_1 += 80;
            if (lisTraffic.data[index2] == 3)
              val1_1 += 120;
            if (lisTraffic.data[index2] == 4)
              val1_1 += 160;
            if (lisTraffic.data[index2] == 5)
              val1_1 += 180;
            if (lisTraffic.data[index2] == 6)
              val1_1 += 190;
          }
        }
      }
      if (specialRuleNumber2 > 0)
      {
        if (x2 == 22 & y2 == 13 & index2 == 1)
          x2 = x2;
        if (this.game.EditObj.origPossiblePull[x1, y1, index2] <= 0)
          val1_1 = 9999;
        else if (this.game.EditObj.PossiblePull[x1, y1, index2] - specialRuleNumber2 < this.game.EditObj.origPossiblePull[x1, y1, index2])
        {
          let mut num11: i32 =  this.game.EditObj.PossiblePull[x1, y1, index2] - specialRuleNumber2;
          if (num11 >= 0)
            val1_1 = val1_1;
          else if (this.game.EditObj.PossiblePull[x1, y1, index2] < 1)
          {
            val1_1 = 9999;
          }
          else
          {
            let mut num12: i32 =  Math.Abs(num11);
            float num13 =  Math.Abs(num12) /  this.game.EditObj.PossiblePull[x1, y1, index2];
            val1_1 =  num13 >= 1.0 ? ( num13 >= 2.0 ? ( num13 >= 4.0 ?  Math.Round( val1_1 +  (120 * num12) /  specialRuleNumber2) :  Math.Round( val1_1 +  (80 * num12) /  specialRuleNumber2)) :  Math.Round( val1_1 +  (40 * num12) /  specialRuleNumber2)) :  Math.Round( ( val1_1 + 20f * num13 *  num12 /  specialRuleNumber2));
          }
        }
      }
      coordinate1.x = val1_1;
      coordinate1.data2 = 0;
      if (!blockLogisticalBonus && theater == 99 | alwaysUseLogisticalBonus)
        coordinate1.data2 = this.GetLogisticalBonus(x1, y1, lisMode);
      return coordinate1;
    }

    pub fn GetLogisticalBonus(x1: i32, y1: i32, lisMode: i32) -> i32
    {
      let mut location: i32 =  this.game.Data.MapObj[0].HexObj[x1, y1].Location;
      let mut logisticalBonus: i32 =  0;
      if (location > -1)
      {
        let mut type: i32 =  this.game.Data.LocObj[location].Type;
        if (this.game.Data.LocTypeObj[type].Logistical > 0)
        {
          logisticalBonus = this.game.Data.LocTypeObj[type].Logistical;
          if (!this.game.Data.LocTypeObj[type].Invincible | this.game.Data.Product >= 6)
            logisticalBonus =  Math.Round(Conversion.Int( logisticalBonus * ( this.game.Data.LocObj[location].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts)));
        }
      }
      if (this.game.Data.Product >= 7 &  this.game.Data.RuleVar[403] > 0.0)
      {
        num: i32;
        if (lisMode > 0 & lisMode <= 99 & location > -1)
        {
          num = 0;
          let mut logCounter: i32 =  this.game.Data.LocObj[location].LogCounter;
          for (let mut index: i32 =  0; index <= logCounter; index += 1)
          {
            if (this.game.Data.LocObj[location].LogType[index] == 800 + lisMode)
              num = this.game.Data.LocObj[location].LogData3[index];
          }
        }
        if (num > 0)
          logisticalBonus += num;
      }
      if (this.game.Data.Product >= 6 &  this.game.Data.RuleVar[471] > 0.0)
      {
        let mut location2: i32 =  this.game.Data.MapObj[0].HexObj[x1, y1].Location2;
        let mut num: i32 =  0;
        if (location2 > -1)
        {
          let mut type: i32 =  this.game.Data.LocObj[location2].Type;
          if (this.game.Data.LocTypeObj[type].Logistical > 0)
          {
            num = this.game.Data.LocTypeObj[type].Logistical;
            if (!this.game.Data.LocTypeObj[type].Invincible | this.game.Data.Product >= 6)
              num =  Math.Round(Conversion.Int( num * ( this.game.Data.LocObj[location2].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts)));
          }
        }
        if (num > 0 && num > logisticalBonus)
          logisticalBonus = num;
      }
      return logisticalBonus;
    }

    pub fn MakeMovePredictionSimple(regnr: i32, movetype: i32, x: i32, y: i32)
    {
      Coordinate[] arySrc1 = new Coordinate[1];
      bool[] arySrc2 = new bool[1];
      let mut num1: i32 =   Math.Round( this.game.Data.RuleVar[3]);
      let mut index1: i32 =  0;
      this.RedimTempValue(9999);
      this.RedimTempCameFrom();
      let mut num2: i32 =  0;
      arySrc1[0].x = x;
      arySrc1[0].y = y;
      arySrc1[0].map = 0;
      arySrc2[0] = true;
      this.game.EditObj.TempValue[index1].Value[x, y] = 0;
      let mut num3: i32 =  1;
      CoordList coordList = CoordList::new();
      while (num3 > 0)
      {
        num3 = 0;
        let mut num4: i32 =  num2;
        for (let mut index2: i32 =  0; index2 <= num4; index2 += 1)
        {
          if (arySrc2[index2])
          {
            let mut tfacing: i32 =  1;
            do
            {
              Coordinate coordinate = this.HexNeighbour(arySrc1[index2].x, arySrc1[index2].y, arySrc1[index2].map, tfacing);
              if (coordinate.onmap)
              {
                let mut num5: i32 =  this.game.EditObj.TempValue[arySrc1[index2].map].Value[arySrc1[index2].x, arySrc1[index2].y];
                let mut num6: i32 =  this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime != regnr ? 9999 : (!(this.game.Data.MapObj[0].HexObj[arySrc1[index2].x, arySrc1[index2].y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[0].HexObj[arySrc1[index2].x, arySrc1[index2].y].Bridge[tfacing - 1]) ? (this.game.Data.MapObj[0].HexObj[arySrc1[index2].x, arySrc1[index2].y].RoadType[tfacing - 1] != -1 ? num5 + 1 : 9999) : 9999);
                bool flag = false;
                if (num6 <= num1 && num6 < this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y])
                  flag = true;
                if (flag)
                {
                  let mut index3: i32 =  -1;
                  let mut num7: i32 =  num2;
                  for (let mut index4: i32 =  0; index4 <= num7; index4 += 1)
                  {
                    if (arySrc2[index4] && arySrc1[index4].x == coordinate.x & arySrc1[index4].y == coordinate.y & arySrc1[index4].map == coordinate.map)
                    {
                      index3 = index4;
                      break;
                    }
                  }
                  if (index3 == -1)
                  {
                    let mut num8: i32 =  num2;
                    for (let mut index5: i32 =  0; index5 <= num8; index5 += 1)
                    {
                      if (!arySrc2[index5])
                      {
                        index3 = index5;
                        break;
                      }
                    }
                  }
                  if (index3 == -1)
                  {
                    num2 += 1;
                    num9: i32;
                    if (num2 > num9)
                    {
                      num9 += 2000;
                      arySrc1 = (Coordinate[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc1, (Array) new Coordinate[num9 + 1]);
                      arySrc2 = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc2, (Array) new bool[num9 + 1]);
                    }
                    index3 = num2;
                  }
                  arySrc1[index3].x = coordinate.x;
                  arySrc1[index3].y = coordinate.y;
                  arySrc1[index3].map = coordinate.map;
                  arySrc1[index3].data1 = arySrc1[index2].data1 + 1;
                  arySrc2[index3] = true;
                  this.game.EditObj.TempValue[coordinate.map].Value[coordinate.x, coordinate.y] = num6;
                  this.game.EditObj.TempCameFrom[coordinate.map].Value[coordinate.x, coordinate.y].onmap = false;
                  num3 += 1;
                }
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
            arySrc2[index2] = false;
          }
          else
            arySrc2[index2] = false;
        }
      }
    }

    pub CoordList MakeMovePrediction2(
      byregnr: i32,
      movetype: i32,
      theater: i32,
      ap: i32,
      x: i32,
      y: i32,
      map: i32,
      bool checkairfield = true,
      bool dontenterenemy = true,
      bool allowshoredrop = false,
      bool muststartonairfield = true,
      bool NoAPPenalties = false,
      bool SeaBlock = false,
      bool BlockAllSea = false,
      bool istransfer = false,
      bool EngineerTest = false,
      bool EnemyPenalty = false,
      bool IsForSupplyLayer = false,
      let mut redux: i32 =  0,
      bool DontCountEnemyRoads = false,
      bool NoBridgePenalty = false,
      bool UseCounterOwner = false,
      bool UseTempOwner = false,
      let mut overruleRoadType: i32 =  -1,
      let mut TarX: i32 =  -1,
      let mut TarY: i32 =  -1,
      let mut TarMap: i32 =  -1,
      let mut BridgeAP: i32 =  0,
      let mut MaxDistance: i32 =  9999,
      let mut SFTypeX: i32 =  -1,
      let mut SFTypeQty: i32 =  0,
      bool tempZoneTest = false,
      bool roadsOnly = false,
      bool alwaysUseLogisticalBonus = false,
      bool useTrafficRules = false,
      bool blockLogisticalBonus = false,
      let mut lisMode: i32 =  0,
      float trafficPointMod = 1f,
      let mut specialRuleNumber: i32 =  0,
      let mut tempZoneTestSpecialMode: i32 =  0,
      bool dist1alwaysDirect = false,
      let mut specialRuleNumber2: i32 =  0)
    {
      Coordinate[] arySrc1 = new Coordinate[1];
      bool[] arySrc2 = new bool[1];
      CoordList coordList1 = CoordList::new();
      this.RedimTempValue(9999);
      this.RedimTempCameFrom();
      this.RedimTempValueSpecial(0);
      this.RedimTempValueSpecial2(0);
      if (x == -1 | y == -1)
        return coordList1;
      let mut num1: i32 =  0;
      arySrc1[0].x = x;
      arySrc1[0].y = y;
      arySrc1[0].map = map;
      arySrc2[0] = true;
      this.game.EditObj.TempValue[map].Value[x, y] = 0;
      let mut num2: i32 =  1;
      coordList1.AddCoord(x, y, map);
      if (theater == 0)
      {
        let mut num3: i32 =  0;
        if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
          num3 = 1;
        if (num3 == 1)
          return coordList1;
      }
      type: i32;
      if (theater == 1)
      {
        let mut num4: i32 =  0;
        let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[x, y].LandscapeType;
        let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
        if (location > -1)
          type = this.game.Data.LocObj[location].Type;
        if (!this.game.Data.LandscapeTypeObj[landscapeType].IsSea)
        {
          if (location > -1)
          {
            if (!this.game.Data.LocTypeObj[type].IsPort)
              num4 = 1;
          }
          else
            num4 = 1;
        }
        if (num4 == 1)
          return coordList1;
      }
      if (muststartonairfield && theater == 2)
      {
        let mut num5: i32 =  0;
        let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[x, y].LandscapeType;
        let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
        if (location > -1)
          type = this.game.Data.LocObj[location].Type;
        if (location > -1)
        {
          if (!(this.game.Data.LocTypeObj[type].IsAirfield | this.game.Data.LocObj[location].isAirfield))
            num5 = 1;
        }
        else
          num5 = 1;
        if (num5 == 1)
          return coordList1;
      }
      CoordList coordList2 = CoordList::new();
      while (num2 > 0)
      {
        num2 = 0;
        let mut num6: i32 =  9999;
        let mut num7: i32 =  num1;
        for (let mut index1: i32 =  0; index1 <= num7; index1 += 1)
        {
          if (arySrc2[index1])
          {
            if (arySrc1[index1].data1 < MaxDistance)
            {
              let mut num8: i32 =  ap;
              let mut num9: i32 =  this.HexNeighbourCount(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map);
              for (let mut tfacing: i32 =  1; tfacing <= num9; tfacing += 1)
              {
                Coordinate coordinate1 = this.HexNeighbour(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, tfacing);
                if (tempZoneTest & coordinate1.onmap && this.game.EditObj.tempZoneTest[coordinate1.x, coordinate1.y] < 1)
                  coordinate1.onmap = false;
                if (dist1alwaysDirect & arySrc1[index1].data1 > 0 & coordinate1.onmap)
                {
                  let mut counter: i32 =  coordList2.counter;
                  for (let mut index2: i32 =  0; index2 <= counter; index2 += 1)
                  {
                    if (coordList2.coord[index2].x == coordinate1.x & coordList2.coord[index2].y == coordinate1.y)
                    {
                      coordinate1.onmap = false;
                      break;
                    }
                  }
                }
                if (coordinate1.onmap)
                {
                  let mut PreviousAPspent: i32 =  this.game.EditObj.TempValue[arySrc1[index1].map].Value[arySrc1[index1].x, arySrc1[index1].y];
                  let mut data2: i32 =  this.game.EditObj.TempValueSpecial2[arySrc1[index1].map].Value[arySrc1[index1].x, arySrc1[index1].y];
                  Coordinate coordinate2 = this.MoveApCostPreview2(x, y, byregnr, movetype, theater, arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, coordinate1.x, coordinate1.y, coordinate1.map, dontenterenemy, allowshoredrop, NoAPPenalties, SeaBlock, BlockAllSea, istransfer, EngineerTest, EnemyPenalty, IsForSupplyLayer, redux, DontCountEnemyRoads, NoBridgePenalty, UseCounterOwner, UseTempOwner, overruleRoadType, BridgeAP, SFTypeX, PreviousAPspent, SFTypeQty, tfacing - 1, roadsOnly, alwaysUseLogisticalBonus, useTrafficRules, blockLogisticalBonus, lisMode, trafficPointMod, specialRuleNumber, specialRuleNumber2);
                  if (coordinate2.data2 > data2)
                    data2 = coordinate2.data2;
                  num10: i32;
                  if (coordinate2.x >= 9999)
                    num10 = 0;
                  else if (data2 >= coordinate2.x)
                  {
                    num10 = data2 - coordinate2.x;
                    coordinate2.x = 0;
                  }
                  else
                  {
                    coordinate2.x -= data2;
                    num10 = 0;
                  }
                  if (coordinate2.data2 > 0)
                    PreviousAPspent += 1;
                  let mut num11: i32 =  PreviousAPspent + coordinate2.x;
                  bool flag = false;
                  if (num11 <= num8)
                  {
                    if (num11 < this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y])
                      flag = true;
                    if (num11 == this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] & num10 > this.game.EditObj.TempValueSpecial2[coordinate1.map].Value[coordinate1.x, coordinate1.y])
                      flag = true;
                  }
                  if (flag)
                  {
                    let mut index3: i32 =  -1;
                    let mut num12: i32 =  num1;
                    for (let mut index4: i32 =  0; index4 <= num12; index4 += 1)
                    {
                      if (arySrc2[index4] && arySrc1[index4].x == coordinate1.x & arySrc1[index4].y == coordinate1.y & arySrc1[index4].map == coordinate1.map)
                      {
                        index3 = index4;
                        break;
                      }
                    }
                    if (index3 == -1)
                    {
                      let mut num13: i32 =  num1;
                      for (let mut index5: i32 =  0; index5 <= num13; index5 += 1)
                      {
                        if (!arySrc2[index5])
                        {
                          index3 = index5;
                          break;
                        }
                      }
                    }
                    if (index3 == -1)
                    {
                      num1 += 1;
                      num14: i32;
                      if (num1 > num14)
                      {
                        num14 += 100;
                        arySrc1 = (Coordinate[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc1, (Array) new Coordinate[num14 + 1]);
                        arySrc2 = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc2, (Array) new bool[num14 + 1]);
                      }
                      index3 = num1;
                    }
                    arySrc1[index3].x = coordinate1.x;
                    arySrc1[index3].y = coordinate1.y;
                    arySrc1[index3].map = coordinate1.map;
                    arySrc1[index3].data1 = arySrc1[index1].data1 + 1;
                    if (dist1alwaysDirect && arySrc1[index3].data1 == 1)
                      coordList2.AddCoord(arySrc1[index3].x, arySrc1[index3].y, arySrc1[index3].map);
                    arySrc2[index3] = true;
                    if (this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 9999)
                      coordList1.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
                    this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = num11;
                    this.game.EditObj.TempValueSpecial[coordinate1.map].Value[coordinate1.x, coordinate1.y] = coordinate2.y;
                    if (!(this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 9999 & this.game.EditObj.TempValue[coordinate1.map].Value[arySrc1[index1].x, arySrc1[index1].y] == 9999))
                    {
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].x = arySrc1[index1].x;
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].y = arySrc1[index1].y;
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].map = arySrc1[index1].map;
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].onmap = true;
                    }
                    else
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].onmap = false;
                    this.game.EditObj.TempValueSpecial2[coordinate1.map].Value[coordinate1.x, coordinate1.y] = num10;
                    if (num11 < num6)
                      num6 = num11;
                    num2 += 1;
                  }
                }
              }
              arySrc2[index1] = false;
            }
            else
              arySrc2[index1] = false;
          }
        }
        if (TarX > -1 && this.game.EditObj.TempValue[TarMap].Value[TarX, TarY] <= num6)
          num2 = -1;
      }
      if (checkairfield && theater == 2 && coordList1.counter > -1)
      {
        let mut counter: i32 =  coordList1.counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut location: i32 =  this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].Location;
          let mut num15: i32 =  0;
          if (location > -1)
          {
            if (!this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsAirfield & !this.game.Data.LocObj[location].isAirfield)
              num15 = 1;
            else if (this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime != byregnr)
            {
              let mut num16: i32 =  0;
              if (this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime > -1 && this.game.Data.RegimeObj[this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime].RegimeRel[byregnr] == 2)
                num16 = 1;
              if (num16 == 0)
                num15 = 1;
            }
          }
          else
            num15 = 1;
          if (num15 == 1)
          {
            coordList1.coord[index].onmap = false;
            this.game.EditObj.TempValue[coordList1.coord[index].map].Value[coordList1.coord[index].x, coordList1.coord[index].y] = 9999;
          }
        }
      }
      return coordList1;
    }

    pub CoordList MakeMovePrediction2_multiStart(
      CoordList tCoordList,
      byregnr: i32,
      movetype: i32,
      theater: i32,
      ap: i32,
      x: i32,
      y: i32,
      map: i32,
      bool checkairfield = true,
      bool dontenterenemy = true,
      bool allowshoredrop = false,
      bool muststartonairfield = true,
      bool NoAPPenalties = false,
      bool SeaBlock = false,
      bool BlockAllSea = false,
      bool istransfer = false,
      bool EngineerTest = false,
      bool EnemyPenalty = false,
      bool IsForSupplyLayer = false,
      let mut redux: i32 =  0,
      bool DontCountEnemyRoads = false,
      bool NoBridgePenalty = false,
      bool UseCounterOwner = false,
      bool UseTempOwner = false,
      let mut overruleRoadType: i32 =  -1,
      let mut TarX: i32 =  -1,
      let mut TarY: i32 =  -1,
      let mut TarMap: i32 =  -1,
      let mut BridgeAP: i32 =  0,
      let mut MaxDistance: i32 =  9999,
      let mut SFTypeX: i32 =  -1,
      let mut SFTypeQty: i32 =  0,
      bool tempZoneTest = false,
      bool roadsOnly = false,
      bool alwaysUseLogisticalBonus = false,
      bool useTrafficRules = false,
      bool blockLogisticalBonus = false,
      let mut lisMode: i32 =  0,
      float trafficPointMod = 1f,
      let mut specialRuleNumber: i32 =  0,
      let mut tempZoneTestSpecialMode: i32 =  0,
      bool dist1alwaysDirect = false,
      let mut specialRuleNumber2: i32 =  0)
    {
      Coordinate[] coordinateArray = new Coordinate[1];
      bool[] flagArray = new bool[1];
      CoordList coordList1 = CoordList::new();
      this.RedimTempValue(9999);
      if (tCoordList.counter == -1)
        return coordList1;
      let mut counter1: i32 =  tCoordList.counter;
      let mut counter2: i32 =  tCoordList.counter;
      Coordinate[] arySrc1 = new Coordinate[counter1 + 1];
      bool[] arySrc2 = new bool[counter1 + 1];
      let mut counter3: i32 =  tCoordList.counter;
      for (let mut index: i32 =  0; index <= counter3; index += 1)
      {
        x = tCoordList.coord[index].x;
        y = tCoordList.coord[index].y;
        this.game.EditObj.TempValue[0].Value[x, y] = tCoordList.coord[index].data1;
        arySrc1[index].x = x;
        arySrc1[index].y = y;
        arySrc1[index].map = map;
        arySrc2[index] = true;
        coordList1.AddCoord(x, y, map);
      }
      let mut num1: i32 =  1 + tCoordList.counter;
      if (theater == 0)
      {
        let mut num2: i32 =  0;
        if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
          num2 = 1;
        if (num2 == 1)
          return coordList1;
      }
      type: i32;
      if (theater == 1)
      {
        let mut num3: i32 =  0;
        let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[x, y].LandscapeType;
        let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
        if (location > -1)
          type = this.game.Data.LocObj[location].Type;
        if (!this.game.Data.LandscapeTypeObj[landscapeType].IsSea)
        {
          if (location > -1)
          {
            if (!this.game.Data.LocTypeObj[type].IsPort)
              num3 = 1;
          }
          else
            num3 = 1;
        }
        if (num3 == 1)
          return coordList1;
      }
      if (muststartonairfield && theater == 2)
      {
        let mut num4: i32 =  0;
        let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[x, y].LandscapeType;
        let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
        if (location > -1)
          type = this.game.Data.LocObj[location].Type;
        if (location > -1)
        {
          if (!(this.game.Data.LocTypeObj[type].IsAirfield | this.game.Data.LocObj[location].isAirfield))
            num4 = 1;
        }
        else
          num4 = 1;
        if (num4 == 1)
          return coordList1;
      }
      CoordList coordList2 = CoordList::new();
      while (num1 > 0)
      {
        num1 = 0;
        let mut num5: i32 =  9999;
        let mut num6: i32 =  counter1;
        for (let mut index1: i32 =  0; index1 <= num6; index1 += 1)
        {
          if (arySrc2[index1])
          {
            if (arySrc1[index1].data1 < MaxDistance)
            {
              let mut num7: i32 =  ap;
              let mut num8: i32 =  this.HexNeighbourCount(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map);
              for (let mut tfacing: i32 =  1; tfacing <= num8; tfacing += 1)
              {
                Coordinate coordinate1 = this.HexNeighbour(arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, tfacing);
                if (tempZoneTest & coordinate1.onmap && this.game.EditObj.tempZoneTest[coordinate1.x, coordinate1.y] < 1)
                  coordinate1.onmap = false;
                if (dist1alwaysDirect & arySrc1[index1].data1 > 0 & coordinate1.onmap)
                {
                  let mut counter4: i32 =  coordList2.counter;
                  for (let mut index2: i32 =  0; index2 <= counter4; index2 += 1)
                  {
                    if (coordList2.coord[index2].x == coordinate1.x & coordList2.coord[index2].y == coordinate1.y)
                    {
                      coordinate1.onmap = false;
                      break;
                    }
                  }
                }
                if (coordinate1.onmap)
                {
                  let mut PreviousAPspent: i32 =  this.game.EditObj.TempValue[arySrc1[index1].map].Value[arySrc1[index1].x, arySrc1[index1].y];
                  let mut data2: i32 =  this.game.EditObj.TempValueSpecial2[arySrc1[index1].map].Value[arySrc1[index1].x, arySrc1[index1].y];
                  Coordinate coordinate2 = this.MoveApCostPreview2(x, y, byregnr, movetype, theater, arySrc1[index1].x, arySrc1[index1].y, arySrc1[index1].map, coordinate1.x, coordinate1.y, coordinate1.map, dontenterenemy, allowshoredrop, NoAPPenalties, SeaBlock, BlockAllSea, istransfer, EngineerTest, EnemyPenalty, IsForSupplyLayer, redux, DontCountEnemyRoads, NoBridgePenalty, UseCounterOwner, UseTempOwner, overruleRoadType, BridgeAP, SFTypeX, PreviousAPspent, SFTypeQty, tfacing - 1, roadsOnly, alwaysUseLogisticalBonus, useTrafficRules, blockLogisticalBonus, lisMode, trafficPointMod, specialRuleNumber, specialRuleNumber2);
                  if (coordinate2.data2 > data2)
                    data2 = coordinate2.data2;
                  num9: i32;
                  if (coordinate2.x >= 9999)
                    num9 = 0;
                  else if (data2 >= coordinate2.x)
                  {
                    num9 = data2 - coordinate2.x;
                    coordinate2.x = 0;
                  }
                  else
                  {
                    coordinate2.x -= data2;
                    num9 = 0;
                  }
                  if (coordinate2.data2 > 0)
                    PreviousAPspent += 1;
                  let mut num10: i32 =  PreviousAPspent + coordinate2.x;
                  bool flag = false;
                  if (num10 <= num7)
                  {
                    if (num10 < this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y])
                      flag = true;
                    if (num10 == this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] & num9 > this.game.EditObj.TempValueSpecial2[coordinate1.map].Value[coordinate1.x, coordinate1.y])
                      flag = true;
                  }
                  if (flag)
                  {
                    let mut index3: i32 =  -1;
                    let mut num11: i32 =  counter1;
                    for (let mut index4: i32 =  0; index4 <= num11; index4 += 1)
                    {
                      if (arySrc2[index4] && arySrc1[index4].x == coordinate1.x & arySrc1[index4].y == coordinate1.y & arySrc1[index4].map == coordinate1.map)
                      {
                        index3 = index4;
                        break;
                      }
                    }
                    if (index3 == -1)
                    {
                      let mut num12: i32 =  counter1;
                      for (let mut index5: i32 =  0; index5 <= num12; index5 += 1)
                      {
                        if (!arySrc2[index5])
                        {
                          index3 = index5;
                          break;
                        }
                      }
                    }
                    if (index3 == -1)
                    {
                      counter1 += 1;
                      if (counter1 > counter2)
                      {
                        counter2 += 100;
                        arySrc1 = (Coordinate[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc1, (Array) new Coordinate[counter2 + 1]);
                        arySrc2 = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc2, (Array) new bool[counter2 + 1]);
                      }
                      index3 = counter1;
                    }
                    arySrc1[index3].x = coordinate1.x;
                    arySrc1[index3].y = coordinate1.y;
                    arySrc1[index3].map = coordinate1.map;
                    arySrc1[index3].data1 = arySrc1[index1].data1 + 1;
                    if (dist1alwaysDirect && arySrc1[index3].data1 == 1)
                      coordList2.AddCoord(arySrc1[index3].x, arySrc1[index3].y, arySrc1[index3].map);
                    arySrc2[index3] = true;
                    if (this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 9999)
                      coordList1.AddCoord(coordinate1.x, coordinate1.y, coordinate1.map);
                    this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] = num10;
                    this.game.EditObj.TempValueSpecial[coordinate1.map].Value[coordinate1.x, coordinate1.y] = coordinate2.y;
                    if (!(this.game.EditObj.TempValue[coordinate1.map].Value[coordinate1.x, coordinate1.y] == 9999 & this.game.EditObj.TempValue[coordinate1.map].Value[arySrc1[index1].x, arySrc1[index1].y] == 9999))
                    {
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].x = arySrc1[index1].x;
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].y = arySrc1[index1].y;
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].map = arySrc1[index1].map;
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].onmap = true;
                    }
                    else
                      this.game.EditObj.TempCameFrom[coordinate1.map].Value[coordinate1.x, coordinate1.y].onmap = false;
                    this.game.EditObj.TempValueSpecial2[coordinate1.map].Value[coordinate1.x, coordinate1.y] = num9;
                    if (num10 < num5)
                      num5 = num10;
                    num1 += 1;
                  }
                }
              }
              arySrc2[index1] = false;
            }
            else
              arySrc2[index1] = false;
          }
        }
        if (TarX > -1 && this.game.EditObj.TempValue[TarMap].Value[TarX, TarY] <= num5)
          num1 = -1;
      }
      if (checkairfield && theater == 2 && coordList1.counter > -1)
      {
        let mut counter5: i32 =  coordList1.counter;
        for (let mut index: i32 =  0; index <= counter5; index += 1)
        {
          let mut location: i32 =  this.game.Data.MapObj[coordList1.coord[index].map].HexObj[coordList1.coord[index].x, coordList1.coord[index].y].Location;
          let mut num13: i32 =  0;
          if (location > -1)
          {
            if (!this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsAirfield & !this.game.Data.LocObj[location].isAirfield)
              num13 = 1;
            else if (this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime != byregnr)
            {
              let mut num14: i32 =  0;
              if (this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime > -1 && this.game.Data.RegimeObj[this.game.Data.MapObj[this.game.Data.LocObj[location].Map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].Regime].RegimeRel[byregnr] == 2)
                num14 = 1;
              if (num14 == 0)
                num13 = 1;
            }
          }
          else
            num13 = 1;
          if (num13 == 1)
          {
            coordList1.coord[index].onmap = false;
            this.game.EditObj.TempValue[coordList1.coord[index].map].Value[coordList1.coord[index].x, coordList1.coord[index].y] = 9999;
          }
        }
      }
      return coordList1;
    }

    pub CanAddTroops: bool(unr: i32, sftype: i32, ppl: i32, MoveType: i32)
    {
      if ( this.game.Data.RuleVar[331] == 1.0)
        return this.game.Data.UnitObj[unr].SFCount > -1 && this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[0]].Type == sftype && !this.game.Data.SFTypeObj[sftype].Unique;
      if (this.game.Data.UnitObj[unr].IsHQ)
        return true;
      let mut num: i32 =  -1;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFObj[sf].Type == sftype & this.game.Data.SFObj[sf].People == ppl & this.game.Data.SFObj[sf].MoveType == MoveType)
          num = sf;
      }
      return num > -1 ? !this.game.Data.SFTypeObj[sftype].Unique || this.game.Data.UnitObj[unr].SFCount < 7 : this.game.Data.UnitObj[unr].SFCount < 7;
    }

    pub void AddTroops3(
      unr: i32,
      SfType: i32,
      Peopletype: i32,
      Qty: i32,
      Xp: i32,
      Rdn: i32,
      Ap: i32,
      Mor: i32,
      let mut tsc: i32 =  -1,
      let mut entr: i32 =  0,
      let mut offmod: i32 =  0,
      let mut defmod: i32 =  0,
      let mut MoveType: i32 =  -1,
      let mut Ep: i32 =  0,
      let mut vigor: i32 =  100)
    {
      if (Qty < 1)
        return;
      if (Peopletype == 0)
      {
        let mut num1: i32 =  num1;
      }
      if (unr == 106)
        unr = unr;
      sf: i32;
      if (tsc > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        num2: i32;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          sf = this.game.Data.UnitObj[unr].SFList[index];
          num2 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].BasicSupplyNeed * this.game.Data.SFObj[sf].Qty;
        }
        let mut num3: i32 =  this.game.Data.SFTypeObj[SfType].BasicSupplyNeed * Qty;
        let mut supplyConsume: i32 =  this.game.Data.UnitObj[unr].SupplyConsume;
        this.game.Data.UnitObj[unr].SupplyConsume = num3 + num2 <= 0 ? 100 :  Math.Round( (num2 * this.game.Data.UnitObj[unr].SupplyConsume + num3 * tsc) /  (num3 + num2));
        if (tsc < supplyConsume & this.game.Data.UnitObj[unr].SupplyConsume == supplyConsume)
        {
          UnitClass[] unitObj = this.game.Data.UnitObj;
          UnitClass[] unitClassArray = unitObj;
          let mut index1: i32 =  unr;
          let mut index2: i32 =  index1;
          unitClassArray[index2].SupplyConsume = unitObj[index1].SupplyConsume - 1;
        }
        if (0 > this.game.Data.UnitObj[unr].SupplyConsume)
          this.game.Data.UnitObj[unr].SupplyConsume = 0;
      }
      num4: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        num4 = -1;
        if (!this.game.Data.SFTypeObj[SfType].Unique)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
          for (let mut index: i32 =  0; index <= sfCount; index += 1)
          {
            sf = this.game.Data.UnitObj[unr].SFList[index];
            if (this.game.Data.SFObj[sf].Type == SfType & this.game.Data.SFObj[sf].People == Peopletype & this.game.Data.SFObj[sf].MoveType == MoveType)
            {
              num4 = sf;
              break;
            }
          }
        }
      }
      else
        num4 = -1;
      if (num4 > -1)
      {
        object obj =  sf;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].EP += Ep;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Xp =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty * this.game.Data.SFObj[Conversions.ToInteger(obj)].Xp + Qty * Xp) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Vigor =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty * this.game.Data.SFObj[Conversions.ToInteger(obj)].Vigor + Qty * vigor) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Rdn =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty * this.game.Data.SFObj[Conversions.ToInteger(obj)].Rdn + Qty * Rdn) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Mor =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty * this.game.Data.SFObj[Conversions.ToInteger(obj)].Mor + Qty * Mor) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        this.game.Data.SFObj[Conversions.ToInteger(obj)].OffMod =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty * this.game.Data.SFObj[Conversions.ToInteger(obj)].OffMod + Qty * offmod) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        this.game.Data.SFObj[Conversions.ToInteger(obj)].DefMod =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty * this.game.Data.SFObj[Conversions.ToInteger(obj)].DefMod + Qty * defmod) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        if (entr > 0)
          this.game.Data.SFObj[Conversions.ToInteger(obj)].CurrentEntrench =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty * this.game.Data.SFObj[Conversions.ToInteger(obj)].CurrentEntrench + Qty * entr) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        else if (this.game.Data.UnitObj[unr].PreDef == -1)
        {
          let mut minimumEntrench: i32 =  this.game.HandyFunctionsObj.GetMinimumEntrench(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, this.game.Data.SFTypeObj[SfType].UnitGroup);
          this.game.Data.SFObj[Conversions.ToInteger(obj)].CurrentEntrench =  Math.Round(Conversion.Int( (this.game.Data.SFObj[Conversions.ToInteger(obj)].CurrentEntrench * this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty * minimumEntrench) /  (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty + Qty)));
        }
        if (this.game.Data.SFObj[Conversions.ToInteger(obj)].Ap > Ap)
          this.game.Data.SFObj[Conversions.ToInteger(obj)].Ap = Ap;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty += Qty;
      }
      else
      {
        object obj =  this.game.Data.AddSF(unr);
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty = Qty;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Type = SfType;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Ap = Ap;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].EP = Ep;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Xp = Xp;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Vigor = vigor;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Rdn = Rdn;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].OffMod = offmod;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].DefMod = defmod;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].MoveType = MoveType;
        if (entr > 0)
          this.game.Data.SFObj[Conversions.ToInteger(obj)].CurrentEntrench = entr;
        else if (this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1)
          this.game.Data.SFObj[Conversions.ToInteger(obj)].CurrentEntrench = this.game.HandyFunctionsObj.GetMinimumEntrench(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, this.game.Data.SFTypeObj[SfType].UnitGroup);
        this.game.Data.SFObj[Conversions.ToInteger(obj)].Mor = Mor;
        this.game.Data.SFObj[Conversions.ToInteger(obj)].People = Peopletype;
      }
    }

    pub fn RemoveTroops(unr: i32, sftype: i32, peopletype: i32, qty: i32, MoveType: i32)
    {
      let mut num: i32 =  -1;
      sf: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          sf = this.game.Data.UnitObj[unr].SFList[index];
          if (this.game.Data.SFObj[sf].Type == sftype & this.game.Data.SFObj[sf].People == peopletype & this.game.Data.SFObj[sf].MoveType == MoveType)
          {
            num = sf;
            break;
          }
        }
      }
      else
        num = -1;
      if (num <= -1)
        return;
      object obj =  sf;
      this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty -= qty;
      if (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty >= 1)
        return;
      this.game.Data.ChangeSFNr(Conversions.ToInteger(obj), -1);
    }

    pub fn RemoveTroopsRandom(unr: i32, qty: i32)
    {
      SimpleList simpleList = SimpleList::new();
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          simpleList.Add(sf, DrawMod.RandyNumber.Next(0, this.game.Data.SFObj[sf].Qty * 10));
        }
      }
      simpleList.ReverseSort();
      let mut num: i32 =  simpleList.Counter <= -1 ? -1 : simpleList.Id[0];
      if (num <= -1)
        return;
      object obj =  num;
      this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty -= qty;
      if (this.game.Data.SFObj[Conversions.ToInteger(obj)].Qty >= 1)
        return;
      this.game.Data.ChangeSFNr(Conversions.ToInteger(obj), -1);
    }

    pub fn GetLowestAp(unr: i32, bool notair = false) -> i32
    {
      let mut lowestAp: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num: i32 =  1;
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2 & notair)
          num = 0;
        if (num == 1 && this.game.Data.SFObj[sf].Ap < lowestAp)
          lowestAp = this.game.Data.SFObj[sf].Ap;
      }
      return lowestAp;
    }

    pub fn GetLowestMoveCostForAI(unr: i32, bool notair = false) -> i32
    {
      let mut lowestMoveCostForAi: i32 =  9999;
      if (this.game.Data.RoadTypeCounter == -1)
        return 10;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut num: i32 =  1;
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2 & notair)
          num = 0;
        if (num == 1 && this.game.Data.RoadTypeObj[0].MoveCostOverrule[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].MoveType] < lowestMoveCostForAi)
          lowestMoveCostForAi = this.game.Data.RoadTypeObj[0].MoveCostOverrule[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].MoveType];
      }
      return lowestMoveCostForAi;
    }

    pub fn GetLowestAirAp(unr: i32) -> i32
    {
      let mut lowestAirAp: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2 && this.game.Data.SFObj[sf].Ap < lowestAirAp)
          lowestAirAp = this.game.Data.SFObj[sf].Ap;
      }
      return lowestAirAp;
    }

    pub fn GetLowestAirApRule(unr: i32) -> i32
    {
      let mut lowestAirApRule: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 9999;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 2 && this.game.Data.SFTypeObj[type].AirAPRule > 0 && this.game.Data.SFTypeObj[type].AirAPRule < lowestAirApRule)
          lowestAirApRule = this.game.Data.SFTypeObj[type].AirAPRule;
      }
      return lowestAirApRule;
    }

    pub fn GetLowestAirRdn(unr: i32, bool frontlineonly = false) -> i32
    {
      let mut lowestAirRdn: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 2 && !frontlineonly | frontlineonly & !this.game.Data.SFTypeObj[type].BackBench && this.game.Data.SFObj[sf].Rdn < lowestAirRdn)
          lowestAirRdn = this.game.Data.SFObj[sf].Rdn;
      }
      if (lowestAirRdn == 9999)
        lowestAirRdn = 0;
      return lowestAirRdn;
    }

    pub fn GetLowestlandartAp(unr: i32, dist: i32) -> i32
    {
      let mut lowestlandartAp: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 0 && this.game.Data.SFTypeObj[type].ArtRange >= dist && this.game.Data.SFObj[sf].Ap < lowestlandartAp)
          lowestlandartAp = this.game.Data.SFObj[sf].Ap;
      }
      return lowestlandartAp;
    }

    pub fn GetLowestlandDirectAp(unr: i32, dist: i32) -> i32
    {
      let mut lowestlandDirectAp: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 0 && this.game.Data.SFTypeObj[type].directRange >= dist && this.game.Data.SFObj[sf].Ap < lowestlandDirectAp)
          lowestlandDirectAp = this.game.Data.SFObj[sf].Ap;
      }
      return lowestlandDirectAp;
    }

    pub fn GetLowestseaartAp(unr: i32, dist: i32) -> i32
    {
      let mut lowestseaartAp: i32 =  9999;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 1 && this.game.Data.SFTypeObj[type].ArtRange >= dist && this.game.Data.SFObj[sf].Ap < lowestseaartAp)
          lowestseaartAp = this.game.Data.SFObj[sf].Ap;
      }
      return lowestseaartAp;
    }

    pub LoadSomething: String(tfilter: String, ttitle: String, tinitdir: String, bool withinPath)
    {
      OpenFileDialog openFileDialog1 = OpenFileDialog::new();
      OpenFileDialog openFileDialog2 = openFileDialog1;
      openFileDialog2.Filter = tfilter;
      openFileDialog2.FilterIndex = 1;
      openFileDialog2.Title = ttitle;
      openFileDialog2.CheckFileExists = true;
      openFileDialog2.CheckPathExists = true;
      openFileDialog2.ValidateNames = true;
      openFileDialog2.DereferenceLinks = true;
      openFileDialog2.RestoreDirectory = false;
      openFileDialog2.InitialDirectory = Path.GetFullPath(tinitdir);
      let mut num: i32 =   openFileDialog2.ShowDialog();
      if (Operators.CompareString(openFileDialog1.FileName, "", false) == 0)
      {
        str: String;
        return str;
      }
      return !withinPath ? openFileDialog1.FileName : (Strings.Len(openFileDialog1.FileName) <= Strings.Len(tinitdir) ? "" : Strings.Right(openFileDialog1.FileName, Strings.Len(openFileDialog1.FileName) - Strings.Len(tinitdir)));
    }

    pub ReturnLongMaster: String(filename: String, shortmaster: String)
    {
      filename = filename.Replace("\\", "/");
      shortmaster = shortmaster.Replace("\\", "/");
      if (Strings.InStr(shortmaster, "/") > 0)
      {
        let mut num: i32 =   Interaction.MsgBox( "Master should not be long, code will continue");
        return shortmaster;
      }
      if (Strings.InStr(filename, "/") > 0)
      {
        let mut Length: i32 =  1;
        let mut num: i32 =  1;
        while (num > 0)
        {
          num = Strings.InStr(Length + 1, filename, "/");
          if (num > 0)
            Length = num;
        }
        path: String = Strings.Left(filename, Length) + shortmaster;
        if (System.IO.File.Exists(path))
          return path;
      }
      return this.game.AppPath + this.game.ModScenarioDir + "/" + shortmaster;
    }

    pub ReturnShortMaster: String(filename: String)
    {
      filename = filename.Replace("\\", "/");
      str: String = filename;
      if (Strings.InStr(filename, "/") <= 0)
        return str;
      let mut num1: i32 =  1;
      let mut num2: i32 =  1;
      while (num2 > 0)
      {
        num2 = Strings.InStr(num1 + 1, filename, "/");
        if (num2 > 0)
          num1 = num2;
      }
      return Strings.Mid(filename, num1 + 1, Strings.Len(filename) - num1);
    }

    pub SaveSomething: String(tfilter: String, ttitle: String, tinitdir: String, bool withinPath)
    {
      SaveFileDialog saveFileDialog1 = SaveFileDialog::new();
      SaveFileDialog saveFileDialog2 = saveFileDialog1;
      saveFileDialog2.Filter = tfilter;
      saveFileDialog2.FilterIndex = 1;
      saveFileDialog2.Title = ttitle;
      saveFileDialog2.CheckFileExists = false;
      saveFileDialog2.CheckPathExists = true;
      saveFileDialog2.ValidateNames = true;
      saveFileDialog2.AutoUpgradeEnabled = true;
      saveFileDialog2.DereferenceLinks = true;
      saveFileDialog2.RestoreDirectory = false;
      if (tinitdir.Length > 0)
        saveFileDialog2.InitialDirectory = Path.GetFullPath(tinitdir);
      let mut num1: i32 =   saveFileDialog2.ShowDialog();
      if (Operators.CompareString(saveFileDialog1.FileName, "", false) == 0)
      {
        str: String;
        return str;
      }
      str1: String = !withinPath ? saveFileDialog1.FileName : (Strings.Len(saveFileDialog1.FileName) <= Strings.Len(tinitdir) ? "" : Strings.Right(saveFileDialog1.FileName, Strings.Len(saveFileDialog1.FileName) - Strings.Len(tinitdir)));
      if (Strings.InStr(str1, ":") > 0)
      {
        let mut num2: i32 =  this.CheckDiskSpace(Strings.Left(str1, Strings.InStr(str1, ":")));
        if (num2 > 0 & num2 < 50)
        {
          let mut num3: i32 =   Interaction.MsgBox( "Save aborted. Volume must have at least 50mb free memory in order to save.");
        }
      }
      return str1;
    }

    pub CanProduceItemResult CanProduceItem(
      locnr: i32,
      regnr: i32,
      itemtypenr: i32,
      let mut sfpplnr: i32 =  -1,
      bool recurse = false,
      bool doblocks = true)
    {
      CanProduceItemResult produceItemResult = CanProduceItemResult::new();
      if (this.game.Data.ItemTypeObj[itemtypenr].RegimeSpecific == -2)
      {
        produceItemResult.result = false;
        return produceItemResult;
      }
      if (this.game.Data.ItemTypeObj[itemtypenr].RegimeSpecific > -1 && this.game.Data.ItemTypeObj[itemtypenr].RegimeSpecific != regnr)
      {
        produceItemResult.result = false;
        return produceItemResult;
      }
      type: i32;
      if (locnr > -1)
      {
        type = this.game.Data.LocObj[locnr].Type;
        if (regnr == -1)
          regnr = this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime;
      }
      if (regnr == -1)
        regnr = this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime;
      if (regnr == -1)
      {
        produceItemResult.result = false;
        return produceItemResult;
      }
      let mut peopleGroup1: i32 =  this.game.Data.PeopleObj[this.game.Data.RegimeObj[regnr].People].PeopleGroup;
      if (locnr > -1 && this.game.Data.LocObj[locnr].People > -1)
      {
        let mut peopleGroup2: i32 =  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].PeopleGroup;
        if (this.game.Data.ItemTypeObj[itemtypenr].UseProdMod <= 1 &&  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod[peopleGroup1] <= 0.0)
        {
          produceItemResult.result = false;
          produceItemResult.refusal = "Location cannot produce this itemgroup.";
          return produceItemResult;
        }
        if (this.game.Data.ItemTypeObj[itemtypenr].UseProdMod == 2 &&  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod2[peopleGroup1] <= 0.0)
        {
          produceItemResult.result = false;
          produceItemResult.refusal = "Location cannot produce this itemgroup.";
          return produceItemResult;
        }
        if (this.game.Data.ItemTypeObj[itemtypenr].UseProdMod == 3 &&  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod3[peopleGroup1] <= 0.0)
        {
          produceItemResult.result = false;
          produceItemResult.refusal = "Location cannot produce this itemgroup.";
          return produceItemResult;
        }
        if (this.game.Data.ItemTypeObj[itemtypenr].UseProdMod == 4 &&  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod4[peopleGroup1] <= 0.0)
        {
          produceItemResult.result = false;
          produceItemResult.refusal = "Location cannot produce this itemgroup.";
          return produceItemResult;
        }
      }
      if (locnr > -1 && !this.game.Data.LocTypeObj[type].ItemGroup[this.game.Data.ItemTypeObj[itemtypenr].ItemGroup])
      {
        produceItemResult.result = false;
        produceItemResult.refusal = "Location cannot produce this itemgroup.";
        return produceItemResult;
      }
      if (this.game.Data.ItemTypeObj[itemtypenr].IsSFType > -1)
      {
        let mut isSfType: i32 =  this.game.Data.ItemTypeObj[itemtypenr].IsSFType;
        if (locnr > -1)
        {
          if (!this.game.Data.SFTypeObj[isSfType].PeopleGroup[this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].PeopleGroup])
          {
            produceItemResult.result = false;
            produceItemResult.refusal = "Location does not have the people that are needed to make this SFtype";
            return produceItemResult;
          }
          if (this.game.Data.SFTypeObj[isSfType].Theater == 1)
          {
            let mut num: i32 =  0;
            let mut tfacing: i32 =  1;
            do
            {
              Coordinate coordinate = this.HexNeighbour(this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y, this.game.Data.LocObj[locnr].Map, tfacing);
              if (coordinate.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                num += 1;
              tfacing += 1;
            }
            while (tfacing <= 6);
            if (num == 0)
            {
              produceItemResult.result = false;
              produceItemResult.refusal = "No Sea around location";
              return produceItemResult;
            }
          }
        }
      }
      if (locnr > -1)
      {
        if (!this.game.Data.LocTypeObj[type].PeopleGroup[peopleGroup1])
        {
          produceItemResult.result = false;
          return produceItemResult;
        }
        if (!this.game.Data.ItemTypeObj[itemtypenr].PeopleGroup[peopleGroup1])
        {
          produceItemResult.result = false;
          return produceItemResult;
        }
      }
      let mut index1: i32 =  0;
      do
      {
        let mut index2: i32 =  locnr != -1 ? (this.game.Data.LocObj[locnr].People != this.game.Data.RegimeObj[regnr].People ? regnr : regnr) : (sfpplnr != this.game.Data.RegimeObj[regnr].People ? regnr : regnr);
        if (this.game.Data.ItemTypeObj[itemtypenr].ResFieldNeeded[index1] > -1 && !this.game.Data.RegimeObj[index2].ResField[this.game.Data.ItemTypeObj[itemtypenr].ResFieldNeeded[index1]])
        {
          produceItemResult.result = false;
          return produceItemResult;
        }
        if (this.game.Data.ItemTypeObj[itemtypenr].RegimeSlotsNeeded[index1] > -1 && this.game.Data.RegimeObj[regnr].RegimeSlot[this.game.Data.ItemTypeObj[itemtypenr].RegimeSlotsNeeded[index1]] < this.game.Data.ItemTypeObj[itemtypenr].RegimeSlotsNeededQty[index1])
        {
          produceItemResult.result = false;
          return produceItemResult;
        }
        if (this.game.Data.ItemTypeObj[itemtypenr].GameSlotsNeeded[index1] > -1 && this.game.Data.GameSlot[this.game.Data.ItemTypeObj[itemtypenr].GameSlotsNeeded[index1]] < this.game.Data.ItemTypeObj[itemtypenr].GameSlotsNeededQty[index1])
        {
          produceItemResult.result = false;
          return produceItemResult;
        }
        index1 += 1;
      }
      while (index1 <= 4);
      if (doblocks & locnr > -1 && !recurse)
      {
        let mut itemTypeCounter: i32 =  this.game.Data.ItemTypeCounter;
        for (let mut itemtypenr1: i32 =  0; itemtypenr1 <= itemTypeCounter; itemtypenr1 += 1)
        {
          if (this.CanProduceItem(locnr, regnr, itemtypenr1, sfpplnr, true, doblocks).result && this.game.Data.ItemTypeObj[itemtypenr1].Blocks == itemtypenr)
          {
            produceItemResult.result = false;
            return produceItemResult;
          }
        }
      }
      produceItemResult.result = true;
      produceItemResult.estimated = 1;
      return produceItemResult;
    }

    pub fn GetCarryCapPts(unr: i32, theater: i32) -> i32
    {
      carryCapPts: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == theater)
            carryCapPts += this.game.Data.SFTypeObj[type].CarryCap * this.game.Data.SFObj[sf].Qty;
        }
      }
      return carryCapPts;
    }

    pub fn GetLocTypeItemTypesAmmount(loctype: i32) -> i32
    {
      let mut itemTypesAmmount: i32 =  0;
      let mut index: i32 =  0;
      do
      {
        if (this.game.Data.LocTypeObj[loctype].ItemGroup[index])
          itemTypesAmmount += 1;
        index += 1;
      }
      while (index <= 99);
      return itemTypesAmmount;
    }

    pub fn GetPowerPtsAbsolute(unr: i32, bool onlyland = false, bool stafftoo = true) -> i32
    {
      powerPtsAbsolute: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (!onlyland | onlyland & this.game.Data.SFTypeObj[type].Theater == 0 && !(!stafftoo & this.game.Data.SFTypeObj[type].StaffPts > 0))
            powerPtsAbsolute += this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty;
        }
      }
      return powerPtsAbsolute;
    }

    pub fn GetPowerPtsAbsoluteForWholeChainOfCommand(hqnr: i32, bool onlyland = false, bool stafftoo = true) -> i32
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      wholeChainOfCommand: i32;
      for (let mut unr: i32 =  0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].Regime == this.game.Data.UnitObj[hqnr].Regime && this.game.Data.UnitObj[unr].PreDef == -1 && this.IsUnitInHQChain(unr, hqnr) | hqnr == unr && this.game.Data.UnitObj[unr].SFCount > -1)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
          for (let mut index: i32 =  0; index <= sfCount; index += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
            let mut type: i32 =  this.game.Data.SFObj[sf].Type;
            if (!onlyland | onlyland & this.game.Data.SFTypeObj[type].Theater == 0 && !(!stafftoo & this.game.Data.SFTypeObj[type].StaffPts > 0))
              wholeChainOfCommand += this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty;
          }
        }
      }
      return wholeChainOfCommand;
    }

    pub fn GetPowerPtsAbsoluteForAirOnly(unr: i32) -> i32
    {
      absoluteForAirOnly: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
            absoluteForAirOnly += this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty;
        }
      }
      return absoluteForAirOnly;
    }

    pub fn GetAirCarryCapPts(unr: i32) -> i32
    {
      airCarryCapPts: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 1)
            airCarryCapPts += this.game.Data.SFTypeObj[type].AirCarrierCap * this.game.Data.SFObj[sf].Qty;
        }
      }
      return airCarryCapPts;
    }

    pub fn GetAntiStrucPts(unr: i32) -> i32
    {
      antiStrucPts: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          antiStrucPts += this.game.Data.SFTypeObj[type].AntiStrucPts * this.game.Data.SFObj[sf].Qty;
        }
      }
      return antiStrucPts;
    }

    pub fn GetUnitSFNr(unr: i32, Sftyp2: i32, ppl: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut unitSfNr: i32 =  0; unitSfNr <= sfCount; unitSfNr += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[unitSfNr];
          if (this.game.Data.SFObj[sf].Type == Sftyp2 & ppl == this.game.Data.SFObj[sf].People)
            return unitSfNr;
        }
      }
      return -1;
    }

    pub fn GetBlowBridgePts(unr: i32) -> i32
    {
      blowBridgePts: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut num: i32 =  this.game.Data.SFTypeObj[type].BlowBridgePts * this.game.Data.SFObj[sf].Qty;
          if (this.game.Data.SFTypeObj[type].manpower > 0 & this.game.Data.Product == 6)
            num =  Math.Round( (num * this.game.Data.SFTypeObj[type].manpower) / 10.0);
          if (this.game.Data.SFTypeObj[type].EP > 0)
            num =  Math.Round( num * ( (this.game.Data.SFObj[sf].EP + this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].EP) /  (this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].EP)));
          blowBridgePts += num;
        }
      }
      return blowBridgePts;
    }

    pub fn GetAirCarryCapPtsOccupied(unr: i32) -> i32
    {
      carryCapPtsOccupied: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
            carryCapPtsOccupied += this.game.Data.SFTypeObj[type].Weight * this.game.Data.SFObj[sf].Qty;
        }
      }
      return carryCapPtsOccupied;
    }

    pub CanUnitMove: bool(unr: i32, bool ignoreFuel = false)
    {
      let mut lowestAp: i32 =  this.GetLowestAp(unr);
      if (this.game.Data.UnitObj[unr].LastAP == lowestAp)
        return this.game.Data.UnitObj[unr].LastMove;
      this.game.Data.UnitObj[unr].LastMove = false;
      this.game.Data.UnitObj[unr].LastAP = lowestAp;
      if (this.game.Data.UnitObj[unr].X == -1)
        return false;
      let mut num: i32 =  this.HexNeighbourCount(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map);
      for (let mut tfacing: i32 =  1; tfacing <= num; tfacing += 1)
      {
        Coordinate coordinate = this.HexNeighbour(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, tfacing);
        if (coordinate.onmap && this.GetLowestAp(unr) >= this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, coordinate.x, coordinate.y, coordinate.map, ignoreFuel: ignoreFuel).x)
        {
          this.game.Data.UnitObj[unr].LastMove = true;
          return true;
        }
      }
      if (!(this.HasUnitAirSF(unr) & this.HasUnitNavySF(unr)) || this.GetLowestAp(unr, true) <= 0)
        return false;
      this.game.Data.UnitObj[unr].LastMove = true;
      return true;
    }

    pub Encrypt: String(plainText: String)
    {
      ICryptoTransform encryptor = RijndaelManaged::new().CreateEncryptor(new byte[32]
      {
        (byte) 170,
        (byte) 56,
        (byte) 56,
        (byte) 124,
        (byte) 31,
        (byte) 136,
        (byte) 211,
        (byte) 100,
        (byte) 100,
        (byte) 51,
        (byte) 111,
        (byte) 88,
        (byte) 217,
        (byte) 92,
        (byte) 214,
        (byte) 36,
        (byte) 164,
        (byte) 188,
        (byte) 51,
        (byte) 51,
        (byte) 36,
        (byte) 187,
        (byte) 195,
        (byte) 205,
        (byte) 87,
        (byte) 167,
        (byte) 81,
        (byte) 248,
        (byte) 173,
        (byte) 7,
        (byte) 194,
        (byte) 10
      }, new byte[16]
      {
        (byte) 33,
        (byte) 163,
        (byte) 253,
        byte.MaxValue,
        byte.MaxValue,
        (byte) 140,
        (byte) 132,
        (byte) 198,
        (byte) 25,
        (byte) 94,
        (byte) 222,
        (byte) 141,
        (byte) 181,
        (byte) 152,
        (byte) 94,
        (byte) 28
      });
      byte[] bytes = Encoding.Unicode.GetBytes(plainText);
      return Convert.ToBase64String(encryptor.TransformFinalBlock(bytes, 0, bytes.Length));
    }

    pub Decrypt: String(encryptedText: String)
    {
      ICryptoTransform decryptor = RijndaelManaged::new().CreateDecryptor(new byte[32]
      {
        (byte) 170,
        (byte) 56,
        (byte) 56,
        (byte) 124,
        (byte) 31,
        (byte) 136,
        (byte) 211,
        (byte) 100,
        (byte) 100,
        (byte) 51,
        (byte) 111,
        (byte) 88,
        (byte) 217,
        (byte) 92,
        (byte) 214,
        (byte) 36,
        (byte) 164,
        (byte) 188,
        (byte) 51,
        (byte) 51,
        (byte) 36,
        (byte) 187,
        (byte) 195,
        (byte) 205,
        (byte) 87,
        (byte) 167,
        (byte) 81,
        (byte) 248,
        (byte) 173,
        (byte) 7,
        (byte) 194,
        (byte) 10
      }, new byte[16]
      {
        (byte) 33,
        (byte) 163,
        (byte) 253,
        byte.MaxValue,
        byte.MaxValue,
        (byte) 140,
        (byte) 132,
        (byte) 198,
        (byte) 25,
        (byte) 94,
        (byte) 222,
        (byte) 141,
        (byte) 181,
        (byte) 152,
        (byte) 94,
        (byte) 28
      });
      byte[] inputBuffer = Convert.FromBase64String(encryptedText);
      return Encoding.Unicode.GetString(decryptor.TransformFinalBlock(inputBuffer, 0, inputBuffer.Length));
    }

    pub CanUnitMoveFreeCheck: bool(unr: i32, bool ignoreFuel = false)
    {
      this.GetLowestAp(unr);
      if (this.game.Data.UnitObj[unr].X == -1)
        return false;
      let mut num: i32 =  this.HexNeighbourCount(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map);
      for (let mut tfacing: i32 =  1; tfacing <= num; tfacing += 1)
      {
        Coordinate coordinate = this.HexNeighbour(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, tfacing);
        if (coordinate.onmap && this.GetLowestAp(unr) >= this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, coordinate.x, coordinate.y, coordinate.map, ignoreFuel: ignoreFuel).x)
          return true;
      }
      return this.HasUnitAirSF(unr) & this.HasUnitNavySF(unr) && this.GetLowestAp(unr, true) > 0;
    }

    pub CanUnitMove2: bool(unr: i32)
    {
      let mut lowestAp: i32 =  this.GetLowestAp(unr);
      if (this.game.Data.UnitObj[unr].LastAP == lowestAp)
        return this.game.Data.UnitObj[unr].LastMove;
      this.game.Data.UnitObj[unr].LastMove = false;
      this.game.Data.UnitObj[unr].LastAP = lowestAp;
      if (this.game.Data.UnitObj[unr].FreeCombatX > -1)
      {
        this.game.Data.UnitObj[unr].LastMove = true;
        return true;
      }
      if (this.game.Data.UnitObj[unr].X == -1)
        return false;
      let mut num: i32 =  this.HexNeighbourCount(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map);
      for (let mut tfacing: i32 =  1; tfacing <= num; tfacing += 1)
      {
        Coordinate coordinate = this.HexNeighbour(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, tfacing);
        if (coordinate.onmap && lowestAp >= this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, coordinate.x, coordinate.y, coordinate.map, true, NoAPPenalty: true).x)
        {
          this.game.Data.UnitObj[unr].LastMove = true;
          return true;
        }
      }
      if (!(this.HasUnitAirSF(unr) & this.HasUnitNavySF(unr)) || this.GetLowestAp(unr, true) <= 0)
        return false;
      this.game.Data.UnitObj[unr].LastMove = true;
      return true;
    }

    pub CanUnitBuild: bool(unr: i32)
    {
      this.GetUnitEP(unr);
      let mut locTypeCounter: i32 =  this.game.Data.LocTypeCounter;
      for (let mut loctype: i32 =  0; loctype <= locTypeCounter; loctype += 1)
      {
        if (this.CanConstructLoc(loctype, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, this.game.Data.UnitObj[unr].Regime, unr, true))
          return true;
      }
      return false;
    }

    pub CanUnitInfra: bool(unr: i32)
    {
      let mut x1: i32 =  this.game.Data.UnitObj[unr].X;
      let mut y: i32 =  this.game.Data.UnitObj[unr].Y;
      let mut map: i32 =  this.game.Data.UnitObj[unr].Map;
      let mut tfacing: i32 =  1;
      do
      {
        Coordinate coordinate1 = this.HexNeighbourSameMap(x1, y, map, tfacing);
        if (coordinate1.onmap && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[map].HexObj[coordinate1.x, coordinate1.y].Regime, this.game.Data.UnitObj[unr].Regime) |  this.game.Data.RuleVar[483] > 0.0 & this.game.Data.Product >= 6)
        {
          let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[coordinate1.x, coordinate1.y].LandscapeType;
          if (this.game.Data.LandscapeTypeObj[landscapeType].CanBuildRoad)
          {
            Coordinate coordinate2;
            x2: i32;
            if ( this.game.Data.RuleVar[483] > 0.0 & this.game.Data.Product >= 6)
            {
              coordinate2 = this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, x1, y, map, coordinate1.x, coordinate1.y, coordinate1.map, true, IgnoreBridges: true);
              x2 = coordinate2.x;
            }
            else
            {
              coordinate2 = this.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, x1, y, map, coordinate1.x, coordinate1.y, coordinate1.map, IgnoreBridges: true);
              x2 = coordinate2.x;
            }
            let mut lowestAp: i32 =  this.GetLowestAp(unr);
            if (x2 <= lowestAp)
            {
              if (this.game.Data.MapObj[map].HexObj[x1, y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[map].HexObj[x1, y].Bridge[tfacing - 1])
              {
                if ( this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x1, y].RiverType[tfacing - 1]].BridgeCostModifier *  this.game.Data.BridgeObj[0].EPCost <=  this.game.HandyFunctionsObj.GetUnitEP(unr) &&  this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[825] && this.CanConstructBridge(unr, x1, y, map, tfacing - 1))
                  return true;
              }
              else if (this.game.Data.MapObj[map].HexObj[x1, y].RoadType[tfacing - 1] == -1)
              {
                if ( this.game.Data.RuleVar[32] > -1.0 &&  this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[823] &&  this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost *  this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
                  return true;
              }
              else if ( this.game.Data.RuleVar[820] > -1.0 &  this.game.Data.MapObj[map].HexObj[x1, y].RoadType[tfacing - 1] ==  this.game.Data.RuleVar[821] &&  this.game.Data.RuleVar[32] > -1.0 &&  this.game.Data.RuleVar[822] == -1.0 |  this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[ Math.Round( Math.Max(0.0f, this.game.Data.RuleVar[822]))] >=  this.game.Data.RuleVar[824] &&  this.game.Data.RoadTypeObj[ Math.Round( this.game.Data.RuleVar[32])].EPCost *  this.game.Data.LandscapeTypeObj[landscapeType].RoadCostModifier <=  this.game.HandyFunctionsObj.GetUnitEP(unr))
                return true;
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      return false;
    }

    pub CanUnitIntercept: bool(unr: i32, Coordinate target, vsregime: i32)
    {
      if (this.game.Data.UnitObj[unr].SOInterceptRdnStop >= this.GetAverageAirRdn(unr))
        return false;
      let mut index: i32 =  vsregime;
      let mut num1: i32 =  1;
      let mut x: i32 =  this.game.Data.UnitObj[unr].X;
      let mut y: i32 =  this.game.Data.UnitObj[unr].Y;
      let mut map: i32 =  this.game.Data.UnitObj[unr].Map;
      if (x == -1)
        return false;
      let mut minimumAirfieldLevel: i32 =  this.SE1_GetUnitMinimumAirfieldLevel(unr);
      if (this.game.Data.UnitObj[unr].Regime == index)
        num1 = 0;
      if (this.game.Data.UnitObj[unr].PreDef > -1)
        return false;
      if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeRel[index] >= 1)
        num1 = 0;
      if (num1 == 1 && this.HasUnitAirSF(unr, true, true) && this.game.Data.MapObj[map].HexObj[x, y].Location > -1 | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea | this.game.Data.Product == 7)
      {
        let mut num2: i32 =  0;
        if (this.game.Data.MapObj[map].HexObj[x, y].Location > -1)
        {
          if (this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Type].IsAirfield)
            num2 = 1;
          if (this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].isAirfield)
            num2 = 1;
        }
        if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
          num2 = 1;
        if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[target.x, target.y].LandscapeType].IsSea && this.game.Data.MapObj[map].HexObj[target.x, target.y].UnitCounter > -1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[target.x, target.y].UnitList[0];
          if (this.game.Data.UnitObj[unit].Regime != this.game.Data.UnitObj[unr].Regime)
          {
            num2 = 0;
            if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unit].Regime].RegimeRel[this.game.Data.UnitObj[unr].Regime] == 2 && this.game.Data.RegimeObj[vsregime].RegimeRel[this.game.Data.UnitObj[unr].Regime] == 0)
              num2 = 1;
          }
        }
        if (this.game.Data.Product == 7)
        {
          if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[target.x, target.y].LandscapeType].IsSea)
            num2 = minimumAirfieldLevel <= 0 ? 1 : (this.game.Data.MapObj[map].HexObj[x, y].Location <= -1 ? 0 : (minimumAirfieldLevel <= this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].tempAirfieldLevel ? num2 : 0));
          if (this.game.Data.UnitObj[unr].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].Type == 8)
            num2 = 0;
        }
        if (num2 == 1)
        {
          let mut increaseap: i32 =   Math.Round( Conversion.Int( this.GetLowestAirRdn(unr, true) * this.game.Data.RuleVar[147]));
          if (num2 == 1 && increaseap > 0)
          {
            this.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, false, PredictAirOnly: true, attack: true, increaseap: increaseap, OnlyFrontline: true);
            if (increaseap >= this.game.EditObj.TempValue[target.map].Value[target.x, target.y] && this.game.HandyFunctionsObj.GetAverageAirRdn(unr, true) > this.game.Data.UnitObj[unr].SOInterceptRdnStop)
              return true;
          }
        }
      }
      return false;
    }

    pub CanUnitAA: bool(unr: i32, Coordinate target, vsregime: i32)
    {
      let mut index1: i32 =  vsregime;
      let mut num: i32 =  1;
      if (this.game.Data.UnitObj[unr].Regime == index1)
        num = 0;
      if (this.game.Data.UnitObj[unr].PreDef > -1)
        return false;
      if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeRel[index1] >= 1)
        num = 0;
      if (num == 1 && this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
        {
          let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index2]].Type;
          if (this.game.Data.UnitObj[unr].Map == target.map && this.game.Data.SFTypeObj[type].AARange >= this.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map))
            return true;
        }
      }
      return false;
    }

    pub HasUnitAirSF: bool(unr: i32, bool nonbackbench = false, bool testSOrdn = false, bool UseInitialSO = false)
    {
      let mut num1: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut num2: i32 =  !testSOrdn ? -1 : (!UseInitialSO ? this.game.Data.UnitObj[unr].SOInterceptRdnStop : this.game.Data.UnitObj[unr].StartIntercept);
          if (!nonbackbench)
          {
            if (this.game.Data.SFTypeObj[type].Theater == 2 && this.game.Data.SFObj[sf].Rdn > num2)
              num1 = 1;
          }
          else if (this.game.Data.SFTypeObj[type].Theater == 2 && !this.game.Data.SFTypeObj[type].BackBench && this.game.Data.SFObj[sf].Rdn > num2)
            num1 = 1;
        }
      }
      return num1 > 0;
    }

    pub HasUnitAirSF: bool(
      unr: i32,
      data: DataClass,
      bool nonbackbench = false,
      bool testSOrdn = false,
      bool UseInitialSO = false)
    {
      let mut num1: i32 =  0;
      if (data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  data.UnitObj[unr].SFList[index];
          let mut type: i32 =  data.SFObj[sf].Type;
          let mut num2: i32 =  !testSOrdn ? -1 : (!UseInitialSO ? data.UnitObj[unr].SOInterceptRdnStop : data.UnitObj[unr].StartIntercept);
          if (!nonbackbench)
          {
            if (data.SFTypeObj[type].Theater == 2 && data.SFObj[sf].Rdn > num2)
              num1 = 1;
          }
          else if (data.SFTypeObj[type].Theater == 2 && !data.SFTypeObj[type].BackBench && data.SFObj[sf].Rdn > num2)
            num1 = 1;
        }
      }
      return num1 > 0;
    }

    pub HasUnitOnlyParaLandSF: bool(unr: i32)
    {
      let mut num1: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
          let mut num2: i32 =  0;
          if (this.game.Data.SFTypeObj[type].Theater == 0 && this.game.Data.SFTypeObj[type].CanDoParadrop)
            num2 = 1;
          if (num2 == 0)
            num1 = 1;
        }
      }
      else
        num1 = 1;
      return num1 == 0;
    }

    pub HasUnitNavySF: bool(unr: i32)
    {
      let mut num: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].Theater == 1)
            num = 1;
        }
      }
      return num > 0;
    }

    pub HasUnitNavySF: bool(unr: i32, data: DataClass)
    {
      let mut num: i32 =  0;
      if (data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  data.UnitObj[unr].SFList[index];
          let mut type: i32 =  data.SFObj[sf].Type;
          if (data.SFTypeObj[type].Theater == 1)
            num = 1;
        }
      }
      return num > 0;
    }

    pub fn HasUnitAA(unr: i32) -> i32
    {
      let mut num: i32 =  -1;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
          if (this.game.Data.SFTypeObj[type].AARange > num)
            num = this.game.Data.SFTypeObj[type].AARange;
          if (this.game.Data.SFTypeObj[type].AIRoleScore[12] > 0 & num == -1)
            num = 0;
        }
      }
      return num >= 0 ? num : -1;
    }

    pub HasUnitlandSF: bool(unr: i32)
    {
      let mut num: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].Theater == 0)
            num = 1;
        }
      }
      return num > 0;
    }

    pub HasUnitSFType: bool(unr: i32, typ: i32)
    {
      let mut num: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          if (this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type == typ)
            num += 1;
        }
      }
      return num > 0;
    }

    pub HasUnitSFTypeVar: bool(unr: i32, varType: i32, let mut equalOrAbove: i32 =  -1, let mut equalOrBelow: i32 =  -1)
    {
      let mut num: i32 =  0;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
          if (this.game.Data.SFTypeObj[type].SFTypeVar[varType] >= equalOrAbove | equalOrAbove == -1 && this.game.Data.SFTypeObj[type].SFTypeVar[varType] <= equalOrBelow | equalOrBelow == -1)
            num += 1;
        }
      }
      return num > 0;
    }

    pub HasUnitArtSF: bool(unr: i32, data: DataClass)
    {
      let mut num: i32 =  0;
      if (data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  data.UnitObj[unr].SFList[index];
          let mut type: i32 =  data.SFObj[sf].Type;
          if (data.SFTypeObj[type].ArtRange >= 1)
            num = 1;
        }
      }
      return num > 0;
    }

    pub fn GetUnitBestArtRange(unr: i32, data: DataClass) -> i32
    {
      let mut unitBestArtRange: i32 =  0;
      if (data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  data.UnitObj[unr].SFList[index];
          let mut type: i32 =  data.SFObj[sf].Type;
          if (data.SFTypeObj[type].ArtRange >= unitBestArtRange)
            unitBestArtRange = data.SFTypeObj[type].ArtRange;
        }
      }
      return unitBestArtRange;
    }

    pub CanDoArtAttack: bool(unr: i32, Coordinate target, bool Prognosis)
    {
      if (this.game.Data.UnitObj[unr].PreDef > -1)
      {
        bool flag;
        return flag;
      }
      if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].Map == target.map)
      {
        let mut dist: i32 =  !Prognosis ? this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, target.x, target.y, target.map) : this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY, 0, target.x, target.y, target.map);
        if (0 < dist && dist <= this.GetMaxArtRange(unr, 0) && (this.game.EditObj.OrderType == 0 || !Information.IsNothing( this.game.EditObj.TempUnitList) && 10 <= this.game.HandyFunctionsObj.GetLowestlandartAp(unr, dist) && this.game.EditObj.TempUnitList.counter < 15 | this.game.EditObj.TempUnitList.CheckIfPresent(unr)))
          return true;
      }
      return false;
    }

    pub CanDoDirectAttack: bool(unr: i32, Coordinate target, bool Prognosis)
    {
      if (this.game.Data.UnitObj[unr].PreDef > -1)
      {
        bool flag;
        return flag;
      }
      if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].Map == target.map)
      {
        let mut dist: i32 =  !Prognosis ? this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, target.x, target.y, target.map) : this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY, 0, target.x, target.y, target.map);
        if (0 < dist && dist <= this.GetMaxDirectRange(unr, 0))
        {
          if (this.game.EditObj.OrderType == 0)
            return true;
          if (!Information.IsNothing( this.game.EditObj.TempUnitList) && 10 <= this.game.HandyFunctionsObj.GetLowestlandDirectAp(unr, dist) && this.game.EditObj.TempUnitList.counter < 15 | this.game.EditObj.TempUnitList.CheckIfPresent(unr))
          {
            this.SetTempLos(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, dist + 1, false);
            if (this.game.EditObj.TempLos[0].Value[target.x, target.y] > 0)
              return true;
          }
        }
      }
      return false;
    }

    pub CanDoSeaArtAttack: bool(unr: i32, Coordinate target)
    {
      if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].Map == target.map)
      {
        let mut dist: i32 =  this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map);
        if (0 < dist && dist <= this.GetMaxArtRange(unr, 1) && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[target.x, target.y].LandscapeType].IsSea && 10 <= this.game.HandyFunctionsObj.GetLowestseaartAp(unr, dist) && this.game.EditObj.TempUnitList.counter < 15 | this.game.EditObj.TempUnitList.CheckIfPresent(unr))
          return true;
      }
      return false;
    }

    pub CanDoSeaAttack: bool(unr: i32, Coordinate target) => this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn && this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map) <= 1 && this.game.HandyFunctionsObj.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map, true).x <= this.game.HandyFunctionsObj.GetLowestAp(unr) && this.game.EditObj.TempUnitList.counter < 15 | this.game.EditObj.TempUnitList.CheckIfPresent(unr);

    pub CanDoLandAttack: bool(unr: i32, Coordinate target) => this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn && !this.game.HandyFunctionsObj.HasUnitAirSF(unr) && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map) <= 1 && this.game.HandyFunctionsObj.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map, true).x <= this.game.HandyFunctionsObj.GetLowestAp(unr) &&  this.game.Data.RuleVar[307] <=  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) && this.game.EditObj.TempUnitList.counter < 15 | this.game.EditObj.TempUnitList.CheckIfPresent(unr);

    pub OrderResult CanDoLandAttack2(unr: i32, Coordinate target)
    {
      OrderResult orderResult = OrderResult::new();
      orderResult.OK = false;
      orderResult.Data = 0;
      if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & !Information.IsNothing( this.game.EditObj.TempUnitList) && !this.game.HandyFunctionsObj.HasUnitAirSF(unr) && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map) <= 1)
      {
        if ( this.game.Data.RuleVar[493] > 0.0)
        {
          if ( this.game.Data.RuleVar[307] <=  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) && this.game.EditObj.TempUnitList.counter < 15 | this.game.EditObj.TempUnitList.CheckIfPresent(unr))
          {
            Coordinate coordinate = this.game.HandyFunctionsObj.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map, true);
            let mut lowestAp: i32 =  this.game.HandyFunctionsObj.GetLowestAp(unr);
            if (coordinate.x <= lowestAp)
            {
              orderResult.OK = true;
              orderResult.Data = 0;
            }
            else if (coordinate.data2 > 0 & coordinate.data2 <= 100)
            {
              orderResult.OK = true;
              orderResult.Data = coordinate.data2;
              if (coordinate.data2 >= 100)
                orderResult.Data = 0;
            }
            return orderResult;
          }
        }
        else if (this.game.HandyFunctionsObj.MoveApCostPreview(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, target.x, target.y, target.map, true).x <= this.game.HandyFunctionsObj.GetLowestAp(unr) &&  this.game.Data.RuleVar[307] <=  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) && this.game.EditObj.TempUnitList.counter < 15 | this.game.EditObj.TempUnitList.CheckIfPresent(unr))
        {
          orderResult.OK = true;
          return orderResult;
        }
      }
      return orderResult;
    }

    pub fn CurrentAttackStack() -> i32
    {
      num: i32;
      if (this.game.EditObj.TempUnitList.counter > -1)
      {
        let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut unr: i32 =  this.game.EditObj.TempUnitList.unr[index];
          num += this.GetUnitStackPts(unr);
        }
      }
      return num;
    }

    pub fn CurrentAttackStackAir() -> i32
    {
      num: i32;
      if (this.game.EditObj.TempUnitList.counter > -1)
      {
        let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut unr: i32 =  this.game.EditObj.TempUnitList.unr[index];
          num += this.GetUnitairStackPts(unr);
        }
      }
      return num;
    }

    pub fn CurrentAttackStackart() -> i32
    {
      num: i32;
      if (this.game.EditObj.TempUnitList.counter > -1)
      {
        let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
        for (let mut index: i32 =  0; index <= counter; index += 1)
        {
          let mut unr: i32 =  this.game.EditObj.TempUnitList.unr[index];
          num += this.GetUnitartStackPts(unr);
        }
      }
      return num;
    }

    pub fn maxAttackStack() -> i32
    {
      int[] numArray = new int[6];
      if (this.game.EditObj.TempUnitList.counter > -1)
      {
        let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
        for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
        {
          let mut index2: i32 =  this.game.EditObj.TempUnitList.unr[index1];
          let mut num: i32 =  this.HexFacing(this.game.EditObj.TargetX, this.game.EditObj.TargetY, this.game.EditObj.TargetMap, this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, this.game.Data.UnitObj[index2].Map);
          if (num > 0)
          {
            let mut index3: i32 =  num - 1;
            numArray[index3] = numArray[index3] + 1;
          }
        }
      }
      let mut index: i32 =  0;
      num1: i32;
      do
      {
        if (numArray[index] > 0)
          num1 =  Math.Round( ( num1 + this.game.Data.RuleVar[31]));
        index += 1;
      }
      while (index <= 5);
      if (num1 == 0)
        num1 =  Math.Round( this.game.Data.RuleVar[31]);
      if ( num1 <  this.game.Data.RuleVar[30])
        num1 =  Math.Round( this.game.Data.RuleVar[30]);
      return num1;
    }

    pub fn maxAttackStackPrognosis(bool facingInData2 = false) -> i32
    {
      int[] numArray = new int[6];
      if (Information.IsNothing( this.game.EditObj.TempUnitList))
        return 0;
      if (this.game.EditObj.TempUnitList.counter > -1)
      {
        let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
        for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
        {
          let mut index2: i32 =  this.game.EditObj.TempUnitList.unr[index1];
          if (facingInData2)
          {
            let mut index3: i32 =  this.game.EditObj.TempUnitList.data2[index1];
            numArray[index3] = numArray[index3] + 1;
          }
          else
          {
            let mut num: i32 =  this.HexFacing(this.game.EditObj.TargetX, this.game.EditObj.TargetY, this.game.EditObj.TargetMap, this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0);
            if (num > 0)
            {
              let mut index4: i32 =  num - 1;
              numArray[index4] = numArray[index4] + 1;
            }
          }
        }
      }
      let mut index: i32 =  0;
      num1: i32;
      do
      {
        if (numArray[index] > 0)
          num1 =  Math.Round( ( num1 + this.game.Data.RuleVar[31]));
        index += 1;
      }
      while (index <= 5);
      if (num1 == 0)
        num1 =  Math.Round( this.game.Data.RuleVar[31]);
      if ( num1 <  this.game.Data.RuleVar[30])
        num1 =  Math.Round( this.game.Data.RuleVar[30]);
      return num1;
    }

    pub CanDoAirStrike: bool(unr: i32, Coordinate target)
    {
      bool flag = false;
      if (this.game.Data.Product == 7 && this.game.HandyFunctionsObj.SE1_GetUnitMinimumAirfieldLevel(unr) < 1)
        flag = true;
      if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn && this.game.HandyFunctionsObj.HasUnitAirSF(unr) && this.game.Data.UnitObj[unr].PreDef == -1)
      {
        if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.Data.UnitObj[unr].Map].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType].IsSea)
        {
          if (!Conversions.ToBoolean(Operators.OrObject( (this.game.HandyFunctionsObj.IsHexAirfield(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map) | flag), Operators.CompareObjectGreaterEqual( this.GetAirCarryCapPts(unr), Operators.SubtractObject(this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, true), this.game.HandyFunctionsObj.GetUnitNonSeaWeight(unr, false)), false))))
            return false;
          let mut unitAirRangeInHex: i32 =  this.GetUnitAirRangeInHex(unr);
          if (unitAirRangeInHex == -1)
          {
            this.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, false, PredictAirOnly: true, attack: true);
            if (this.game.EditObj.TempValue[target.map].Value[target.x, target.y] <= this.game.HandyFunctionsObj.GetLowestAirAp(unr))
              return true;
          }
          else if (this.Distance(target.x, target.y, 0, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0) <= unitAirRangeInHex)
            return true;
        }
        else
        {
          this.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, false, PredictAirOnly: true, attack: true);
          if (this.game.EditObj.TempValue[target.map].Value[target.x, target.y] <= this.game.HandyFunctionsObj.GetLowestAirAp(unr))
            return true;
        }
      }
      return false;
    }

    pub fn GetMaxArtRange(unr: i32, temptheater: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut maxArtRange: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].Theater == temptheater && this.game.Data.SFTypeObj[type].ArtRange > maxArtRange)
          maxArtRange = this.game.Data.SFTypeObj[type].ArtRange;
      }
      return maxArtRange;
    }

    pub fn GetMaxAARange(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut maxAaRange: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].AARange > maxAaRange)
          maxAaRange = this.game.Data.SFTypeObj[type].AARange;
      }
      return maxAaRange;
    }

    pub fn GetMaxAirRange(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut num: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 2 && this.game.Data.SFTypeObj[type].AirAPRule > -1 && this.game.Data.SFTypeObj[type].AirAPRule > num)
          num = this.game.Data.SFTypeObj[type].AirAPRule;
      }
      return num < 1 ? 0 :  Math.Round(Math.Floor( this.game.HandyFunctionsObj.GetLowestAirAp(unr) /  num));
    }

    pub AIMatrix AutoMoveLongRangeMatrix(
      targetX: i32,
      targetY: i32,
      width: i32,
      height: i32)
    {
      AIMatrix aiMatrix1 = new AIMatrix( this.game.DC2AIObj, width, height, 0, 0);
      AIMatrix aiMatrix2 = new AIMatrix( this.game.DC2AIObj, width, height, 0, 0);
      MapClass mapClass = this.game.Data.MapObj[0];
      let mut num1: i32 =  1;
      aiMatrix1.Value[targetX, targetY] = 1;
      let mut num2: i32 =  width;
      for (let mut index1: i32 =  0; index1 <= num2; index1 += 1)
      {
        let mut num3: i32 =  height;
        for (let mut index2: i32 =  0; index2 <= num3; index2 += 1)
          aiMatrix2.Value[index1, index2] = 99999;
      }
      aiMatrix2.Value[targetX, targetY] = 1;
      num4: i32;
      do
      {
        num4 = 0;
        let mut num5: i32 =  width;
        for (let mut cx: i32 =  0; cx <= num5; cx += 1)
        {
          let mut num6: i32 =  height;
          for (let mut cy: i32 =  0; cy <= num6; cy += 1)
          {
            if (mapClass.HexObj[cx, cy].Regime == this.game.Data.Turn && aiMatrix1.Value[cx, cy] == num1 && aiMatrix2.Value[cx, cy] > 0)
            {
              let mut index: i32 =  0;
              do
              {
                Coordinate coordinate = this.HexNeighbour(cx, cy, 0, index + 1);
                if (coordinate.onmap && mapClass.HexObj[coordinate.x, coordinate.y].Regime == this.game.Data.Turn && aiMatrix2.Value[cx, cy] < aiMatrix2.Value[coordinate.x, coordinate.y])
                {
                  if (mapClass.HexObj[cx, cy].RoadType[index] > -1)
                  {
                    num4 += 1;
                    let mut num7: i32 =  aiMatrix2.Value[cx, cy] + 1;
                    if (num7 < aiMatrix2.Value[coordinate.x, coordinate.y])
                    {
                      aiMatrix1.Value[coordinate.x, coordinate.y] = num1 + 1;
                      aiMatrix2.Value[coordinate.x, coordinate.y] = num7;
                    }
                  }
                  else
                  {
                    num4 += 1;
                    let mut num8: i32 =  aiMatrix2.Value[cx, cy] + 10;
                    if (num8 < aiMatrix2.Value[coordinate.x, coordinate.y])
                    {
                      aiMatrix1.Value[coordinate.x, coordinate.y] = num1 + 1;
                      aiMatrix2.Value[coordinate.x, coordinate.y] = num8;
                    }
                  }
                }
                index += 1;
              }
              while (index <= 5);
            }
          }
        }
        num1 += 1;
      }
      while (num4 > 0);
      return aiMatrix2;
    }

    pub fn GetMaxDirectRange(unr: i32, temptheater: i32) -> i32
    {
      if ( this.game.Data.RuleVar[419] < 1.0 || this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut maxDirectRange: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].Theater == temptheater | temptheater == -1 && this.game.Data.SFTypeObj[type].directRange > maxDirectRange)
          maxDirectRange = this.game.Data.SFTypeObj[type].directRange;
      }
      return maxDirectRange;
    }

    pub fn HexAverageEntrenchment(x: i32, y: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut unitCounter: i32 =  this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[0].HexObj[x, y].UnitList[index1];
        let mut sfCount: i32 =  this.game.Data.UnitObj[unit].SFCount;
        for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index2];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          let mut currentEntrench: i32 =  this.game.Data.SFObj[sf].CurrentEntrench;
          let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
          num1 += this.game.Data.SFTypeObj[type].PowerPts * qty * currentEntrench;
          num2 += this.game.Data.SFTypeObj[type].PowerPts * qty;
        }
      }
      return num2 <= 0 ? 0 :  Math.Round( num1 /  num2);
    }

    pub fn GetArtPercent(unr: i32, bool useHis) -> i32
    {
      if (useHis & this.game.Data.UnitObj[unr].HistoricalSubPart > -1 & this.game.Data.UnitObj[unr].Historical > -1)
      {
        let mut preDef: i32 =  this.game.HandyFunctionsObj.GetPreDef(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].SubParts[this.game.Data.UnitObj[unr].HistoricalSubPart]);
        if (preDef > -1)
          unr = preDef;
      }
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].ArtRange > 0)
        {
          num1 += this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty * this.game.Data.SFTypeObj[type].PowerPts;
          num2 += this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty * this.game.Data.SFTypeObj[type].PowerPts;
        }
        else
          num2 += this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty * this.game.Data.SFTypeObj[type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round( (num1 * 100) /  num2);
    }

    pub fn GetDirectPercent(unr: i32, bool useHis) -> i32
    {
      if (useHis & this.game.Data.UnitObj[unr].HistoricalSubPart > -1 & this.game.Data.UnitObj[unr].Historical > -1)
      {
        let mut preDef: i32 =  this.game.HandyFunctionsObj.GetPreDef(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].SubParts[this.game.Data.UnitObj[unr].HistoricalSubPart]);
        if (preDef > -1)
          unr = preDef;
      }
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut type: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].directRange > 0)
        {
          num1 += this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty * this.game.Data.SFTypeObj[type].PowerPts;
          num2 += this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty * this.game.Data.SFTypeObj[type].PowerPts;
        }
        else
          num2 += this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty * this.game.Data.SFTypeObj[type].PowerPts;
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round( (num1 * 100) /  num2);
    }

    pub IsHexHarbourOrSea: bool(x: i32, y: i32, map: i32)
    {
      if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
        return true;
      let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
      return location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsPort;
    }

    pub IsHexHarbourOrSea: bool(x: i32, y: i32, map: i32, Data: DataClass)
    {
      if (Data.LandscapeTypeObj[Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
        return true;
      let mut location: i32 =  Data.MapObj[map].HexObj[x, y].Location;
      if (location <= -1)
        return false;
      let mut type: i32 =  Data.LocObj[location].Type;
      return Data.LocTypeObj[type].IsPort;
    }

    pub IsHexNextToSea: bool(x: i32, y: i32, map: i32)
    {
      let mut tfacing: i32 =  1;
      do
      {
        Coordinate coordinate = this.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
          return true;
        tfacing += 1;
      }
      while (tfacing <= 6);
      return false;
    }

    pub IsHexNextOnOrNextToFriendlyLoc: bool(x: i32, y: i32, map: i32)
    {
      if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1)
        return true;
      let mut tfacing: i32 =  1;
      do
      {
        Coordinate coordinate = this.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[x, y].Regime == this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Location > -1)
          return true;
        tfacing += 1;
      }
      while (tfacing <= 6);
      return false;
    }

    pub IsHexAirfield: bool(x: i32, y: i32, map: i32)
    {
      if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
        return false;
      let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
      return location > -1 && (this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsAirfield || this.game.Data.LocObj[location].isAirfield);
    }

    pub IsHexAirfield: bool(x: i32, y: i32, map: i32, data: DataClass)
    {
      if (data.LandscapeTypeObj[data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
        return false;
      let mut location: i32 =  data.MapObj[map].HexObj[x, y].Location;
      if (location <= -1)
        return false;
      let mut type: i32 =  data.LocObj[location].Type;
      return data.LocTypeObj[type].IsAirfield || this.game.Data.LocObj[location].isAirfield;
    }

    pub IsHexPort: bool(x: i32, y: i32, map: i32)
    {
      if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
        return false;
      let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
      return location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].IsPort;
    }

    pub CanAddRoadToHex: bool(x: i32, y: i32, map: i32, hq: i32, CoordList tlist)
    {
      if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].CanBuildRoad)
        return false;
      this.MakeMovePrediction2(this.game.Data.UnitObj[hq].Regime,  Math.Round( this.game.Data.RuleVar[0]), 0,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[hq].X, this.game.Data.UnitObj[hq].Y, this.game.Data.UnitObj[hq].Map);
      if (this.game.EditObj.TempValue[map].Value[x, y] > 9998)
        return false;
      if (tlist.counter == -1)
        return true;
      let mut counter: i32 =  tlist.counter;
      for (let mut index: i32 =  0; index <= counter; index += 1)
      {
        if (tlist.coord[index].x == x & tlist.coord[index].y == y & tlist.coord[index].map == map)
          return false;
      }
      return map == tlist.coord[tlist.counter].map && this.Distance(tlist.coord[tlist.counter].x, tlist.coord[tlist.counter].y, tlist.coord[tlist.counter].map, x, y, map) <= 1;
    }

    pub CanConstructBridge: bool(hq: i32, x: i32, y: i32, map: i32, facing: i32)
    {
      if (facing != -1 && this.game.Data.MapObj[map].HexObj[x, y].Bridge[facing] || facing != -1 && (this.game.Data.MapObj[map].HexObj[x, y].RiverType[facing] == -1 ||  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[facing]].BridgeCostModifier < 0.0))
        return false;
      Coordinate coordinate;
      if ( this.game.Data.RuleVar[320] == 1.0)
      {
        coordinate = this.HexNeighbour(x, y, map, facing + 1);
        if (!coordinate.onmap)
          return false;
        let mut index: i32 =  facing + 3;
        if (index > 5)
          index -= 6;
        if (this.game.Data.MapObj[map].HexObj[x, y].RoadType[facing] == -1 || this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].RoadType[index] == -1)
          return false;
      }
      if (facing != -1)
      {
        coordinate = this.HexNeighbour(x, y, map, facing + 1);
        if (!coordinate.onmap ||  this.game.Data.RuleVar[483] < 1.0 | this.game.Data.Product < 6 && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[map].HexObj[x, y].Regime, this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime))
          return false;
      }
      return true;
    }

    pub CanBlowBridge: bool(hq: i32, x: i32, y: i32, map: i32, facing: i32)
    {
      this.MakeMovePrediction2(this.game.Data.UnitObj[hq].Regime,  Math.Round( this.game.Data.RuleVar[0]), 0,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[hq].X, this.game.Data.UnitObj[hq].Y, this.game.Data.UnitObj[hq].Map);
      return this.game.EditObj.TempValue[map].Value[x, y] <= 9998 && this.game.Data.MapObj[map].HexObj[x, y].Bridge[facing];
    }

    pub CanConstructLoc: bool(
      loctype: i32,
      x: i32,
      y: i32,
      map: i32,
      regnr: i32,
      unr: i32,
      bool potentialy = false)
    {
      if (!this.game.Data.LocTypeObj[loctype].Buildable || this.game.Data.LocTypeObj[loctype].SlotType > -1 && this.game.Data.MapObj[map].HexObj[x, y].AreaCode[this.game.Data.LocTypeObj[loctype].SlotType] != this.game.Data.LocTypeObj[loctype].SlotValue)
        return false;
      if (this.game.Data.MapObj[map].HexObj[x, y].Location > -1)
      {
        if (!(this.game.Data.LocTypeObj[loctype].UpgradeNr > -1 & this.game.Data.LocTypeObj[loctype].UpgradeNr == this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Type))
          return false;
        let mut num: i32 =  num;
        if (this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].StructuralPts < this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Type].StructuralPts)
          return false;
      }
      else if (this.game.Data.LocTypeObj[loctype].UpgradeNr > -1)
        return false;
      if (!this.game.Data.LocTypeObj[loctype].Buildable || !this.game.Data.LocTypeObj[loctype].PeopleGroup[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regnr].People].PeopleGroup] ||  this.game.Data.RuleVar[862] > 0.0 && !this.game.HandyFunctionsObj.IsHexNextToSea(x, y, map) & this.game.Data.LocTypeObj[loctype].IsPort)
        return false;
      let mut index: i32 =  0;
      while ((this.game.Data.LocTypeObj[loctype].Research[index] <= -1 || this.game.Data.RegimeObj[regnr].ResField[this.game.Data.LocTypeObj[loctype].Research[index]]) && (!(this.game.Data.LocTypeObj[loctype].VarType[index] > -1 & this.game.Data.LocTypeObj[loctype].VarQty[index] > 0) || this.game.Data.RegimeObj[regnr].RegimeSlot[this.game.Data.LocTypeObj[loctype].VarType[index]] >= this.game.Data.LocTypeObj[loctype].VarQty[index]))
      {
        index += 1;
        if (index > 4)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[map].MapWidth;
          for (let mut x2: i32 =  0; x2 <= mapWidth; x2 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[map].MapHeight;
            for (let mut y2: i32 =  0; y2 <= mapHeight; y2 += 1)
            {
              let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x2, y2].Location;
              if (location > -1)
              {
                let mut locTypeGroup: i32 =  this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].LocTypeGroup;
                let mut num: i32 =  this.Distance(x, y, map, x2, y2, map);
                if (this.game.Data.LocTypeObj[loctype].MinDistance[locTypeGroup] > -1 && this.game.Data.LocTypeObj[loctype].MinDistance[locTypeGroup] > num)
                  return false;
              }
            }
          }
          return this.game.Data.LocTypeObj[loctype].BuildgroundType[this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].BuildGround] && (potentialy || (unr <= -1 ||  this.game.HandyFunctionsObj.HQSupplyChain(unr, true) >=  this.game.Data.LocTypeObj[loctype].SupplyCost /  this.game.Data.RuleVar[77]) && this.game.Data.RegimeObj[this.game.Data.Turn].ResPts >= this.game.Data.LocTypeObj[loctype].PPCost && (unr <= -1 || this.game.HandyFunctionsObj.GetUnitEP(unr) >= this.game.Data.LocTypeObj[loctype].EPCost));
        }
      }
      return false;
    }

    pub fn GetVisibleHisVar(his: i32) -> i32
    {
      let mut visibleHisVar: i32 =  0;
      let mut hisVarCount: i32 =  this.game.Data.HistoricalUnitObj[his].HisVarCount;
      for (let mut index: i32 =  0; index <= hisVarCount; index += 1)
      {
        if (this.game.Data.HistoricalUnitObj[his].HisVarCount >= index && this.game.Data.HistoricalUnitObj[his].HisVarNato[index] > 0 | this.game.Data.HistoricalUnitObj[his].HisVarSmall[index] > 0)
          visibleHisVar += 1;
      }
      return visibleHisVar;
    }

    pub fn GetRegimeHistoryTotSteps(regnr: i32) -> i32
    {
      if (this.game.Data.RegimeObj[regnr].HistoryStepCounter == -1)
        return -1;
      let mut num1: i32 =  -1;
      num2: i32;
      let mut num3: i32 =  num2;
      regimeHistoryTotSteps: i32;
      try
      {
        let mut historyStepCounter: i32 =  this.game.Data.RegimeObj[regnr].HistoryStepCounter;
        for (let mut index: i32 =  0; index <= historyStepCounter; index += 1)
        {
          HistoryStepClass historyStepClass = this.game.Data.RegimeObj[regnr].HistoryStep[index];
          if (num1 != historyStepClass.StepNr)
          {
            num1 = historyStepClass.StepNr;
            regimeHistoryTotSteps += 1;
          }
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        regimeHistoryTotSteps = num3;
        ProjectData.ClearProjectError();
      }
      return regimeHistoryTotSteps;
    }

    pub fn CheckCargoLoss(unr: i32,  UnitList UL, Attacker: i32, Defender: i32) -> i32
    {
      let mut x: i32 =  this.game.Data.UnitObj[unr].X;
      let mut y: i32 =  this.game.Data.UnitObj[unr].Y;
      let mut map: i32 =  this.game.Data.UnitObj[unr].Map;
      let mut num1: i32 =  0;
      let mut landscapeType: i32 =  this.game.Data.MapObj[map].HexObj[x, y].LandscapeType;
      if (this.game.Data.LandscapeTypeObj[landscapeType].IsSea)
      {
        let mut unitCarryCap: i32 =  this.GetUnitCarryCap(unr, 1);
        let mut num2: i32 =  Conversions.ToInteger(this.GetUnitNonSeaWeight(unr, false)) + Conversions.ToInteger(this.GetUnitExcessWeight(unr));
        if (num2 > unitCarryCap)
        {
          float loss =  (1.0 -  unitCarryCap /  num2);
          if (this.game.Data.UnitObj[unr].PassengerCounter > -1)
          {
            let mut passengerCounter: i32 =  this.game.Data.UnitObj[unr].PassengerCounter;
            for (let mut index: i32 =  0; index <= passengerCounter; index += 1)
            {
              let mut passenger: i32 =  this.game.Data.UnitObj[unr].PassengerList[index];
              if (this.DoLoseCargo(passenger, loss, Attacker, Defender) == 1)
                UL.add(passenger);
            }
          }
          num1 = this.DoLoseCargo(unr, loss, Attacker, Defender);
        }
      }
      let mut num3: i32 =  1;
      if (this.game.Data.LandscapeTypeObj[landscapeType].IsSea)
        num3 = 0;
      if (this.game.Data.MapObj[map].HexObj[x, y].Location > -1 & this.game.Data.UnitObj[unr].Regime != Attacker)
      {
        num3 = 0;
        if (this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Type].IsAirfield)
          num3 = 1;
        if (this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].isAirfield)
          num3 = 1;
      }
      if (num3 == 0 && num1 == 0)
      {
        let mut airCarryCapPts: i32 =  this.GetAirCarryCapPts(unr);
        let mut integer: i32 =  Conversions.ToInteger(Operators.SubtractObject(this.GetUnitNonSeaWeight(unr, true), this.GetUnitNonSeaWeight(unr, false)));
        if (integer > airCarryCapPts)
        {
          float loss =  (1.0 -  airCarryCapPts /  integer);
          num1 = this.DoLoseCargoAircraft(unr, loss, Attacker, Defender);
        }
      }
      return num1;
    }

    pub fn DoLoseCargo(unr: i32, float loss, Attacker: i32, Defender: i32) -> i32
    {
      num1: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        for (let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount; sfCount >= 0; sfCount += -1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[sfCount];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 0)
          {
            let mut num2: i32 =   Math.Round( Conversion.Int( this.game.Data.SFObj[sf].Qty * loss)) + 1;
            if (num2 > this.game.Data.SFObj[sf].Qty)
              num2 = this.game.Data.SFObj[sf].Qty;
            index1: i32;
            index2: i32;
            if (this.game.Data.UnitObj[unr].Regime == Attacker)
            {
              index1 = Attacker;
              index2 = Defender;
            }
            else
            {
              index1 = Defender;
              index2 = Attacker;
            }
            if (index2 < Attacker &  this.game.Data.RuleVar[841] == 0.0)
            {
              skills: Vec<i32> = this.game.Data.RegimeObj[index2].SKills;
              numArray: Vec<i32> = skills;
              let mut index3: i32 =  type;
              let mut index4: i32 =  index3;
              let mut index5: i32 =  this.game.Data.Round + 1;
              let mut index6: i32 =  index5;
              let mut num3: i32 =  skills[index3, index5] + num2;
              numArray[index4, index6] = num3;
            }
            else
            {
              skills: Vec<i32> = this.game.Data.RegimeObj[index2].SKills;
              numArray: Vec<i32> = skills;
              let mut index7: i32 =  type;
              let mut index8: i32 =  index7;
              let mut round: i32 =  this.game.Data.Round;
              let mut index9: i32 =  round;
              let mut num4: i32 =  skills[index7, round] + num2;
              numArray[index8, index9] = num4;
            }
            if (index1 < Attacker &  this.game.Data.RuleVar[841] == 0.0)
            {
              sloss: Vec<i32> = this.game.Data.RegimeObj[index1].SLoss;
              numArray: Vec<i32> = sloss;
              let mut index10: i32 =  type;
              let mut index11: i32 =  index10;
              let mut index12: i32 =  this.game.Data.Round + 1;
              let mut index13: i32 =  index12;
              let mut num5: i32 =  sloss[index10, index12] + num2;
              numArray[index11, index13] = num5;
            }
            else
            {
              sloss: Vec<i32> = this.game.Data.RegimeObj[index1].SLoss;
              numArray: Vec<i32> = sloss;
              let mut index14: i32 =  type;
              let mut index15: i32 =  index14;
              let mut round: i32 =  this.game.Data.Round;
              let mut index16: i32 =  round;
              let mut num6: i32 =  sloss[index14, round] + num2;
              numArray[index15, index16] = num6;
            }
            if (index1 == Attacker)
            {
              sloss: Vec<i32> = this.game.Data.RegimeObj[index1].SLoss;
              numArray: Vec<i32> = sloss;
              let mut index17: i32 =  type;
              let mut index18: i32 =  index17;
              let mut index19: i32 =  0;
              let mut index20: i32 =  index19;
              let mut num7: i32 =  sloss[index17, index19] + num2;
              numArray[index18, index20] = num7;
            }
            if (index2 == Attacker)
            {
              skills: Vec<i32> = this.game.Data.RegimeObj[index2].SKills;
              numArray: Vec<i32> = skills;
              let mut index21: i32 =  type;
              let mut index22: i32 =  index21;
              let mut index23: i32 =  0;
              let mut index24: i32 =  index23;
              let mut num8: i32 =  skills[index21, index23] + num2;
              numArray[index22, index24] = num8;
            }
            SFClass[] sfObj = this.game.Data.SFObj;
            SFClass[] sfClassArray = sfObj;
            let mut index25: i32 =  sf;
            let mut index26: i32 =  index25;
            sfClassArray[index26].Qty = sfObj[index25].Qty - num2;
            num1 += this.game.Data.SFObj[sf].Qty;
            if (this.game.Data.SFObj[sf].Qty < 1)
              this.game.Data.RemoveSF(sf);
          }
          else
            num1 += this.game.Data.SFObj[sf].Qty;
        }
      }
      let mut num9: i32 =   Math.Round( Conversion.Int( this.game.Data.UnitObj[unr].Supply * loss)) + 1;
      if (num9 > this.game.Data.UnitObj[unr].Supply)
        num9 = this.game.Data.UnitObj[unr].Supply;
      UnitClass[] unitObj = this.game.Data.UnitObj;
      UnitClass[] unitClassArray = unitObj;
      let mut index27: i32 =  unr;
      let mut index28: i32 =  index27;
      unitClassArray[index28].Supply = unitObj[index27].Supply - num9;
      return num1 < 1 ? 1 : 0;
    }

    pub fn DoLoseCargoAircraft(unr: i32, float loss, Attacker: i32, Defender: i32) -> i32
    {
      num1: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        for (let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount; sfCount >= 0; sfCount += -1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[sfCount];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2)
          {
            let mut num2: i32 =   Math.Round( Conversion.Int( this.game.Data.SFObj[sf].Qty * loss)) + 1;
            if (num2 > this.game.Data.SFObj[sf].Qty)
              num2 = this.game.Data.SFObj[sf].Qty;
            index1: i32;
            index2: i32;
            if (this.game.Data.UnitObj[unr].Regime == Attacker)
            {
              index1 = Attacker;
              index2 = Defender;
            }
            else
            {
              index1 = Defender;
              index2 = Attacker;
            }
            if (index2 < Attacker &  this.game.Data.RuleVar[841] == 0.0)
            {
              skills: Vec<i32> = this.game.Data.RegimeObj[index2].SKills;
              numArray: Vec<i32> = skills;
              let mut index3: i32 =  type;
              let mut index4: i32 =  index3;
              let mut index5: i32 =  this.game.Data.Round + 1;
              let mut index6: i32 =  index5;
              let mut num3: i32 =  skills[index3, index5] + num2;
              numArray[index4, index6] = num3;
            }
            else
            {
              skills: Vec<i32> = this.game.Data.RegimeObj[index2].SKills;
              numArray: Vec<i32> = skills;
              let mut index7: i32 =  type;
              let mut index8: i32 =  index7;
              let mut round: i32 =  this.game.Data.Round;
              let mut index9: i32 =  round;
              let mut num4: i32 =  skills[index7, round] + num2;
              numArray[index8, index9] = num4;
            }
            if (index1 < Attacker &  this.game.Data.RuleVar[841] == 0.0)
            {
              sloss: Vec<i32> = this.game.Data.RegimeObj[index1].SLoss;
              numArray: Vec<i32> = sloss;
              let mut index10: i32 =  type;
              let mut index11: i32 =  index10;
              let mut index12: i32 =  this.game.Data.Round + 1;
              let mut index13: i32 =  index12;
              let mut num5: i32 =  sloss[index10, index12] + num2;
              numArray[index11, index13] = num5;
            }
            else
            {
              sloss: Vec<i32> = this.game.Data.RegimeObj[index1].SLoss;
              numArray: Vec<i32> = sloss;
              let mut index14: i32 =  type;
              let mut index15: i32 =  index14;
              let mut round: i32 =  this.game.Data.Round;
              let mut index16: i32 =  round;
              let mut num6: i32 =  sloss[index14, round] + num2;
              numArray[index15, index16] = num6;
            }
            if (index1 == Attacker)
            {
              sloss: Vec<i32> = this.game.Data.RegimeObj[index1].SLoss;
              numArray: Vec<i32> = sloss;
              let mut index17: i32 =  type;
              let mut index18: i32 =  index17;
              let mut index19: i32 =  0;
              let mut index20: i32 =  index19;
              let mut num7: i32 =  sloss[index17, index19] + num2;
              numArray[index18, index20] = num7;
            }
            if (index2 == Attacker)
            {
              skills: Vec<i32> = this.game.Data.RegimeObj[index2].SKills;
              numArray: Vec<i32> = skills;
              let mut index21: i32 =  type;
              let mut index22: i32 =  index21;
              let mut index23: i32 =  0;
              let mut index24: i32 =  index23;
              let mut num8: i32 =  skills[index21, index23] + num2;
              numArray[index22, index24] = num8;
            }
            SFClass[] sfObj = this.game.Data.SFObj;
            SFClass[] sfClassArray = sfObj;
            let mut index25: i32 =  sf;
            let mut index26: i32 =  index25;
            sfClassArray[index26].Qty = sfObj[index25].Qty - num2;
            num1 += this.game.Data.SFObj[sf].Qty;
            if (this.game.Data.SFObj[sf].Qty < 1)
              this.game.Data.RemoveSF(sf);
          }
          else
            num1 += this.game.Data.SFObj[sf].Qty;
        }
      }
      return num1 < 1 ? 1 : 0;
    }

    pub fn ImportPreDefUnitsOnly(filename: String, bool HisToo = false)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      data: DataClass = this.game.Data;
      if (HisToo)
      {
        if (dataClass2.HistoricalUnitCounter > -1)
        {
          data.HistoricalUnitObj = new HistoricalUnitClass[dataClass2.HistoricalUnitCounter + 1];
          data.HistoricalUnitCounter = dataClass2.HistoricalUnitCounter;
          let mut historicalUnitCounter: i32 =  dataClass2.HistoricalUnitCounter;
          for (let mut index: i32 =  0; index <= historicalUnitCounter; index += 1)
            data.HistoricalUnitObj[index] = dataClass2.HistoricalUnitObj[index];
        }
        else
        {
          data.HistoricalUnitObj = new HistoricalUnitClass[1];
          data.HistoricalUnitCounter = -1;
        }
      }
      if (dataClass2.UnitCounter > -1)
      {
        let mut unitCounter1: i32 =  dataClass2.UnitCounter;
        for (let mut index1: i32 =  0; index1 <= unitCounter1; index1 += 1)
        {
          if (dataClass2.UnitObj[index1].PreDef > -1)
          {
            let mut num: i32 =  -1;
            let mut unitCounter2: i32 =  data.UnitCounter;
            for (let mut index2: i32 =  0; index2 <= unitCounter2; index2 += 1)
            {
              if (data.UnitObj[index2].PreDef == dataClass2.UnitObj[index1].PreDef)
                num = index2;
            }
            unr: i32;
            if (num == -1)
            {
              data += 1.UnitCounter;
              data.UnitObj = (UnitClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.UnitObj, (Array) new UnitClass[data.UnitCounter + 1]);
              unr = data.UnitCounter;
              data.UnitObj[unr] = new UnitClass(0);
            }
            else
              unr = num;
            for (let mut sfCount: i32 =  data.UnitObj[unr].SFCount; sfCount >= 0; sfCount += -1)
              data.UnitObj[unr].RemoveSF(data.UnitObj[unr].SFList[sfCount]);
            data.UnitObj[unr].Name = dataClass2.UnitObj[index1].Name;
            data.UnitObj[unr].SODefendPercent = dataClass2.UnitObj[index1].SODefendPercent;
            data.UnitObj[unr].SOInterceptRdnStop = dataClass2.UnitObj[index1].SOInterceptRdnStop;
            data.UnitObj[unr].SOSupReqPercent = dataClass2.UnitObj[index1].SOSupReqPercent;
            data.UnitObj[unr].SOReplacementPercent = dataClass2.UnitObj[index1].SOReplacementPercent;
            data.UnitObj[unr].Supply = dataClass2.UnitObj[index1].Supply;
            data.UnitObj[unr].IsHQ = dataClass2.UnitObj[index1].IsHQ;
            data.UnitObj[unr].PreDef = dataClass2.UnitObj[index1].PreDef;
            data.UnitObj[unr].HQ = -1;
            if (dataClass2.UnitObj[index1].SFCount > -1)
            {
              let mut sfCount: i32 =  dataClass2.UnitObj[index1].SFCount;
              for (let mut index3: i32 =  0; index3 <= sfCount; index3 += 1)
              {
                let mut sf: i32 =  dataClass2.UnitObj[index1].SFList[index3];
                SFClass sfClass = dataClass2.SFObj[sf];
                this.game.HandyFunctionsObj.AddTroops3(unr, sfClass.Type, sfClass.People, sfClass.Qty, sfClass.Xp, sfClass.Rdn, sfClass.Ap, sfClass.Mor, entr: sfClass.CurrentEntrench, MoveType: sfClass.MoveType);
              }
            }
          }
        }
      }
      this.ZipFile(str);
      dataClass1 = (DataClass) null;
    }

    pub void LoadMasterFile(
      filename: String,
      bool onlyrulevar = false,
      bool alsohistorical = true,
      bool LoadDescription = false,
      bool LoadGameVars = false,
      bool LoadVariants = true)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray1 = new bool[100];
      int[] numArray2 = new int[100];
      str: String = filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      bool masterfileReadPeople = this.game.Data.MasterfileReadPeople;
      if (this.game.Data.PeopleCounter < 0)
        this.game.Data.MasterfileReadPeople = true;
      data: DataClass = this.game.Data;
      if (!onlyrulevar)
      {
        data.BridgeObj[0] = dataClass.BridgeObj[0];
        if (dataClass.RoadTypeCounter > data.RoadTypeCounter)
        {
          data.RoadTypeCounter = dataClass.RoadTypeCounter;
          data.RoadTypeObj = (RoadTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.RoadTypeObj, (Array) new RoadTypeClass[dataClass.RoadTypeCounter + 1]);
        }
        if (dataClass.ReinfCounter > data.ReinfCounter)
        {
          data.ReinfCounter = dataClass.ReinfCounter;
          data.ReinfName = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ReinfName, (Array) new string[data.ReinfCounter + 1]);
          data.ReinfId = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ReinfId, (Array) new int[data.ReinfCounter + 1]);
          data.ReinfLibId = (LibIdClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ReinfLibId, (Array) new LibIdClass[data.ReinfCounter + 1]);
          data.ReinfRatio = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ReinfRatio, (Array) new int[data.ReinfCounter + 1]);
          let mut reinfCounter: i32 =  dataClass.ReinfCounter;
          for (let mut index: i32 =  0; index <= reinfCounter; index += 1)
          {
            data.ReinfName[index] = dataClass.ReinfName[index];
            data.ReinfId[index] = dataClass.ReinfId[index];
            data.ReinfLibId[index] = dataClass.ReinfLibId[index];
            data.ReinfRatio[index] = dataClass.ReinfRatio[index];
          }
        }
        if (dataClass.reinfIdCounter > data.reinfIdCounter)
          data.reinfIdCounter = dataClass.reinfIdCounter;
        if (dataClass.RoadTypeCounter > -1)
        {
          let mut roadTypeCounter: i32 =  dataClass.RoadTypeCounter;
          for (let mut index: i32 =  0; index <= roadTypeCounter; index += 1)
            data.RoadTypeObj[index] = dataClass.RoadTypeObj[index];
        }
        if (dataClass.RiverTypeCounter > data.RiverTypeCounter)
        {
          data.RiverTypeCounter = dataClass.RiverTypeCounter;
          data.RiverTypeObj = (RiverTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.RiverTypeObj, (Array) new RiverTypeClass[dataClass.RiverTypeCounter + 1]);
        }
        if (dataClass.RiverTypeCounter > -1)
        {
          let mut riverTypeCounter: i32 =  dataClass.RiverTypeCounter;
          for (let mut index: i32 =  0; index <= riverTypeCounter; index += 1)
            data.RiverTypeObj[index] = dataClass.RiverTypeObj[index];
        }
        num1: i32;
        if (dataClass.LocTypeCounter > data.LocTypeCounter)
        {
          num1 = data.LocTypeCounter;
          data.LocTypeCounter = dataClass.LocTypeCounter;
          data.LocTypeObj = (LocationTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LocTypeObj, (Array) new LocationTypeClass[dataClass.LocTypeCounter + 1]);
        }
        if (dataClass.LocTypeCounter > -1)
        {
          let mut locTypeCounter: i32 =  dataClass.LocTypeCounter;
          for (let mut index1: i32 =  0; index1 <= locTypeCounter; index1 += 1)
          {
            if (index1 <= num1 && !data.MasterfileReadPeople)
            {
              let mut index2: i32 =  0;
              do
              {
                flagArray1[index2] = data.LocTypeObj[index1].PeopleGroup[index2];
                index2 += 1;
              }
              while (index2 <= 99);
            }
            data.LocTypeObj[index1] = dataClass.LocTypeObj[index1];
            if (index1 <= num1 && !data.MasterfileReadPeople)
            {
              let mut index3: i32 =  0;
              do
              {
                data.LocTypeObj[index1].PeopleGroup[index3] = flagArray1[index3];
                index3 += 1;
              }
              while (index3 <= 99);
            }
          }
        }
        if (dataClass.SFTypeCounter > data.SFTypeCounter)
        {
          num1 = data.SFTypeCounter;
          data.SFTypeCounter = dataClass.SFTypeCounter;
          data.SFTypeObj = (SFTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SFTypeObj, (Array) new SFTypeClass[dataClass.SFTypeCounter + 1]);
        }
        if (dataClass.SFTypeCounter > -1)
        {
          let mut sfTypeCounter: i32 =  dataClass.SFTypeCounter;
          for (let mut index4: i32 =  0; index4 <= sfTypeCounter; index4 += 1)
          {
            if (index4 <= num1 && !data.MasterfileReadPeople)
            {
              let mut index5: i32 =  0;
              do
              {
                flagArray1[index5] = data.SFTypeObj[index4].PeopleGroup[index5];
                index5 += 1;
              }
              while (index5 <= 99);
            }
            data.SFTypeObj[index4] = dataClass.SFTypeObj[index4];
            if (index4 <= num1 && !data.MasterfileReadPeople)
            {
              let mut index6: i32 =  0;
              do
              {
                data.SFTypeObj[index4].PeopleGroup[index6] = flagArray1[index6];
                index6 += 1;
              }
              while (index6 <= 99);
            }
          }
        }
        if (data.MasterfileReadPeople)
        {
          if (dataClass.PeopleCounter > data.PeopleCounter)
          {
            data.PeopleCounter = dataClass.PeopleCounter;
            data.PeopleObj = new PeopleClass[data.PeopleCounter + 1];
          }
          if (dataClass.PeopleCounter > -1)
          {
            let mut peopleCounter: i32 =  dataClass.PeopleCounter;
            for (let mut index: i32 =  0; index <= peopleCounter; index += 1)
              data.PeopleObj[index] = dataClass.PeopleObj[index];
          }
        }
        if (dataClass.ItemTypeCounter > data.ItemTypeCounter)
        {
          num1 = data.ItemTypeCounter;
          data.ItemTypeCounter = dataClass.ItemTypeCounter;
          data.ItemTypeObj = (ItemTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ItemTypeObj, (Array) new ItemTypeClass[dataClass.ItemTypeCounter + 1]);
        }
        if (dataClass.ItemTypeCounter > -1)
        {
          let mut itemTypeCounter: i32 =  dataClass.ItemTypeCounter;
          for (let mut index7: i32 =  0; index7 <= itemTypeCounter; index7 += 1)
          {
            if (index7 <= num1 && !data.MasterfileReadPeople)
            {
              let mut index8: i32 =  0;
              do
              {
                flagArray1[index8] = data.ItemTypeObj[index7].PeopleGroup[index8];
                index8 += 1;
              }
              while (index8 <= 99);
            }
            data.ItemTypeObj[index7] = dataClass.ItemTypeObj[index7];
            if (index7 <= num1 && !data.MasterfileReadPeople)
            {
              let mut index9: i32 =  0;
              do
              {
                data.ItemTypeObj[index7].PeopleGroup[index9] = flagArray1[index9];
                index9 += 1;
              }
              while (index9 <= 99);
            }
          }
        }
        if (dataClass.LandscapeTypeCounter > data.LandscapeTypeCounter)
        {
          data.LandscapeTypeCounter = dataClass.LandscapeTypeCounter;
          data.LandscapeTypeObj = (LandscapeTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LandscapeTypeObj, (Array) new LandscapeTypeClass[dataClass.LandscapeTypeCounter + 1]);
        }
        if (dataClass.LandscapeTypeCounter > -1)
        {
          let mut landscapeTypeCounter: i32 =  dataClass.LandscapeTypeCounter;
          for (let mut index: i32 =  0; index <= landscapeTypeCounter; index += 1)
            data.LandscapeTypeObj[index] = dataClass.LandscapeTypeObj[index];
        }
        let mut sfTypeCounter1: i32 =  data.SFTypeCounter;
        for (let mut index: i32 =  0; index <= sfTypeCounter1; index += 1)
        {
          data.SFTypeObj[index].CombatModAtt = (float[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SFTypeObj[index].CombatModAtt, (Array) new float[data.LandscapeTypeCounter + 1]);
          data.SFTypeObj[index].CombatModDef = (float[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SFTypeObj[index].CombatModDef, (Array) new float[data.LandscapeTypeCounter + 1]);
          data.SFTypeObj[index].ExtraRecon = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SFTypeObj[index].ExtraRecon, (Array) new int[data.LandscapeTypeCounter + 1]);
        }
        let mut landscapeTypeCounter1: i32 =  data.LandscapeTypeCounter;
        for (let mut index: i32 =  0; index <= landscapeTypeCounter1; index += 1)
          data.LandscapeTypeObj[index].OverIsTop = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LandscapeTypeObj[index].OverIsTop, (Array) new bool[data.LandscapeTypeObj[index].BasicSpriteCounter + 1]);
        let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
        for (let mut index10: i32 =  0; index10 <= mapWidth; index10 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
          for (let mut index11: i32 =  0; index11 <= mapHeight; index11 += 1)
          {
            let mut index12: i32 =  this.game.Data.MapObj[0].HexObj[index10, index11].LandscapeType;
            let mut num2: i32 =  this.game.Data.MapObj[0].HexObj[index10, index11].SpriteNr;
            if (index12 > data.LandscapeTypeCounter)
              index12 = data.LandscapeTypeCounter;
            if (num2 > data.LandscapeTypeObj[index12].BasicSpriteCounter)
              num2 = data.LandscapeTypeObj[index12].BasicSpriteCounter;
            this.game.Data.MapObj[0].HexObj[index10, index11].LandscapeType = index12;
            this.game.Data.MapObj[0].HexObj[index10, index11].SpriteNr = num2;
          }
        }
        if (dataClass.ResearchCounter > data.ResearchCounter)
        {
          num1 = data.ResearchCounter;
          data.ResearchCounter = dataClass.ResearchCounter;
          data.ResearchObj = (ResearchClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ResearchObj, (Array) new ResearchClass[dataClass.ResearchCounter + 1]);
        }
        if (dataClass.ResearchCounter > -1)
        {
          let mut researchCounter: i32 =  dataClass.ResearchCounter;
          for (let mut index13: i32 =  0; index13 <= researchCounter; index13 += 1)
          {
            if (!data.MasterfileReadPeople && index13 <= num1)
            {
              let mut index14: i32 =  0;
              do
              {
                numArray2[index14] = data.ResearchObj[index13].PointCost[index14];
                index14 += 1;
              }
              while (index14 <= 99);
            }
            data.ResearchObj[index13] = dataClass.ResearchObj[index13];
            if (!data.MasterfileReadPeople && index13 <= num1)
            {
              let mut index15: i32 =  0;
              do
              {
                data.ResearchObj[index13].PointCost[index15] = numArray2[index15];
                index15 += 1;
              }
              while (index15 <= 99);
            }
          }
        }
        data.StringCounter = dataClass.StringCounter;
        data.TempString = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.TempString, (Array) new string[data.StringCounter + 1]);
        let mut stringCounter: i32 =  data.StringCounter;
        for (let mut index: i32 =  0; index <= stringCounter; index += 1)
        {
          if (index > -1 & index < 200 | index > 299)
            data.TempString[index] = dataClass.TempString[index];
          else if (data.MasterfileReadPeople)
            data.TempString[index] = dataClass.TempString[index];
        }
        if (dataClass.EventCounter > data.EventCounter)
        {
          data.EventCounter = dataClass.EventCounter;
          data.EventObj = (EventClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.EventObj, (Array) new EventClass[data.EventCounter + 1]);
        }
        if (dataClass.EventCounter > -1)
        {
          let mut eventCounter: i32 =  dataClass.EventCounter;
          for (let mut index: i32 =  0; index <= eventCounter; index += 1)
          {
            if (Information.IsNothing( data.EventObj[index]))
              data.EventObj[index] = dataClass.EventObj[index];
            else if (!(data.EventObj[index].CommandCounter > -1 & dataClass.EventObj[index].CommandCounter == -1))
              data.EventObj[index] = dataClass.EventObj[index];
          }
        }
        if (dataClass.ActionCardCounter > data.ActionCardCounter)
        {
          data.ActionCardCounter = dataClass.ActionCardCounter;
          data.ActionCardObj = (ActionCardClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ActionCardObj, (Array) new ActionCardClass[data.ActionCardCounter + 1]);
        }
        if (dataClass.ActionCardCounter > -1)
        {
          let mut actionCardCounter: i32 =  dataClass.ActionCardCounter;
          for (let mut index: i32 =  0; index <= actionCardCounter; index += 1)
            data.ActionCardObj[index] = dataClass.ActionCardObj[index];
        }
        if (alsohistorical)
        {
          object[] objArray = new object[data.UnitCounter + 1];
          let mut unitCounter1: i32 =  data.UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter1; index += 1)
            objArray[index] = data.UnitObj[index].Historical <= -1 ?  -1 :  data.HistoricalUnitObj[data.UnitObj[index].Historical].ID;
          if (dataClass.HistoricalUnitCounter > data.HistoricalUnitCounter)
          {
            data.HistoricalUnitCounter = dataClass.HistoricalUnitCounter;
            data.HistoricalUnitObj = (HistoricalUnitClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.HistoricalUnitObj, (Array) new HistoricalUnitClass[dataClass.HistoricalUnitCounter + 1]);
          }
          if (dataClass.HistoricalUnitCounter > -1)
          {
            let mut historicalUnitCounter: i32 =  dataClass.HistoricalUnitCounter;
            for (let mut index: i32 =  0; index <= historicalUnitCounter; index += 1)
              data.HistoricalUnitObj[index] = dataClass.HistoricalUnitObj[index];
          }
          let mut unitCounter2: i32 =  data.UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter2; index += 1)
          {
            if (Operators.ConditionalCompareObjectGreater(objArray[index],  -1, false))
              data.UnitObj[index].Historical = this.GetHistoricalUnitByID(Conversions.ToInteger(objArray[index]));
          }
        }
        if (dataClass.EventPicCounter > data.EventPicCounter)
        {
          data.EventPicCounter = dataClass.EventPicCounter;
          data.EventPicName = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.EventPicName, (Array) new string[data.EventPicCounter + 1]);
          data.eventPicLibId = (LibIdClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.eventPicLibId, (Array) new LibIdClass[data.EventPicCounter + 1]);
          data.EventPicNr = new int[data.EventPicCounter + 1];
        }
        if (dataClass.EventPicCounter > -1)
        {
          let mut eventPicCounter: i32 =  dataClass.EventPicCounter;
          for (let mut index: i32 =  0; index <= eventPicCounter; index += 1)
          {
            data.eventPicLibId[index] = LibIdClass::new();
            if (Strings.Len(dataClass.EventPicName[index]) > 0 & Strings.InStr(dataClass.EventPicName[index], "empty.bmp") <= 0)
              data.EventPicName[index] = dataClass.EventPicName[index];
            else if (Information.IsNothing( data.EventPicName[index]))
              data.EventPicName[index] = dataClass.EventPicName[index];
          }
        }
        if (dataClass.SmallPicCounter > data.SmallPicCounter)
        {
          data.SmallPicCounter = dataClass.SmallPicCounter;
          data.SmallPicName = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SmallPicName, (Array) new string[data.SmallPicCounter + 1]);
          data.SmallLibId = (LibIdClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SmallLibId, (Array) new LibIdClass[data.SmallPicCounter + 1]);
          data.SmallPicNr = new int[data.SmallPicCounter + 1];
        }
        if (dataClass.SmallPicCounter > -1)
        {
          let mut smallPicCounter: i32 =  dataClass.SmallPicCounter;
          for (let mut index: i32 =  0; index <= smallPicCounter; index += 1)
          {
            data.SmallLibId[index] = LibIdClass::new();
            data.SmallPicName[index] = dataClass.SmallPicName[index];
          }
        }
        if (dataClass.StringListCounter > data.StringListCounter)
        {
          data.StringListCounter = dataClass.StringListCounter;
          data.StringListObj = (StringListClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.StringListObj, (Array) new StringListClass[data.StringListCounter + 1]);
        }
        if (dataClass.StringListCounter > -1)
        {
          let mut stringListCounter: i32 =  dataClass.StringListCounter;
          for (let mut index: i32 =  0; index <= stringListCounter; index += 1)
            data.StringListObj[index] = dataClass.StringListObj[index];
        }
        if (dataClass.StringIDCounter > data.StringIDCounter)
          data.StringIDCounter = dataClass.StringIDCounter;
        let mut index16: i32 =  0;
        do
        {
          if (Strings.Len(dataClass.GameSlotName[index16]) > 0 & Operators.CompareString(dataClass.GameSlotName[index16], "Empty", false) != 0 & LoadGameVars)
          {
            data.GameSlotName[index16] = dataClass.GameSlotName[index16];
            data.GameSlotShow[index16] = dataClass.GameSlotShow[index16];
            data.GameSlotNato[index16] = dataClass.GameSlotNato[index16];
            data.GameSlotSmallGfx[index16] = dataClass.GameSlotSmallGfx[index16];
            data.GameSlotShow2[index16] = dataClass.GameSlotShow2[index16];
            if (LoadGameVars & index16 < 400)
              data.GameSlot[index16] = dataClass.GameSlot[index16];
          }
          index16 += 1;
        }
        while (index16 <= 499);
        let mut index17: i32 =  0;
        do
        {
          if (Strings.Len(dataClass.RegimeSlotName[index17]) > 0 & Operators.CompareString(dataClass.RegimeSlotName[index17], "Empty", false) != 0 & LoadGameVars)
          {
            data.RegimeSlotName[index17] = dataClass.RegimeSlotName[index17];
            data.RegimeSlotShow[index17] = dataClass.RegimeSlotShow[index17];
            data.RegimeSlotNato[index17] = dataClass.RegimeSlotNato[index17];
            data.RegimeSlotSmallGfx[index17] = dataClass.RegimeSlotSmallGfx[index17];
          }
          index17 += 1;
        }
        while (index17 <= 499);
        if (LoadVariants)
        {
          let mut index18: i32 =  0;
          do
          {
            if (dataClass.Variants[index18] > -1)
            {
              data.Variants[index18] = dataClass.Variants[index18];
              data.VariantEvent[index18] = dataClass.VariantEvent[index18];
            }
            index18 += 1;
          }
          while (index18 <= 11);
        }
        if (dataClass.UnitCounter > -1)
        {
          let mut unitCounter3: i32 =  dataClass.UnitCounter;
          for (let mut index19: i32 =  0; index19 <= unitCounter3; index19 += 1)
          {
            if (dataClass.UnitObj[index19].PreDef > -1)
            {
              let mut num3: i32 =  -1;
              let mut unitCounter4: i32 =  data.UnitCounter;
              for (let mut index20: i32 =  0; index20 <= unitCounter4; index20 += 1)
              {
                if (data.UnitObj[index20].PreDef == dataClass.UnitObj[index19].PreDef)
                  num3 = index20;
              }
              unr: i32;
              if (num3 == -1)
              {
                data += 1.UnitCounter;
                data.UnitObj = (UnitClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.UnitObj, (Array) new UnitClass[data.UnitCounter + 1]);
                unr = data.UnitCounter;
                data.UnitObj[unr] = new UnitClass(0);
              }
              else
                unr = num3;
              for (let mut sfCount: i32 =  data.UnitObj[unr].SFCount; sfCount >= 0; sfCount += -1)
                data.UnitObj[unr].RemoveSF(data.UnitObj[unr].SFList[sfCount]);
              data.UnitObj[unr].Name = dataClass.UnitObj[index19].Name;
              data.UnitObj[unr].SODefendPercent = dataClass.UnitObj[index19].SODefendPercent;
              data.UnitObj[unr].SOInterceptRdnStop = dataClass.UnitObj[index19].SOInterceptRdnStop;
              data.UnitObj[unr].SOSupReqPercent = dataClass.UnitObj[index19].SOSupReqPercent;
              data.UnitObj[unr].SOReplacementPercent = dataClass.UnitObj[index19].SOReplacementPercent;
              data.UnitObj[unr].Supply = dataClass.UnitObj[index19].Supply;
              data.UnitObj[unr].IsHQ = dataClass.UnitObj[index19].IsHQ;
              data.UnitObj[unr].PreDef = dataClass.UnitObj[index19].PreDef;
              data.UnitObj[unr].HQ = -1;
              if (dataClass.UnitObj[index19].SFCount > -1)
              {
                let mut sfCount: i32 =  dataClass.UnitObj[index19].SFCount;
                for (let mut index21: i32 =  0; index21 <= sfCount; index21 += 1)
                {
                  let mut sf: i32 =  dataClass.UnitObj[index19].SFList[index21];
                  SFClass sfClass = dataClass.SFObj[sf];
                  this.game.HandyFunctionsObj.AddTroops3(unr, sfClass.Type, sfClass.People, sfClass.Qty, sfClass.Xp, sfClass.Rdn, sfClass.Ap, sfClass.Mor, entr: sfClass.CurrentEntrench, MoveType: sfClass.MoveType);
                }
              }
            }
          }
        }
      }
      bool[] flagArray2 = new bool[this.game.Data.SFCounter + 1];
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index22: i32 =  0; index22 <= unitCounter; index22 += 1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[index22].SFCount;
        for (let mut index23: i32 =  0; index23 <= sfCount; index23 += 1)
          flagArray2[this.game.Data.UnitObj[index22].SFList[index23]] = true;
      }
      for (let mut sfCounter: i32 =  this.game.Data.SFCounter; sfCounter >= 0; sfCounter += -1)
      {
        if (!flagArray2[sfCounter])
          this.game.Data.RemoveSF(sfCounter);
        if (sfCounter % 30 == 0)
          Application.DoEvents();
      }
      data.RuleCounter = dataClass.RuleCounter;
      data.RuleString = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.RuleString, (Array) new string[data.RuleCounter + 1]);
      data.RuleGroup = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.RuleGroup, (Array) new int[data.RuleCounter + 1]);
      data.RuleVar = (float[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.RuleVar, (Array) new float[data.RuleCounter + 1]);
      let mut ruleCounter: i32 =  data.RuleCounter;
      for (let mut index: i32 =  0; index <= ruleCounter; index += 1)
        data.RuleVar[index] = dataClass.RuleVar[index];
      if (dataClass.NoAIAdvice)
        data.NoAIAdvice = true;
      data.UseAI = dataClass.UseAI;
      data.SystemGfx = dataClass.SystemGfx;
      data.ScenarioDir = dataClass.ScenarioDir;
      data.SoundDir = dataClass.SoundDir;
      data.Product = dataClass.Product;
      data.RuleSetName = dataClass.RuleSetName;
      if (LoadDescription)
        data.Description = dataClass.Description;
      data.scenarioVersionMaster = dataClass.scenarioVersion;
      this.game.Data.MasterfileReadPeople = masterfileReadPeople;
      this.game.Data.SetEventNames();
      this.game.Data.SetDefaultRules(true);
      GC.Collect();
      Application.DoEvents();
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index: i32 =  0; index <= regimeCounter; index += 1)
      {
        if (this.game.Data.ResearchCounter > this.game.Data.RegimeObj[index].ResFieldCounter)
        {
          this.game.Data.RegimeObj[index].ResFieldCounter = this.game.Data.ResearchCounter;
          this.game.Data.RegimeObj[index].ResField = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].ResField, (Array) new bool[this.game.Data.RegimeObj[index].ResFieldCounter + 1]);
        }
      }
      let mut locCounter: i32 =  this.game.Data.LocCounter;
      for (let mut index: i32 =  0; index <= locCounter; index += 1)
      {
        if (this.game.Data.LocObj[index].StructuralPts > this.game.Data.LocTypeObj[this.game.Data.LocObj[index].Type].StructuralPts)
          this.game.Data.LocObj[index].StructuralPts = this.game.Data.LocTypeObj[this.game.Data.LocObj[index].Type].StructuralPts;
      }
    }

    pub fn LoadHistoricalUnits(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data: DataClass = this.game.Data;
      object[] objArray = new object[data.UnitCounter + 1];
      let mut unitCounter1: i32 =  data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter1; index += 1)
        objArray[index] = data.UnitObj[index].Historical <= -1 ?  -1 :  data.HistoricalUnitObj[data.UnitObj[index].Historical].ID;
      if (dataClass2.HistoricalUnitCounter > data.HistoricalUnitCounter)
      {
        data.HistoricalUnitCounter = dataClass2.HistoricalUnitCounter;
        data.HistoricalUnitObj = (HistoricalUnitClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.HistoricalUnitObj, (Array) new HistoricalUnitClass[dataClass2.HistoricalUnitCounter + 1]);
      }
      if (dataClass2.HistoricalUnitCounter > -1)
      {
        let mut historicalUnitCounter: i32 =  dataClass2.HistoricalUnitCounter;
        for (let mut index: i32 =  0; index <= historicalUnitCounter; index += 1)
          data.HistoricalUnitObj[index] = dataClass2.HistoricalUnitObj[index];
      }
      let mut unitCounter2: i32 =  data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter2; index += 1)
      {
        if (Operators.ConditionalCompareObjectGreater(objArray[index],  -1, false))
          data.UnitObj[index].Historical = this.GetHistoricalUnitByID(Conversions.ToInteger(objArray[index]));
      }
      dataClass1 = (DataClass) null;
    }

    pub fn LoadUnitsByFullOverwrite(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      for (let mut unitCounter: i32 =  this.game.Data.UnitCounter; unitCounter >= 0; unitCounter += -1)
      {
        data: DataClass = this.game.Data;
        let mut nr: i32 =  unitCounter;
        let mut gameClass: GameClass = (GameClass) null;
         let mut local: GameClass =  gameClass;
        data.RemoveUnit(nr,  local);
      }
      for (let mut sfCounter: i32 =  this.game.Data.SFCounter; sfCounter >= 0; sfCounter += -1)
        this.game.Data.RemoveSF(sfCounter);
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data1: DataClass = this.game.Data;
      data1.UnitCounter = dataClass2.UnitCounter;
      data1.UnitObj = new UnitClass[dataClass2.UnitCounter + 1];
      let mut unitCounter1: i32 =  data1.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter1; index += 1)
        data1.UnitObj[index] = dataClass2.UnitObj[index];
      data1.SFCounter = dataClass2.SFCounter;
      data1.SFObj = new SFClass[dataClass2.SFCounter + 1];
      let mut sfCounter1: i32 =  data1.SFCounter;
      for (let mut index: i32 =  0; index <= sfCounter1; index += 1)
        data1.SFObj[index] = dataClass2.SFObj[index];
      for (let mut unitCounter2: i32 =  this.game.Data.UnitCounter; unitCounter2 >= 0; unitCounter2 += -1)
      {
        if (this.game.Data.UnitObj[unitCounter2].PreDef == -1 & this.game.Data.UnitObj[unitCounter2].X > -1)
        {
          if (this.game.Data.UnitObj[unitCounter2].X <= this.game.Data.MapObj[0].MapWidth & this.game.Data.UnitObj[unitCounter2].Y <= this.game.Data.MapObj[0].MapHeight)
            this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unitCounter2].X, this.game.Data.UnitObj[unitCounter2].Y].AddUnitToList(unitCounter2);
          else if (this.game.Data.UnitObj[unitCounter2].PreDef == -1)
          {
            data2: DataClass = this.game.Data;
            let mut nr: i32 =  unitCounter2;
            let mut gameClass: GameClass = (GameClass) null;
             let mut local: GameClass =  gameClass;
            data2.RemoveUnit(nr,  local);
          }
        }
      }
      dataClass1 = (DataClass) null;
    }

    pub Coordinate GetAverageHQCoordinate(useHQ: i32)
    {
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      num3: i32;
      for (let mut unr: i32 =  0; unr <= unitCounter1; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].HQ == useHQ | unr == useHQ && !this.game.Data.UnitObj[unr].IsHQ & this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 && this.CanWeSeeUnit(unr, this.game.Data.Turn) > 0)
        {
          let mut x1: i32 =  this.game.Data.UnitObj[unr].X;
          let mut y1: i32 =  this.game.Data.UnitObj[unr].Y;
          num1 += 1;
          num2 += x1;
          num3 += y1;
          if (unr == useHQ)
          {
            let mut num4: i32 =  0;
            do
            {
              let mut x2: i32 =  this.game.Data.UnitObj[unr].X;
              let mut y2: i32 =  this.game.Data.UnitObj[unr].Y;
              num1 += 1;
              num2 += x2;
              num3 += y2;
              num4 += 1;
            }
            while (num4 <= 4);
          }
        }
      }
      Coordinate averageHqCoordinate = Coordinate::new();
      averageHqCoordinate.onmap = false;
      if (num1 == 0)
        return averageHqCoordinate;
      if (num1 > 0 & this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[useHQ].Historical].Type <= 5)
      {
        averageHqCoordinate.onmap = true;
        averageHqCoordinate.x =  Math.Round( num2 /  num1);
        averageHqCoordinate.y =  Math.Round( num3 /  num1);
      }
      else if (this.CanWeSeeUnit(useHQ, this.game.Data.Turn) > 0)
      {
        averageHqCoordinate.x = this.game.Data.UnitObj[useHQ].X;
        averageHqCoordinate.y = this.game.Data.UnitObj[useHQ].Y;
        averageHqCoordinate.onmap = true;
      }
      if (averageHqCoordinate.onmap && this.GetRegime(this.game.Data.MapObj[0].HexObj[averageHqCoordinate.x, averageHqCoordinate.y].Regime) != this.GetRegime(this.game.Data.Turn))
      {
        averageHqCoordinate.onmap = false;
        let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
        for (let mut unr: i32 =  0; unr <= unitCounter2; unr += 1)
        {
          if (this.game.Data.UnitObj[unr].HQ == useHQ | unr == useHQ && !this.game.Data.UnitObj[unr].IsHQ & this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 && this.CanWeSeeUnit(unr, this.game.Data.Turn) > 0)
          {
            averageHqCoordinate.onmap = true;
            averageHqCoordinate.x = this.game.Data.UnitObj[unr].X;
            averageHqCoordinate.y = this.game.Data.UnitObj[unr].Y;
            break;
          }
        }
      }
      return averageHqCoordinate;
    }

    pub fn LoadSFTypes(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data: DataClass = this.game.Data;
      if (Interaction.MsgBox( "Overwrite existing SFTypes?", MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.Yes)
      {
        if (Interaction.MsgBox( "Only overwrite graphics sheet data? ", MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.Yes)
        {
          if (dataClass2.SFTypeCounter > data.SFTypeCounter)
          {
            data.SFTypeCounter = dataClass2.SFTypeCounter;
            data.SFTypeObj = (SFTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SFTypeObj, (Array) new SFTypeClass[dataClass2.SFTypeCounter + 1]);
          }
          if (dataClass2.SFTypeCounter > -1)
          {
            let mut sfTypeCounter: i32 =  dataClass2.SFTypeCounter;
            for (let mut index1: i32 =  0; index1 <= sfTypeCounter; index1 += 1)
            {
              SFTypeClass sfTypeClass = dataClass2.SFTypeObj[index1];
              let mut index2: i32 =  index1;
              data.SFTypeObj[index2].ExtraCounter = sfTypeClass.ExtraCounter;
              data.SFTypeObj[index2].BaseColor = sfTypeClass.BaseColor;
              data.SFTypeObj[index2].SymbolGroup = sfTypeClass.SymbolGroup;
              data.SFTypeObj[index2].SymbolWeight = sfTypeClass.SymbolWeight;
              data.SFTypeObj[index2].SymbolOverrule = sfTypeClass.SymbolOverrule;
              data.SFTypeObj[index2].ExtraCode = (int[]) sfTypeClass.ExtraCode.Clone();
              data.SFTypeObj[index2].ExtraName = (string[]) sfTypeClass.ExtraName.Clone();
              data.SFTypeObj[index2].ExtraPicFileName = (string[]) sfTypeClass.ExtraPicFileName.Clone();
              data.SFTypeObj[index2].ExtraSidewaysFileName = (string[]) sfTypeClass.ExtraSidewaysFileName.Clone();
              data.SFTypeObj[index2].ExtraSymbolColBigFileName = (string[]) sfTypeClass.ExtraSymbolColBigFileName.Clone();
              data.SFTypeObj[index2].ExtraSymbolColBigFileName2 = (string[]) sfTypeClass.ExtraSymbolColBigFileName2.Clone();
              data.SFTypeObj[index2].ExtraSymbolFileName = (string[]) sfTypeClass.ExtraSymbolFileName.Clone();
              data.SFTypeObj[index2].ExtraSymbolFileName2 = (string[]) sfTypeClass.ExtraSymbolFileName2.Clone();
              data.SFTypeObj[index2].ExtraPicSpriteID = (int[]) sfTypeClass.ExtraPicSpriteID.Clone();
              data.SFTypeObj[index2].ExtraSidewaysSpriteID = (int[]) sfTypeClass.ExtraSidewaysSpriteID.Clone();
              data.SFTypeObj[index2].ExtraSymbolColBigSprite2ID = (int[]) sfTypeClass.ExtraSymbolColBigSprite2ID.Clone();
              data.SFTypeObj[index2].ExtraSymbolColBigSpriteID = (int[]) sfTypeClass.ExtraSymbolColBigSpriteID.Clone();
              data.SFTypeObj[index2].ExtraSymbolSprite2ID = (int[]) sfTypeClass.ExtraSymbolSprite2ID.Clone();
              data.SFTypeObj[index2].ExtraSymbolSpriteID = (int[]) sfTypeClass.ExtraSymbolSpriteID.Clone();
              data.SFTypeObj[index2].PicFileName = sfTypeClass.PicFileName;
              data.SFTypeObj[index2].SidewaysFileName = sfTypeClass.SidewaysFileName;
              data.SFTypeObj[index2].SymbolColBigFileName = sfTypeClass.SymbolColBigFileName;
              data.SFTypeObj[index2].SymbolColBigFileName2 = sfTypeClass.SymbolColBigFileName2;
              data.SFTypeObj[index2].SymbolFileName = sfTypeClass.SymbolFileName;
              data.SFTypeObj[index2].SymbolFileName2 = sfTypeClass.SymbolFileName2;
            }
          }
        }
        else
        {
          if (dataClass2.SFTypeCounter > data.SFTypeCounter)
          {
            data.SFTypeCounter = dataClass2.SFTypeCounter;
            data.SFTypeObj = (SFTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SFTypeObj, (Array) new SFTypeClass[dataClass2.SFTypeCounter + 1]);
          }
          if (dataClass2.SFTypeCounter > -1)
          {
            let mut sfTypeCounter: i32 =  dataClass2.SFTypeCounter;
            for (let mut index: i32 =  0; index <= sfTypeCounter; index += 1)
              data.SFTypeObj[index] = dataClass2.SFTypeObj[index];
          }
        }
      }
      else if (dataClass2.SFTypeCounter > -1)
      {
        let mut sfTypeCounter: i32 =  dataClass2.SFTypeCounter;
        for (let mut index: i32 =  0; index <= sfTypeCounter; index += 1)
        {
          data.AddSFType();
          data.SFTypeObj[data.SFTypeCounter] = dataClass2.SFTypeObj[index].Clone();
        }
      }
      dataClass1 = (DataClass) null;
      GC.Collect();
      Application.DoEvents();
      this.game.Data.LoadGraphics((Form1) null);
      let mut sfTypeCounter1: i32 =  this.game.Data.SFTypeCounter;
      for (let mut index3: i32 =  0; index3 <= sfTypeCounter1; index3 += 1)
      {
        let mut upperBound1: i32 =  this.game.Data.SFTypeObj[index3].CombatModAtt.GetUpperBound(0);
        if (upperBound1 < this.game.Data.LandscapeTypeCounter)
        {
          this.game.Data.SFTypeObj[index3].CombatModAtt = (float[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.SFTypeObj[index3].CombatModAtt, (Array) new float[this.game.Data.LandscapeTypeCounter + 1]);
          this.game.Data.SFTypeObj[index3].CombatModDef = (float[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.SFTypeObj[index3].CombatModDef, (Array) new float[this.game.Data.LandscapeTypeCounter + 1]);
          let mut num: i32 =  upperBound1 + 1;
          let mut landscapeTypeCounter: i32 =  this.game.Data.LandscapeTypeCounter;
          for (let mut index4: i32 =  num; index4 <= landscapeTypeCounter; index4 += 1)
          {
            this.game.Data.SFTypeObj[index3].CombatModAtt[index4] = 1f;
            this.game.Data.SFTypeObj[index3].CombatModDef[index4] = 1f;
          }
        }
        let mut upperBound2: i32 =  this.game.Data.SFTypeObj[index3].ExtraRecon.GetUpperBound(0);
        if (upperBound2 < this.game.Data.LandscapeTypeCounter)
        {
          this.game.Data.SFTypeObj[index3].ExtraRecon = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.SFTypeObj[index3].ExtraRecon, (Array) new int[this.game.Data.LandscapeTypeCounter + 1]);
          let mut num: i32 =  upperBound2 + 1;
          let mut landscapeTypeCounter: i32 =  this.game.Data.LandscapeTypeCounter;
          for (let mut index5: i32 =  num; index5 <= landscapeTypeCounter; index5 += 1)
            this.game.Data.SFTypeObj[index3].ExtraRecon[index5] = 0;
        }
      }
    }

    pub fn LoadLandscapeTypes(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data: DataClass = this.game.Data;
      if (dataClass2.LandscapeTypeCounter > data.LandscapeTypeCounter)
      {
        data.LandscapeTypeCounter = dataClass2.LandscapeTypeCounter;
        data.LandscapeTypeObj = (LandscapeTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LandscapeTypeObj, (Array) new LandscapeTypeClass[dataClass2.LandscapeTypeCounter + 1]);
      }
      if (dataClass2.LandscapeTypeCounter > -1)
      {
        let mut landscapeTypeCounter: i32 =  dataClass2.LandscapeTypeCounter;
        for (let mut index: i32 =  0; index <= landscapeTypeCounter; index += 1)
          data.LandscapeTypeObj[index] = dataClass2.LandscapeTypeObj[index];
      }
      let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
      for (let mut index1: i32 =  0; index1 <= sfTypeCounter; index1 += 1)
      {
        let mut upperBound1: i32 =  this.game.Data.SFTypeObj[index1].CombatModAtt.GetUpperBound(0);
        if (upperBound1 < this.game.Data.LandscapeTypeCounter)
        {
          this.game.Data.SFTypeObj[index1].CombatModAtt = (float[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.SFTypeObj[index1].CombatModAtt, (Array) new float[this.game.Data.LandscapeTypeCounter + 1]);
          this.game.Data.SFTypeObj[index1].CombatModDef = (float[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.SFTypeObj[index1].CombatModDef, (Array) new float[this.game.Data.LandscapeTypeCounter + 1]);
          let mut num: i32 =  upperBound1 + 1;
          let mut landscapeTypeCounter: i32 =  this.game.Data.LandscapeTypeCounter;
          for (let mut index2: i32 =  num; index2 <= landscapeTypeCounter; index2 += 1)
          {
            this.game.Data.SFTypeObj[index1].CombatModAtt[index2] = 1f;
            this.game.Data.SFTypeObj[index1].CombatModDef[index2] = 1f;
          }
        }
        let mut upperBound2: i32 =  this.game.Data.SFTypeObj[index1].ExtraRecon.GetUpperBound(0);
        if (upperBound2 < this.game.Data.LandscapeTypeCounter)
        {
          this.game.Data.SFTypeObj[index1].ExtraRecon = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.SFTypeObj[index1].ExtraRecon, (Array) new int[this.game.Data.LandscapeTypeCounter + 1]);
          let mut num: i32 =  upperBound2 + 1;
          let mut landscapeTypeCounter: i32 =  this.game.Data.LandscapeTypeCounter;
          for (let mut index3: i32 =  num; index3 <= landscapeTypeCounter; index3 += 1)
            this.game.Data.SFTypeObj[index1].ExtraRecon[index3] = 0;
        }
      }
      dataClass1 = (DataClass) null;
      GC.Collect();
      Application.DoEvents();
      this.game.Data.LoadGraphics((Form1) null);
    }

    pub fn LoadItemTypes(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data: DataClass = this.game.Data;
      if (dataClass2.ItemTypeCounter > data.ItemTypeCounter)
      {
        data.ItemTypeCounter = dataClass2.ItemTypeCounter;
        data.ItemTypeObj = (ItemTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ItemTypeObj, (Array) new ItemTypeClass[dataClass2.ItemTypeCounter + 1]);
      }
      if (dataClass2.ItemTypeCounter > -1)
      {
        let mut itemTypeCounter: i32 =  dataClass2.ItemTypeCounter;
        for (let mut index: i32 =  0; index <= itemTypeCounter; index += 1)
          data.ItemTypeObj[index] = dataClass2.ItemTypeObj[index];
      }
      let mut itemTypeCounter1: i32 =  this.game.Data.ItemTypeCounter;
      Number: i32;
      for (let mut index1: i32 =  0; index1 <= itemTypeCounter1; index1 += 1)
      {
        let mut index2: i32 =  0;
        do
        {
          if (this.game.Data.ItemTypeObj[index1].ResFieldNeeded[index2] > this.game.Data.ResearchCounter)
          {
            this.game.Data.ItemTypeObj[index1].ResFieldNeeded[index2] = -1;
            Number += 1;
          }
          index2 += 1;
        }
        while (index2 <= 4);
      }
      if (Number > 0)
      {
        let mut num: i32 =   Interaction.MsgBox( (Conversion.Str( Number) + " researchfields disabled because not present."), Title: ( "Shadow Empire : Planetary Conquest"));
      }
      dataClass1 = (DataClass) null;
      GC.Collect();
      Application.DoEvents();
      this.game.Data.LoadGraphics((Form1) null);
    }

    pub fn LoadGameVars(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data: DataClass = this.game.Data;
      let mut index: i32 =  0;
      do
      {
        data.GameSlot[index] = dataClass2.GameSlot[index];
        data.GameSlotName[index] = dataClass2.GameSlotName[index];
        data.GameSlotNato[index] = dataClass2.GameSlotNato[index];
        data.GameSlotShow[index] = dataClass2.GameSlotShow[index];
        data.GameSlotShow2[index] = dataClass2.GameSlotShow2[index];
        data.GameSlotSmallGfx[index] = dataClass2.GameSlotSmallGfx[index];
        index += 1;
      }
      while (index <= 499);
      let mut num: i32 =   Interaction.MsgBox( "Gamevars,names and settings loaded!", Title: ( "Shadow Empire : Planetary Conquest"));
      dataClass1 = (DataClass) null;
      GC.Collect();
      Application.DoEvents();
      this.game.Data.LoadGraphics((Form1) null);
    }

    pub LoadMap: bool(filename: String, bool simpleLoad = false, bool reload = false)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = filename;
      if (!System.IO.File.Exists(str))
        str = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return false;
      this.Unzip(str);
      dataClass1: DataClass = !simpleLoad ? DataClass::new() : new DataClass(DontLoadGraphics: true);
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      if (Operators.CompareString(dataClass2.RuleSetName, this.data.RuleSetName, false) != 0 & simpleLoad)
      {
        if (Interaction.MsgBox( ("The name of the ruleset of the map (" + dataClass2.RuleSetName + ") is different from the ruleset you are using (" + this.data.RuleSetName + "). Do you want to import map anyway?"), MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.No)
          return false;
      }
      data: DataClass = this.game.Data;
      if (reload && !(data.MapObj[0].MapWidth == dataClass2.MapObj[0].MapWidth & data.MapObj[0].MapHeight == dataClass2.MapObj[0].MapHeight))
      {
        let mut num: i32 =   Interaction.MsgBox( "Map not same size. Reload is cancelled.", Title: ( "Shadow Empire : Planetary Conquest"));
        bool flag;
        return flag;
      }
      if (simpleLoad | data.MapObj[0].MapWidth == dataClass2.MapObj[0].MapWidth & data.MapObj[0].MapHeight == dataClass2.MapObj[0].MapHeight)
      {
        bool flag1;
        bool flag2;
        if (!simpleLoad)
        {
          if (Interaction.MsgBox( "Also import locations?", MsgBoxStyle.YesNo) == MsgBoxResult.Yes)
            flag1 = true;
          if (Interaction.MsgBox( "Also overwrite owner of hexes?", MsgBoxStyle.YesNo) == MsgBoxResult.Yes)
            flag2 = true;
        }
        else
        {
          flag1 = true;
          flag2 = false;
        }
        data.MapObj[0].MapLoop = dataClass2.MapObj[0].MapLoop;
        data.MapObj[0].MapWidth = dataClass2.MapObj[0].MapWidth;
        data.MapObj[0].MapHeight = dataClass2.MapObj[0].MapHeight;
        if (simpleLoad & !reload)
        {
          let mut mapWidth: i32 =  data.MapObj[0].MapWidth;
          for (let mut index1: i32 =  0; index1 <= mapWidth; index1 += 1)
          {
            let mut mapHeight: i32 =  data.MapObj[0].MapHeight;
            for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
            {
              while (data.MapObj[0].HexObj[index1, index2].UnitCounter > -1)
              {
                dataClass3: DataClass = data;
                let mut unit: i32 =  data.MapObj[0].HexObj[index1, index2].UnitList[0];
                let mut gameClass: GameClass = (GameClass) null;
                 let mut local: GameClass =  gameClass;
                dataClass3.RemoveUnit(unit,  local);
              }
              if (data.MapObj[0].HexObj[index1, index2].Location > -1)
                data.RemoveLoc(data.MapObj[0].HexObj[index1, index2].Location);
            }
          }
          data.MapObj[0].HexObj = new HexClass[dataClass2.MapObj[0].MapWidth + 1, dataClass2.MapObj[0].MapHeight + 1];
        }
        let mut mapWidth1: i32 =  dataClass2.MapObj[0].MapWidth;
        for (let mut index3: i32 =  0; index3 <= mapWidth1; index3 += 1)
        {
          let mut mapHeight: i32 =  dataClass2.MapObj[0].MapHeight;
          for (let mut index4: i32 =  0; index4 <= mapHeight; index4 += 1)
          {
            if (simpleLoad)
              data.MapObj[0].HexObj[index3, index4] = new HexClass(0, this.game.Data.RegimeCounter, this.game.Data.RegimeCounter);
            let mut index5: i32 =  0;
            do
            {
              data.MapObj[0].HexObj[index3, index4].AreaCode[index5] = dataClass2.MapObj[0].HexObj[index3, index4].AreaCode[index5];
              index5 += 1;
            }
            while (index5 <= 9);
            let mut index6: i32 =  0;
            do
            {
              data.MapObj[0].HexObj[index3, index4].Bridge[index6] = dataClass2.MapObj[0].HexObj[index3, index4].Bridge[index6];
              data.MapObj[0].HexObj[index3, index4].RiverType[index6] = dataClass2.MapObj[0].HexObj[index3, index4].RiverType[index6];
              data.MapObj[0].HexObj[index3, index4].RoadType[index6] = dataClass2.MapObj[0].HexObj[index3, index4].RoadType[index6];
              index6 += 1;
            }
            while (index6 <= 5);
            data.MapObj[0].HexObj[index3, index4].CardUponConquest = dataClass2.MapObj[0].HexObj[index3, index4].CardUponConquest;
            data.MapObj[0].HexObj[index3, index4].LabelText1 = dataClass2.MapObj[0].HexObj[index3, index4].LabelText1;
            data.MapObj[0].HexObj[index3, index4].LabelText2 = dataClass2.MapObj[0].HexObj[index3, index4].LabelText2;
            data.MapObj[0].HexObj[index3, index4].LabelType1 = dataClass2.MapObj[0].HexObj[index3, index4].LabelType1;
            data.MapObj[0].HexObj[index3, index4].LabelType2 = dataClass2.MapObj[0].HexObj[index3, index4].LabelType2;
            data.MapObj[0].HexObj[index3, index4].LandscapeType = dataClass2.MapObj[0].HexObj[index3, index4].LandscapeType;
            if (flag1)
              data.MapObj[0].HexObj[index3, index4].Location = dataClass2.MapObj[0].HexObj[index3, index4].Location;
            data.MapObj[0].HexObj[index3, index4].Name = dataClass2.MapObj[0].HexObj[index3, index4].Name;
            if (flag2)
              data.MapObj[0].HexObj[index3, index4].Regime = dataClass2.MapObj[0].HexObj[index3, index4].Regime;
            if (flag2)
              data.MapObj[0].HexObj[index3, index4].OrigOwner = dataClass2.MapObj[0].HexObj[index3, index4].OrigOwner;
            data.MapObj[0].HexObj[index3, index4].SpecialSprite = dataClass2.MapObj[0].HexObj[index3, index4].SpecialSprite;
            data.MapObj[0].HexObj[index3, index4].SpecialType = dataClass2.MapObj[0].HexObj[index3, index4].SpecialType;
            data.MapObj[0].HexObj[index3, index4].SpriteNr = dataClass2.MapObj[0].HexObj[index3, index4].SpriteNr;
            data.MapObj[0].HexObj[index3, index4].VP = dataClass2.MapObj[0].HexObj[index3, index4].VP;
            data.MapObj[0].HexObj[index3, index4].randomOverrule = dataClass2.MapObj[0].HexObj[index3, index4].randomOverrule;
            data.MapObj[0].HexObj[index3, index4].SmallLabel = dataClass2.MapObj[0].HexObj[index3, index4].SmallLabel;
            data.MapObj[0].HexObj[index3, index4].SmallLabelType = dataClass2.MapObj[0].HexObj[index3, index4].SmallLabelType;
            data.MapObj[0].HexObj[index3, index4].HeightLevel = dataClass2.MapObj[0].HexObj[index3, index4].HeightLevel;
          }
        }
        if (flag1)
        {
          data.LocCounter = dataClass2.LocCounter;
          data.LocObj = (LocationClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LocObj, (Array) new LocationClass[data.LocCounter + 1]);
          let mut locCounter: i32 =  dataClass2.LocCounter;
          for (let mut index: i32 =  0; index <= locCounter; index += 1)
            data.LocObj[index] = dataClass2.LocObj[index];
        }
        if (!simpleLoad)
        {
          if (flag1)
          {
            let mut num1: i32 =   Interaction.MsgBox( "Map and locations loaded!", Title: ( "Shadow Empire : Planetary Conquest"));
          }
          else
          {
            let mut num2: i32 =   Interaction.MsgBox( "Map loaded!", Title: ( "Shadow Empire : Planetary Conquest"));
          }
        }
        dataClass1 = (DataClass) null;
        GC.Collect();
        Application.DoEvents();
        if (!simpleLoad)
          this.game.Data.LoadGraphics((Form1) null);
        return true;
      }
      let mut num3: i32 =   Interaction.MsgBox( ("Import map is " + dataClass2.MapObj[0].MapWidth.ToString() + "x" + dataClass2.MapObj[0].MapHeight.ToString() + ". Can not import due to this. First change your current map to same size."), Title: ( "Shadow Empire : Planetary Conquest"));
      return false;
    }

    pub fn LoadResearch(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data: DataClass = this.game.Data;
      if (dataClass2.ResearchCounter > data.ResearchCounter)
      {
        data.ResearchCounter = dataClass2.ResearchCounter;
        data.ResearchObj = (ResearchClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ResearchObj, (Array) new ResearchClass[dataClass2.ResearchCounter + 1]);
      }
      if (dataClass2.ResearchCounter > -1)
      {
        let mut researchCounter: i32 =  dataClass2.ResearchCounter;
        for (let mut index: i32 =  0; index <= researchCounter; index += 1)
          data.ResearchObj[index] = dataClass2.ResearchObj[index];
      }
      let mut researchCounter1: i32 =  this.game.Data.ResearchCounter;
      Number: i32;
      for (let mut index: i32 =  0; index <= researchCounter1; index += 1)
      {
        let mut num: i32 =  0;
        do
        {
          if (this.game.Data.ResearchObj[index].SFTypePic > this.game.Data.SFTypeCounter)
          {
            this.game.Data.ResearchObj[index].SFTypePic = -1;
            Number += 1;
          }
          num += 1;
        }
        while (num <= 4);
      }
      if (Number > 0)
      {
        let mut num1: i32 =   Interaction.MsgBox( (Conversion.Str( Number) + " sftype pictures disabled because not present."), Title: ( "Shadow Empire : Planetary Conquest"));
      }
      dataClass1 = (DataClass) null;
      GC.Collect();
      Application.DoEvents();
      this.game.Data.LoadGraphics((Form1) null);
    }

    pub fn LoadLocTypes(filename: String)
    {
      float[] numArray1 = new float[100];
      bool[] flagArray = new bool[100];
      int[] numArray2 = new int[100];
      str: String = this.game.AppPath + filename;
      if (!System.IO.File.Exists(str))
        return;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      this.ZipFile(str);
      data: DataClass = this.game.Data;
      if (dataClass2.LocTypeCounter > data.LocTypeCounter)
      {
        data.LocTypeCounter = dataClass2.LocTypeCounter;
        data.LocTypeObj = (LocationTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LocTypeObj, (Array) new LocationTypeClass[dataClass2.LocTypeCounter + 1]);
      }
      if (dataClass2.LocTypeCounter > -1)
      {
        let mut locTypeCounter: i32 =  dataClass2.LocTypeCounter;
        for (let mut index: i32 =  0; index <= locTypeCounter; index += 1)
          data.LocTypeObj[index] = dataClass2.LocTypeObj[index];
      }
      let mut locTypeCounter1: i32 =  this.game.Data.LocTypeCounter;
      Number: i32;
      for (let mut index1: i32 =  0; index1 <= locTypeCounter1; index1 += 1)
      {
        if (this.game.Data.LocTypeObj[index1].OnDestructLT > this.game.Data.LandscapeTypeCounter)
        {
          this.game.Data.LocTypeObj[index1].OnDestructLT = 0;
          this.game.Data.LocTypeObj[index1].OnDestructSpriteNr = 0;
          Number += 1;
        }
        if (this.game.Data.LocTypeObj[index1].OverdrawLTNr > this.game.Data.LandscapeTypeCounter)
        {
          this.game.Data.LocTypeObj[index1].OverdrawLTNr = -1;
          this.game.Data.LocTypeObj[index1].OverdrawSpriteNr = -1;
          Number += 1;
        }
        if (this.game.Data.LocTypeObj[index1].PictureLT > this.game.Data.LandscapeTypeCounter)
        {
          this.game.Data.LocTypeObj[index1].PictureLT = -1;
          this.game.Data.LocTypeObj[index1].PictureSprite = -1;
          Number += 1;
        }
        let mut index2: i32 =  0;
        do
        {
          if (this.game.Data.LocTypeObj[index1].Research[index2] > this.game.Data.ResearchCounter)
          {
            this.game.Data.LocTypeObj[index1].Research[index2] = -1;
            Number += 1;
          }
          index2 += 1;
        }
        while (index2 <= 4);
      }
      if (Number > 0)
      {
        let mut num: i32 =   Interaction.MsgBox( (Conversion.Str( Number) + " settings because referred to landscape type or research not present."), Title: ( "Shadow Empire : Planetary Conquest"));
      }
      dataClass1 = (DataClass) null;
      GC.Collect();
      Application.DoEvents();
      this.game.Data.LoadGraphics((Form1) null);
    }

    pub fn AlternateLoadMasterFile(filename: String)
    {
      str: String = this.game.AppPath + "scenarios\\" + filename;
      this.Unzip(str);
      dataClass1: DataClass = DataClass::new();
      dataClass2: DataClass = DataClass.deserialize(str);
      data: DataClass = this.game.Data;
      data.BridgeObj[0] = dataClass2.BridgeObj[0];
      if (dataClass2.RoadTypeCounter > data.RoadTypeCounter)
      {
        data.RoadTypeCounter = dataClass2.RoadTypeCounter;
        data.RoadTypeObj = (RoadTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.RoadTypeObj, (Array) new RoadTypeClass[dataClass2.RoadTypeCounter + 1]);
      }
      if (dataClass2.RoadTypeCounter > -1)
      {
        let mut roadTypeCounter: i32 =  dataClass2.RoadTypeCounter;
        for (let mut index: i32 =  0; index <= roadTypeCounter; index += 1)
          data.RoadTypeObj[index] = dataClass2.RoadTypeObj[index];
      }
      if (dataClass2.RiverTypeCounter > data.RiverTypeCounter)
      {
        data.RiverTypeCounter = dataClass2.RiverTypeCounter;
        data.RiverTypeObj = (RiverTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.RiverTypeObj, (Array) new RiverTypeClass[dataClass2.RiverTypeCounter + 1]);
      }
      if (dataClass2.RiverTypeCounter > -1)
      {
        let mut riverTypeCounter: i32 =  data.RiverTypeCounter;
        for (let mut index: i32 =  0; index <= riverTypeCounter; index += 1)
          data.RiverTypeObj[index] = dataClass2.RiverTypeObj[index];
      }
      if (dataClass2.LocTypeCounter > data.LocTypeCounter)
      {
        data.LocTypeCounter = dataClass2.LocTypeCounter;
        data.LocTypeObj = (LocationTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LocTypeObj, (Array) new LocationTypeClass[data.LocTypeCounter + 1]);
      }
      if (dataClass2.LocTypeCounter > -1)
      {
        let mut locTypeCounter: i32 =  data.LocTypeCounter;
        for (let mut index: i32 =  0; index <= locTypeCounter; index += 1)
          data.LocTypeObj[index] = dataClass2.LocTypeObj[index];
      }
      if (dataClass2.SFTypeCounter > data.SFTypeCounter)
      {
        data.SFTypeCounter = dataClass2.SFTypeCounter;
        data.SFTypeObj = (SFTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.SFTypeObj, (Array) new SFTypeClass[data.SFTypeCounter + 1]);
      }
      if (data.SFTypeCounter > -1)
      {
        let mut sfTypeCounter: i32 =  data.SFTypeCounter;
        for (let mut index: i32 =  0; index <= sfTypeCounter; index += 1)
          data.SFTypeObj[index] = dataClass2.SFTypeObj[index];
      }
      if (dataClass2.PeopleCounter > data.PeopleCounter)
      {
        data.PeopleCounter = dataClass2.PeopleCounter;
        data.PeopleObj = (PeopleClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.PeopleObj, (Array) new PeopleClass[data.PeopleCounter + 1]);
      }
      if (data.PeopleCounter > -1)
      {
        let mut peopleCounter: i32 =  data.PeopleCounter;
        for (let mut index: i32 =  0; index <= peopleCounter; index += 1)
          data.PeopleObj[index] = dataClass2.PeopleObj[index];
      }
      if (dataClass2.ItemTypeCounter > data.ItemTypeCounter)
      {
        data.ItemTypeCounter = dataClass2.ItemTypeCounter;
        data.ItemTypeObj = (ItemTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ItemTypeObj, (Array) new ItemTypeClass[data.ItemTypeCounter + 1]);
      }
      if (data.ItemTypeCounter > -1)
      {
        let mut itemTypeCounter: i32 =  data.ItemTypeCounter;
        for (let mut index: i32 =  0; index <= itemTypeCounter; index += 1)
          data.ItemTypeObj[index] = dataClass2.ItemTypeObj[index];
      }
      if (dataClass2.LandscapeTypeCounter > data.LandscapeTypeCounter)
      {
        data.LandscapeTypeCounter = dataClass2.LandscapeTypeCounter;
        data.LandscapeTypeObj = (LandscapeTypeClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.LandscapeTypeObj, (Array) new LandscapeTypeClass[data.LandscapeTypeCounter + 1]);
      }
      if (data.LandscapeTypeCounter > -1)
      {
        let mut landscapeTypeCounter: i32 =  data.LandscapeTypeCounter;
        for (let mut index: i32 =  0; index <= landscapeTypeCounter; index += 1)
          data.LandscapeTypeObj[index] = dataClass2.LandscapeTypeObj[index];
      }
      if (dataClass2.ResearchCounter > data.ResearchCounter)
      {
        data.ResearchCounter = dataClass2.ResearchCounter;
        data.ResearchObj = (ResearchClass[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) data.ResearchObj, (Array) new ResearchClass[data.ResearchCounter + 1]);
      }
      if (data.ResearchCounter > -1)
      {
        let mut researchCounter: i32 =  data.ResearchCounter;
        for (let mut index: i32 =  0; index <= researchCounter; index += 1)
          data.ResearchObj[index] = dataClass2.ResearchObj[index];
      }
      data.StringCounter = dataClass2.StringCounter;
      data.TempString = new string[data.StringCounter + 1];
      let mut stringCounter: i32 =  data.StringCounter;
      for (let mut index: i32 =  0; index <= stringCounter; index += 1)
        data.TempString[index] = dataClass2.TempString[index];
      data.RuleCounter = dataClass2.RuleCounter;
      data.RuleString = new string[data.RuleCounter + 1];
      data.RuleGroup = new int[data.RuleCounter + 1];
      data.RuleVar = new float[data.RuleCounter + 1];
      let mut ruleCounter: i32 =  data.RuleCounter;
      for (let mut index: i32 =  0; index <= ruleCounter; index += 1)
      {
        data.RuleString[index] = dataClass2.RuleString[index];
        data.RuleGroup[index] = dataClass2.RuleGroup[index];
        data.RuleVar[index] = dataClass2.RuleVar[index];
      }
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index: i32 =  0; index <= regimeCounter; index += 1)
      {
        if (this.game.Data.ResearchCounter > this.game.Data.RegimeObj[index].ResFieldCounter)
        {
          this.game.Data.RegimeObj[index].ResFieldCounter = this.game.Data.ResearchCounter;
          this.game.Data.RegimeObj[index].ResField = (bool[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].ResField, (Array) new bool[this.game.Data.RegimeObj[index].ResFieldCounter + 1]);
        }
      }
      this.ZipFile(str);
      this.game.Data.SetEventNames();
      BitmapStore.ReloadSystemGraphics(this.game.Data.SystemGfx);
      this.game.Data.LoadGraphics((Form1) null);
      dataClass1 = (DataClass) null;
    }

    pub fn GetRegimeVP(regnr: i32) -> i32
    {
      let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
      regimeVp: i32;
      for (let mut index1: i32 =  0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
        {
          if (this.game.Data.MapObj[0].HexObj[index1, index2].Regime == regnr)
            regimeVp += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
        }
      }
      return regimeVp;
    }

    pub fn DoStrucPtsDammage(x: i32, y: i32, map: i32, dam: i32, bool onlytown = false, bool both = true)
    {
      if ( this.game.Data.RuleVar[305] > 0.0)
      {
        onlytown = true;
        both = false;
      }
      index1: i32;
      num1: i32;
      if (onlytown | both && this.game.Data.MapObj[map].HexObj[x, y].Location > -1 && !this.game.Data.LocTypeObj[this.game.Data.LocObj[index1].Type].Invincible)
      {
        num2: i32;
        num1 = num2 + 1;
      }
      num3: i32;
      if (!onlytown | num1 == 0 | both)
      {
        let mut index2: i32 =  0;
        while (!this.game.Data.MapObj[map].HexObj[x, y].Bridge[index2])
        {
          index2 += 1;
          if (index2 > 5)
            goto label_9;
        }
        num1 += 1;
        num3 = 1;
label_9:
        if (num1 == 0)
        {
          num1 = 1;
          onlytown = true;
          both = false;
        }
      }
      this.game.EditObj.CombatOneSentence = "";
      if (num1 == 0)
        return;
      dam =  Math.Round(Conversion.Int( dam /  num1));
      if (onlytown | both && this.game.Data.MapObj[0].HexObj[x, y].Location > -1)
      {
        let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
        let mut type: i32 =  this.game.Data.LocObj[location].Type;
        if (!this.game.Data.LocTypeObj[type].Invincible)
        {
          let mut Number: i32 =  dam;
          this.game.EditObj.CombatOneSentence = "Loc has " + Conversion.Str( this.game.Data.LocObj[location].StructuralPts) + "pts. Dam done to loc: " + Strings.Trim(Conversion.Str( Number)) + ".";
          LocationClass[] locObj = this.game.Data.LocObj;
          LocationClass[] locationClassArray = locObj;
          let mut index3: i32 =  location;
          let mut index4: i32 =  index3;
          locationClassArray[index4].StructuralPts = locObj[index3].StructuralPts - Number;
          if (1 > this.game.Data.LocObj[location].StructuralPts)
          {
            if (this.game.Data.LocTypeObj[type].OnDestructLT > -1)
            {
              this.game.EditObj.CombatOneSentence += ". Loc destroyed!";
              this.game.Data.MapObj[map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].LandscapeType = this.game.Data.LocTypeObj[type].OnDestructLT;
              this.game.Data.MapObj[map].HexObj[this.game.Data.LocObj[location].X, this.game.Data.LocObj[location].Y].SpriteNr = this.game.Data.LocTypeObj[type].OnDestructSpriteNr;
              this.game.Data.RemoveLoc(location);
            }
            else if (this.game.Data.LocTypeObj[type].OnDestructLT == -2)
            {
              this.game.EditObj.CombatOneSentence += ". Loc destroyed!";
              this.game.Data.RemoveLoc(location);
            }
            else
            {
              this.game.EditObj.CombatOneSentence += ". Loc is knocked out!";
              this.game.Data.LocObj[location].StructuralPts = 0;
            }
          }
          else
          {
            editObj: EditClass = this.game.EditObj;
            editObj.CombatOneSentence = editObj.CombatOneSentence + ". Loc down to " + Strings.Trim(Conversion.Str( this.game.Data.LocObj[location].StructuralPts)) + " pts.";
          }
        }
      }
      if (!(!onlytown | both) || num3 != 1)
        return;
      let mut num4: i32 =  0;
      let mut index5: i32 =  0;
      do
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].Bridge[index5])
          num4 += 1;
        index5 += 1;
      }
      while (index5 <= 5);
      dam =  Math.Round(Conversion.Int( dam /  num4));
      let mut index6: i32 =  0;
      do
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].Bridge[index6] & this.game.Data.MapObj[map].HexObj[x, y].RiverType[index6] > -1)
        {
          let mut Number: i32 =   Math.Round( (this.game.Data.RuleVar[7] * this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[index6]].BridgeCostModifier));
          editObj: EditClass = this.game.EditObj;
          editObj.CombatOneSentence = editObj.CombatOneSentence + Strings.Trim(Conversion.Str( dam)) + " vs Brid: " + Strings.Trim(Conversion.Str( Number));
          let mut num5: i32 =   Math.Round(Conversion.Int( dam * 0.5 *  VBMath.Rnd()) +  dam * 0.5);
          let mut num6: i32 =   Math.Round( VBMath.Rnd() *  this.game.Data.RuleVar[7] *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[index6]].BridgeCostModifier * 0.5 + 0.5 *  this.game.Data.RuleVar[7] *  this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[index6]].BridgeCostModifier);
          if (num6 < 9999)
          {
            if (num5 > num6)
            {
              this.game.EditObj.CombatOneSentence += ". Bridge destroyed!";
              this.game.Data.MapObj[map].HexObj[x, y].Bridge[index6] = false;
              Coordinate coordinate = this.HexNeighbour(x, y, map, index6 + 1);
              if (this.HexFacing(coordinate.x, coordinate.y, map, x, y, map) > 0)
                this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].Bridge[this.HexFacing(coordinate.x, coordinate.y, map, x, y, map) - 1] = false;
            }
            else
              this.game.EditObj.CombatOneSentence += ". Bridge has survived.";
          }
          else
            this.game.EditObj.CombatOneSentence += ". Bridge is indestructable.";
        }
        index6 += 1;
      }
      while (index6 <= 5);
    }

    pub HasHexBridge: bool(x: i32, y: i32, map: i32)
    {
      let mut index: i32 =  0;
      while (!this.game.Data.MapObj[map].HexObj[x, y].Bridge[index])
      {
        index += 1;
        if (index > 5)
          return false;
      }
      return true;
    }

    pub HasHexBrokenBridge: bool(x: i32, y: i32, map: i32)
    {
      let mut index: i32 =  0;
      while (this.game.Data.MapObj[map].HexObj[x, y].RiverType[index] <= -1 || this.game.Data.MapObj[map].HexObj[x, y].Bridge[index] || this.game.Data.MapObj[map].HexObj[x, y].RoadType[index] <= -1)
      {
        index += 1;
        if (index > 5)
          return false;
      }
      return true;
    }

    pub HasHexRiver: bool(x: i32, y: i32, map: i32)
    {
      let mut index: i32 =  0;
      while (this.game.Data.MapObj[map].HexObj[x, y].RiverType[index] <= -1 || this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RiverType[index]].drawInteriorOnly)
      {
        index += 1;
        if (index > 5)
          return false;
      }
      return true;
    }

    pub HasHexRiverOrInteriorRiver: bool(x: i32, y: i32, map: i32)
    {
      let mut index: i32 =  0;
      while (this.game.Data.MapObj[map].HexObj[x, y].RiverType[index] <= -1)
      {
        index += 1;
        if (index > 5)
          return false;
      }
      return true;
    }

    pub HasHexRiverExitingInIt: bool(x: i32, y: i32, map: i32)
    {
      let mut tfacing: i32 =  1;
      while (this.game.Data.MapObj[map].HexObj[x, y].RiverType[tfacing - 1] <= -1)
      {
        Coordinate coordinate = this.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          let mut num1: i32 =  tfacing + 3;
          if (num1 > 6)
            num1 -= 6;
          let mut num2: i32 =  num1 + 1;
          if (num2 == 7)
            num2 = 1;
          if (this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].RiverType[num2 - 1] > -1 && !this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].RiverType[num2 - 1]].drawInteriorOnly)
            return true;
          let mut num3: i32 =  num1 - 1;
          if (num3 == 0)
            num3 = 6;
          if (this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].RiverType[num3 - 1] > -1 && !this.game.Data.RiverTypeObj[this.game.Data.MapObj[map].HexObj[coordinate.x, coordinate.y].RiverType[num3 - 1]].drawInteriorOnly)
            return true;
        }
        tfacing += 1;
        if (tfacing > 6)
          return false;
      }
      return true;
    }

    pub HasHexRoad: bool(x: i32, y: i32, map: i32)
    {
      let mut index: i32 =  0;
      while (this.game.Data.MapObj[map].HexObj[x, y].RoadType[index] <= -1)
      {
        index += 1;
        if (index > 5)
          return false;
      }
      return true;
    }

    pub fn HexRoadCount(x: i32, y: i32, map: i32) -> i32
    {
      let mut num: i32 =  0;
      let mut index: i32 =  0;
      do
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].RoadType[index] > -1)
          num += 1;
        index += 1;
      }
      while (index <= 5);
      return num;
    }

    pub fn HexLowestRulevar99moveCost(x: i32, y: i32, map: i32) -> i32
    {
      let mut num1: i32 =  999;
      if ( this.game.Data.RuleVar[99] < 0.0 | this.game.Data.RoadTypeCounter == -1)
        return 999;
      let mut index: i32 =  0;
      do
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].RoadType[index] > -1)
        {
          let mut num2: i32 =  this.game.Data.RoadTypeObj[this.game.Data.MapObj[map].HexObj[x, y].RoadType[index]].MoveCostOverrule[ Math.Round( this.game.Data.RuleVar[99])];
          if (num2 < num1)
            num1 = num2;
        }
        index += 1;
      }
      while (index <= 5);
      return num1;
    }

    pub float GetConcentricBonus2()
    {
      Neighbours neighbours = Neighbours::new();
      if (this.game.EditObj.TempUnitList.counter > -1)
      {
        let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
        for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
        {
          let mut index2: i32 =  this.game.EditObj.TempUnitList.unr[index1];
          if (this.game.Data.UnitObj[index2].Map == this.game.EditObj.OrderMap && this.Distance(this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, this.game.Data.UnitObj[index2].Map, this.game.EditObj.OrderX, this.game.EditObj.OrderY, this.game.EditObj.OrderMap) == 1)
          {
            let mut index3: i32 =  this.HexFacing(this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, this.game.Data.UnitObj[index2].Map, this.game.EditObj.OrderX, this.game.EditObj.OrderY, this.game.EditObj.OrderMap) - 1;
            if (index3 >= 0 & index3 <= 5)
              neighbours.data[index3] = 1;
          }
        }
      }
      bool flag1 = false;
      if (this.game.Data.RegimeObj[this.game.Data.Turn].AI)
        flag1 = true;
      if (this.GetHQsInUnitList() > 1)
      {
         Neighbours local1 =  neighbours;
        bool flag2 = true;
         bool local2 =  flag2;
        let mut num: i32 =  flag1 ? 1 : 0;
        return this.GetConcentricBonus( local1,  local2, num != 0);
      }
       Neighbours local3 =  neighbours;
      bool flag3 = false;
       bool local4 =  flag3;
      let mut num1: i32 =  flag1 ? 1 : 0;
      return this.GetConcentricBonus( local3,  local4, num1 != 0);
    }

    pub float GetConcentricBonus2Prognosis(bool aiExtraBonus, bool facingInData2 = false)
    {
      Neighbours neighbours = Neighbours::new();
      let mut num1: i32 =  0;
      if (this.game.EditObj.TempUnitList.counter > -1)
      {
        let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
        for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
        {
          let mut index2: i32 =  this.game.EditObj.TempUnitList.unr[index1];
          if (facingInData2)
          {
            let mut index3: i32 =  this.game.EditObj.TempUnitList.data2[index1];
            if (neighbours.data[index3] < 1)
              num1 += 1;
            neighbours.data[index3] = 1;
          }
          else if (this.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.EditObj.OrderX, this.game.EditObj.OrderY, 0) == 1)
          {
            let mut index4: i32 =  this.HexFacing(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.EditObj.OrderX, this.game.EditObj.OrderY, this.game.EditObj.OrderMap) - 1;
            if (neighbours.data[index4] < 1)
              num1 += 1;
            neighbours.data[index4] = 1;
          }
        }
      }
      bool flag1 = false;
      if (this.game.Data.RegimeObj[this.game.Data.Turn].AI)
        flag1 = true;
      float concentricBonus;
      if (this.GetHQsInUnitList() > 1)
      {
         Neighbours local1 =  neighbours;
        bool flag2 = true;
         bool local2 =  flag2;
        let mut num2: i32 =  flag1 ? 1 : 0;
        concentricBonus = this.GetConcentricBonus( local1,  local2, num2 != 0);
      }
      else
      {
         Neighbours local3 =  neighbours;
        bool flag3 = false;
         bool local4 =  flag3;
        let mut num3: i32 =  flag1 ? 1 : 0;
        concentricBonus = this.GetConcentricBonus( local3,  local4, num3 != 0);
      }
      if (aiExtraBonus && this.game.Data.RegimeObj[this.game.Data.Turn].AI)
        concentricBonus += 0.3f *  num1;
      return concentricBonus;
    }

    pub object GetHQsInUnitList( UnitList UL)
    {
      let mut num: i32 =  -1;
      if (UL.counter <= -1)
        return  0;
      let mut counter: i32 =  UL.counter;
      hqsInUnitList: i32;
      for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
      {
        let mut index2: i32 =  UL.unr[index1];
        if (!this.game.Data.UnitObj[index2].IsHQ)
        {
          if (this.game.Data.UnitObj[index2].HQ > -1)
          {
            if (num == -1)
            {
              num = this.game.Data.UnitObj[index2].HQ;
              hqsInUnitList += 1;
            }
            else if (num != this.game.Data.UnitObj[index2].HQ)
              hqsInUnitList += 1;
          }
          else
          {
            num = -2;
            hqsInUnitList += 1;
          }
        }
        else if (num == -1)
        {
          num = index2;
          hqsInUnitList += 1;
        }
        else
        {
          num = index2;
          if (num != this.game.Data.UnitObj[index2].HQ)
            hqsInUnitList += 1;
        }
      }
      return  hqsInUnitList;
    }

    pub fn GetHQsInUnitList() -> i32
    {
      let mut num: i32 =  -1;
      let mut hqsInUnitList: i32 =  0;
      if (this.game.EditObj.TempUnitList.counter <= -1)
        return 0;
      let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
      for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
      {
        let mut index2: i32 =  this.game.EditObj.TempUnitList.unr[index1];
        if (!this.game.Data.UnitObj[index2].IsHQ)
        {
          if (this.game.Data.UnitObj[index2].HQ > -1)
          {
            if (num == -1)
            {
              num = this.game.Data.UnitObj[index2].HQ;
              hqsInUnitList += 1;
            }
            else if (num != this.game.Data.UnitObj[index2].HQ)
              hqsInUnitList += 1;
          }
          else
          {
            num = -1;
            hqsInUnitList += 1;
          }
        }
        else if (num == -1)
        {
          num = index2;
          hqsInUnitList += 1;
        }
        else if (num != index2)
          hqsInUnitList += 1;
      }
      return hqsInUnitList;
    }

    pub float GetConcentricBonus( Neighbours neighbour,  bool multiplehq, bool forAI)
    {
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut num3: i32 =  0;
      let mut num4: i32 =  0;
      let mut num5: i32 =  0;
      let mut index1: i32 =  0;
      do
      {
        if (neighbour.data[index1] < 1)
        {
          if (num5 == 1)
            num2 += 1;
          if (num5 == 2)
            num3 += 1;
          if (num5 == 3)
            num4 += 1;
        }
        else
        {
          num5 += 1;
          num6: i32;
          num6 += 1;
        }
        index1 += 1;
      }
      while (index1 <= 5);
      let mut index2: i32 =  0;
      while (neighbour.data[index2] < 1)
      {
        if (num5 == 0)
          num1 += 1;
        if (num5 == 1)
          num2 += 1;
        if (num5 == 2)
          num3 += 1;
        if (num5 == 3)
          num4 += 1;
        index2 += 1;
        if (index2 > 5)
          break;
      }
      let mut num7: i32 =  0;
      let mut num8: i32 =  0;
      let mut num9: i32 =  0;
      let mut num10: i32 =  0;
      if (num2 == 1)
        num7 += 1;
      if (num2 == 2)
        num8 += 1;
      if (num2 == 3)
        num9 += 1;
      if (num2 == 4)
        num10 += 1;
      if (num3 == 1)
        num7 += 1;
      if (num3 == 2)
        num8 += 1;
      if (num3 == 3)
        num9 += 1;
      if (num3 == 4)
        num10 += 1;
      if (num4 == 1)
        num7 += 1;
      if (num4 == 2)
        num8 += 1;
      if (num4 == 3)
        num9 += 1;
      if (num4 == 4)
        num10 += 1;
      float num11 = 0.0f;
      if (num7 == 0 & num8 == 0 & num9 == 0 & num10 == 1)
        num11 = this.game.Data.RuleVar[132];
      if (num7 == 1 & num8 == 0 & num9 == 1 & num10 == 0)
        num11 = this.game.Data.RuleVar[133];
      if (num7 == 0 & num8 == 2 & num9 == 0 & num10 == 0)
        num11 = this.game.Data.RuleVar[134];
      if (num7 == 0 & num8 == 0 & num9 == 1 & num10 == 0)
        num11 = this.game.Data.RuleVar[134];
      if (num7 == 1 & num8 == 1 & num9 == 0 & num10 == 0)
        num11 = this.game.Data.RuleVar[135];
      if (num7 == 3 & num8 == 0 & num9 == 0 & num10 == 0)
        num11 = this.game.Data.RuleVar[136];
      if (num7 == 0 & num8 == 1 & num9 == 0 & num10 == 0)
        num11 = this.game.Data.RuleVar[136];
      if (num7 == 2 & num8 == 0 & num9 == 0 & num10 == 0)
        num11 = this.game.Data.RuleVar[137];
      if (num7 == 0 & num8 == 0 & num9 == 0 & num10 == 0 & num5 == 4)
        num11 = this.game.Data.RuleVar[136];
      if (num7 == 1 & num8 == 0 & num9 == 0 & num10 == 0 & num5 == 4)
        num11 = this.game.Data.RuleVar[137];
      if (num5 == 5)
        num11 = this.game.Data.RuleVar[138];
      if (num5 == 6)
        num11 = this.game.Data.RuleVar[139];
      return !multiplehq ? 1f + num11 : (!(forAI &  this.game.Data.RuleVar[993] > 0.0) ?  (1.0 +  num11 / 2.0) : 1f + num11);
    }

    pub fn GetNumberOfSubordinates(hq: i32) -> i32
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      numberOfSubordinates: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].HQ == hq)
        {
          if (this.game.Data.UnitObj[index].IsHQ)
            numberOfSubordinates += 2;
          else
            numberOfSubordinates += 1;
        }
      }
      return numberOfSubordinates;
    }

    pub fn AddXToMap(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      let mut mapWidth2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth2; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
          hexClassArray[index1, index2] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Clone();
      }
      MapClass[] mapObj = this.game.Data.MapObj;
      MapClass[] mapClassArray = mapObj;
      let mut mapSelected: i32 =  this.game.EditObj.MapSelected;
      let mut index3: i32 =  mapSelected;
      mapClassArray[index3].MapWidth = mapObj[mapSelected].MapWidth + tempint;
      this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index4: i32 =  0; index4 <= mapWidth3; index4 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index4, index5] = index4 <= mapWidth1 ? hexClassArray[index4, index5].Clone() : new HexClass(0, this.game.Data.RegimeCounter, this.game.Data.RegimeCounter);
      }
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index6: i32 =  0; index6 <= regimeCounter; index6 += 1)
      {
        this.game.Data.RegimeObj[index6].HistoryForce = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistoryOwner = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistorySFType = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistoryHis = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistoryDepth = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].AIVP = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].AIPower = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].AIDefense = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].MapCount = this.game.Data.MapCounter;
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index7: i32 =  0; index7 <= mapCounter; index7 += 1)
        {
          this.game.Data.RegimeObj[index6].HistoryForce[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistoryOwner[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistorySFType[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistoryHis[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistoryDepth[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].AIVP[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].AIPower[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].AIDefense[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
        }
      }
    }

    pub fn AddXToMapLeft(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      this.AddXToMap(tempint);
      for (let mut index1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth - tempint; index1 >= 0; index1 += -1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
        {
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1 + tempint, index2] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Clone();
          let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1 + tempint, index2].UnitCounter;
          for (let mut index3: i32 =  0; index3 <= unitCounter; index3 += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1 + tempint, index2].UnitList[index3];
            this.game.Data.UnitObj[unit].X = index1 + tempint;
            this.game.Data.UnitObj[unit].Y = index2;
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1 + tempint, index2].Location;
          if (location > -1)
          {
            this.game.Data.LocObj[location].X = index1 + tempint;
            this.game.Data.LocObj[location].Y = index2;
          }
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2] = new HexClass(0, this.game.Data.RegimeCounter, this.game.Data.RegimeCounter);
        }
      }
    }

    pub fn RemoveXToMap(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      let mut mapWidth2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      let mut num: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth - tempint + 1;
      for (let mut index1: i32 =  mapWidth2; index1 >= num; index1 += -1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
        {
          for (let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitCounter; unitCounter >= 0; unitCounter += -1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitList[unitCounter];
            data: DataClass = this.game.Data;
            let mut nr: i32 =  unit;
            let mut gameClass: GameClass = (GameClass) null;
             let mut local: GameClass =  gameClass;
            data.RemoveUnit(nr,  local);
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Location;
          if (location > -1)
            this.game.Data.RemoveLoc(location);
        }
      }
      let mut mapWidth3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index3: i32 =  0; index3 <= mapWidth3; index3 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index4: i32 =  0; index4 <= mapHeight; index4 += 1)
          hexClassArray[index3, index4] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4].Clone();
      }
      MapClass[] mapObj = this.game.Data.MapObj;
      MapClass[] mapClassArray = mapObj;
      let mut mapSelected: i32 =  this.game.EditObj.MapSelected;
      let mut index5: i32 =  mapSelected;
      mapClassArray[index5].MapWidth = mapObj[mapSelected].MapWidth - tempint;
      this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth4: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index6: i32 =  0; index6 <= mapWidth4; index6 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index7: i32 =  0; index7 <= mapHeight; index7 += 1)
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index6, index7] = hexClassArray[index6, index7].Clone();
      }
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index8: i32 =  0; index8 <= regimeCounter; index8 += 1)
      {
        this.game.Data.RegimeObj[index8].HistoryForce = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistoryOwner = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistorySFType = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistoryHis = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistoryDepth = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].AIVP = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].AIPower = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].AIDefense = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].MapCount = this.game.Data.MapCounter;
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index9: i32 =  0; index9 <= mapCounter; index9 += 1)
        {
          this.game.Data.RegimeObj[index8].HistoryForce[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistoryOwner[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistorySFType[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistoryHis[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistoryDepth[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].AIVP[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].AIPower[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].AIDefense[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
        }
      }
      this.game.SelectX = 0;
      this.game.SelectY = 0;
      this.game.CornerX = 0;
      this.game.CornerY = 0;
      this.game.EditObj.UnitSelected = -1;
    }

    pub fn RemoveXToMapLeft(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      let mut num1: i32 =  tempint - 1;
      for (let mut index1: i32 =  0; index1 <= num1; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
        {
          for (let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitCounter; unitCounter >= 0; unitCounter += -1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitList[unitCounter];
            data: DataClass = this.game.Data;
            let mut nr: i32 =  unit;
            let mut gameClass: GameClass = (GameClass) null;
             let mut local: GameClass =  gameClass;
            data.RemoveUnit(nr,  local);
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Location;
          if (location > -1)
            this.game.Data.RemoveLoc(location);
        }
      }
      let mut num2: i32 =  tempint;
      let mut mapWidth2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index3: i32 =  num2; index3 <= mapWidth2; index3 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index4: i32 =  0; index4 <= mapHeight; index4 += 1)
        {
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3 - tempint, index4] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4].Clone();
          let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3 - tempint, index4].UnitCounter;
          for (let mut index5: i32 =  0; index5 <= unitCounter; index5 += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3 - tempint, index4].UnitList[index5];
            this.game.Data.UnitObj[unit].X = index3 - tempint;
            this.game.Data.UnitObj[unit].Y = index4;
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3 - tempint, index4].Location;
          if (location > -1)
          {
            this.game.Data.LocObj[location].X = index3 - tempint;
            this.game.Data.LocObj[location].Y = index4;
          }
        }
      }
      let mut mapWidth3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index6: i32 =  0; index6 <= mapWidth3; index6 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index7: i32 =  0; index7 <= mapHeight; index7 += 1)
          hexClassArray[index6, index7] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index6, index7].Clone();
      }
      MapClass[] mapObj = this.game.Data.MapObj;
      MapClass[] mapClassArray = mapObj;
      let mut mapSelected: i32 =  this.game.EditObj.MapSelected;
      let mut index8: i32 =  mapSelected;
      mapClassArray[index8].MapWidth = mapObj[mapSelected].MapWidth - tempint;
      this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth4: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index9: i32 =  0; index9 <= mapWidth4; index9 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index10: i32 =  0; index10 <= mapHeight; index10 += 1)
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index9, index10] = hexClassArray[index9, index10].Clone();
      }
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index11: i32 =  0; index11 <= regimeCounter; index11 += 1)
      {
        this.game.Data.RegimeObj[index11].HistoryForce = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistoryOwner = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistorySFType = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistoryHis = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistoryDepth = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].AIVP = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].AIPower = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].AIDefense = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].MapCount = this.game.Data.MapCounter;
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index12: i32 =  0; index12 <= mapCounter; index12 += 1)
        {
          this.game.Data.RegimeObj[index11].HistoryForce[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistoryOwner[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistorySFType[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistoryHis[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistoryDepth[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].AIVP[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].AIPower[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].AIDefense[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
        }
      }
      this.game.SelectX = 0;
      this.game.SelectY = 0;
      this.game.CornerX = 0;
      this.game.CornerY = 0;
      this.game.EditObj.UnitSelected = -1;
    }

    pub fn AddYToMap(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapHeight1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
      let mut mapWidth1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight2; index2 += 1)
          hexClassArray[index1, index2] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Clone();
      }
      MapClass[] mapObj = this.game.Data.MapObj;
      MapClass[] mapClassArray = mapObj;
      let mut mapSelected: i32 =  this.game.EditObj.MapSelected;
      let mut index3: i32 =  mapSelected;
      mapClassArray[index3].MapHeight = mapObj[mapSelected].MapHeight + tempint;
      this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index4: i32 =  0; index4 <= mapWidth2; index4 += 1)
      {
        let mut mapHeight3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index5: i32 =  0; index5 <= mapHeight3; index5 += 1)
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index4, index5] = index5 <= mapHeight1 ? hexClassArray[index4, index5].Clone() : new HexClass(0, this.game.Data.RegimeCounter, this.game.Data.RegimeCounter);
      }
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index6: i32 =  0; index6 <= regimeCounter; index6 += 1)
      {
        this.game.Data.RegimeObj[index6].HistoryForce = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistoryOwner = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistorySFType = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistoryHis = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].HistoryDepth = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].AIVP = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].AIPower = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].AIDefense = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index6].MapCount = this.game.Data.MapCounter;
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index7: i32 =  0; index7 <= mapCounter; index7 += 1)
        {
          this.game.Data.RegimeObj[index6].HistoryForce[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistoryOwner[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistorySFType[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistoryHis[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].HistoryDepth[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].AIVP[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].AIPower[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
          this.game.Data.RegimeObj[index6].AIDefense[index7] = new MapMatrix2(this.game.Data.MapObj[index7].MapWidth, this.game.Data.MapObj[index7].MapHeight);
        }
      }
    }

    pub fn AddYToMapLeft(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      this.AddYToMap(tempint);
      let mut mapWidth: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth; index1 += 1)
      {
        for (let mut index2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight - tempint; index2 >= 0; index2 += -1)
        {
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2 + tempint] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Clone();
          let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2 + tempint].UnitCounter;
          for (let mut index3: i32 =  0; index3 <= unitCounter; index3 += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2 + tempint].UnitList[index3];
            this.game.Data.UnitObj[unit].X = index1;
            this.game.Data.UnitObj[unit].Y = index2 + tempint;
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2 + tempint].Location;
          if (location > -1)
          {
            this.game.Data.LocObj[location].X = index1;
            this.game.Data.LocObj[location].Y = index2 + tempint;
          }
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2] = new HexClass(0, this.game.Data.RegimeCounter, this.game.Data.RegimeCounter);
        }
      }
    }

    pub fn RemoveYToMap(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapHeight1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
      let mut mapWidth1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        let mut num: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight - tempint + 1;
        for (let mut index2: i32 =  mapHeight2; index2 >= num; index2 += -1)
        {
          for (let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitCounter; unitCounter >= 0; unitCounter += -1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitList[unitCounter];
            data: DataClass = this.game.Data;
            let mut nr: i32 =  unit;
            let mut gameClass: GameClass = (GameClass) null;
             let mut local: GameClass =  gameClass;
            data.RemoveUnit(nr,  local);
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Location;
          if (location > -1)
            this.game.Data.RemoveLoc(location);
        }
      }
      let mut mapWidth2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index3: i32 =  0; index3 <= mapWidth2; index3 += 1)
      {
        let mut mapHeight3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index4: i32 =  0; index4 <= mapHeight3; index4 += 1)
          hexClassArray[index3, index4] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4].Clone();
      }
      MapClass[] mapObj = this.game.Data.MapObj;
      MapClass[] mapClassArray = mapObj;
      let mut mapSelected: i32 =  this.game.EditObj.MapSelected;
      let mut index5: i32 =  mapSelected;
      mapClassArray[index5].MapHeight = mapObj[mapSelected].MapHeight - tempint;
      this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index6: i32 =  0; index6 <= mapWidth3; index6 += 1)
      {
        let mut mapHeight4: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index7: i32 =  0; index7 <= mapHeight4; index7 += 1)
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index6, index7] = index7 <= mapHeight1 ? hexClassArray[index6, index7].Clone() : new HexClass(0, this.game.Data.RegimeCounter, this.game.Data.RegimeCounter);
      }
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index8: i32 =  0; index8 <= regimeCounter; index8 += 1)
      {
        this.game.Data.RegimeObj[index8].HistoryForce = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistoryOwner = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistorySFType = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistoryHis = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].HistoryDepth = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].AIVP = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].AIPower = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].AIDefense = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index8].MapCount = this.game.Data.MapCounter;
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index9: i32 =  0; index9 <= mapCounter; index9 += 1)
        {
          this.game.Data.RegimeObj[index8].HistoryForce[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistoryOwner[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistorySFType[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistoryHis[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].HistoryDepth[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].AIVP[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].AIPower[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
          this.game.Data.RegimeObj[index8].AIDefense[index9] = new MapMatrix2(this.game.Data.MapObj[index9].MapWidth, this.game.Data.MapObj[index9].MapHeight);
        }
      }
      this.game.SelectX = 0;
      this.game.SelectY = 0;
      this.game.CornerX = 0;
      this.game.CornerY = 0;
      this.game.EditObj.UnitSelected = -1;
    }

    pub fn RemoveYToMapLeft(tempint: i32)
    {
      HexClass[,] hexClassArray = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapHeight1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
      let mut mapWidth1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth1; index1 += 1)
      {
        let mut num: i32 =  tempint - 1;
        for (let mut index2: i32 =  0; index2 <= num; index2 += 1)
        {
          for (let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitCounter; unitCounter >= 0; unitCounter += -1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].UnitList[unitCounter];
            data: DataClass = this.game.Data;
            let mut nr: i32 =  unit;
            let mut gameClass: GameClass = (GameClass) null;
             let mut local: GameClass =  gameClass;
            data.RemoveUnit(nr,  local);
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Location;
          if (location > -1)
            this.game.Data.RemoveLoc(location);
        }
      }
      let mut mapWidth2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index3: i32 =  0; index3 <= mapWidth2; index3 += 1)
      {
        let mut num: i32 =  tempint;
        let mut mapHeight2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index4: i32 =  num; index4 <= mapHeight2; index4 += 1)
        {
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4 - tempint] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4].Clone();
          let mut unitCounter: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4 - tempint].UnitCounter;
          for (let mut index5: i32 =  0; index5 <= unitCounter; index5 += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4 - tempint].UnitList[index5];
            this.game.Data.UnitObj[unit].X = index3;
            this.game.Data.UnitObj[unit].Y = index4 - tempint;
          }
          let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index3, index4 - tempint].Location;
          if (location > -1)
          {
            this.game.Data.LocObj[location].X = index3;
            this.game.Data.LocObj[location].Y = index4 - tempint;
          }
        }
      }
      let mut mapWidth3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index6: i32 =  0; index6 <= mapWidth3; index6 += 1)
      {
        let mut mapHeight3: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index7: i32 =  0; index7 <= mapHeight3; index7 += 1)
          hexClassArray[index6, index7] = this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index6, index7].Clone();
      }
      MapClass[] mapObj = this.game.Data.MapObj;
      MapClass[] mapClassArray = mapObj;
      let mut mapSelected: i32 =  this.game.EditObj.MapSelected;
      let mut index8: i32 =  mapSelected;
      mapClassArray[index8].MapHeight = mapObj[mapSelected].MapHeight - tempint;
      this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj = new HexClass[this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth + 1, this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight + 1];
      let mut mapWidth4: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index9: i32 =  0; index9 <= mapWidth4; index9 += 1)
      {
        let mut mapHeight4: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index10: i32 =  0; index10 <= mapHeight4; index10 += 1)
          this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index9, index10] = index10 <= mapHeight1 ? hexClassArray[index9, index10].Clone() : new HexClass(0, this.game.Data.RegimeCounter, this.game.Data.RegimeCounter);
      }
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index11: i32 =  0; index11 <= regimeCounter; index11 += 1)
      {
        this.game.Data.RegimeObj[index11].HistoryForce = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistoryOwner = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistorySFType = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistoryHis = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].HistoryDepth = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].AIVP = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].AIPower = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].AIDefense = new MapMatrix2[this.game.Data.MapCounter + 1];
        this.game.Data.RegimeObj[index11].MapCount = this.game.Data.MapCounter;
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index12: i32 =  0; index12 <= mapCounter; index12 += 1)
        {
          this.game.Data.RegimeObj[index11].HistoryForce[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistoryOwner[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistorySFType[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistoryHis[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].HistoryDepth[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].AIVP[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].AIPower[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
          this.game.Data.RegimeObj[index11].AIDefense[index12] = new MapMatrix2(this.game.Data.MapObj[index12].MapWidth, this.game.Data.MapObj[index12].MapHeight);
        }
      }
      this.game.SelectX = 0;
      this.game.SelectY = 0;
      this.game.CornerX = 0;
      this.game.CornerY = 0;
      this.game.EditObj.UnitSelected = -1;
    }

    pub fn CountLandHexesOnMap(map: i32) -> i32
    {
      let mut mapWidth: i32 =  this.game.Data.MapObj[map].MapWidth;
      num: i32;
      for (let mut index1: i32 =  0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[map].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
        {
          if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[index1, index2].LandscapeType].IsSea)
            num += 1;
        }
      }
      return num;
    }

    pub GetHexName: String(x: i32, y: i32, map: i32, bool excludeLabelIfNoLoc = false)
    {
      if (x < 0 | y < 0 | x > this.game.Data.MapObj[0].MapWidth | y > this.game.Data.MapObj[0].MapHeight)
        return "Unknown Hex";
      Left: String = this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].Name;
      if (this.game.Data.Product > 6)
        Left = Left + " (" + x.ToString() + "," + y.ToString() + ")";
      if (Strings.Len(this.game.Data.MapObj[map].HexObj[x, y].Name) > 0 && !excludeLabelIfNoLoc)
        Left = this.game.Data.MapObj[map].HexObj[x, y].Name;
      if (this.game.Data.MapObj[map].HexObj[x, y].Location > -1)
      {
        Left = Strings.Len(this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Name) <= 0 ? this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Type].Name : this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Name;
        if (Operators.CompareString(Left, ".", false) == 0)
        {
          Left = this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].Name;
          if (this.game.Data.Product > 6)
            Left = Left + " (" + x.ToString() + "," + y.ToString() + ")";
        }
      }
      else if (this.game.Data.MapObj[map].HexObj[x, y].Location2 > -1)
      {
        Left = Strings.Len(this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location2].Name) <= 0 ? this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location2].Type].Name : this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location2].Name;
        if (Operators.CompareString(Left, ".", false) == 0)
        {
          Left = this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].Name;
          if (this.game.Data.Product > 6)
            Left = Left + " (" + x.ToString() + "," + y.ToString() + ")";
        }
      }
      return Left;
    }

    pub fn GetProdPtsForLoc(locnr: i32, slot: i32, bool AddRem = false) -> i32
    {
      let mut type: i32 =  this.game.Data.LocObj[locnr].Type;
      let mut people: i32 =  this.game.Data.LocObj[locnr].People;
      index1: i32;
      regime: i32;
      if (this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime > -1)
      {
        index1 = this.game.Data.RegimeObj[this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime].People;
        regime = this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime;
      }
      else
        index1 = people;
      let mut prodPtsForLoc: i32 =   Math.Round( this.game.Data.LocTypeObj[type].MaxProd * ( this.game.Data.LocObj[locnr].ProdPercent[slot] / 100.0));
      let mut index2: i32 =  this.game.Data.LocObj[locnr].Production[slot];
      if (index2 > -1)
      {
        if (this.game.Data.ItemTypeObj[index2].UseProdMod <= 1)
          prodPtsForLoc =  Math.Round( ( prodPtsForLoc * this.game.Data.PeopleObj[people].ProdMod[this.game.Data.PeopleObj[index1].PeopleGroup]));
        if (this.game.Data.ItemTypeObj[index2].UseProdMod == 2)
          prodPtsForLoc =  Math.Round( ( prodPtsForLoc * this.game.Data.PeopleObj[people].ProdMod2[this.game.Data.PeopleObj[index1].PeopleGroup]));
        if (this.game.Data.ItemTypeObj[index2].UseProdMod == 3)
          prodPtsForLoc =  Math.Round( ( prodPtsForLoc * this.game.Data.PeopleObj[people].ProdMod3[this.game.Data.PeopleObj[index1].PeopleGroup]));
        if (this.game.Data.ItemTypeObj[index2].UseProdMod == 4)
          prodPtsForLoc =  Math.Round( ( prodPtsForLoc * this.game.Data.PeopleObj[people].ProdMod4[this.game.Data.PeopleObj[index1].PeopleGroup]));
      }
      else
        prodPtsForLoc = 0;
      if (regime > -1 && this.game.Data.RegimeObj[regime].ProdBonus != 0)
        prodPtsForLoc =  Math.Round( prodPtsForLoc * ( (this.game.Data.RegimeObj[regime].ProdBonus + 100) / 100.0));
      if (this.game.Data.LocTypeObj[type].StructuralPts > 0)
        prodPtsForLoc =  Math.Round( prodPtsForLoc * ( this.game.Data.LocObj[locnr].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts));
      if (AddRem)
        prodPtsForLoc += this.game.Data.LocObj[locnr].ProdPointRemainder[slot];
      return prodPtsForLoc;
    }

    pub fn GetProdPtsForLoc2(locnr: i32) -> i32
    {
      let mut type: i32 =  this.game.Data.LocObj[locnr].Type;
      let mut people: i32 =  this.game.Data.LocObj[locnr].People;
      index: i32;
      regime: i32;
      if (this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime > -1)
      {
        index = this.game.Data.RegimeObj[this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime].People;
        regime = this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime;
      }
      else
        index = people;
      let mut prodPtsForLoc2: i32 =   Math.Round( ( this.game.Data.LocTypeObj[type].MaxProd * this.game.Data.PeopleObj[people].ProdMod[this.game.Data.PeopleObj[index].PeopleGroup]));
      if (regime > -1 && this.game.Data.RegimeObj[regime].ProdBonus != 0)
        prodPtsForLoc2 =  Math.Round( prodPtsForLoc2 * ( (this.game.Data.RegimeObj[regime].ProdBonus + 100) / 100.0));
      if (this.game.Data.LocTypeObj[type].StructuralPts > 0)
        prodPtsForLoc2 =  Math.Round( prodPtsForLoc2 * ( this.game.Data.LocObj[locnr].StructuralPts /  this.game.Data.LocTypeObj[type].StructuralPts));
      return prodPtsForLoc2;
    }

    pub double GetEstimatedProduction(
      prodslot: i32,
      locnr: i32,
      bool withremainder,
      bool onlyremainder,
      bool dontshowregvar = false)
    {
      let mut index1: i32 =  this.game.Data.LocObj[locnr].Production[prodslot];
      let mut type: i32 =  this.game.Data.LocObj[locnr].Type;
      let mut regime: i32 =  this.game.Data.MapObj[this.game.Data.LocObj[locnr].Map].HexObj[this.game.Data.LocObj[locnr].X, this.game.Data.LocObj[locnr].Y].Regime;
      num1: i32;
      if (!onlyremainder)
      {
        num1 = this.GetProdPtsForLoc(locnr, prodslot);
        if (withremainder)
          num1 += this.game.Data.LocObj[locnr].ProdPointRemainder[prodslot];
      }
      else
      {
        num2: i32;
        num1 = num2 + this.game.Data.LocObj[locnr].ProdPointRemainder[prodslot];
      }
      if (this.game.Data.ItemTypeObj[this.game.Data.LocObj[locnr].Production[prodslot]].IsSupply)
        num1 =  Math.Round( ( num1 * this.game.Data.SupplyMultiplier));
      if (this.game.Data.ItemTypeObj[this.game.Data.LocObj[locnr].Production[prodslot]].IsResPt)
        num1 =  Math.Round( ( num1 * this.game.Data.PPMultiplier));
      let mut prodWeight: i32 =  this.game.Data.ItemTypeObj[index1].ProdWeight;
      double estimatedProduction = Math.Round( num1 /  prodWeight, 1);
      if (!dontshowregvar && this.game.Data.Turn > -1)
      {
        let mut index2: i32 =  0;
        do
        {
          if (this.game.Data.ItemTypeObj[index1].RegimeSlotsCost[index2] > -1 & this.game.Data.ItemTypeObj[index1].RegimeSlotsCostQty[index2] > 0)
          {
            let mut num3: i32 =  this.game.Data.RegimeObj[regime].RegimeSlot[this.game.Data.ItemTypeObj[index1].RegimeSlotsCost[index2]];
            let mut num4: i32 =  num3 <= 0 ? 0 :  Math.Round(Conversion.Int( num3 /  this.game.Data.ItemTypeObj[index1].RegimeSlotsCostQty[index2]));
            if (estimatedProduction >  num4)
              estimatedProduction =  num4;
          }
          index2 += 1;
        }
        while (index2 <= 4);
      }
      return estimatedProduction;
    }

    pub double GetEstimatedProduction(locnr: i32, itemtype: i32)
    {
      let mut num: i32 =  this.game.Data.LocTypeObj[this.game.Data.LocObj[locnr].Type].MaxProd;
      if (this.game.Data.ItemTypeObj[itemtype].IsSupply)
        num =  Math.Round( ( num * this.game.Data.SupplyMultiplier));
      if (this.game.Data.ItemTypeObj[itemtype].IsResPt)
        num =  Math.Round( ( num * this.game.Data.PPMultiplier));
      let mut prodWeight: i32 =  this.game.Data.ItemTypeObj[itemtype].ProdWeight;
      return  num /  prodWeight;
    }

    pub fn NumberOfOtherHQinHex(x: i32, y: i32, map: i32, currentunr: i32) -> i32
    {
      let mut num: i32 =  0;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        if (unit != currentunr && this.game.Data.UnitObj[unit].IsHQ)
          num += 1;
      }
      return num;
    }

    pub fn IDOfOtherHQinHex(x: i32, y: i32, map: i32, currentunr: i32) -> i32
    {
      let mut num: i32 =  -1;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter < 0)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
        if (unit != currentunr && this.game.Data.UnitObj[unit].IsHQ)
          num = unit;
      }
      return num;
    }

    pub fn CopyUnit(unr: i32, funr: i32, bool CopyName = true)
    {
      for (let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount; sfCount >= 0; sfCount += -1)
        this.game.Data.UnitObj[unr].RemoveSF(this.game.Data.UnitObj[unr].SFList[sfCount]);
      if (CopyName)
        this.game.Data.UnitObj[unr].Name = this.game.Data.UnitObj[funr].Name;
      this.game.Data.UnitObj[unr].SODefendPercent = this.game.Data.UnitObj[funr].SODefendPercent;
      this.game.Data.UnitObj[unr].SOReplacementPercent = this.game.Data.UnitObj[funr].SOReplacementPercent;
      this.game.Data.UnitObj[unr].SOInterceptRdnStop = this.game.Data.UnitObj[funr].SOInterceptRdnStop;
      this.game.Data.UnitObj[unr].SOSupReqPercent = this.game.Data.UnitObj[funr].SOSupReqPercent;
      this.game.Data.UnitObj[unr].Supply = this.game.Data.UnitObj[funr].Supply;
      this.game.Data.UnitObj[unr].IsHQ = this.game.Data.UnitObj[funr].IsHQ;
      this.game.Data.UnitObj[unr].HQ = this.game.Data.UnitObj[funr].HQ;
      if (this.game.Data.UnitObj[unr].X == -1)
      {
        this.game.Data.UnitObj[unr].SODefendPercent = 50;
        this.game.Data.UnitObj[unr].SOInterceptRdnStop = 100;
        this.game.Data.UnitObj[unr].SOSupReqPercent = 100;
        this.game.Data.UnitObj[unr].SOReplacementPercent = 100;
      }
      if (this.game.Data.UnitObj[funr].SFCount <= -1)
        return;
      let mut sfCount1: i32 =  this.game.Data.UnitObj[funr].SFCount;
      for (let mut index: i32 =  0; index <= sfCount1; index += 1)
      {
        SFClass sfClass = this.game.Data.SFObj[this.game.Data.UnitObj[funr].SFList[index]];
        this.game.HandyFunctionsObj.AddTroops3(unr, sfClass.Type, sfClass.People, sfClass.Qty, sfClass.Xp, sfClass.Rdn, sfClass.Ap, sfClass.Mor, MoveType: sfClass.MoveType, vigor: sfClass.Vigor);
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[this.game.Data.UnitObj[unr].SFCount];
        this.game.Data.SFObj[sf].CurrentEntrench = sfClass.CurrentEntrench;
        this.game.Data.SFObj[sf].MoveType = sfClass.MoveType;
      }
    }

    pub fn GetNextPreDefNr() -> i32
    {
      let mut nextPreDefNr: i32 =  0;
      if (this.game.Data.UnitCounter <= -1)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef > -1 && this.game.Data.UnitObj[index].PreDef >= nextPreDefNr)
          nextPreDefNr = this.game.Data.UnitObj[index].PreDef + 1;
      }
      return nextPreDefNr;
    }

    pub fn SetInitialXY(regnr: i32)
    {
      let mut num1: i32 =  -1;
      let mut num2: i32 =  0;
      let mut num3: i32 =  0;
      num4: i32;
      num5: i32;
      if (this.game.EditObj.Zoom == -1)
      {
        num4 = 27;
        num5 = 24;
      }
      if (this.game.EditObj.Zoom == 0)
      {
        num4 = 53;
        num5 = 48;
      }
      if (this.game.EditObj.Zoom == 1)
      {
        num4 = 106;
        num5 = 96;
      }
      if (this.game.Data.RegimeObj[regnr].UberRegime > -1)
        regnr = this.game.Data.RegimeObj[regnr].UberRegime;
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      num6: i32;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
          {
            if (this.game.Data.MapObj[index1].HexObj[index2, index3].Regime == regnr)
            {
              let mut location: i32 =  this.game.Data.MapObj[index1].HexObj[index2, index3].Location;
              if (location > -1 && this.game.Data.LocObj[location].StructuralPts + this.game.Data.MapObj[index1].HexObj[index2, index3].VP > num1)
              {
                num1 = this.game.Data.LocObj[location].StructuralPts + this.game.Data.MapObj[index1].HexObj[index2, index3].VP;
                num2 = index2;
                num3 = index3;
                num6 = index1;
              }
            }
          }
        }
      }
      let mut index4: i32 =  -1;
      let mut num7: i32 =  -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index5: i32 =  0; index5 <= unitCounter; index5 += 1)
      {
        if (this.game.Data.UnitObj[index5].Historical > -1 & this.game.Data.UnitObj[index5].X > -1 & this.game.Data.UnitObj[index5].PreDef == -1 & this.game.Data.UnitObj[index5].Regime == this.game.Data.Turn)
        {
          let mut historical: i32 =  this.game.Data.UnitObj[index5].Historical;
          if (this.game.Data.HistoricalUnitObj[historical].Type > num7)
          {
            num7 = this.game.Data.HistoricalUnitObj[historical].Type;
            index4 = index5;
          }
        }
      }
      if (index4 > -1)
      {
        num6 = 0;
        num2 = this.game.Data.UnitObj[index4].X;
        num3 = this.game.Data.UnitObj[index4].Y;
      }
      this.game.EditObj.MapSelected = num6;
      this.game.SelectX = num2;
      this.game.SelectY = num3;
      this.game.CornerX =  this.game.Data.RuleVar[839] != 1.0 ?  Math.Round( this.game.SelectX - ( (this.game.ScreenWidth - 200) / 2.0 - 0.0) /  num4) :  Math.Round( this.game.SelectX - ( this.game.ScreenWidth / 2.0 - 0.0) /  num4);
      let mut num8: i32 =  265;
      if (this.game.Data.Round == 0)
        num8 += 100;
      this.game.CornerY =  Math.Round( this.game.SelectY -  (this.game.ScreenHeight - num8) / 2.0 /  num5);
      if (0 > this.game.CornerX)
        this.game.CornerX = 0;
      if (0 > this.game.CornerY)
        this.game.CornerY = 0;
      this.SetCornerXY();
      if (!this.game.Data.MapObj[0].MapLoop)
        return;
      this.game.EditObj.MiniMapOffset = this.game.SelectX -  Math.Round(Math.Floor( this.game.Data.MapObj[0].MapWidth / 2.0));
      if (this.game.EditObj.MiniMapOffset < 0)
      {
        this.game.EditObj.MiniMapOffset = this.game.Data.MapObj[0].MapWidth + this.game.EditObj.MiniMapOffset;
        if (this.game.EditObj.MiniMapOffset < 0)
          this.game.EditObj.MiniMapOffset = 0;
        if ((this.game.EditObj.MiniMapOffset + 2) % 2 > 0)
          this += 1.game.EditObj.MiniMapOffset;
        if (this.game.EditObj.MiniMapOffset <= this.game.Data.MapObj[0].MapWidth)
          return;
        this.game.EditObj.MiniMapOffset = 0;
      }
      else
      {
        if ((this.game.EditObj.MiniMapOffset + 2) % 2 <= 0)
          return;
        this += 1.game.EditObj.MiniMapOffset;
      }
    }

    pub fn CenterOnXY(tx: i32, ty: i32, bool dontChangeHex = false, let mut useWidth: i32 =  -1, let mut useHeight: i32 =  -1)
    {
      num1: i32;
      num2: i32;
      if (this.game.EditObj.Zoom == -1)
      {
        num1 = 27;
        num2 = 24;
      }
      if (this.game.EditObj.Zoom == 0)
      {
        num1 = 53;
        num2 = 48;
      }
      if (this.game.EditObj.Zoom == 1)
      {
        num1 = 106;
        num2 = 96;
      }
      let mut num3: i32 =  this.game.ScreenWidth;
      let mut num4: i32 =  265;
      if (this.game.Data.Round == 0)
        num4 += 100;
      let mut num5: i32 =  this.game.ScreenHeight - num4;
      if ( this.game.Data.RuleVar[839] != 1.0)
        num3 -= 200;
      if (useWidth > -1)
      {
        num3 = useWidth;
        num5 = useHeight;
      }
      if (!dontChangeHex)
      {
        this.game.SelectX = tx;
        this.game.SelectY = ty;
      }
      this.game.CornerX =  this.game.Data.RuleVar[839] != 1.0 ?  Math.Round( tx - ( num3 / 2.0 - 0.0) /  num1) :  Math.Round( tx - ( num3 / 2.0 - 0.0) /  num1);
      this.game.CornerY =  Math.Round( ty - Math.Floor( num5 / 2.0 /  num2));
      if (!this.game.Data.MapObj[0].MapLoop)
      {
        if (0 > this.game.CornerX)
          this.game.CornerX = 0;
      }
      else if (0 > this.game.CornerX)
        this.game.CornerX = this.game.Data.MapObj[0].MapWidth + this.game.CornerX;
      if (-1 > this.game.CornerY)
        this.game.CornerY = -1;
      if (this.game.Data.Product > 5)
        return;
      this.SetCornerXY();
    }

    pub fn NextUnit()
    {
      let mut index: i32 =  this.game.EditObj.UnitSelected;
      do
      {
        index += 1;
        if (index > this.game.Data.UnitCounter)
          index = 0;
        if (!this.game.Data.UnitObj[index].DidMove & !this.game.Data.UnitObj[index].DidAttack && this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].X > -1 && this.game.Data.UnitObj[index].Regime == this.game.Data.Turn)
        {
          this.game.EditObj.UnitSelected = index;
          break;
        }
      }
      while (index != this.game.EditObj.UnitSelected);
    }

    pub fn NextUnit2()
    {
      let mut index: i32 =  this.game.EditObj.UnitSelected;
      do
      {
        --index;
        if (index < 0)
          index = this.game.Data.UnitCounter;
        if (!this.game.Data.UnitObj[index].DidMove & !this.game.Data.UnitObj[index].DidAttack && this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].X > -1 && this.game.Data.UnitObj[index].Regime == this.game.Data.Turn)
        {
          this.game.EditObj.UnitSelected = index;
          break;
        }
      }
      while (index != this.game.EditObj.UnitSelected);
    }

    pub fn AllHQToTopOutside(X: i32, Y: i32)
    {
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut index1: i32 =  0; index1 <= unitCounter1; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].IsHQ && this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].X > -1 && this.GetRegime(this.game.Data.UnitObj[index1].Regime) == this.GetRegime(this.game.Data.Turn))
        {
          let mut x: i32 =  this.game.Data.UnitObj[index1].X;
          let mut y: i32 =  this.game.Data.UnitObj[index1].Y;
          if (!(X == x & y == Y))
          {
            let mut num: i32 =  index1;
            index2: i32;
            while (this.game.Data.MapObj[index2].HexObj[x, y].UnitList[0] != num)
            {
              let mut unit: i32 =  this.game.Data.MapObj[index2].HexObj[x, y].UnitList[this.game.Data.MapObj[index2].HexObj[x, y].UnitCounter];
              index2 = 0;
              if (this.game.Data.MapObj[index2].HexObj[x, y].UnitCounter > 0)
              {
                for (let mut unitCounter2: i32 =  this.game.Data.MapObj[index2].HexObj[x, y].UnitCounter; unitCounter2 >= 1; unitCounter2 += -1)
                  this.game.Data.MapObj[index2].HexObj[x, y].UnitList[unitCounter2] = this.game.Data.MapObj[index2].HexObj[x, y].UnitList[unitCounter2 - 1];
              }
              this.game.Data.MapObj[index2].HexObj[x, y].UnitList[0] = unit;
            }
          }
        }
      }
    }

    pub fn SetcornerXY2(let mut useX: i32 =  -1, let mut useY: i32 =  -1, bool useZoom = false)
    {
      cornerX: i32;
      cornerY: i32;
      if (useX == -1)
      {
        useX = this.game.SelectX;
        useY = this.game.SelectY;
      }
      else
      {
        cornerX = this.game.CornerX;
        cornerY = this.game.CornerY;
      }
      num1: i32;
      num2: i32;
      if (this.game.EditObj.Zoom == -1)
      {
        num1 = 27;
        num2 = 24;
      }
      if (this.game.EditObj.Zoom == 0)
      {
        num1 = 53;
        num2 = 48;
      }
      if (this.game.EditObj.Zoom == 1)
      {
        num1 = 106;
        num2 = 96;
      }
      this.game.CornerX =  Math.Round( useX - ( this.game.ScreenWidth / 2.0 - 0.0) /  num1);
      let mut num3: i32 =  325;
      if (this.game.Data.Round == 0)
        num3 += 100;
      this.game.CornerY =  Math.Round( useY -  (this.game.ScreenHeight - num3) / 2.0 /  num2);
      if (this.game.Data.MapObj[0].MapLoop)
      {
        if (0 > this.game.CornerX)
          this.game.CornerX = this.game.Data.MapObj[0].MapWidth + this.game.CornerX;
        if (0 > this.game.CornerX)
          this.game.CornerX = 0;
      }
      else
      {
        if (0 > this.game.CornerX)
          this.game.CornerX = 0;
        this.SetCornerXY();
      }
      if (useX > -1)
      {
        num4: i32;
        num5: i32;
        if (!useZoom)
        {
          num4 = 53;
          num5 = 48;
        }
        else if (this.game.EditObj.Zoom == -1)
        {
          num4 = 26;
          num5 = 24;
        }
        else if (this.game.EditObj.Zoom == 0)
        {
          num4 = 53;
          num5 = 48;
        }
        else
        {
          num4 = 106;
          num5 = 96;
        }
        this.game.HandyFunctionsObj.Distance(this.game.CornerX, this.game.CornerY, 0, cornerX, cornerY, 0, 19);
        let mut val1: i32 =  Math.Abs(this.game.CornerX - cornerX);
        let mut num6: i32 =  Math.Abs(this.game.CornerY - cornerY);
        if (this.game.Data.MapObj[0].MapLoop)
          val1 = Math.Min(Math.Min(val1, Math.Abs(this.game.CornerX - (cornerX + this.game.Data.MapObj[0].MapWidth))), Math.Abs(this.game.CornerX + this.game.Data.MapObj[0].MapWidth) - cornerX);
        let mut num7: i32 =   Math.Round(Math.Floor( this.game.ScreenWidth /  (num4 * 2)));
        let mut num8: i32 =   Math.Round(Math.Floor( (this.game.ScreenHeight - num3) /  (num5 * 2)));
        let mut num9: i32 =  num7 - 2;
        let mut num10: i32 =  num8 - 1;
        if (val1 < num9 & num6 < num10)
        {
          this.game.CornerX = cornerX;
          this.game.CornerY = cornerY;
        }
      }
      if (-3 <= this.game.CornerY)
        return;
      this.game.CornerY = -3;
    }

    pub fn SetCornerXY()
    {
      let mut num1: i32 =  325;
      num2: i32;
      num3: i32;
      if (this.game.EditObj.Zoom == -1)
      {
        num2 = 27;
        num3 = 24;
      }
      if (this.game.EditObj.Zoom == 0)
      {
        num2 = 53;
        num3 = 48;
      }
      if (this.game.EditObj.Zoom == 1)
      {
        num2 = 106;
        num3 = 96;
      }
      if (this.game.Data.Round == 0)
        num1 += 100;
      let mut num4: i32 =   this.game.Data.RuleVar[839] != 1.0 ?  Math.Round( (this.game.ScreenWidth - 200) /  num2) :  Math.Round( this.game.ScreenWidth /  num2);
      let mut num5: i32 =   Math.Round( (this.game.ScreenHeight - num1) /  num3);
      let mut num6: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth - this.game.CornerX;
      let mut num7: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight - this.game.CornerY;
      if (num4 > num6)
        this.game.CornerX = this.game.CornerX - (num4 - num6) + 2;
      if (num5 > num7)
        this.game.CornerY = this.game.CornerY - (num5 - num7) + 1;
      if ((this.game.CornerX + 10) % 2 > 0)
        this += 1.game.CornerX;
      if (this.game.CornerY > -1 & (this.game.CornerY + 10) % 2 > 0)
        this += 1.game.CornerY;
      if (this.game.Data.MapObj[0].MapLoop)
      {
        if (0 > this.game.CornerX)
          this.game.CornerX = this.game.Data.MapObj[0].MapWidth + this.game.CornerX;
        if (0 > this.game.CornerX)
          this.game.CornerX = 0;
      }
      else if (0 > this.game.CornerX)
        this.game.CornerX = 0;
      if (-3 <= this.game.CornerY)
        return;
      this.game.CornerY = -3;
    }

    pub fn DoAirRecon(x: i32, y: i32, map: i32, tot: i32, unr: i32) => this.SetHexReconAndZOCUnitMoves(-1, -1, -1, x, y, map, this.game.Data.UnitObj[unr].Regime, unr, false, changezoc: false);

    pub CanUpgrade: bool(sfnr: i32, unr: i32, bool DontCheckHQ = false)
    {
      peopleGroup: i32;
      if (sfnr > -1)
        peopleGroup = this.game.Data.PeopleObj[this.game.Data.SFObj[sfnr].People].PeopleGroup;
      let mut upgradeToo: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeToo;
      let mut upgradeCost: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeCost;
      let mut upgradeXp: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeXP;
      if (upgradeToo == -1 || upgradeToo > this.game.Data.SFTypeCounter || upgradeXp > this.game.Data.SFObj[sfnr].Xp || !this.game.Data.SFTypeObj[upgradeToo].PeopleGroup[peopleGroup])
        return false;
      let mut num: i32 =  0;
      let mut itemTypeCounter: i32 =  this.game.Data.ItemTypeCounter;
      for (let mut itemtypenr: i32 =  0; itemtypenr <= itemTypeCounter; itemtypenr += 1)
      {
        if (this.game.Data.ItemTypeObj[itemtypenr].IsSFType == upgradeToo && this.CanProduceItem(-1, this.game.Data.UnitObj[unr].Regime, itemtypenr, this.game.Data.SFObj[sfnr].People, doblocks: false).result)
          num = 1;
      }
      return num != 0 && (DontCheckHQ || (!this.game.Data.UnitObj[unr].IsHQ ? this.game.Data.UnitObj[unr].HQ : unr) != -1);
    }

    pub fn CanUpgradeCost(sfnr: i32, unr: i32, qty: i32) -> i32
    {
      let mut peopleGroup: i32 =  this.game.Data.PeopleObj[this.game.Data.SFObj[sfnr].People].PeopleGroup;
      let mut upgradeToo: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeToo;
      let mut upgradeCost: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeCost;
      return this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeXP > this.game.Data.SFObj[sfnr].Xp || !this.game.Data.SFTypeObj[upgradeToo].PeopleGroup[peopleGroup] || (!this.game.Data.UnitObj[unr].IsHQ ? this.game.Data.UnitObj[unr].HQ : unr) == -1 ? -1 :  Math.Round( ( (upgradeCost * qty) / this.game.Data.RuleVar[77]));
    }

    pub fn CanUpgradeMax(sfnr: i32, unr: i32, hq: i32) -> i32
    {
      let mut peopleGroup: i32 =  this.game.Data.PeopleObj[this.game.Data.SFObj[sfnr].People].PeopleGroup;
      let mut upgradeToo: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeToo;
      let mut upgradeCost: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeCost;
      let mut upgradeXp: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeXP;
      if (hq == -1)
        return -1;
      return upgradeCost < 1 ? 9999 :  Math.Round( Conversion.Int( this.game.Data.UnitObj[hq].Supply / ( upgradeCost / this.game.Data.RuleVar[77])));
    }

    pub fn HQSupply(unr: i32) -> i32
    {
      let mut index: i32 =  !this.game.Data.UnitObj[unr].IsHQ ? this.game.Data.UnitObj[unr].HQ : unr;
      return index == -1 ? 0 : this.game.Data.UnitObj[index].Supply;
    }

    pub fn HQSupplyChain(unr: i32, bool recurse = false, let mut fromunit: i32 =  -1) -> i32
    {
      if (unr == -1)
        return 0;
      let mut unr1: i32 =  !(this.game.Data.UnitObj[unr].IsHQ & fromunit == -1) ? this.game.Data.UnitObj[unr].HQ : unr;
      if (unr1 == -1)
        return 0;
      num: i32;
      if (unr1 != unr)
      {
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.UnitObj[unr1].Regime,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y, this.game.Data.UnitObj[unr1].Map, allowshoredrop: true);
        num = this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
      }
      else
        num = 0;
      return  num <=  this.game.Data.RuleVar[53] ? Math.Max(this.game.Data.UnitObj[unr1].Supply, this.HQSupplyChain(unr1, true, unr)) : 0;
    }

    pub CanUpgrade: bool(sfnr: i32, unr: i32, qty: i32)
    {
      let mut peopleGroup: i32 =  this.game.Data.PeopleObj[this.game.Data.SFObj[sfnr].People].PeopleGroup;
      let mut upgradeToo: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeToo;
      let mut upgradeCost: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeCost;
      if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr].Type].UpgradeXP > this.game.Data.SFObj[sfnr].Xp || !this.game.Data.SFTypeObj[upgradeToo].PeopleGroup[peopleGroup])
        return false;
      let mut index: i32 =  !this.game.Data.UnitObj[unr].IsHQ ? this.game.Data.UnitObj[unr].HQ : unr;
      if (index == -1)
        return false;
      let mut num: i32 =  upgradeCost * qty;
      return this.game.Data.UnitObj[index].Supply >= num;
    }

    pub fn CanSwap(sfnr1: i32, sfnr2: i32) -> i32
    {
      if (this.game.Data.SFObj[sfnr1].People != this.game.Data.SFObj[sfnr2].People)
        return 0;
      let mut unitGroup: i32 =  this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr1].Type].UnitGroup;
      unitGroup = this.game.Data.SFTypeObj[this.game.Data.SFObj[sfnr2].Type].UnitGroup;
      let mut qty: i32 =  this.game.Data.SFObj[sfnr1].Qty;
      if (this.game.Data.SFObj[sfnr2].Qty < qty)
        qty = this.game.Data.SFObj[sfnr2].Qty;
      return qty;
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    pub GetNavyUnitForProduction: i32(
      x: i32,
      y: i32,
      map: i32,
      sftype: i32,
      ppl: i32,
      movetype: i32)
    {
      let mut unitForProduction1: i32 =  -1;
      let mut location: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Location;
      if (location == -1)
      {
        let mut num: i32 =   Interaction.MsgBox( "Location does not exist", Title: ( "Shadow Empire : Planetary Conquest"));
        ProjectData.EndApp();
      }
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.game.Data.UnitObj[unit].IsHQ)
            unitForProduction1 = unit;
        }
      }
      if (unitForProduction1 > -1)
        return unitForProduction1;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.game.Data.UnitObj[unit].SFCount + this.game.Data.UnitObj[unit].PassengerCounter + 1 < 6 | this.game.Data.UnitObj[unit].IsHQ && this.CanAddTroops(unit, sftype, ppl, movetype) && this.HasUnitNavySF(unit))
            unitForProduction1 = unit;
        }
      }
      if (unitForProduction1 > -1)
        return unitForProduction1;
      if (!this.game.Data.RegimeObj[this.game.Data.Turn].AI)
      {
        if ( this.game.Data.RuleVar[332] == 0.0 && this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
        {
          let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter; index += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
            if (this.game.Data.UnitObj[unit].HQ == this.game.Data.LocObj[location].HQ && this.game.Data.UnitObj[unit].SFCount + this.game.Data.UnitObj[unit].PassengerCounter + 1 < 6 | this.game.Data.UnitObj[unit].IsHQ && this.CanAddTroops(unit, sftype, ppl, movetype))
              unitForProduction1 = unit;
          }
        }
        if (unitForProduction1 > -1)
          return unitForProduction1;
        if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
        {
          let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter; index += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
            if (this.game.Data.UnitObj[unit].SFCount + this.game.Data.UnitObj[unit].PassengerCounter + 1 < 6 | this.game.Data.UnitObj[unit].IsHQ && this.CanAddTroops(unit, sftype, ppl, movetype))
              unitForProduction1 = unit;
          }
        }
        if (unitForProduction1 > -1)
          return unitForProduction1;
      }
      else if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.game.Data.UnitObj[unit].SFCount == -1 && this.game.Data.UnitObj[unit].AIUnitGoal == 8 | this.game.Data.UnitObj[unit].AIUnitGoal == 9 | this.game.Data.UnitObj[unit].AIUnitGoal == 10 && this.game.Data.UnitObj[unit].SFCount + this.game.Data.UnitObj[unit].PassengerCounter + 1 < 6 | this.game.Data.UnitObj[unit].IsHQ && this.CanAddTroops(unit, sftype, ppl, movetype))
            ;
        }
      }
      unitForProduction2: i32;
      if ( this.game.Data.RegimeObj[this.game.Data.MapObj[map].HexObj[x, y].Regime].ResPts >=  this.game.Data.RuleVar[46])
      {
        this.game.ProcessingObj.NewUnit(x, y, 0, false, this.game.Data.MapObj[map].HexObj[x, y].Regime);
        unitForProduction2 = this.game.Data.UnitCounter;
        this.game.Data.UnitObj[unitForProduction2].HQ = this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].HQ;
        this.game.Data.UnitObj[unitForProduction2].SetAPToZero = 1;
      }
      else
        unitForProduction2 = -1;
      return unitForProduction2;
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    pub fn GetAnyUnitForProduction(x: i32, y: i32, map: i32, sftype: i32, ppl: i32, movetype: i32) -> i32
    {
      let mut unitForProduction1: i32 =  -1;
      if (this.game.Data.MapObj[map].HexObj[x, y].Location == -1)
      {
        let mut num: i32 =   Interaction.MsgBox( "Location does not exist", Title: ( "Shadow Empire : Planetary Conquest"));
        ProjectData.EndApp();
      }
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.game.Data.UnitObj[unit].IsHQ)
            unitForProduction1 = unit;
        }
      }
      if (unitForProduction1 > -1)
        return unitForProduction1;
      if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.HasUnitSFType(unit, sftype) && this.CanAddTroops(unit, sftype, ppl, movetype) && this.HasUnitNavySF(unit))
            unitForProduction1 = unit;
        }
      }
      if (unitForProduction1 > -1)
        return unitForProduction1;
      if (!this.game.Data.RegimeObj[this.game.Data.Turn].AI)
      {
        if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
        {
          let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter; index += 1)
          {
            let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
            if (this.game.Data.UnitObj[unit].SFCount + this.game.Data.UnitObj[unit].PassengerCounter + 1 < 6 | this.game.Data.UnitObj[unit].IsHQ && this.CanAddTroops(unit, sftype, ppl, movetype))
              unitForProduction1 = unit;
          }
        }
        if (unitForProduction1 > -1)
          return unitForProduction1;
      }
      else if (this.game.Data.MapObj[map].HexObj[x, y].UnitCounter > -1)
      {
        let mut unitCounter: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitCounter;
        for (let mut index: i32 =  0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 =  this.game.Data.MapObj[map].HexObj[x, y].UnitList[index];
          if (this.game.Data.UnitObj[unit].SFCount == -1 && this.game.Data.UnitObj[unit].AIUnitGoal == 8 | this.game.Data.UnitObj[unit].AIUnitGoal == 9 | this.game.Data.UnitObj[unit].AIUnitGoal == 10 && this.game.Data.UnitObj[unit].SFCount + this.game.Data.UnitObj[unit].PassengerCounter + 1 < 6 | this.game.Data.UnitObj[unit].IsHQ && this.CanAddTroops(unit, sftype, ppl, movetype))
            ;
        }
      }
      unitForProduction2: i32;
      if ( this.game.Data.RegimeObj[this.game.Data.MapObj[map].HexObj[x, y].Regime].ResPts >=  this.game.Data.RuleVar[46])
      {
        this.game.ProcessingObj.NewUnit(x, y, 0, false, this.game.Data.MapObj[map].HexObj[x, y].Regime);
        unitForProduction2 = this.game.Data.UnitCounter;
        this.game.Data.UnitObj[unitForProduction2].HQ = this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].HQ;
        this.game.Data.UnitObj[unitForProduction2].SetAPToZero = 1;
      }
      else
        unitForProduction2 = -1;
      return unitForProduction2;
    }

    pub fn GetProdTotalPercent(locnr: i32) -> i32
    {
      let mut index: i32 =  0;
      prodTotalPercent: i32;
      do
      {
        prodTotalPercent += this.game.Data.LocObj[locnr].ProdPercent[index];
        index += 1;
      }
      while (index <= 3);
      return prodTotalPercent;
    }

    pub fn GetCapPts(unr: i32, theater: i32) -> i32
    {
      capPts: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == theater)
            capPts += this.game.Data.SFTypeObj[type].Cap * this.game.Data.SFObj[sf].Qty;
        }
      }
      return capPts;
    }

    pub fn GetInterdictPower(unr: i32) -> i32
    {
      interdictPower: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
          let mut type: i32 =  this.game.Data.SFObj[sf].Type;
          if (this.game.Data.SFTypeObj[type].Theater == 2 & !this.game.Data.SFTypeObj[type].BackBench)
            interdictPower += this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty;
        }
      }
      return interdictPower;
    }

    pub void MakeFuzzyOwner(
      bool real,
      bool supplyLayerMode,
      forRegime: i32,
      bool switchFirstTurnIfNotRegime = false)
    {
      let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
      let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
      numArray1: Vec<i32> = new int[mapWidth + 1, mapHeight + 1];
      numArray2: Vec<i32> = new int[mapWidth + 1, mapHeight + 1];
      let mut num1: i32 =   Math.Round(Conversion.Val( this.game.Data.RuleVar[456]));
      this.game.EditObj.resourceVpCacheSet = false;
      let mut num2: i32 =  mapWidth;
      for (let mut x: i32 =  0; x <= num2; x += 1)
      {
        let mut num3: i32 =  mapHeight;
        for (let mut y: i32 =  0; y <= num3; y += 1)
        {
          numArray1[x, y] = -1;
          let mut num4: i32 =  0;
          let mut num5: i32 =  0;
          let mut num6: i32 =  -1;
          if (x == 56 & y == 6)
            x = x;
          if (this.game.Data.MapObj[0].HexObj[x, y].Location2 > -1)
          {
            if (this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location2].Type].isSupplyBase)
              num4 = 1;
            if (this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location2].Type].isSupplySource)
              num4 = 1;
          }
          if (this.game.Data.MapObj[0].HexObj[x, y].UnitCounter > -1)
          {
            let mut regime: i32 =  this.game.Data.UnitObj[this.game.Data.MapObj[0].HexObj[x, y].UnitList[0]].Regime;
            if (regime == forRegime)
            {
              num4 = 1;
              num6 = regime;
            }
            else if (this.VisibleEnemyUnitsInHex(x, y, 0, forRegime))
            {
              num4 = 1;
              num6 = regime;
            }
            else if (real)
            {
              if (!this.IsAlliedOrSelf(forRegime, regime))
              {
                num4 = 1;
                num6 = regime;
              }
            }
            else if (this.game.Data.MapObj[0].HexObj[x, y].VP > 0)
              num4 = 1;
            else if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[x, y].LandscapeType].FuzzyOwnerAssured)
              num4 = 1;
          }
          else if (this.game.Data.MapObj[0].HexObj[x, y].VP > 0)
            num4 = 1;
          else if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[x, y].LandscapeType].FuzzyOwnerAssured)
            num4 = 1;
          if (this.game.Data.MapObj[0].HexObj[x, y].FuzzyBlock == 1 && !real)
          {
            if (!real & !supplyLayerMode)
              num5 = 1;
            else if (!real & supplyLayerMode)
            {
              switch (num1)
              {
                case 1:
                  if (this.HasHexRoad(x, y, 0))
                  {
                    num5 = 1;
                    break;
                  }
                  break;
                case 2:
                  num5 = 1;
                  break;
              }
            }
          }
          if (num4 == 1 && this.game.Data.MapObj[0].HexObj[x, y].Regime > -1)
          {
            numArray1[x, y] = this.game.Data.MapObj[0].HexObj[x, y].Regime;
            if (num6 > -1)
              numArray1[x, y] = num6;
          }
          if (num5 == 1)
          {
            numArray2[x, y] = 1;
            numArray1[x, y] = -1;
            if (num6 > -1)
              numArray1[x, y] = num6;
          }
        }
      }
      bool flag1 = true;
      let mut num7: i32 =  -1;
      numArray3: Vec<i32> = new int[mapWidth + 1, mapHeight + 1];
      numArray4: Vec<i32> = new int[mapWidth + 1, mapHeight + 1];
      let mut num8: i32 =  mapWidth;
      Coordinate coordinate;
      while (flag1)
      {
        num7 += 1;
        flag1 = false;
        let mut num9: i32 =  1;
        do
        {
          let mut num10: i32 =  num8;
          for (let mut cx: i32 =  0; cx <= num10; cx += 1)
          {
            let mut num11: i32 =  mapHeight;
            for (let mut cy: i32 =  0; cy <= num11; cy += 1)
            {
              if (numArray3[cx, cy] == num7 && numArray1[cx, cy] > -1 && !switchFirstTurnIfNotRegime & (numArray1[cx, cy] == forRegime & num9 == 2 | numArray1[cx, cy] != forRegime & num9 == 1) | switchFirstTurnIfNotRegime & (numArray1[cx, cy] == forRegime & num9 == 1 | numArray1[cx, cy] != forRegime & num9 == 2))
              {
                let mut tfacing: i32 =  1;
                do
                {
                  coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                  if (coordinate.onmap && numArray3[coordinate.x, coordinate.y] == 0 && num9 == 1 | num9 == 2 & numArray2[coordinate.x, coordinate.y] == 0 && numArray1[coordinate.x, coordinate.y] == -1 && this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1 && !(this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[0].HexObj[cx, cy].Bridge[tfacing - 1]))
                  {
                    numArray1[coordinate.x, coordinate.y] = numArray1[cx, cy];
                    flag1 = true;
                    numArray3[coordinate.x, coordinate.y] = num7 + 1;
                    numArray4[coordinate.x, coordinate.y] = 1;
                  }
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
          num9 += 1;
        }
        while (num9 <= 2);
        if (num7 > 9999)
          break;
      }
      bool flag2 = true;
      let mut num12: i32 =  -1;
      numArray5: Vec<i32> = new int[num8 + 1, mapHeight + 1];
      while (flag2)
      {
        num12 += 1;
        flag2 = false;
        let mut num13: i32 =  1;
        do
        {
          let mut num14: i32 =  num8;
          for (let mut cx: i32 =  0; cx <= num14; cx += 1)
          {
            let mut num15: i32 =  mapHeight;
            for (let mut cy: i32 =  0; cy <= num15; cy += 1)
            {
              if (numArray5[cx, cy] == num12 && numArray1[cx, cy] > -1 && !switchFirstTurnIfNotRegime & (numArray1[cx, cy] == forRegime & num13 == 2 | numArray1[cx, cy] != forRegime & num13 == 1) | switchFirstTurnIfNotRegime & (numArray1[cx, cy] == forRegime & num13 == 1 | numArray1[cx, cy] != forRegime & num13 == 2))
              {
                if (!(num13 == 1 & numArray4[cx, cy] > 0 & num12 == 0))
                {
                  let mut tfacing: i32 =  1;
                  do
                  {
                    coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                    if (coordinate.onmap && numArray5[coordinate.x, coordinate.y] == 0 && num13 == 1 | num13 == 2 & numArray2[coordinate.x, coordinate.y] == 0 && numArray1[coordinate.x, coordinate.y] == -1)
                    {
                      numArray1[coordinate.x, coordinate.y] = numArray1[cx, cy];
                      flag2 = true;
                      numArray5[coordinate.x, coordinate.y] = num12 + 1;
                    }
                    tfacing += 1;
                  }
                  while (tfacing <= 6);
                }
                else
                  numArray5[cx, cy] = num12 + 1;
              }
            }
          }
          num13 += 1;
        }
        while (num13 <= 2);
        if (num12 > 9999)
          break;
      }
      let mut num16: i32 =  num8;
      for (let mut index1: i32 =  0; index1 <= num16; index1 += 1)
      {
        let mut num17: i32 =  mapHeight;
        for (let mut index2: i32 =  0; index2 <= num17; index2 += 1)
        {
          if (index1 == 12 & index2 == 11)
            index1 = index1;
          this.game.Data.MapObj[0].HexObj[index1, index2].Regime = numArray1[index1, index2];
        }
      }
    }

    pub fn MakeSupplyLayer(unr: i32, bool enemypenalty = false)
    {
      this.RedimTempSup(9999);
      this.RedimTempSupCameFrom();
      bool useTrafficRules = false;
      float trafficPointMod = 0.0f;
      if ( this.game.Data.RuleVar[459] > 0.0 & this.game.Data.Product >= 6)
      {
        useTrafficRules = true;
        if ( this.game.Data.RuleVar[487] > 0.0 &  this.game.Data.RuleVar[487] < 100.0)
        {
          float num =  (100 -  Math.Round( (this.game.Data.RuleVar[487] / 3f))) / 100f;
          trafficPointMod = 1f;
        }
      }
      this.game.EditObj.SupplyPath = (CoordList) null;
      this.game.EditObj.RightClickX = -1;
      if (unr <= -1)
        return;
      let mut movetype: i32 =   Math.Round( this.game.Data.RuleVar[99]);
      SimpleList simpleList = SimpleList::new();
      let mut hq: i32 =  this.game.Data.UnitObj[unr].HQ;
      this.game.HandyFunctionsObj.RedimTempValue(0);
      num1: i32;
      if ( this.game.Data.RuleVar[324] == 1.0)
      {
        for (; hq > -1; hq = this.game.Data.UnitObj[hq].HQ)
          simpleList.Add(hq, 1);
        for (let mut counter: i32 =  simpleList.Counter; counter >= 0; counter += -1)
        {
          let mut index1: i32 =  simpleList.Id[counter];
          if (counter < simpleList.Counter)
            num1 = this.game.EditObj.TempValue[this.game.Data.UnitObj[index1].Map].Value[this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y];
          if ( this.game.Data.RuleVar[455] > 0.0)
            this.MakeFuzzyOwner(false, true, this.game.Data.Turn);
          this.MakeMovePrediction2(this.game.Data.UnitObj[index1].Regime, movetype, 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, this.game.Data.UnitObj[index1].Map, allowshoredrop: true, SeaBlock: true, EnemyPenalty: enemypenalty, IsForSupplyLayer: true, useTrafficRules: true);
          if ( this.game.EditObj.TempValue[this.game.Data.UnitObj[unr].Map].Value[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] <=  this.game.Data.RuleVar[3])
          {
            if (counter < simpleList.Counter)
            {
              let mut mapCounter: i32 =  this.game.Data.MapCounter;
              for (let mut index2: i32 =  0; index2 <= mapCounter; index2 += 1)
              {
                let mut mapWidth: i32 =  this.game.Data.MapObj[index2].MapWidth;
                for (let mut index3: i32 =  0; index3 <= mapWidth; index3 += 1)
                {
                  let mut mapHeight: i32 =  this.game.Data.MapObj[index2].MapHeight;
                  for (let mut index4: i32 =  0; index4 <= mapHeight; index4 += 1)
                  {
                    numArray1: Vec<i32> = this.game.EditObj.TempValue[index2].Value;
                    numArray2: Vec<i32> = numArray1;
                    let mut index5: i32 =  index3;
                    let mut index6: i32 =  index5;
                    let mut index7: i32 =  index4;
                    let mut index8: i32 =  index7;
                    let mut num2: i32 =  numArray1[index5, index7] + num1;
                    numArray2[index6, index8] = num2;
                  }
                }
              }
            }
            num1 = this.game.EditObj.TempValue[this.game.Data.UnitObj[unr].Map].Value[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
          }
          else
            break;
        }
      }
      if ( this.game.Data.RuleVar[455] > 0.0)
        this.MakeFuzzyOwner(false, true, this.game.Data.Turn);
      this.game.EditObj.LayerSupplyAP =  Math.Round( this.game.Data.RuleVar[3]);
      this.MakeMovePrediction2(this.game.Data.UnitObj[unr].Regime, movetype, 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, allowshoredrop: true, SeaBlock: true, EnemyPenalty: enemypenalty, IsForSupplyLayer: true, useTrafficRules: useTrafficRules, trafficPointMod: trafficPointMod);
      if ( this.game.Data.RuleVar[324] == 1.0)
      {
        let mut mapCounter: i32 =  this.game.Data.MapCounter;
        for (let mut index9: i32 =  0; index9 <= mapCounter; index9 += 1)
        {
          let mut mapWidth: i32 =  this.game.Data.MapObj[index9].MapWidth;
          for (let mut index10: i32 =  0; index10 <= mapWidth; index10 += 1)
          {
            let mut mapHeight: i32 =  this.game.Data.MapObj[index9].MapHeight;
            for (let mut index11: i32 =  0; index11 <= mapHeight; index11 += 1)
            {
              numArray3: Vec<i32> = this.game.EditObj.TempValue[index9].Value;
              numArray4: Vec<i32> = numArray3;
              let mut index12: i32 =  index10;
              let mut index13: i32 =  index12;
              let mut index14: i32 =  index11;
              let mut index15: i32 =  index14;
              let mut num3: i32 =  numArray3[index12, index14] + num1;
              numArray4[index13, index15] = num3;
            }
          }
        }
      }
      let mut mapCounter1: i32 =  this.game.Data.MapCounter;
      for (let mut index16: i32 =  0; index16 <= mapCounter1; index16 += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[index16].MapWidth;
        for (let mut index17: i32 =  0; index17 <= mapWidth; index17 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index16].MapHeight;
          for (let mut index18: i32 =  0; index18 <= mapHeight; index18 += 1)
          {
            if (this.game.EditObj.TempSup[index16].Value[index17, index18] > 9998 & this.game.EditObj.TempValue[index16].Value[index17, index18] < 9999)
            {
              this.game.EditObj.TempSup[index16].Value[index17, index18] = this.game.EditObj.TempValue[index16].Value[index17, index18];
              this.game.EditObj.TempSupCameFrom[index16].Value[index17, index18] = this.game.EditObj.TempCameFrom[index16].Value[index17, index18];
            }
          }
        }
      }
    }

    pub fn MakeSupplyLayer3(x: i32, y: i32, map: i32, bool enemypenalty = false, bool fastMode = false)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.RedimTempSup(9999);
      this.RedimTempSupCameFrom();
      bool useTrafficRules = false;
      float trafficPointMod = 0.0f;
      if ( this.game.Data.RuleVar[459] > 0.0 & this.game.Data.Product >= 6)
      {
        useTrafficRules = true;
        if ( this.game.Data.RuleVar[487] > 0.0 &  this.game.Data.RuleVar[487] < 100.0)
        {
          float num =  (100 -  Math.Round( (this.game.Data.RuleVar[487] / 3f))) / 100f;
          trafficPointMod = 1f;
        }
      }
      this.game.EditObj.SupplyPath = (CoordList) null;
      this.game.EditObj.RightClickX = -1;
      let mut num1: i32 =   Math.Round( this.game.Data.RuleVar[99]);
      this.game.HandyFunctionsObj.RedimTempValue(0);
      if ( this.game.Data.RuleVar[455] > 0.0 & !fastMode)
      {
        if (this.game.Data.MapObj[0].HexObj[x, y].Regime != this.game.Data.Turn & this.game.Data.MapObj[0].HexObj[x, y].Regime > -1)
          this.MakeFuzzyOwner(false, true, this.game.Data.Turn, true);
        else
          this.MakeFuzzyOwner(false, true, this.game.Data.Turn);
      }
      let mut num2: i32 =  -1;
      if (x > -1 & y > -1)
        num2 = this.game.Data.MapObj[map].HexObj[x, y].Regime;
      if (num2 == -1)
        num2 = this.game.Data.Turn;
      let mut movetype: i32 =   Math.Round( this.game.Data.RuleVar[99]);
      let mut ap: i32 =   Math.Round( this.game.Data.RuleVar[3]);
      this.game.EditObj.LayerSupplyAP = ap;
      index1: i32;
      let mut mapWidth1: i32 =  this.game.Data.MapObj[index1].MapWidth;
      for (let mut x1: i32 =  0; x1 <= mapWidth1; x1 += 1)
      {
        let mut mapHeight1: i32 =  this.game.Data.MapObj[index1].MapHeight;
        for (let mut y1: i32 =  0; y1 <= mapHeight1; y1 += 1)
        {
          if (this.game.Data.MapObj[0].HexObj[x1, y1].Regime == num2)
          {
            let mut location2: i32 =  this.game.Data.MapObj[0].HexObj[x1, y1].Location2;
            if (location2 > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location2].Type].isSupplySource)
            {
              if (!fastMode)
                this.MakeMovePrediction2(num2, movetype, 99, ap, x1, y1, 0, allowshoredrop: true, EnemyPenalty: enemypenalty, IsForSupplyLayer: true, useTrafficRules: useTrafficRules, trafficPointMod: trafficPointMod);
              else
                this.MakeMovePredictionSimple(num2, movetype, x1, y1);
              let mut mapWidth2: i32 =  this.game.Data.MapObj[index1].MapWidth;
              for (let mut index2: i32 =  0; index2 <= mapWidth2; index2 += 1)
              {
                let mut mapHeight2: i32 =  this.game.Data.MapObj[index1].MapHeight;
                for (let mut index3: i32 =  0; index3 <= mapHeight2; index3 += 1)
                {
                  if (this.game.EditObj.TempValue[index1].Value[index2, index3] < 9999)
                  {
                    if (this.game.EditObj.TempSup[index1].Value[index2, index3] > this.game.EditObj.TempValue[index1].Value[index2, index3])
                    {
                      numArray[index2, index3] = this.game.EditObj.TempValueSpecial2[index1].Value[index2, index3];
                      this.game.EditObj.TempSup[index1].Value[index2, index3] = this.game.EditObj.TempValue[index1].Value[index2, index3];
                      this.game.EditObj.TempSupCameFrom[index1].Value[index2, index3] = this.game.EditObj.TempCameFrom[index1].Value[index2, index3];
                    }
                    else if (this.game.EditObj.TempSup[index1].Value[index2, index3] == this.game.EditObj.TempValue[index1].Value[index2, index3] && numArray[index2, index3] > 0 & numArray[index2, index3] < this.game.EditObj.TempValueSpecial2[index1].Value[index2, index3])
                    {
                      numArray[index2, index3] = this.game.EditObj.TempValueSpecial2[index1].Value[index2, index3];
                      this.game.EditObj.TempSup[index1].Value[index2, index3] = this.game.EditObj.TempValue[index1].Value[index2, index3];
                      this.game.EditObj.TempSupCameFrom[index1].Value[index2, index3] = this.game.EditObj.TempCameFrom[index1].Value[index2, index3];
                    }
                  }
                }
              }
            }
          }
        }
      }
      let mut mapWidth3: i32 =  this.game.Data.MapObj[index1].MapWidth;
      for (let mut index4: i32 =  0; index4 <= mapWidth3; index4 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
        for (let mut index5: i32 =  0; index5 <= mapHeight; index5 += 1)
        {
          if (numArray[index4, index5] > this.game.EditObj.TempValueSpecial2[index1].Value[index4, index5])
            this.game.EditObj.TempValueSpecial2[index1].Value[index4, index5] = numArray[index4, index5];
        }
      }
    }

    pub fn MakeSupplyLayer2(x: i32, y: i32, map: i32, bool enemypenalty = false)
    {
      this.game.EditObj.SupplyPath = (CoordList) null;
      this.game.EditObj.RightClickX = -1;
      bool useTrafficRules = false;
      if ( this.game.Data.RuleVar[459] > 0.0 & this.game.Data.Product >= 6)
        useTrafficRules = true;
      this.RedimTempSup(9999);
      this.RedimTempSupCameFrom();
      let mut movetype: i32 =   Math.Round( this.game.Data.RuleVar[99]);
      bool blockLogisticalBonus = false;
      float trafficPointMod = 0.0f;
      if ( this.game.Data.RuleVar[487] > 0.0 &  this.game.Data.RuleVar[487] < 100.0)
      {
        float num =  (100 -  Math.Round( (this.game.Data.RuleVar[487] / 3f))) / 100f;
        trafficPointMod = 1f;
      }
      num1: i32;
      if (num1 != this.game.Data.Turn &  this.game.Data.RuleVar[890] > 0.0)
        movetype =  Math.Round( this.game.Data.RuleVar[890]);
      let mut ap: i32 =   Math.Round( this.game.Data.RuleVar[3]);
      if ( this.game.Data.RuleVar[462] > 0.0 && this.game.Data.MapObj[0].HexObj[x, y].Location2 > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location2].Type].isSupplyBase)
      {
        ap = this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location2].Type].supplyRange;
        blockLogisticalBonus = true;
      }
      if ( this.game.Data.RuleVar[455] > 0.0)
      {
        if (this.game.Data.MapObj[0].HexObj[x, y].Regime != this.game.Data.Turn & this.game.Data.MapObj[0].HexObj[x, y].Regime > -1)
          this.MakeFuzzyOwner(false, true, this.game.Data.Turn, true);
        else
          this.MakeFuzzyOwner(false, true, this.game.Data.Turn);
      }
      let mut byregnr: i32 =  this.game.Data.MapObj[map].HexObj[x, y].Regime;
      if (byregnr == -1)
        byregnr = this.game.Data.Turn;
      this.game.EditObj.LayerSupplyAP = ap;
      if (byregnr != this.game.Data.Turn &  this.game.Data.RuleVar[890] > 0.0)
        this.MakeMovePrediction2(byregnr, movetype, 99, ap, x, y, map, allowshoredrop: true, EnemyPenalty: enemypenalty, IsForSupplyLayer: true, useTrafficRules: useTrafficRules, blockLogisticalBonus: blockLogisticalBonus, trafficPointMod: trafficPointMod);
      else
        this.MakeMovePrediction2(byregnr, movetype, 99, ap, x, y, map, allowshoredrop: true, EnemyPenalty: enemypenalty, IsForSupplyLayer: true, useTrafficRules: useTrafficRules, blockLogisticalBonus: blockLogisticalBonus, trafficPointMod: trafficPointMod);
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
          {
            if (this.game.EditObj.TempSup[index1].Value[index2, index3] > 9998 & this.game.EditObj.TempValue[index1].Value[index2, index3] < 9999)
            {
              this.game.EditObj.TempSup[index1].Value[index2, index3] = this.game.EditObj.TempValue[index1].Value[index2, index3];
              this.game.EditObj.TempSupCameFrom[index1].Value[index2, index3] = this.game.EditObj.TempCameFrom[index1].Value[index2, index3];
            }
          }
        }
      }
    }

    pub object NumberOfPeaces(regnr: i32)
    {
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      num: i32;
      for (let mut index: i32 =  0; index <= regimeCounter; index += 1)
      {
        if (index != regnr && this.game.Data.RegimeObj[regnr].RegimeRel[index] >= 1)
          num += 1;
      }
      return  num;
    }

    pub fn deleted_CopyDataFrom()
    {
      bool[] flagArray = new bool[20];
      let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
      for (let mut index1: i32 =  0; index1 <= sfTypeCounter; index1 += 1)
      {
        if (this.game.Data.SFTypeObj[index1].CopyDataFrom > -1)
        {
          let mut index2: i32 =  0;
          do
          {
            flagArray[index2] = this.game.Data.SFTypeObj[index1].PeopleGroup[index2];
            index2 += 1;
          }
          while (index2 <= 19);
          name: String = this.game.Data.SFTypeObj[index1].Name;
          picFileName: String = this.game.Data.SFTypeObj[index1].PicFileName;
          symbolFileName: String = this.game.Data.SFTypeObj[index1].SymbolFileName;
          let mut copyDataFrom: i32 =  this.game.Data.SFTypeObj[index1].CopyDataFrom;
          this.game.Data.SFTypeObj[index1] = this.game.Data.SFTypeObj[this.game.Data.SFTypeObj[index1].CopyDataFrom].Clone();
          let mut index3: i32 =  0;
          do
          {
            this.game.Data.SFTypeObj[index1].PeopleGroup[index3] = flagArray[index3];
            index3 += 1;
          }
          while (index3 <= 19);
          this.game.Data.SFTypeObj[index1].Name = name;
          this.game.Data.SFTypeObj[index1].PicFileName = picFileName;
          this.game.Data.SFTypeObj[index1].SymbolFileName = symbolFileName;
          this.game.Data.SFTypeObj[index1].CopyDataFrom = copyDataFrom;
          this.game.Data.SFTypeObj[index1].LoadSprites();
        }
      }
    }

    pub IsUnitInHQChain: bool(unr: i32, hq: i32)
    {
      if (unr == -1)
        return false;
      if (hq == -1)
        return true;
      for (; this.game.Data.UnitObj[unr].HQ > -1; unr = this.game.Data.UnitObj[unr].HQ)
      {
        num: i32;
        num += 1;
        if (num > 99 || unr == hq)
          return false;
        if (this.game.Data.UnitObj[unr].HQ == hq)
          return true;
      }
      return false;
    }

    pub fn GetUnitCumulativeReplacement(unr: i32, hq: i32) -> i32
    {
      let mut cumulativeReplacement: i32 =  100;
      for (; this.game.Data.UnitObj[unr].HQ > -1; unr = this.game.Data.UnitObj[unr].HQ)
      {
        num: i32;
        num += 1;
        cumulativeReplacement =  Math.Round( cumulativeReplacement * ( this.game.Data.UnitObj[unr].SOReplacementPercent / 100.0));
        if (num > 99 || unr == hq)
          return cumulativeReplacement;
      }
      return cumulativeReplacement;
    }

    pub float GetStaffCombatMod(unr: i32)
    {
      if (unr == -1)
        return 0.0f;
      num1: i32;
      num2: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          num1 += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty;
          num2 =  Math.Round( ( num2 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty) * this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffCombatMod));
        }
      }
      float staffCombatMod = num1 <= 0 ? 0.0f :  num2 /  num1;
      if (this.game.Data.UnitObj[unr].Historical > -1)
      {
        let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
        if (this.game.Data.HistoricalUnitObj[historical].StaffSize > 0 && this.game.Data.HistoricalUnitObj[historical].Type < 6 |  this.game.Data.RuleVar[927] == 0.0)
        {
          if (this.GetGroupPowerPoints(unr) > this.game.Data.HistoricalUnitObj[historical].StaffSize)
            staffCombatMod *=  ((100.0 +  this.game.Data.HistoricalUnitObj[historical].CombatMod * ( this.game.Data.HistoricalUnitObj[historical].StaffSize /  this.GetGroupPowerPoints(unr))) / 100.0);
          else
            staffCombatMod *=  (100 + this.game.Data.HistoricalUnitObj[historical].CombatMod) / 100f;
        }
      }
      return staffCombatMod;
    }

    pub fn GetRealHqCombatImprovementPercentage(unr: i32) -> i32
    {
      let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
      if (historical == -1)
        return 0;
      let mut staffPoints: i32 =  this.game.HandyFunctionsObj.GetStaffPoints(unr);
      let mut num1: i32 =  this.game.HandyFunctionsObj.GetStaffNeeded(unr);
      if (num1 == 0)
        num1 = 1;
      num2: i32;
      if ( Math.Round(40.0 * ( staffPoints /  num1)) > 80)
        num2 = 80;
      if ( Math.Round(40.0 * ( this.game.Data.HistoricalUnitObj[historical].StaffSize /  num1)) > 80)
        num2 = 80;
      num3: i32;
      if (this.game.Data.UnitObj[unr].Historical > -1 && this.game.Data.HistoricalUnitObj[historical].StaffSize > 0)
        num3 = !(this.game.Data.HistoricalUnitObj[historical].Type < 6 |  this.game.Data.RuleVar[927] == 0.0) ? 0 : (num1 <= this.game.Data.HistoricalUnitObj[historical].StaffSize ? this.game.Data.HistoricalUnitObj[historical].CombatMod :  Math.Round( this.game.Data.HistoricalUnitObj[historical].CombatMod * Math.Min(1.0,  this.game.Data.HistoricalUnitObj[historical].StaffSize /  num1)));
      num4: i32;
      num5: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          num4 += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty;
          num5 =  Math.Round( num5 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty) * ( this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Xp / 100.0) *  this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffCombatMod * Math.Min(1.0,  staffPoints /  num1));
        }
      }
      let mut num6: i32 =  num4 <= 0 ? 0 :  Math.Round(100.0 * ( num5 /  num4));
      let mut num7: i32 =   Math.Round( num6 * ( (100 + num3) / 100.0));
      let mut num8: i32 =  num6 +  Math.Round(100.0 *  this.game.Data.RuleVar[140] * Math.Min(1.0,  staffPoints /  num1));
      return num7 +  Math.Round(100.0 *  this.game.Data.RuleVar[140] * Math.Min(1.0,  staffPoints /  num1));
    }

    pub float GetCombatImprovePercent(unr: i32)
    {
      if (!this.game.Data.UnitObj[unr].IsHQ)
        unr = this.game.Data.UnitObj[unr].HQ;
      if (unr == -1)
        return 1f;
      let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
      if (historical == -1)
        return 1f;
      let mut staffPoints: i32 =  this.game.HandyFunctionsObj.GetStaffPoints(unr);
      let mut num1: i32 =  this.game.HandyFunctionsObj.GetStaffNeeded(unr);
      if (num1 == 0)
        num1 = 1;
      let mut staffSize: i32 =  this.game.Data.HistoricalUnitObj[historical].StaffSize;
      num2: i32;
      if (this.game.Data.UnitObj[unr].Historical > -1 && this.game.Data.HistoricalUnitObj[historical].StaffSize > 0)
        num2 = num1 <= this.game.Data.HistoricalUnitObj[historical].StaffSize ? this.game.Data.HistoricalUnitObj[historical].CombatMod :  Math.Round( this.game.Data.HistoricalUnitObj[historical].CombatMod * Math.Min(1.0,  this.game.Data.HistoricalUnitObj[historical].StaffSize /  num1));
      num3: i32;
      num4: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          num3 += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty;
          num4 =  Math.Round( num4 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty) * ( this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Xp / 100.0) *  this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffCombatMod * Math.Min(1.0,  staffPoints /  num1));
        }
      }
      let mut num5: i32 =  num3 <= 0 ? 0 :  Math.Round(100.0 * ( num4 /  num3));
      let mut num6: i32 =   Math.Round( num5 * ( (100 + num2) / 100.0));
      return  (num5 +  Math.Round(100.0 *  this.game.Data.RuleVar[140] * Math.Min(1.0,  staffPoints /  num1)) + 100) / 100f;
    }

    pub float GetStaffMoraleMod(unr: i32)
    {
      if (unr == -1)
        return 0.0f;
      num1: i32;
      num2: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          num1 += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty;
          num2 =  Math.Round( ( num2 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty) * this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffMoraleMod));
        }
      }
      float staffMoraleMod = num1 <= 0 ? 0.0f :  num2 /  num1;
      if (this.game.Data.UnitObj[unr].Historical > -1)
      {
        let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
        if (this.game.Data.HistoricalUnitObj[historical].StaffSize > 0 && this.game.Data.HistoricalUnitObj[historical].Type < 6 |  this.game.Data.RuleVar[927] == 0.0)
        {
          if (this.GetGroupPowerPoints(unr) > this.game.Data.HistoricalUnitObj[historical].StaffSize)
            staffMoraleMod *=  ((100.0 +  this.game.Data.HistoricalUnitObj[historical].MoraleMod * ( this.game.Data.HistoricalUnitObj[historical].StaffSize /  this.GetGroupPowerPoints(unr))) / 100.0);
          else
            staffMoraleMod *=  (100 + this.game.Data.HistoricalUnitObj[historical].MoraleMod) / 100f;
        }
      }
      return staffMoraleMod;
    }

    pub fn GetStaffNeeded(unr: i32) -> i32
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      staffNeeded: i32;
      for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].HQ == unr | index1 == unr)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[index1].SFCount;
          for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
          {
            if (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].StaffPts < 1 && !(index1 != unr & this.game.Data.UnitObj[index1].IsHQ) && this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].Theater == 0)
              staffNeeded += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].PowerPts * this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Qty;
          }
        }
      }
      return staffNeeded;
    }

    pub GetStaffPercent: i32(
      unr: i32,
      bool combatmod = false,
      let mut additionalstaffpts: i32 =  0,
      let mut additionalpowerpts: i32 =  0)
    {
      if (unr < 0)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      num1: i32;
      for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].HQ == unr | index1 == unr)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[index1].SFCount;
          for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
          {
            if (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].StaffPts < 1 && !(index1 != unr & this.game.Data.UnitObj[index1].IsHQ) && this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].Theater == 0)
              num1 += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].PowerPts * this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Qty;
          }
        }
      }
      let mut num2: i32 =  num1 + additionalpowerpts;
      num3: i32;
      num4: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          num3 += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty;
          num4 =  Math.Round( num4 +  (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty) * ( this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Xp / 100.0));
        }
      }
      let mut num5: i32 =  num3 + additionalstaffpts;
      float num6 = num5 <= 0 ? 0.0f :  num4 /  num5;
      staffPercent: i32;
      if (num2 > 0)
      {
        staffPercent =  Math.Round(Conversion.Int( num5 /  num2 * 100.0));
        if (staffPercent > 999999)
          staffPercent = 999999;
      }
      else
        staffPercent = 999999;
      if (combatmod)
      {
        if (staffPercent > 100)
          staffPercent = 100;
        staffPercent =  Math.Round( ( staffPercent * num6));
      }
      return staffPercent;
    }

    pub fn GetStaffPoints(unr: i32) -> i32
    {
      if (unr < 0)
        return 0;
      staffPoints: i32;
      if (this.game.Data.UnitObj[unr].SFCount > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
          staffPoints += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type].StaffPts * this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Qty;
      }
      return staffPoints;
    }

    pub fn GetSingleCapHQ() -> i32
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      singleCapHq: i32;
      num: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn | this.game.Data.UnitObj[index].Regime == this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime && this.game.Data.UnitObj[index].IsHQ & (this.game.Data.UnitObj[index].LandCap > 0 | this.game.Data.UnitObj[index].AirCap > 0 | this.game.Data.UnitObj[index].NavyCap > 0))
        {
          singleCapHq = index;
          num += 1;
        }
      }
      if (num == 1)
        return singleCapHq;
      return num == 0 ? -2 : -1;
    }

    pub fn GetGroupPowerPoints(unr: i32) -> i32
    {
      if (unr < 0)
        return 0;
      let mut groupPowerPoints: i32 =  0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].HQ == unr | index1 == unr)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[index1].SFCount;
          for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
          {
            if (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].StaffPts < 1 && !(index1 != unr & this.game.Data.UnitObj[index1].IsHQ) && this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].Theater == 0)
              groupPowerPoints += this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Type].PowerPts * this.game.Data.SFObj[this.game.Data.UnitObj[index1].SFList[index2]].Qty;
          }
        }
      }
      return groupPowerPoints;
    }

    pub fn DoResMod()
    {
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut unr: i32 =  0; unr <= unitCounter1; unr += 1)
      {
        this.game.Data.UnitObj[unr].SupplyConsume = 100;
        this.game.Data.UnitObj[unr].StartPower = this.GetPowerPtsAbsolute(unr, true);
      }
      let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
      for (let mut index1: i32 =  0; index1 <= historicalUnitCounter; index1 += 1)
      {
        let mut num: i32 =  0;
        let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
        for (let mut index2: i32 =  0; index2 <= unitCounter2; index2 += 1)
        {
          if (this.game.Data.UnitObj[index2].Historical == index1)
            num += 1;
        }
        this.game.Data.HistoricalUnitObj[index1].StartSize = num;
      }
      if (this.game.Data.LocCounter == -1 || this.game.Data.ResearchCounter == -1 || this.game.Data.ResMod < 1)
        return;
      let mut locCounter: i32 =  this.game.Data.LocCounter;
      num1: i32;
      for (let mut index: i32 =  0; index <= locCounter; index += 1)
        num1 += this.game.Data.LocTypeObj[this.game.Data.LocObj[index].Type].MaxProd;
      float num2 =  num1 /  this.game.Data.ResMod;
      let mut researchCounter: i32 =  this.game.Data.ResearchCounter;
      for (let mut index3: i32 =  0; index3 <= researchCounter; index3 += 1)
      {
        let mut index4: i32 =  0;
        do
        {
          if (this.game.Data.ResearchObj[index3].PointCost[index4] > 0)
          {
            this.game.Data.ResearchObj[index3].PointCost[index4] =  Math.Round( Conversion.Int( this.game.Data.ResearchObj[index3].PointCost[index4] * num2));
            if (this.game.Data.ResearchObj[index3].PointCost[index4] < 1)
              this.game.Data.ResearchObj[index3].PointCost[index4] = 1;
          }
          index4 += 1;
        }
        while (index4 <= 19);
      }
      let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
      for (let mut index: i32 =  0; index <= sfTypeCounter; index += 1)
      {
        if (this.game.Data.SFTypeObj[index].ModelCost > 0)
        {
          this.game.Data.SFTypeObj[index].ModelCost =  Math.Round( Conversion.Int( this.game.Data.SFTypeObj[index].ModelCost * num2));
          if (this.game.Data.SFTypeObj[index].ModelCost < 1)
            this.game.Data.SFTypeObj[index].ModelCost = 0;
        }
      }
    }

    pub fn GetDivBonus(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].Historical <= -1)
        return 0;
      let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
      if (this.game.Data.HistoricalUnitObj[historical].StartSize <= 1)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      num: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (index != unr & this.game.Data.UnitObj[index].Historical == historical & this.game.Data.UnitObj[index].Map == this.game.Data.UnitObj[unr].Map && this.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y, this.game.Data.UnitObj[index].Map) <= 1)
          num += 1;
      }
      let mut divBonus: i32 =  0;
      if (num == 1)
        divBonus =  Math.Round( this.game.Data.RuleVar[143]);
      if (num == 2)
        divBonus =  Math.Round( this.game.Data.RuleVar[144]);
      if (num == 3)
        divBonus =  Math.Round( this.game.Data.RuleVar[145]);
      if (num >= 4)
        divBonus =  Math.Round( this.game.Data.RuleVar[146]);
      if (divBonus < 0)
        divBonus = 0;
      return divBonus;
    }

    pub fn GetDivBonusPrognosis(unr: i32) -> i32
    {
      if (this.game.Data.UnitObj[unr].Historical <= -1)
        return 0;
      let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
      if (this.game.Data.HistoricalUnitObj[historical].StartSize <= 1)
        return 0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      num: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (index != unr & this.game.Data.UnitObj[index].Historical == historical)
        {
          let mut x2: i32 =  this.game.Data.UnitObj[index].X;
          let mut y2: i32 =  this.game.Data.UnitObj[index].Y;
          if (this.game.Data.UnitObj[index].TempX > -1)
            x2 = this.game.Data.UnitObj[index].TempX;
          if (this.game.Data.UnitObj[index].TempY > -1)
            y2 = this.game.Data.UnitObj[index].TempY;
          if (this.Distance(this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY, 0, x2, y2, 0) <= 1)
            num += 1;
        }
      }
      let mut divBonusPrognosis: i32 =  0;
      if (num == 1)
        divBonusPrognosis =  Math.Round( this.game.Data.RuleVar[143]);
      if (num == 2)
        divBonusPrognosis =  Math.Round( this.game.Data.RuleVar[144]);
      if (num == 3)
        divBonusPrognosis =  Math.Round( this.game.Data.RuleVar[145]);
      if (num >= 4)
        divBonusPrognosis =  Math.Round( this.game.Data.RuleVar[146]);
      if (divBonusPrognosis < 0)
        divBonusPrognosis = 0;
      return divBonusPrognosis;
    }

    pub fn GetDivBonusForAttack(tarx: i32, tary: i32, tarmap: i32) -> i32
    {
      int[] numArray = new int[this.game.Data.HistoricalUnitCounter + 1];
      let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
      num1: i32;
      num2: i32;
      for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
      {
        let mut index2: i32 =  this.game.EditObj.TempUnitList.unr[index1];
        let mut num3: i32 =  0;
        let mut num4: i32 =  0;
        let mut num5: i32 =  0;
        if (this.game.Data.UnitObj[index2].Historical > -1)
        {
          let mut historical: i32 =  this.game.Data.UnitObj[index2].Historical;
          if (numArray[historical] == 0)
          {
            numArray[historical] = 1;
            num5 = 1;
            if (this.game.Data.HistoricalUnitObj[historical].StartSize > 1)
            {
              let mut unitCounter: i32 =  this.game.Data.UnitCounter;
              for (let mut tunr: i32 =  0; tunr <= unitCounter; tunr += 1)
              {
                if (tunr != index2 & this.game.Data.UnitObj[tunr].Historical == historical)
                {
                  if (this.game.EditObj.TempUnitList.CheckIfPresent(tunr))
                  {
                    num5 += 1;
                    num3 += 1;
                  }
                  else if (tarmap == this.game.Data.UnitObj[tunr].Map && this.Distance(tarx, tary, tarmap, this.game.Data.UnitObj[tunr].X, this.game.Data.UnitObj[tunr].Y, this.game.Data.UnitObj[tunr].Map) <= 1)
                    num3 += 1;
                }
              }
              num4 = 0;
              if (num3 == 1)
                num4 =  Math.Round( this.game.Data.RuleVar[143]);
              if (num3 == 2)
                num4 =  Math.Round( this.game.Data.RuleVar[144]);
              if (num3 == 3)
                num4 =  Math.Round( this.game.Data.RuleVar[145]);
              if (num3 >= 4)
                num4 =  Math.Round( this.game.Data.RuleVar[146]);
              if (num4 < 0)
                num4 = 0;
            }
          }
        }
        num1 += num5;
        num2 += num5 * num4;
      }
      return num1 == 0 ? 0 :  Math.Round( num2 /  num1);
    }

    pub fn GetDivBonusForAttackPrognosis(tarx: i32, tary: i32) -> i32
    {
      let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
      for (let mut index: i32 =  0; index <= historicalUnitCounter; index += 1)
        this.htempb[index] = false;
      let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
      num1: i32;
      num2: i32;
      for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
      {
        let mut index2: i32 =  this.game.EditObj.TempUnitList.unr[index1];
        let mut num3: i32 =  0;
        let mut num4: i32 =  0;
        let mut num5: i32 =  0;
        if (this.game.Data.UnitObj[index2].Historical > -1)
        {
          let mut historical: i32 =  this.game.Data.UnitObj[index2].Historical;
          if (!this.htempb[historical])
          {
            this.htempb[historical] = true;
            num5 = 1;
            if (this.game.Data.HistoricalUnitObj[historical].StartSize > 1)
            {
              let mut unitCounter: i32 =  this.game.Data.UnitCounter;
              for (let mut tunr: i32 =  0; tunr <= unitCounter; tunr += 1)
              {
                if (tunr != index2 & this.game.Data.UnitObj[tunr].Historical == historical)
                {
                  if (this.game.EditObj.TempUnitList.CheckIfPresent(tunr))
                  {
                    num5 += 1;
                    num3 += 1;
                  }
                  else if (this.Distance(tarx, tary, 0, this.game.Data.UnitObj[tunr].TempX, this.game.Data.UnitObj[tunr].TempY, 0) <= 1)
                    num3 += 1;
                }
              }
              num4 = 0;
              if (num3 == 1)
                num4 =  Math.Round( this.game.Data.RuleVar[143]);
              if (num3 == 2)
                num4 =  Math.Round( this.game.Data.RuleVar[144]);
              if (num3 == 3)
                num4 =  Math.Round( this.game.Data.RuleVar[145]);
              if (num3 >= 4)
                num4 =  Math.Round( this.game.Data.RuleVar[146]);
              if (num4 < 0)
                num4 = 0;
            }
          }
        }
        num1 += num5;
        num2 += num5 * num4;
      }
      return num1 == 0 ? 0 :  Math.Round( num2 /  num1);
    }

    pub fn Gethqpowifhqis(unr: i32, hq: i32, bool UseTemp = false) -> i32
    {
      float num1 = this.game.Data.RuleVar[73];
      if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AI &&  this.game.Data.RuleVar[987] > 0.0)
        num1 = this.game.Data.RuleVar[987];
      let mut num2: i32 =  -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      x2: i32;
      y2: i32;
      map2: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].IsHQ & hq == index)
        {
          num2 = index;
          x2 = this.game.Data.UnitObj[index].X;
          y2 = this.game.Data.UnitObj[index].Y;
          map2 = this.game.Data.UnitObj[index].Map;
          if (UseTemp & this.game.Data.UnitObj[index].TempX > -1 & this.game.Data.UnitObj[index].TempY > -1)
          {
            x2 = this.game.Data.UnitObj[index].TempX;
            y2 = this.game.Data.UnitObj[index].TempY;
            map2 = 0;
          }
        }
      }
      let mut num3: i32 =  num2 <= -1 ? 99 : (!(UseTemp & this.game.Data.UnitObj[unr].TempX > -1) ? (this.game.Data.UnitObj[unr].Map != map2 ? 99 : this.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, x2, y2, map2)) : this.Distance(this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY, 0, x2, y2, 0));
      num4: i32;
      if ( num3 <=  num1)
      {
        num4 = 100;
      }
      else
      {
        num4 =  Math.Round(100.0 -  this.game.Data.RuleVar[74] * ( num3 -  num1));
        if (0 > num4)
          num4 = 0;
      }
      return num4;
    }

    pub fn Gethqpow(unr: i32, bool UseTemp = false) -> i32
    {
      float num1 = this.game.Data.RuleVar[73];
      if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AI &&  this.game.Data.RuleVar[987] > 0.0)
        num1 = this.game.Data.RuleVar[987];
      let mut num2: i32 =  -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      x2: i32;
      y2: i32;
      map2: i32;
      for (let mut index: i32 =  0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].IsHQ && index == this.game.Data.UnitObj[unr].HQ)
        {
          num2 = index;
          x2 = this.game.Data.UnitObj[index].X;
          y2 = this.game.Data.UnitObj[index].Y;
          map2 = this.game.Data.UnitObj[index].Map;
          if (UseTemp & this.game.Data.UnitObj[index].TempX > -1 & this.game.Data.UnitObj[index].TempY > -1)
          {
            x2 = this.game.Data.UnitObj[index].TempX;
            y2 = this.game.Data.UnitObj[index].TempY;
            map2 = 0;
          }
        }
      }
      let mut num3: i32 =  num2 <= -1 ? 99 : (!(UseTemp & this.game.Data.UnitObj[unr].TempX > -1) ? (this.game.Data.UnitObj[unr].Map != map2 ? 99 : this.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, x2, y2, map2)) : this.Distance(this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY, 0, x2, y2, 0));
      num4: i32;
      if ( num3 <=  num1)
      {
        num4 = 100;
      }
      else
      {
        num4 =  Math.Round(100.0 -  this.game.Data.RuleVar[74] * ( num3 -  num1));
        if (0 > num4)
          num4 = 0;
      }
      return num4;
    }

    pub fn RedimStats()
    {
      if (this.game.Data.Round != 0)
        ;
      if (this.game.Data.Round <= 1)
      {
        let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
        for (let mut index: i32 =  0; index <= regimeCounter; index += 1)
        {
          this.game.Data.RegimeObj[index].SLoss = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
          this.game.Data.RegimeObj[index].SKills = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
          this.game.Data.RegimeObj[index].SProd = new int[this.game.Data.ItemTypeCounter + 1, this.game.Data.Round + 1 + 1];
          this.game.Data.RegimeObj[index].SPresent = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
          this.game.Data.RegimeObj[index].ExtraStat = new int[3, this.game.Data.Round + 1 + 1];
          this.game.Data.RegimeObj[index].SASKilled = new int[this.game.Data.SFTypeCounter + 1];
          this.game.Data.RegimeObj[index].SASProdLost = new int[this.game.Data.ItemTypeCounter + 1];
        }
      }
      else
      {
        let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
        for (let mut index: i32 =  0; index <= regimeCounter; index += 1)
        {
          try
          {
            this.game.Data.RegimeObj[index].SLoss = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].SLoss, (Array) new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            this.game.Data.RegimeObj[index].SLoss = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
            ProjectData.ClearProjectError();
          }
          try
          {
            this.game.Data.RegimeObj[index].SKills = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].SKills, (Array) new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            this.game.Data.RegimeObj[index].SKills = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
            ProjectData.ClearProjectError();
          }
          try
          {
            this.game.Data.RegimeObj[index].SProd = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].SProd, (Array) new int[this.game.Data.ItemTypeCounter + 1, this.game.Data.Round + 1 + 1]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            this.game.Data.RegimeObj[index].SProd = new int[this.game.Data.ItemTypeCounter + 1, this.game.Data.Round + 1 + 1];
            ProjectData.ClearProjectError();
          }
          try
          {
            this.game.Data.RegimeObj[index].SPresent = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].SPresent, (Array) new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            this.game.Data.RegimeObj[index].SPresent = new int[this.game.Data.SFTypeCounter + 1, this.game.Data.Round + 1 + 1];
            ProjectData.ClearProjectError();
          }
          try
          {
            this.game.Data.RegimeObj[index].ExtraStat = (int[,]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].ExtraStat, (Array) new int[3, this.game.Data.Round + 1 + 1]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            this.game.Data.RegimeObj[index].ExtraStat = new int[3, this.game.Data.Round + 1 + 1];
            ProjectData.ClearProjectError();
          }
          try
          {
            this.game.Data.RegimeObj[index].SASKilled = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].SASKilled, (Array) new int[this.game.Data.SFTypeCounter + 1]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            this.game.Data.RegimeObj[index].SASKilled = new int[this.game.Data.SFTypeCounter + 1];
            ProjectData.ClearProjectError();
          }
          try
          {
            this.game.Data.RegimeObj[index].SASProdLost = (int[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) this.game.Data.RegimeObj[index].SASProdLost, (Array) new int[this.game.Data.ItemTypeCounter + 1]);
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            this.game.Data.RegimeObj[index].SASProdLost = new int[this.game.Data.ItemTypeCounter + 1];
            ProjectData.ClearProjectError();
          }
        }
      }
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
          {
            let mut tfacing: i32 =  1;
            do
            {
              Coordinate coordinate = this.HexNeighbour(index2, index3, index1, tfacing);
              if (coordinate.onmap && this.game.Data.MapObj[index1].HexObj[index2, index3].RiverType[tfacing - 1] > -1 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[index1].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
              {
                this.game.Data.MapObj[index1].HexObj[index2, index3].RiverType[tfacing - 1] = -1;
                let mut num: i32 =  this.HexFacing(coordinate.x, coordinate.y, coordinate.map, index2, index3, index1);
                this.game.Data.MapObj[index1].HexObj[coordinate.x, coordinate.y].RiverType[num - 1] = -1;
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
        }
      }
      let mut locCounter: i32 =  this.game.Data.LocCounter;
      for (let mut locnr: i32 =  0; locnr <= locCounter; locnr += 1)
      {
        if (this.game.Data.LocTypeObj[this.game.Data.LocObj[locnr].Type].AutoProd > -1)
        {
          let mut index: i32 =  0;
          do
          {
            this.game.Data.LocObj[locnr].Production[index] = -1;
            this.game.Data.LocObj[locnr].ProdPercent[index] = 0;
            index += 1;
          }
          while (index <= 3);
          this.game.Data.LocObj[locnr].Production[0] = this.game.Data.LocTypeObj[this.game.Data.LocObj[locnr].Type].AutoProd;
          this.game.Data.LocObj[locnr].ProdPercent[0] = 100;
          this.UpgradeProduction(locnr);
        }
      }
      this.RedimTempValue(9999);
      this.RedimTempValue2(0);
      this.RedimTempValueSpecial(0);
    }

    pub fn GetTopHQ(unr: i32) -> i32
    {
      let mut num: i32 =  0;
      if (unr == -1)
        return -1;
      let mut hq: i32 =  this.game.Data.UnitObj[unr].HQ;
      while (hq > -1)
      {
        unr = hq;
        num += 1;
        hq = this.game.Data.UnitObj[hq].HQ;
        if (num > 39)
          break;
      }
      return unr;
    }

    pub fn MissingTroopsInPowerPoints(unr: i32) -> i32
    {
      if (!(this.game.Data.UnitObj[unr].Historical > -1 & this.game.Data.UnitObj[unr].HistoricalSubPart > -1) || this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].SubParts[this.game.Data.UnitObj[unr].HistoricalSubPart] <= -1)
        return 0;
      let mut num1: i32 =  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(this.game.HandyFunctionsObj.GetPreDef(this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].SubParts[this.game.Data.UnitObj[unr].HistoricalSubPart]));
      let mut powerPtsAbsolute: i32 =  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
      if (num1 == 0)
        num1 = 1;
      let mut num2: i32 =   Math.Round(100.0 - 100.0 * ( powerPtsAbsolute /  num1));
      if (0 > num2)
        num2 = 0;
      return num2;
    }

    pub fn UpgradeProduction(locnr: i32)
    {
      let mut itemTypeCounter: i32 =  this.game.Data.ItemTypeCounter;
      for (let mut itemtypenr: i32 =  0; itemtypenr <= itemTypeCounter; itemtypenr += 1)
      {
        if (this.game.Data.ItemTypeObj[itemtypenr].Blocks > -1)
        {
          let mut blocks: i32 =  this.game.Data.ItemTypeObj[itemtypenr].Blocks;
          let mut num1: i32 =  locnr;
          let mut num2: i32 =  locnr;
          for (let mut locnr1: i32 =  num1; locnr1 <= num2; locnr1 += 1)
          {
            if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.Data.LocObj[locnr1].X, this.game.Data.LocObj[locnr1].Y].Regime > -1)
            {
              let mut index: i32 =  0;
              do
              {
                if (this.game.Data.LocObj[locnr1].Production[index] == this.game.Data.ItemTypeObj[itemtypenr].Blocks && this.game.HandyFunctionsObj.CanProduceItem(locnr1, this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.Data.LocObj[locnr1].X, this.game.Data.LocObj[locnr1].Y].Regime, itemtypenr).result)
                {
                  this.game.Data.LocObj[locnr1].Production[index] = itemtypenr;
                  num3: i32;
                  num3 += 1;
                }
                index += 1;
              }
              while (index <= 3);
            }
          }
        }
      }
    }

    pub CanLocProduce: bool(locnr: i32, regnr: i32)
    {
      if (this.game.Data.Round == 0)
        return true;
      if (this.game.Data.LocTypeObj[this.game.Data.LocObj[locnr].Type].MaxProd < 1)
        return false;
      let mut itemTypeCounter: i32 =  this.game.Data.ItemTypeCounter;
      for (let mut index: i32 =  0; index <= itemTypeCounter; index += 1)
      {
        if (this.game.Data.LocTypeObj[this.game.Data.LocObj[locnr].Type].ItemGroup[this.game.Data.ItemTypeObj[index].ItemGroup])
        {
          let mut useProdMod: i32 =  this.game.Data.ItemTypeObj[index].UseProdMod;
          if ((useProdMod == 0 | useProdMod == 1) &  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regnr].People].PeopleGroup] > 0.0 || useProdMod == 2 &  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod2[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regnr].People].PeopleGroup] > 0.0 || useProdMod == 3 &  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod3[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regnr].People].PeopleGroup] > 0.0 || useProdMod == 4 &  this.game.Data.PeopleObj[this.game.Data.LocObj[locnr].People].ProdMod4[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regnr].People].PeopleGroup] > 0.0)
            return true;
        }
      }
      return false;
    }

    pub fn GetRealHQSupplyPts(unr: i32) -> i32
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        num += this.game.Data.SFTypeObj[type].SupplyCarry * this.game.Data.SFObj[sf].Qty;
      }
      let mut realHqSupplyPts: i32 =  this.game.Data.UnitObj[unr].Supply - num;
      if (0 > realHqSupplyPts)
        realHqSupplyPts = 0;
      return realHqSupplyPts;
    }

    pub fn DoAntiInfraDammage(bool AdjustCall = false)
    {
      MapMatrix2[] mapMatrix2Array = new MapMatrix2[this.game.Data.MapCounter + 1];
      int[] numArray1 = new int[500];
      let mut mapCounter1: i32 =  this.game.Data.MapCounter;
      for (let mut index: i32 =  0; index <= mapCounter1; index += 1)
        mapMatrix2Array[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
      let mut mapCounter2: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter2; index1 += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
          {
            this.game.Data.MapObj[index1].HexObj[index2, index3].DammageToInfra = 0;
            this.game.Data.MapObj[index1].HexObj[index2, index3].DammageVisible = 0;
            let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
            for (let mut Index: i32 =  0; Index <= regimeCounter; Index += 1)
              this.game.Data.MapObj[index1].HexObj[index2, index3].set_DammagePerRegime(Index, 0);
          }
        }
      }
      let mut itemTypeCounter: i32 =  this.game.Data.ItemTypeCounter;
      for (let mut index: i32 =  0; index <= itemTypeCounter; index += 1)
        this.game.Data.RegimeObj[this.game.Data.Turn].SASProdLost[index] = 0;
      this.game.Data.RegimeObj[this.game.Data.Turn].SASSupplyLost = 0;
      if (!this.game.Data.ASOn)
        return;
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut unr: i32 =  0; unr <= unitCounter1; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].X > -1)
        {
          if (!AdjustCall)
            this.game.Data.UnitObj[unr].StartIntercept = this.game.Data.UnitObj[unr].SOInterceptRdnStop;
          if (this.HasUnitAirSF(unr, true, true, true))
          {
            let mut x: i32 =  this.game.Data.UnitObj[unr].X;
            let mut y: i32 =  this.game.Data.UnitObj[unr].Y;
            let mut map: i32 =  this.game.Data.UnitObj[unr].Map;
            if (this.game.Data.MapObj[map].HexObj[x, y].Location > -1 | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
            {
              let mut num1: i32 =  0;
              if (this.game.Data.MapObj[map].HexObj[x, y].Location > -1)
              {
                if (this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].Type].IsAirfield)
                  num1 = 1;
                if (this.game.Data.LocObj[this.game.Data.MapObj[map].HexObj[x, y].Location].isAirfield)
                  num1 = 1;
              }
              if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[map].HexObj[x, y].LandscapeType].IsSea)
                num1 = 1;
              let mut index4: i32 =  0;
              do
              {
                numArray1[index4] = 0;
                index4 += 1;
              }
              while (index4 <= 499);
              let mut sfCount1: i32 =  this.game.Data.UnitObj[unr].SFCount;
              type1: i32;
              for (let mut index5: i32 =  0; index5 <= sfCount1; index5 += 1)
              {
                let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index5];
                let mut type2: i32 =  this.game.Data.SFObj[sf].Type;
                if (this.game.Data.SFTypeObj[type2].Theater == 2 && !this.game.Data.SFTypeObj[type2].BackBench)
                {
                  let mut fuelRegimeVar: i32 =  this.game.Data.SFTypeObj[type2].FuelRegimeVar;
                  let mut currentSlot: i32 =  this.game.Data.SFTypeObj[type1].FuelRegimeVar;
                  if ( this.game.Data.RuleVar[949] > 0.0)
                    currentSlot = this.game.HandyFunctionsObj.GetFuelSlot949(currentSlot, this.game.Data.UnitObj[unr].RealX( this.game), this.game.Data.UnitObj[unr].RealY( this.game));
                  let mut index6: i32 =  currentSlot;
                  if (index6 > -1)
                  {
                    let mut num2: i32 =  this.game.Data.SFTypeObj[type2].FuelForAttackDef * 2 * this.game.Data.SFObj[sf].Qty;
                    int[] numArray2 = numArray1;
                    int[] numArray3 = numArray2;
                    let mut index7: i32 =  index6;
                    let mut index8: i32 =  index7;
                    let mut num3: i32 =  numArray2[index7] + num2;
                    numArray3[index8] = num3;
                    if (numArray1[index6] > this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].RegimeSlot[index6])
                      num1 = 0;
                  }
                }
              }
              if (num1 == 1)
              {
                let mut sfCount2: i32 =  this.game.Data.UnitObj[unr].SFCount;
                for (let mut index9: i32 =  0; index9 <= sfCount2; index9 += 1)
                {
                  let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index9];
                  type1 = this.game.Data.SFObj[sf].Type;
                  let mut ap: i32 =   Math.Round( ( this.game.Data.SFObj[sf].Rdn * this.game.Data.RuleVar[147]));
                  if (!this.game.Data.SFTypeObj[type1].BackBench & this.game.Data.SFTypeObj[type1].Theater == 2 && ap > 0)
                  {
                    this.MakeMovePrediction2(this.game.Data.UnitObj[unr].Regime, this.game.Data.SFTypeObj[type1].MoveType, 2, ap, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, false, false, muststartonairfield: false);
                    let mut mapCounter3: i32 =  this.game.Data.MapCounter;
                    for (let mut index10: i32 =  0; index10 <= mapCounter3; index10 += 1)
                    {
                      let mut mapWidth: i32 =  this.game.Data.MapObj[index10].MapWidth;
                      for (let mut index11: i32 =  0; index11 <= mapWidth; index11 += 1)
                      {
                        let mut mapHeight: i32 =  this.game.Data.MapObj[index10].MapHeight;
                        for (let mut index12: i32 =  0; index12 <= mapHeight; index12 += 1)
                        {
                          if (this.game.EditObj.TempValue[index10].Value[index11, index12] < 999)
                            mapMatrix2Array[index10].Value[index11, index12] = 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      let mut mapCounter4: i32 =  this.game.Data.MapCounter;
      for (let mut index13: i32 =  0; index13 <= mapCounter4; index13 += 1)
      {
        let mut mapWidth1: i32 =  this.game.Data.MapObj[index13].MapWidth;
        for (let mut index14: i32 =  0; index14 <= mapWidth1; index14 += 1)
        {
          let mut mapHeight1: i32 =  this.game.Data.MapObj[index13].MapHeight;
          for (let mut index15: i32 =  0; index15 <= mapHeight1; index15 += 1)
          {
            let mut unitCounter2: i32 =  this.game.Data.MapObj[index13].HexObj[index14, index15].UnitCounter;
            for (let mut index16: i32 =  0; index16 <= unitCounter2; index16 += 1)
            {
              let mut unit: i32 =  this.game.Data.MapObj[index13].HexObj[index14, index15].UnitList[index16];
              if (this.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.UnitObj[unit].Regime) & this.game.Data.UnitObj[unit].SODoAS)
              {
                Coordinate coordinate;
                if (this.HasUnitAirSF(unit) && this.GetLowestAirRdn(unit) > this.game.Data.UnitObj[unit].SOInterceptRdnStop)
                {
                  let mut sfCount: i32 =  this.game.Data.UnitObj[unit].SFCount;
                  for (let mut index17: i32 =  0; index17 <= sfCount; index17 += 1)
                  {
                    let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index17];
                    let mut type: i32 =  this.game.Data.SFObj[sf].Type;
                    let mut ap: i32 =   Math.Round(Conversion.Int( this.game.Data.SFObj[sf].Rdn * ( this.game.Data.SFTypeObj[type].AntiSupplyRange / 100.0)));
                    if (this.game.Data.SFTypeObj[type].Theater == 2 && this.game.Data.SFTypeObj[type].AntiSupply > 0 | this.game.Data.SFTypeObj[type].AntiSupplySea > 0)
                    {
                      this.MakeMovePrediction2(this.game.Data.UnitObj[unit].Regime, this.game.Data.SFTypeObj[type].MoveType, 2, ap, this.game.Data.UnitObj[unit].X, this.game.Data.UnitObj[unit].Y, this.game.Data.UnitObj[unit].Map, false, false, NoAPPenalties: true);
                      let mut mapCounter5: i32 =  this.game.Data.MapCounter;
                      for (let mut cmap: i32 =  0; cmap <= mapCounter5; cmap += 1)
                      {
                        let mut mapWidth2: i32 =  this.game.Data.MapObj[cmap].MapWidth;
                        for (let mut cx: i32 =  0; cx <= mapWidth2; cx += 1)
                        {
                          let mut mapHeight2: i32 =  this.game.Data.MapObj[cmap].MapHeight;
                          for (let mut cy: i32 =  0; cy <= mapHeight2; cy += 1)
                          {
                            if (this.game.EditObj.TempValue[cmap].Value[cx, cy] < 999 && mapMatrix2Array[cmap].Value[cx, cy] == 0)
                            {
                              let mut num4: i32 =  !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].LandscapeType].IsSea ?  Math.Round( (this.game.Data.SFTypeObj[type].AntiSupply * this.game.Data.SFObj[sf].Qty) * ( this.game.Data.SFObj[sf].Rdn / 100.0)) :  Math.Round( (this.game.Data.SFTypeObj[type].AntiSupplySea * this.game.Data.SFObj[sf].Qty) * ( this.game.Data.SFObj[sf].Rdn / 100.0));
                              let mut tfacing: i32 =  1;
                              do
                              {
                                coordinate = this.HexNeighbourSameMap(cx, cy, cmap, tfacing);
                                if (coordinate.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].LandscapeType].IsSea && this.game.Data.MapObj[cmap].HexObj[coordinate.x, coordinate.y].Regime == this.game.Data.Turn && this.game.Data.MapObj[cmap].HexObj[coordinate.x, coordinate.y].Location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[cmap].HexObj[coordinate.x, coordinate.y].Location].Type].IsPort && this.Distance(this.game.Data.UnitObj[unit].X, this.game.Data.UnitObj[unit].Y, this.game.Data.UnitObj[unit].Map, coordinate.x, coordinate.y, coordinate.map) <= 1 &&  this.game.Data.RuleVar[303] > 0.0)
                                  num4 =  Math.Round( ( num4 * this.game.Data.RuleVar[303]));
                                tfacing += 1;
                              }
                              while (tfacing <= 6);
                              HexClass[,] hexObj1 = this.game.Data.MapObj[cmap].HexObj;
                              HexClass[,] hexClassArray1 = hexObj1;
                              let mut index18: i32 =  cx;
                              let mut index19: i32 =  index18;
                              let mut index20: i32 =  cy;
                              let mut index21: i32 =  index20;
                              hexClassArray1[index19, index21].DammageToInfra = hexObj1[index18, index20].DammageToInfra + num4;
                              HexClass[,] hexObj2 = this.game.Data.MapObj[cmap].HexObj;
                              HexClass[,] hexClassArray2 = hexObj2;
                              let mut index22: i32 =  cx;
                              let mut index23: i32 =  index22;
                              let mut index24: i32 =  cy;
                              let mut index25: i32 =  index24;
                              hexClassArray2[index23, index25].DammageVisible = hexObj2[index22, index24].DammageVisible + num4;
                              HexClass[,] hexObj3 = this.game.Data.MapObj[cmap].HexObj;
                              HexClass[,] hexClassArray3 = hexObj3;
                              let mut index26: i32 =  cx;
                              let mut index27: i32 =  index26;
                              let mut index28: i32 =  cy;
                              let mut index29: i32 =  index28;
                              HexClass hexClass = hexClassArray3[index27, index29];
                              let mut regime: i32 =  this.game.Data.UnitObj[unit].Regime;
                              let mut Index: i32 =  regime;
                              let mut num5: i32 =  hexObj3[index26, index28].get_DammagePerRegime(regime) + num4;
                              hexClass.set_DammagePerRegime(Index, num5);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                let mut sfCount3: i32 =  this.game.Data.UnitObj[unit].SFCount;
                for (let mut index30: i32 =  0; index30 <= sfCount3; index30 += 1)
                {
                  let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index30];
                  let mut type: i32 =  this.game.Data.SFObj[sf].Type;
                  let mut ap: i32 =   Math.Round(Conversion.Int( this.game.Data.SFObj[sf].Rdn * ( this.game.Data.SFTypeObj[type].AntiSupplyRange / 100.0)));
                  let mut num6: i32 =  0;
                  if (this.game.Data.SFTypeObj[type].Theater == 1 & this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.Data.UnitObj[unit].Map].HexObj[this.game.Data.UnitObj[unit].X, this.game.Data.UnitObj[unit].Y].LandscapeType].IsSea)
                    num6 = 1;
                  if (this.game.Data.SFTypeObj[type].Theater == 0)
                    num6 = 1;
                  if (num6 == 1 && this.game.Data.SFTypeObj[type].AntiSupply > 0 | this.game.Data.SFTypeObj[type].AntiSupplySea > 0)
                  {
                    this.MakeMovePrediction2(this.game.Data.UnitObj[unit].Regime, this.game.Data.SFTypeObj[type].MoveType, this.game.Data.SFTypeObj[type].Theater, ap, this.game.Data.UnitObj[unit].X, this.game.Data.UnitObj[unit].Y, this.game.Data.UnitObj[unit].Map, false, muststartonairfield: false, NoAPPenalties: true);
                    let mut mapCounter6: i32 =  this.game.Data.MapCounter;
                    for (let mut cmap: i32 =  0; cmap <= mapCounter6; cmap += 1)
                    {
                      let mut mapWidth3: i32 =  this.game.Data.MapObj[cmap].MapWidth;
                      for (let mut cx: i32 =  0; cx <= mapWidth3; cx += 1)
                      {
                        let mut mapHeight3: i32 =  this.game.Data.MapObj[cmap].MapHeight;
                        for (let mut cy: i32 =  0; cy <= mapHeight3; cy += 1)
                        {
                          if (this.game.EditObj.TempValue[cmap].Value[cx, cy] < 999 && this.game.Data.SFTypeObj[type].Theater < 2)
                          {
                            let mut num7: i32 =  !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[cmap].HexObj[cx, cy].LandscapeType].IsSea ?  Math.Round( (this.game.Data.SFTypeObj[type].AntiSupply * this.game.Data.SFObj[sf].Qty) * ( this.game.Data.SFObj[sf].Rdn / 100.0)) :  Math.Round( (this.game.Data.SFTypeObj[type].AntiSupplySea * this.game.Data.SFObj[sf].Qty) * ( this.game.Data.SFObj[sf].Rdn / 100.0));
                            let mut tfacing: i32 =  1;
                            do
                            {
                              coordinate = this.HexNeighbour(cx, cy, cmap, tfacing);
                              if (coordinate.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[cx, cy].LandscapeType].IsSea && this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Regime == this.game.Data.Turn && this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[coordinate.map].HexObj[coordinate.x, coordinate.y].Location].Type].IsPort && this.Distance(this.game.Data.UnitObj[unit].X, this.game.Data.UnitObj[unit].Y, this.game.Data.UnitObj[unit].Map, coordinate.x, coordinate.y, coordinate.map) <= 1 &&  this.game.Data.RuleVar[303] > 0.0)
                                num7 =  Math.Round( ( num7 * this.game.Data.RuleVar[303]));
                              tfacing += 1;
                            }
                            while (tfacing <= 6);
                            HexClass[,] hexObj4 = this.game.Data.MapObj[cmap].HexObj;
                            HexClass[,] hexClassArray4 = hexObj4;
                            let mut index31: i32 =  cx;
                            let mut index32: i32 =  index31;
                            let mut index33: i32 =  cy;
                            let mut index34: i32 =  index33;
                            hexClassArray4[index32, index34].DammageToInfra = hexObj4[index31, index33].DammageToInfra + num7;
                            HexClass[,] hexObj5 = this.game.Data.MapObj[cmap].HexObj;
                            HexClass[,] hexClassArray5 = hexObj5;
                            let mut index35: i32 =  cx;
                            let mut index36: i32 =  index35;
                            let mut index37: i32 =  cy;
                            let mut index38: i32 =  index37;
                            HexClass hexClass = hexClassArray5[index36, index38];
                            let mut regime: i32 =  this.game.Data.UnitObj[unit].Regime;
                            let mut Index: i32 =  regime;
                            let mut num8: i32 =  hexObj5[index35, index37].get_DammagePerRegime(regime) + num7;
                            hexClass.set_DammagePerRegime(Index, num8);
                            if (this.game.Data.SFTypeObj[type].Theater == 0 | !this.game.Data.FOWOn)
                            {
                              HexClass[,] hexObj6 = this.game.Data.MapObj[cmap].HexObj;
                              HexClass[,] hexClassArray6 = hexObj6;
                              let mut index39: i32 =  cx;
                              let mut index40: i32 =  index39;
                              let mut index41: i32 =  cy;
                              let mut index42: i32 =  index41;
                              hexClassArray6[index40, index42].DammageVisible = hexObj6[index39, index41].DammageVisible + num7;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    pub fn GetBreakPercent(unr: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      num2: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 0)
        {
          num2 += this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
          if (this.game.Data.PeopleObj[this.game.Data.SFObj[sf].People].BreakAt > -1)
            num1 += this.game.Data.PeopleObj[this.game.Data.SFObj[sf].People].BreakAt * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
        }
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetMaxStockpile(unr: i32) -> i32
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      maxStockpile: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        maxStockpile += this.game.Data.SFTypeObj[type].StockpileMax * this.game.Data.SFObj[sf].Qty;
      }
      return maxStockpile;
    }

    pub object GetStockpileUsePerRound(unr: i32)
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      stockpileUsePerRound: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        stockpileUsePerRound += this.game.Data.SFTypeObj[type].StockpileUsedPerRound * this.game.Data.SFObj[sf].Qty;
      }
      return  stockpileUsePerRound;
    }

    pub object GetMaxSupplyRequest(unr: i32)
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      maxSupplyRequest: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].SupplyMaxIn > 0)
          maxSupplyRequest += this.game.Data.SFTypeObj[type].SupplyMaxIn * this.game.Data.SFObj[sf].Qty;
        else
          maxSupplyRequest += (this.game.Data.SFTypeObj[type].SupplyCarry + this.game.Data.SFTypeObj[type].BasicSupplyNeed) * this.game.Data.SFObj[sf].Qty;
      }
      return  maxSupplyRequest;
    }

    pub object GetStockpileRequest(unr: i32)
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      stockpileRequest: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        stockpileRequest += this.game.Data.SFTypeObj[type].StockpileMaxIn * this.game.Data.SFObj[sf].Qty;
      }
      let mut num: i32 =  this.game.Data.UnitObj[unr].StockpileCurrent + stockpileRequest;
      let mut maxStockpile: i32 =  this.GetMaxStockpile(unr);
      if (num > maxStockpile)
        stockpileRequest -= num - maxStockpile;
      if (0 > stockpileRequest)
        stockpileRequest = 0;
      return  stockpileRequest;
    }

    pub fn GetHumanPlayers() -> i32
    {
      let mut reg1: i32 =  -1;
      let mut humanPlayers: i32 =  0;
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut reg2: i32 =  0; reg2 <= regimeCounter; reg2 += 1)
      {
        if (!(reg1 == reg2 | reg1 > -1 & this.game.Data.RegimeObj[reg2].UberRegime == reg1) && !(this.game.HandyFunctionsObj.IsAlliedOrSelf(reg1, reg2) &  this.game.Data.RuleVar[328] == 1.0) && !this.game.Data.RegimeObj[reg2].Sleep && !this.game.Data.RegimeObj[reg2].AI)
        {
          reg1 = reg2;
          if (this.game.Data.RegimeObj[reg2].UberRegime > -1)
            reg1 = this.game.Data.RegimeObj[reg2].UberRegime;
          humanPlayers += 1;
        }
      }
      return humanPlayers;
    }

    pub fn FindOtherHumanPlayer(regnr: i32) -> i32
    {
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut otherHumanPlayer: i32 =  0; otherHumanPlayer <= regimeCounter; otherHumanPlayer += 1)
      {
        if (!this.game.Data.RegimeObj[otherHumanPlayer].Sleep && !this.game.Data.RegimeObj[otherHumanPlayer].AI & otherHumanPlayer != regnr)
          return otherHumanPlayer;
      }
      return -1;
    }

    pub fn FindAIPlayer() -> i32
    {
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut aiPlayer: i32 =  0; aiPlayer <= regimeCounter; aiPlayer += 1)
      {
        if (!this.game.Data.RegimeObj[aiPlayer].Sleep && this.game.Data.RegimeObj[aiPlayer].AI)
          return aiPlayer;
      }
      return -1;
    }

    pub fn GetAntiSupply(x1: i32, y1: i32, map1: i32, x2: i32, y2: i32, map2: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut index1: i32 =  x2;
      let mut index2: i32 =  y2;
      let mut index3: i32 =  map2;
      let mut num2: i32 =  -1;
      let mut num3: i32 =  -1;
      let mut num4: i32 =  -1;
      d: i32;
      while (num1 == 0)
      {
        if (!(index1 == x1 & index2 == y1 & index3 == map1))
        {
          let mut dammageToInfra: i32 =  this.game.Data.MapObj[index3].HexObj[index1, index2].DammageToInfra;
          Coordinate coordinate = this.game.EditObj.TempCameFrom[index3].Value[index1, index2];
          if (coordinate.onmap)
          {
            num2 = index1;
            num3 = index2;
            num4 = index3;
            index1 = coordinate.x;
            index2 = coordinate.y;
            index3 = coordinate.map;
          }
          else
            num1 = 1;
          d += dammageToInfra;
        }
        if (x1 == index1 & y1 == index2 & map1 == index3)
          num1 = 1;
      }
      if (d > 9000)
        d = 9000;
      return  Math.Round(Conversion.Int(Math.Sqrt( d)));
    }

    pub void SetAntiSupplyKills(
      x1: i32,
      y1: i32,
      map1: i32,
      x2: i32,
      y2: i32,
      map2: i32,
      suppts: i32,
      sftypenr: i32,
      qty: i32)
    {
      int[] numArray1 = new int[this.game.Data.RegimeCounter + 1];
      int[] numArray2 = new int[this.game.Data.RegimeCounter + 1];
      int[] numArray3 = new int[this.game.Data.RegimeCounter + 1];
      MapMatrix2[] mapMatrix2Array = new MapMatrix2[this.game.Data.MapCounter + 1];
      let mut mapCounter1: i32 =  this.game.Data.MapCounter;
      for (let mut index: i32 =  0; index <= mapCounter1; index += 1)
        mapMatrix2Array[index] = new MapMatrix2(this.game.Data.MapObj[index].MapWidth, this.game.Data.MapObj[index].MapHeight);
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      let mut index1: i32 =  x2;
      let mut index2: i32 =  y2;
      let mut index3: i32 =  map2;
      num3: i32;
      while (num1 == 0)
      {
        if (!(index1 == x1 & index2 == y1 & index3 == map1))
        {
          num3 += this.game.Data.MapObj[index3].HexObj[index1, index2].DammageToInfra;
          let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
          for (let mut Index: i32 =  0; Index <= regimeCounter; Index += 1)
          {
            if (Index != this.game.Data.Turn & this.game.Data.RegimeObj[this.game.Data.Turn].RegimeRel[Index] == 0)
            {
              int[] numArray4 = numArray1;
              int[] numArray5 = numArray4;
              let mut index4: i32 =  Index;
              let mut index5: i32 =  index4;
              let mut num4: i32 =  numArray4[index4] + this.game.Data.MapObj[index3].HexObj[index1, index2].get_DammagePerRegime(Index);
              numArray5[index5] = num4;
              int[] numArray6 = numArray2;
              int[] numArray7 = numArray6;
              let mut index6: i32 =  Index;
              let mut index7: i32 =  index6;
              let mut num5: i32 =  numArray6[index6] + 1;
              numArray7[index7] = num5;
            }
          }
          numArray8: Vec<i32> = mapMatrix2Array[index3].Value;
          numArray9: Vec<i32> = numArray8;
          let mut index8: i32 =  index1;
          let mut index9: i32 =  index8;
          let mut index10: i32 =  index2;
          let mut index11: i32 =  index10;
          let mut num6: i32 =  numArray8[index8, index10] + this.game.Data.MapObj[0].HexObj[index1, index2].DammageToInfra;
          numArray9[index9, index11] = num6;
          Coordinate coordinate = this.game.EditObj.TempCameFrom[index3].Value[index1, index2];
          if (coordinate.onmap)
          {
            index1 = coordinate.x;
            index2 = coordinate.y;
            index3 = coordinate.map;
          }
          else
            num1 = 1;
        }
        if (x1 == index1 & y1 == index2 & map1 == index3)
          num1 = 1;
      }
      let mut num7: i32 =  0;
      let mut regimeCounter1: i32 =  this.game.Data.RegimeCounter;
      for (let mut index12: i32 =  0; index12 <= regimeCounter1; index12 += 1)
      {
        if (index12 != this.game.Data.Turn & this.game.Data.RegimeObj[this.game.Data.Turn].RegimeRel[index12] == 0)
        {
          float num8 = num3 <= 0 ? 0.0f :  numArray1[index12] /  num3;
          if (suppts > 0)
          {
            let mut num9: i32 =   Math.Round( (num8 *  suppts));
            if ( VBMath.Rnd() <  num8 *  suppts -  num9)
              num9 += 1;
            if (num9 + num7 > suppts)
              num9 = suppts - num7;
            int[] numArray10 = numArray3;
            int[] numArray11 = numArray10;
            let mut index13: i32 =  index12;
            let mut index14: i32 =  index13;
            let mut num10: i32 =  numArray10[index13] + num9;
            numArray11[index14] = num10;
            num7 += num9;
          }
          else
          {
            let mut num11: i32 =   Math.Round( (num8 *  qty));
            if ( VBMath.Rnd() <  num8 *  qty -  num11)
              num11 += 1;
            if (num11 + num7 > qty)
              num11 = suppts - qty;
            int[] numArray12 = numArray3;
            int[] numArray13 = numArray12;
            let mut index15: i32 =  index12;
            let mut index16: i32 =  index15;
            let mut num12: i32 =  numArray12[index15] + num11;
            numArray13[index16] = num12;
            num7 += num11;
          }
        }
      }
      let mut num13: i32 =  0;
      num2 = 0;
      let mut num14: i32 =  -1;
      let mut regimeCounter2: i32 =  this.game.Data.RegimeCounter;
      for (let mut index17: i32 =  0; index17 <= regimeCounter2; index17 += 1)
      {
        if (index17 != this.game.Data.Turn & this.game.Data.RegimeObj[this.game.Data.Turn].RegimeRel[index17] == 0 && numArray1[index17] > num13)
        {
          num14 = index17;
          num13 = numArray1[index17];
        }
      }
      if (suppts > 0 & num14 > -1)
      {
        if (num7 < suppts)
        {
          int[] numArray14 = numArray3;
          int[] numArray15 = numArray14;
          let mut index18: i32 =  num14;
          let mut index19: i32 =  index18;
          let mut num15: i32 =  numArray14[index18] + (suppts - num7);
          numArray15[index19] = num15;
        }
      }
      else if (num7 < qty & num14 > -1)
      {
        int[] numArray16 = numArray3;
        int[] numArray17 = numArray16;
        let mut index20: i32 =  num14;
        let mut index21: i32 =  index20;
        let mut num16: i32 =  numArray16[index20] + (qty - num7);
        numArray17[index21] = num16;
      }
      let mut regimeCounter3: i32 =  this.game.Data.RegimeCounter;
      for (let mut Index1: i32 =  0; Index1 <= regimeCounter3; Index1 += 1)
      {
        if (Index1 != this.game.Data.Turn & this.game.Data.RegimeObj[this.game.Data.Turn].RegimeRel[Index1] == 0 && (num3 <= 0 ? 0.0 :  ( numArray1[Index1] /  num3)) > 0.0)
        {
          let mut num17: i32 =  0;
          let mut num18: i32 =  0;
          if (suppts > 0 && numArray1[Index1] > 0)
          {
            let mut mapCounter2: i32 =  this.game.Data.MapCounter;
            for (let mut index22: i32 =  0; index22 <= mapCounter2; index22 += 1)
            {
              let mut mapWidth: i32 =  this.game.Data.MapObj[index22].MapWidth;
              for (let mut index23: i32 =  0; index23 <= mapWidth; index23 += 1)
              {
                let mut mapHeight: i32 =  this.game.Data.MapObj[index22].MapHeight;
                for (let mut index24: i32 =  0; index24 <= mapHeight; index24 += 1)
                {
                  if (mapMatrix2Array[index22].Value[index23, index24] > 0)
                  {
                    float num19 = this.game.Data.MapObj[index22].HexObj[index23, index24].get_DammagePerRegime(Index1) <= 0 ? 0.0f :  this.game.Data.MapObj[index22].HexObj[index23, index24].get_DammagePerRegime(Index1) /  numArray1[Index1];
                    if ( num19 > 0.0)
                    {
                      num18 += 1;
                      let mut num20: i32 =   Math.Round( Conversion.Int(num19 *  numArray3[Index1]));
                      if ( VBMath.Rnd() <  num19 *  numArray3[Index1] -  num20)
                        num20 += 1;
                      if (num18 == numArray2[Index1])
                        num20 = numArray3[Index1] - num17;
                      if (num17 >= numArray3[Index1])
                        num20 = 0;
                      if (num20 > 0)
                      {
                        RegimeClass[] regimeObj = this.game.Data.RegimeObj;
                        RegimeClass[] regimeClassArray = regimeObj;
                        let mut index25: i32 =  Index1;
                        let mut index26: i32 =  index25;
                        regimeClassArray[index26].SASSupplyKilled = regimeObj[index25].SASSupplyKilled + num20;
                        HexClass[,] hexObj1 = this.game.Data.MapObj[index22].HexObj;
                        HexClass[,] hexClassArray1 = hexObj1;
                        let mut index27: i32 =  index23;
                        let mut index28: i32 =  index27;
                        let mut index29: i32 =  index24;
                        let mut index30: i32 =  index29;
                        HexClass hexClass1 = hexClassArray1[index28, index30];
                        let mut Index2: i32 =  Index1;
                        let mut Index3: i32 =  Index2;
                        let mut num21: i32 =  hexObj1[index27, index29].get_SupplyKilled(Index2) + num20;
                        hexClass1.set_SupplyKilled(Index3, num21);
                        HexClass[,] hexObj2 = this.game.Data.MapObj[index22].HexObj;
                        HexClass[,] hexClassArray2 = hexObj2;
                        let mut index31: i32 =  index23;
                        let mut index32: i32 =  index31;
                        let mut index33: i32 =  index24;
                        let mut index34: i32 =  index33;
                        HexClass hexClass2 = hexClassArray2[index32, index34];
                        let mut turn: i32 =  this.game.Data.Turn;
                        let mut Index4: i32 =  turn;
                        let mut num22: i32 =  hexObj2[index31, index33].get_SupplyLost(turn) + num20;
                        hexClass2.set_SupplyLost(Index4, num22);
                        num17 += num20;
                      }
                    }
                  }
                }
              }
            }
          }
          if (qty > 0 && numArray1[Index1] > 0)
          {
            let mut num23: i32 =  0;
            let mut num24: i32 =  0;
            let mut mapCounter3: i32 =  this.game.Data.MapCounter;
            for (let mut index35: i32 =  0; index35 <= mapCounter3; index35 += 1)
            {
              let mut mapWidth: i32 =  this.game.Data.MapObj[index35].MapWidth;
              for (let mut index36: i32 =  0; index36 <= mapWidth; index36 += 1)
              {
                let mut mapHeight: i32 =  this.game.Data.MapObj[index35].MapHeight;
                for (let mut index37: i32 =  0; index37 <= mapHeight; index37 += 1)
                {
                  if (mapMatrix2Array[index35].Value[index36, index37] > 0)
                  {
                    float num25 = this.game.Data.MapObj[index35].HexObj[index36, index37].get_DammagePerRegime(Index1) <= 0 ? 0.0f :  this.game.Data.MapObj[index35].HexObj[index36, index37].get_DammagePerRegime(Index1) /  numArray1[Index1];
                    if ( num25 > 0.0)
                    {
                      num24 += 1;
                      let mut num26: i32 =   Math.Round( Conversion.Int(num25 *  numArray3[Index1]));
                      if ( VBMath.Rnd() <  num25 *  numArray3[Index1] -  num26)
                        num26 += 1;
                      if (num24 == numArray2[Index1])
                        num26 = numArray3[Index1] - num23;
                      if (num23 >= numArray3[Index1])
                        num26 = 0;
                      if (num26 > 0)
                      {
                        int[] sasKilled = this.game.Data.RegimeObj[Index1].SASKilled;
                        int[] numArray18 = sasKilled;
                        let mut index38: i32 =  sftypenr;
                        let mut index39: i32 =  index38;
                        let mut num27: i32 =  sasKilled[index38] + num26;
                        numArray18[index39] = num27;
                        HexClass[,] hexObj3 = this.game.Data.MapObj[index35].HexObj;
                        HexClass[,] hexClassArray3 = hexObj3;
                        let mut index40: i32 =  index36;
                        let mut index41: i32 =  index40;
                        let mut index42: i32 =  index37;
                        let mut index43: i32 =  index42;
                        HexClass hexClass3 = hexClassArray3[index41, index43];
                        let mut Index5: i32 =  Index1;
                        let mut Index6: i32 =  Index5;
                        let mut num28: i32 =  hexObj3[index40, index42].get_PowerPointsKilled(Index5) + this.game.Data.SFTypeObj[sftypenr].PowerPts * num26;
                        hexClass3.set_PowerPointsKilled(Index6, num28);
                        HexClass[,] hexObj4 = this.game.Data.MapObj[index35].HexObj;
                        HexClass[,] hexClassArray4 = hexObj4;
                        let mut index44: i32 =  index36;
                        let mut index45: i32 =  index44;
                        let mut index46: i32 =  index37;
                        let mut index47: i32 =  index46;
                        HexClass hexClass4 = hexClassArray4[index45, index47];
                        let mut turn: i32 =  this.game.Data.Turn;
                        let mut Index7: i32 =  turn;
                        let mut num29: i32 =  hexObj4[index44, index46].get_PowerPointsLost(turn) + this.game.Data.SFTypeObj[sftypenr].PowerPts * num26;
                        hexClass4.set_PowerPointsLost(Index7, num29);
                        num23 += num26;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    pub fn GetPowerInReinforcementPoints(unr: i32, rtyp: i32) -> i32
    {
      let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
      reinforcementPoints: i32;
      for (let mut index: i32 =  0; index <= sfCount; index += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].ReinforcementType == rtyp | rtyp == -1)
          reinforcementPoints += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
      }
      return reinforcementPoints;
    }

    pub fn PowerPointsDifferent(unr1: i32, unr2: i32) -> i32
    {
      SimpleList simpleList1 = SimpleList::new();
      SimpleList simpleList2 = SimpleList::new();
      let mut sfCount1: i32 =  this.game.Data.UnitObj[unr1].SFCount;
      for (let mut index1: i32 =  0; index1 <= sfCount1; index1 += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr1].SFList[index1];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut nr: i32 =  simpleList1.FindNr(this.game.Data.SFTypeObj[type].ReinforcementType + 10000 * this.game.Data.SFObj[sf].People);
        if (nr > -1)
        {
          int[] weight = simpleList1.Weight;
          int[] numArray = weight;
          let mut index2: i32 =  nr;
          let mut index3: i32 =  index2;
          let mut num: i32 =  weight[index2] + this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty;
          numArray[index3] = num;
        }
        else
          simpleList1.Add(this.game.Data.SFTypeObj[type].ReinforcementType + 10000 * this.game.Data.SFObj[sf].People, this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty);
      }
      let mut sfCount2: i32 =  this.game.Data.UnitObj[unr2].SFCount;
      for (let mut index4: i32 =  0; index4 <= sfCount2; index4 += 1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr2].SFList[index4];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut nr: i32 =  simpleList2.FindNr(this.game.Data.SFTypeObj[type].ReinforcementType + 10000 * this.game.Data.SFObj[sf].People);
        if (nr > -1)
        {
          int[] weight = simpleList2.Weight;
          int[] numArray = weight;
          let mut index5: i32 =  nr;
          let mut index6: i32 =  index5;
          let mut num: i32 =  weight[index5] + this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty;
          numArray[index6] = num;
        }
        else
          simpleList2.Add(this.game.Data.SFTypeObj[type].ReinforcementType + 10000 * this.game.Data.SFObj[sf].People, this.game.Data.SFTypeObj[type].PowerPts * this.game.Data.SFObj[sf].Qty);
      }
      let mut counter1: i32 =  simpleList1.Counter;
      num1: i32;
      for (let mut index7: i32 =  0; index7 <= counter1; index7 += 1)
      {
        let mut nr: i32 =  simpleList2.FindNr(simpleList1.Id[index7]);
        if (nr != -1)
        {
          int[] weight = simpleList1.Weight;
          int[] numArray = weight;
          let mut index8: i32 =  index7;
          let mut index9: i32 =  index8;
          let mut num2: i32 =  weight[index8] - simpleList2.Weight[nr];
          numArray[index9] = num2;
        }
        simpleList1.Weight[index7] = Math.Abs(simpleList1.Weight[index7]);
        if (simpleList1.Weight[index7] > 0)
          num1 += simpleList1.Weight[index7];
      }
      let mut counter2: i32 =  simpleList2.Counter;
      for (let mut index: i32 =  0; index <= counter2; index += 1)
      {
        if (simpleList1.FindNr(simpleList2.Id[index]) == -1)
          num1 += simpleList2.Weight[index];
      }
      return num1;
    }

    pub fn GetHistoricalsSubUnitCount(hisnr: i32) -> i32
    {
      let mut index: i32 =  0;
      historicalsSubUnitCount: i32;
      do
      {
        if (this.game.Data.HistoricalUnitObj[hisnr].SubParts[index] > -1)
          historicalsSubUnitCount += 1;
        index += 1;
      }
      while (index <= 9);
      return historicalsSubUnitCount;
    }

    pub GetRomanNumerical: String(nr: i32) => nr < 1 ? "" : this.deka2r(nr);

    pub deka2r: String(nr: i32)
    {
      strArray: Vec<String> = new string[13]
      {
        "M",
        "CM",
        "D",
        "CD",
        "C",
        "XC",
        "L",
        "XL",
        "X",
        "IX",
        "V",
        "IV",
        "I"
      };
      int[] numArray = new int[13]
      {
        1000,
        900,
        500,
        400,
        100,
        90,
        50,
        40,
        10,
        9,
        5,
        4,
        1
      };
      short index1 = 0;
      let mut num1: i32 =  nr;
      str: String;
      while (num1 > 0)
      {
        let mut num2: i32 =  num1 / numArray[ index1];
        short num3 = (short) num2;
        for (short index2 = 1;  index2 <=  num3; index2 += 1)
          str += strArray[ index1];
        num1 -= num2 * numArray[ index1];
        index1 += 1;
      }
      return str;
    }

    pub fn Disabled_GetHighCommand(regnr: i32) -> i32
    {
      SimpleList simpleList = SimpleList::new();
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut tid: i32 =  0; tid <= unitCounter1; tid += 1)
      {
        if (this.game.Data.UnitObj[tid].Regime == regnr & this.game.Data.UnitObj[tid].PreDef == -1 & this.game.Data.UnitObj[tid].X > -1 && this.game.Data.UnitObj[tid].IsHQ & this.game.Data.UnitObj[tid].HQ == -1)
        {
          let mut tweight: i32 =  0;
          let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
          for (let mut index: i32 =  0; index <= unitCounter2; index += 1)
          {
            if (this.game.Data.UnitObj[index].Regime == regnr & this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].X > -1 && this.game.Data.UnitObj[index].IsHQ & this.game.Data.UnitObj[index].HQ == tid)
              tweight += 1;
          }
          if (this.game.Data.UnitObj[tid].Historical > -1)
          {
            if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[tid].Historical].Type == 5)
              tweight *= 100;
            if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[tid].Historical].Type == 6)
              tweight *= 200;
            if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[tid].Historical].Type == 7)
              tweight *= 600;
            if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[tid].Historical].Type == 8)
              tweight *= 2400;
          }
          simpleList.Add(tid, tweight);
        }
      }
      if (simpleList.Counter == -1)
        return -1;
      simpleList.Sort();
      return simpleList.Id[simpleList.Counter];
    }

    pub HasUnitHQSomewhereUp: bool(unr: i32, hqnr: i32)
    {
      let mut index: i32 =  unr;
      let mut num: i32 =  0;
      while (num == 0)
      {
        if (this.game.Data.UnitObj[index].HQ == hqnr)
          return true;
        if (this.game.Data.UnitObj[index].HQ == -1)
          num = 1;
        else
          index = this.game.Data.UnitObj[index].HQ;
      }
      return false;
    }

    pub DoDestroyTransporters: i32(
      hq: i32,
      theater: i32,
      cappts: i32,
      x1: i32,
      y1: i32,
      map1: i32,
      x2: i32,
      y2: i32,
      map2: i32)
    {
      num1: i32;
      for (let mut sfCount: i32 =  this.game.Data.UnitObj[hq].SFCount; sfCount >= 0; sfCount += -1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[hq].SFList[sfCount];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        num2: i32;
        for (let mut index: i32 =  1; index <= qty; index += 1)
        {
          if (this.game.Data.SFTypeObj[type].Theater == theater && this.game.Data.SFTypeObj[type].Cap > 0)
          {
            let mut num3: i32 =  cappts;
            float num4 = theater != 0 ?  num3 /  this.game.Data.UnitObj[hq].NavyStart :  num3 /  this.game.Data.UnitObj[hq].LandStart;
            if ( VBMath.Rnd() <  num4)
            {
              num1 += 1;
              num2 += this.game.Data.SFTypeObj[type].Cap;
              this.RemoveTroops(hq, type, this.game.Data.SFObj[sf].People, 1, this.game.Data.SFObj[sf].MoveType);
              this.SetAntiSupplyKills(x1, y1, map1, x2, y2, map2, 0, type, 1);
            }
          }
          if (num2 >= cappts)
            break;
        }
        if (num2 >= cappts)
          break;
      }
      return num1;
    }

    pub DoDestroyRandom: i32(
      hq: i32,
      theater: i32,
      percentage: i32,
      x1: i32,
      y1: i32,
      map1: i32,
      x2: i32,
      y2: i32,
      map2: i32)
    {
      num1: i32;
      for (let mut sfCount: i32 =  this.game.Data.UnitObj[hq].SFCount; sfCount >= 0; sfCount += -1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[hq].SFList[sfCount];
        let mut type: i32 =  this.game.Data.SFObj[sf].Type;
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        for (let mut index: i32 =  1; index <= qty; index += 1)
        {
          float num2 =  percentage / 100f;
          if ( VBMath.Rnd() <  num2)
          {
            num1 += 1;
            num3: i32;
            num3 += this.game.Data.SFTypeObj[type].Cap;
            this.RemoveTroops(hq, type, this.game.Data.SFObj[sf].People, 1, this.game.Data.SFObj[sf].MoveType);
            this.SetAntiSupplyKills(x1, y1, map1, x2, y2, map2, 0, type, 1);
          }
        }
      }
      return num1;
    }

    pub GetMonth: String(nr: i32)
    {
      switch (nr)
      {
        case 1:
          return "January";
        case 2:
          return "February";
        case 3:
          return "March";
        case 4:
          return "April";
        case 5:
          return "May";
        case 6:
          return "June";
        case 7:
          return "July";
        case 8:
          return "August";
        case 9:
          return "September";
        case 10:
          return "October";
        case 11:
          return "November";
        case 12:
          return "December";
        default:
          month: String;
          return month;
      }
    }

    pub fn doscreenshot(extension: String, map: i32)
    {
      this.game.EditObj.TempCoordList = CoordList::new();
      if (this.game.Data.MapWidth + this.game.Data.MapHeight > 400 &  this.game.Data.RuleVar[878] < 1.0)
        return;
      let mut zoom: i32 =  this.game.EditObj.Zoom;
      this.game.EditObj.Zoom = -1;
      let mut mapSelected: i32 =  this.game.EditObj.MapSelected;
      this.game.EditObj.MapSelected = map;
      let mut num1: i32 =  this.CheckDiskSpace(Strings.Left(this.game.AppPath, Strings.InStr(this.game.AppPath, ":")));
      if (num1 > 0 & num1 < 50)
      {
        let mut num2: i32 =   Interaction.MsgBox( "Not enough space left to write to disk.");
      }
      else
      {
        width: i32;
        height: i32;
        if ( this.game.Data.RuleVar[850] == 0.0)
        {
          this.game.EditObj.Zoom = -1;
          width = this.game.Data.MapObj[map].MapWidth * 27 + 40;
          height = this.game.Data.MapObj[map].MapHeight * 24 + 32;
        }
        else if ( this.game.Data.RuleVar[850] == 1.0)
        {
          this.game.EditObj.Zoom = 0;
          width = this.game.Data.MapObj[map].MapWidth * 53 + 80;
          height = this.game.Data.MapObj[map].MapHeight * 48 + 64;
        }
        else if ( this.game.Data.RuleVar[850] == 2.0)
        {
          this.game.EditObj.Zoom = 1;
          width = this.game.Data.MapObj[map].MapWidth * 106 + 160;
          height = this.game.Data.MapObj[map].MapHeight * 96 + 128;
        }
        SubPartClass subPartClass;
        try
        {
          subPartClass =  new MapPartClass(width, height, this.game, true);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
          return;
        }
        FileStream fileStream = new FileStream(this.game.AppPath + "screenshots/" + this.game.Data.Name + "_map" + Conversion.Str( map) + "_turn" + Strings.Trim(Conversion.Str( this.game.Data.Turn)) + "_round" + Strings.Trim(Conversion.Str( this.game.Data.Round)) + "_" + extension + ".jpg", FileMode.Create);
        let mut cornerX: i32 =  this.game.CornerX;
        let mut cornerY: i32 =  this.game.CornerY;
        let mut selectX: i32 =  this.game.SelectX;
        let mut selectY: i32 =  this.game.SelectY;
        bool prefShowFow = this.game.EditObj.PrefShowFOW;
        this.game.CornerX = 0;
        this.game.CornerY = 0;
        this.game.SelectX = -1;
        this.game.SelectY = -1;
        this.game.EditObj.PrefShowFOW = false;
        bitmap1: Bitmap;
        try
        {
          bitmap1 = new Bitmap(width, height, PixelFormat.Format24bppRgb);
          bitmap1.SetResolution( DrawMod.DPIx,  DrawMod.DPIy);
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          ProjectData.ClearProjectError();
          return;
        }
        Graphics Expression = Graphics.FromImage((Image) bitmap1);
        Expression.SmoothingMode = SmoothingMode.AntiAlias;
         let mut local1: &Graphics = &Expression;
        bitmap2: Bitmap = subPartClass.Paint();
         let mut local2: &Bitmap = &bitmap2;
        DrawMod.DrawSimple( local1,  local2, 0, 0);
        bitmap1.Save((Stream) fileStream, ImageFormat.Jpeg);
        fileStream.Close();
        if (!Information.IsNothing( Expression))
        {
          Expression.Dispose();
          Expression = (Graphics) null;
        }
        Expression = (Graphics) null;
        this.game.EditObj.Zoom = zoom;
        this.game.EditObj.PrefShowFOW = prefShowFow;
        this.game.CornerX = cornerX;
        this.game.CornerY = cornerY;
        this.game.SelectX = selectX;
        this.game.SelectY = selectY;
        this.game.EditObj.MapSelected = mapSelected;
      }
    }

    pub fn ZipFile(FileToZip: String)
    {
      Crc32 crc32 = Crc32::new();
      GC.Collect();
      str: String = Path.GetDirectoryName(FileToZip) + "/temp.txt";
      if (System.IO.File.Exists(str))
        System.IO.File.Delete(str);
      System.IO.File.Copy(FileToZip, str);
      Application.DoEvents();
      FileStream fileStream1 = System.IO.File.OpenRead(str);
      byte[] numArray1 = new byte[ (fileStream1.Length - 1L) + 1];
      fileStream1.Read(numArray1, 0, numArray1.Length);
      ZipEntry entry = new ZipEntry(str);
      entry.DateTime = new DateTime(2010, 10, 10, 10, 10, 10);
      entry.DosTime = 0L;
      entry.Size = fileStream1.Length;
      fileStream1.Close();
      Application.DoEvents();
      let mut num1: i32 =  0;
      ZipOutputStream zipOutputStream;
      while (num1 < 9)
      {
        try
        {
          zipOutputStream = new ZipOutputStream((Stream) System.IO.File.Create(FileToZip));
          num1 = 99;
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          num1 += 1;
          Thread.Sleep(500);
          ProjectData.ClearProjectError();
        }
      }
      ZipEntry zipEntry;
      byte[] numArray2;
      FileStream fileStream2;
      if (num1 < 99)
      {
        zipEntry = (ZipEntry) null;
        numArray2 = (byte[]) null;
        fileStream1.Close();
        fileStream2 = (FileStream) null;
        System.IO.File.Delete(str);
        let mut num2: i32 =   Interaction.MsgBox( "Sorry. Was not able to create output stream. This results in file not being zipped properly. Your file is still usable but really big now. This issue might have to do with mediacenter or antivirus software.", Title: ( "Shadow Empire : Planetary Conquest"));
      }
      else
      {
        zipOutputStream.SetLevel(6);
        zipOutputStream.Password = "GarfieldJonesCat";
        zipOutputStream.PutNextEntry(entry);
        zipOutputStream.Write(numArray1, 0, numArray1.Length);
        zipOutputStream.Finish();
        zipOutputStream.Close();
        zipEntry = (ZipEntry) null;
        numArray2 = (byte[]) null;
        fileStream1.Close();
        fileStream2 = (FileStream) null;
        System.IO.File.Delete(str);
      }
    }

    pub fn ZipFileExport2(FileName: String, slist: Vec<String>, backupFolderPath: String) => new FastZip(FastZipEvents::new())
    {
      CreateEmptyDirectories = true
    }.CreateZip(FileName, backupFolderPath, true, "");

     void ProcessFileMethod(object sender, ScanEventArgs args)
    {
    }

    pub fn ZipFileExport(FileName: String, slist: Vec<String>)
    {
      Crc32 crc32 = Crc32::new();
      byte[] numArray1 = new byte[2];
      ZipOutputStream zipOutputStream = new ZipOutputStream((Stream) System.IO.File.Create(FileName));
      zipOutputStream.SetLevel(6);
      let mut upperBound: i32 =  slist.GetUpperBound(0);
      for (let mut index: i32 =  0; index <= upperBound; index += 1)
      {
        if (slist[index].Length > 0)
        {
          FileStream fileStream = System.IO.File.OpenRead(slist[index]);
          byte[] numArray2 = new byte[ (fileStream.Length - 1L) + 1];
          fileStream.Read(numArray2, 0, numArray2.Length);
          ZipEntry entry = new ZipEntry(slist[index].Replace("\\", "/").Replace(this.game.AppPath.Replace("\\", "/"), ""));
          entry.DateTime = DateTime.Now;
          entry.Size = fileStream.Length;
          fileStream.Close();
          crc32.Reset();
          crc32.Update(numArray2);
          entry.Crc = crc32.Value;
          zipOutputStream.PutNextEntry(entry);
          zipOutputStream.Write(numArray2, 0, numArray2.Length);
        }
      }
      zipOutputStream.Finish();
      zipOutputStream.Close();
    }

    pub void RecursiveDirectoryCopy(
      sourceDir: String,
      destDir: String,
      bool fRecursive,
      bool overWrite)
    {
      if (!sourceDir.EndsWith(Path.DirectorySeparatorChar.ToString()))
        sourceDir += Conversions.ToString(Path.DirectorySeparatorChar);
      if (!destDir.EndsWith(Path.DirectorySeparatorChar.ToString()))
        destDir += Conversions.ToString(Path.DirectorySeparatorChar);
      DirectoryInfo directoryInfo1 = new DirectoryInfo(destDir);
      if (!directoryInfo1.Exists)
        directoryInfo1.Create();
      DirectoryInfo directoryInfo2 = (DirectoryInfo) null;
      if (fRecursive)
      {
        foreach (directory: String in Directory.GetDirectories(sourceDir))
        {
          DirectoryInfo directoryInfo3 = new DirectoryInfo(directory);
          DirectoryInfo directoryInfo4 = new DirectoryInfo(destDir + directoryInfo3.Name);
          if (!directoryInfo4.Exists)
            directoryInfo4.Create();
          this.RecursiveDirectoryCopy(directoryInfo3.FullName, directoryInfo4.FullName, fRecursive, overWrite);
          directoryInfo2 = (DirectoryInfo) null;
        }
      }
      foreach (file: String in Directory.GetFiles(sourceDir))
      {
        FileInfo fileInfo1 = new FileInfo(file);
        FileInfo fileInfo2 = new FileInfo(Strings.Replace(file, sourceDir, destDir));
        if (!fileInfo2.Exists)
          fileInfo1.CopyTo(fileInfo2.FullName, overWrite);
        else if (fileInfo1.Length != fileInfo2.Length && overWrite)
          fileInfo1.CopyTo(fileInfo2.FullName, overWrite);
        else if (fileInfo1.Length != fileInfo2.Length && !overWrite)
          Debug.WriteLine(fileInfo1.FullName + " Not copied.");
      }
    }

    pub fn UnzipImport(ZipFile: String)
    {
      appPath: String = this.game.AppPath;
      let mut num1: i32 =  1;
      ZipInputStream zipInputStream = new ZipInputStream((Stream) System.IO.File.OpenRead(ZipFile));
      while (num1 == 1)
      {
        ZipEntry nextEntry;
        num2: i32;
        try
        {
          nextEntry = zipInputStream.GetNextEntry();
        }
        catch (Exception ex)
        {
          ProjectData.SetProjectError(ex);
          zipInputStream.Close();
          num2 = 0;
          ProjectData.ClearProjectError();
          break;
        }
        if (Information.IsNothing( nextEntry))
        {
          num2 = 0;
          break;
        }
        if (nextEntry.IsFile)
        {
          let mut count: i32 =   nextEntry.Size;
          Left: String = Path.GetDirectoryName(nextEntry.Name);
          if (this.game.ModScenarioDir.Length > 0 & Operators.CompareString(Left, "scenarios", false) == 0)
            Left = this.game.ModScenarioDir;
          if (Left.Length > 0)
          {
            path: String = appPath + "/" + Left;
            if (!Directory.Exists(path))
              Directory.CreateDirectory(path);
          }
          str1: String = (appPath + nextEntry.Name).Replace("\\", "/");
          if (this.game.ModScenarioDir.Length > 0)
            str1 = str1.Replace("/scenarios/", "/" + this.game.ModScenarioDir + "/");
          FileStream output = new FileStream(str1, FileMode.Create);
          BinaryWriter binaryWriter = new BinaryWriter((Stream) output, Encoding.ASCII);
          byte[] numArray = new byte[4097];
          while (count > 0)
          {
            count = zipInputStream.Read(numArray, 0, numArray.Length);
            binaryWriter.Write(numArray, 0, count);
          }
          binaryWriter.Close();
          output.Close();
          if (Strings.InStr(str1, "mods/") > 0 & Strings.InStr(str1, ".txt") > 0)
            this.game.EditObj.FindModFile = true;
          if (Strings.InStr(str1, "readme.txt") > 0)
          {
            StreamReader streamReader = System.IO.File.OpenText(str1);
            try
            {
              str2: String = streamReader.ReadToEnd();
              if (Strings.Len(str2) > 500)
                str2 = Strings.Left(str2, 500);
              this.game.EditObj.ZipFileText = str2;
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              this.game.EditObj.ZipFileText = "";
              ProjectData.ClearProjectError();
            }
          }
        }
        else if (nextEntry.IsDirectory)
        {
          path: String = (appPath + nextEntry.Name).Replace("\\", "/");
          if (this.game.ModScenarioDir.Length > 0)
            path = path.Replace("/scenarios/", "/" + this.game.ModScenarioDir + "/");
          Directory.CreateDirectory(path);
        }
      }
      zipInputStream.Close();
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    pub fn Unzip(ZipFile: String)
    {
      GC.Collect();
      str: String = Path.GetDirectoryName(ZipFile) + "/temp.txt";
      if (System.IO.File.Exists(str))
        System.IO.File.Delete(str);
      System.IO.File.Copy(ZipFile, str);
      ZipInputStream zipInputStream = new ZipInputStream((Stream) System.IO.File.OpenRead(str));
      zipInputStream.Password = "GarfieldJonesCat";
      ZipEntry nextEntry;
      try
      {
        nextEntry = zipInputStream.GetNextEntry();
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        zipInputStream.Close();
        System.IO.File.Delete(str);
        ProjectData.ClearProjectError();
        return;
      }
      let mut count: i32 =   nextEntry.Size;
      FileStream output = new FileStream(ZipFile, FileMode.Create);
      BinaryWriter binaryWriter = new BinaryWriter((Stream) output, Encoding.ASCII);
      byte[] numArray = new byte[4097];
      try
      {
        while (count > 0)
        {
          count = zipInputStream.Read(numArray, 0, numArray.Length);
          binaryWriter.Write(numArray, 0, count);
        }
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        zipInputStream.Close();
        binaryWriter.Close();
        output.Close();
        zipInputStream = (ZipInputStream) null;
        binaryWriter = (BinaryWriter) null;
        output = (FileStream) null;
        System.IO.File.Delete(str);
        let mut num: i32 =   Interaction.MsgBox( "Error : Your (save)file is corrupt. Sorry, but we have to exit the game now. ", Title: ( "Shadow Empire : Planetary Conquest"));
        ProjectData.EndApp();
        ProjectData.ClearProjectError();
      }
      zipInputStream.Close();
      binaryWriter.Close();
      output.Close();
      System.IO.File.Delete(str);
    }

    pub CanUnitReceiveTransfer: bool(unr: i32, sftype: i32, qty: i32, ppl: i32) => true;

    pub GetAreaName: String(slot: i32, code: i32)
    {
      if (slot < 0 | slot > 9 || code < 1)
        return "";
      let mut areaCounter: i32 =  this.game.Data.AreaCounter;
      for (let mut index: i32 =  0; index <= areaCounter; index += 1)
      {
        if (this.game.Data.AreaObj[index].Slot == slot & this.game.Data.AreaObj[index].Code == code)
          return this.game.Data.AreaObj[index].Name;
      }
      return "";
    }

    pub fn GetMapUnitByID(hisID: i32) -> i32
    {
      if (hisID < 1)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut mapUnitById: i32 =  0; mapUnitById <= unitCounter; mapUnitById += 1)
      {
        if (this.game.Data.UnitObj[mapUnitById].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[mapUnitById].Historical].ID == hisID)
          return mapUnitById;
      }
      return -1;
    }

    pub fn GetRegimeByID(id: i32) -> i32
    {
      if (id < 1)
        return -1;
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut regimeById: i32 =  0; regimeById <= regimeCounter; regimeById += 1)
      {
        if (this.game.Data.RegimeObj[regimeById].id == id)
          return regimeById;
      }
      return -1;
    }

    pub fn GetPeopleByID(id: i32) -> i32
    {
      if (id < 1)
        return -1;
      let mut peopleCounter: i32 =  this.game.Data.PeopleCounter;
      for (let mut peopleById: i32 =  0; peopleById <= peopleCounter; peopleById += 1)
      {
        if (this.game.Data.PeopleObj[peopleById].id == id)
          return peopleById;
      }
      return -1;
    }

    pub fn GetUnitByHistorical(his: i32) -> i32
    {
      if (his < 0)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut unitByHistorical: i32 =  0; unitByHistorical <= unitCounter; unitByHistorical += 1)
      {
        if (this.game.Data.UnitObj[unitByHistorical].Historical == his)
          return unitByHistorical;
      }
      return -1;
    }

    pub fn GetUnitByHistorical(his: i32, subp: i32) -> i32
    {
      if (his < 0)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut unitByHistorical: i32 =  0; unitByHistorical <= unitCounter; unitByHistorical += 1)
      {
        if (this.game.Data.UnitObj[unitByHistorical].Historical == his && this.game.Data.UnitObj[unitByHistorical].HistoricalSubPart == subp)
          return unitByHistorical;
      }
      return -1;
    }

    pub fn GetUnitByAIid(id: i32) -> i32
    {
      if (id < 1)
        return -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut unitByAiid: i32 =  0; unitByAiid <= unitCounter; unitByAiid += 1)
      {
        if (this.game.Data.UnitObj[unitByAiid].AIid == id)
          return unitByAiid;
      }
      return -1;
    }

    pub fn GetAreaByID(areaID: i32) -> i32
    {
      if (areaID < 1)
        return -1;
      let mut areaCounter: i32 =  this.game.Data.AreaCounter;
      for (let mut areaById: i32 =  0; areaById <= areaCounter; areaById += 1)
      {
        if (this.game.Data.AreaObj[areaById].ID == areaID)
          return areaById;
      }
      return -1;
    }

    pub fn GetAreaBySlot(Slot: i32, Code: i32) -> i32
    {
      let mut areaCounter: i32 =  this.game.Data.AreaCounter;
      for (let mut areaBySlot: i32 =  0; areaBySlot <= areaCounter; areaBySlot += 1)
      {
        if (this.game.Data.AreaObj[areaBySlot].Slot == Slot & this.game.Data.AreaObj[areaBySlot].Code == Code)
          return areaBySlot;
      }
      return -1;
    }

    pub IsHexArea: bool(x: i32, y: i32, area: i32)
    {
      let mut index: i32 =  0;
      while (!(this.game.Data.AreaObj[area].Slot == index & this.game.Data.AreaObj[area].Code == this.game.Data.MapObj[0].HexObj[x, y].AreaCode[index]))
      {
        index += 1;
        if (index > 9)
          return false;
      }
      return true;
    }

    pub fn DisperseAirSupply(x: i32, y: i32, map: i32, pts: i32)
    {
      SimpleList simpleList = SimpleList::new();
      this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[857]), 99,  Math.Round( this.game.Data.RuleVar[858]), x, y, map, allowshoredrop: true, SeaBlock: true, BlockAllSea: true);
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      num1: i32;
      for (let mut tid: i32 =  0; tid <= unitCounter; tid += 1)
      {
        if (this.game.Data.UnitObj[tid].Regime == this.game.Data.Turn && this.game.Data.UnitObj[tid].PreDef == -1 & this.game.Data.UnitObj[tid].X > -1 & this.game.Data.UnitObj[tid].Map == map)
        {
          let mut x1: i32 =  this.game.Data.UnitObj[tid].X;
          let mut y1: i32 =  this.game.Data.UnitObj[tid].Y;
          let mut map1: i32 =  this.game.Data.UnitObj[tid].Map;
          this.game.EditObj.TempValue3[map1].Value[x1, y1] = 9999;
          if ( this.game.EditObj.TempValue[map1].Value[x1, y1] <=  this.game.Data.RuleVar[858])
          {
            let mut tweight: i32 =  this.game.Data.UnitObj[tid].SupplyInReq - this.game.Data.UnitObj[tid].SupplyIn;
            if (this.game.Data.UnitObj[tid].IsHQ)
              tweight -= this.game.Data.UnitObj[tid].SupplyReq - this.game.Data.UnitObj[tid].SupplyOut;
            if (0 > tweight)
              tweight = 0;
            if ( this.game.EditObj.TempValue[map1].Value[x1, y1] >=  this.game.Data.RuleVar[858] * 0.25)
              tweight =  Math.Round( tweight * 0.75);
            else if ( this.game.EditObj.TempValue[map1].Value[x1, y1] >=  this.game.Data.RuleVar[858] * 0.5)
              tweight =  Math.Round( tweight * 0.5);
            else if ( this.game.EditObj.TempValue[map1].Value[x1, y1] >=  this.game.Data.RuleVar[858] * 0.75)
              tweight =  Math.Round( tweight * 0.25);
            num1 += tweight;
            simpleList.Add(tid, tweight);
          }
          this.game.EditObj.TempValue3[map1].Value[x1, y1] = 0;
        }
      }
      if (simpleList.Counter <= -1)
        return;
      float num2 =  pts /  num1;
      if ( num2 > 1.0)
        num2 = 1f;
      let mut counter: i32 =  simpleList.Counter;
      for (let mut index1: i32 =  0; index1 <= counter; index1 += 1)
      {
        let mut num3: i32 =  simpleList.Id[index1];
        let mut num4: i32 =   Math.Round( ( simpleList.Weight[index1] * num2));
        UnitClass[] unitObj1 = this.game.Data.UnitObj;
        UnitClass[] unitClassArray1 = unitObj1;
        let mut index2: i32 =  num3;
        let mut index3: i32 =  index2;
        unitClassArray1[index3].Supply = unitObj1[index2].Supply + num4;
        UnitClass[] unitObj2 = this.game.Data.UnitObj;
        UnitClass[] unitClassArray2 = unitObj2;
        let mut index4: i32 =  num3;
        let mut index5: i32 =  index4;
        unitClassArray2[index5].SupplyIn = unitObj2[index4].SupplyIn + num4;
      }
    }

    pub fn RemoveAllActionCardofType(regnr: i32, actcardnr: i32)
    {
      for (let mut actionCardCounter: i32 =  this.game.Data.RegimeObj[regnr].ActionCardCounter; actionCardCounter >= 0; actionCardCounter += -1)
      {
        if (this.game.Data.RegimeObj[regnr].ActionCard[actionCardCounter] == actcardnr)
          this.game.Data.RegimeObj[regnr].RemoveActionCard(actionCardCounter);
      }
    }

    pub fn RemoveHistoryActionCard(regnr: i32, actcardnr: i32)
    {
      for (let mut cardHistoryCounter: i32 =  this.game.Data.RegimeObj[regnr].ActionCardHistoryCounter; cardHistoryCounter >= 0; cardHistoryCounter += -1)
      {
        if (this.game.Data.RegimeObj[regnr].ActionCardHistory[cardHistoryCounter] == actcardnr)
          this.game.Data.RegimeObj[regnr].RemoveActionCardHistory(cardHistoryCounter);
      }
    }

    pub fn DownloadFile(url: String, savename: String) -> i32
    {
      try
      {
        HttpWebRequest httpWebRequest1 = (HttpWebRequest) WebRequest.Create(url);
        httpWebRequest1.Timeout = 500;
        HttpWebResponse response = (HttpWebResponse) httpWebRequest1.GetResponse();
        Stream responseStream = response.GetResponseStream();
        HttpWebRequest httpWebRequest2;
        if (System.IO.File.Exists(savename))
        {
          try
          {
            if (new FileInfo(savename).Length == response.ContentLength)
            {
              responseStream.Close();
              response.Close();
              httpWebRequest2 = (HttpWebRequest) null;
              goto label_11;
            }
          }
          catch (Exception ex)
          {
            ProjectData.SetProjectError(ex);
            ProjectData.ClearProjectError();
          }
        }
        byte[] numArray = new byte[1000001];
        let mut length: i32 =  numArray.Length;
        let mut num1: i32 =  0;
        num2: i32;
        for (; length > 0; length -= num2)
        {
          num2 = responseStream.Read(numArray, num1, length);
          if (num2 != 0)
            num1 += num2;
          else
            break;
        }
        FileStream fileStream = new FileStream(savename, FileMode.OpenOrCreate, FileAccess.Write);
        fileStream.Write(numArray, 0, num1);
        responseStream.Close();
        fileStream.Close();
        response.Close();
        httpWebRequest2 = (HttpWebRequest) null;
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        ProjectData.ClearProjectError();
      }
label_11:
      num: i32;
      return num;
    }

    pub fn randomizeLT()
    {
      VBMath.Randomize();
      let mut mapCounter: i32 =  this.game.Data.MapCounter;
      for (let mut index1: i32 =  0; index1 <= mapCounter; index1 += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[index1].MapWidth;
        for (let mut index2: i32 =  0; index2 <= mapWidth; index2 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index1].MapHeight;
          for (let mut index3: i32 =  0; index3 <= mapHeight; index3 += 1)
          {
            let mut landscapeType: i32 =  this.game.Data.MapObj[index1].HexObj[index2, index3].LandscapeType;
            let mut spriteNr: i32 =  this.game.Data.MapObj[index1].HexObj[index2, index3].SpriteNr;
            if (this.game.Data.LandscapeTypeObj[landscapeType].BasicSpriteRandom[spriteNr] > 0)
            {
              let mut num: i32 =  this.RandomizeHexLT(landscapeType, spriteNr);
              this.game.Data.MapObj[index1].HexObj[index2, index3].SpriteNr = num;
            }
          }
        }
      }
    }

    pub fn RandomizeHex(ix: i32, iy: i32, imap: i32)
    {
      let mut landscapeType: i32 =  this.game.Data.MapObj[imap].HexObj[ix, iy].LandscapeType;
      let mut spriteNr: i32 =  this.game.Data.MapObj[imap].HexObj[ix, iy].SpriteNr;
      if (this.game.Data.LandscapeTypeObj[landscapeType].BasicSpriteRandom[spriteNr] <= 0)
        return;
      let mut num: i32 =  this.RandomizeHexLT(landscapeType, spriteNr);
      this.game.Data.MapObj[imap].HexObj[ix, iy].SpriteNr = num;
    }

    pub fn RandomizeHexLT(ltnr: i32, spnr: i32) -> i32
    {
      let mut num1: i32 =  0;
      let mut basicSpriteCounter1: i32 =  this.game.Data.LandscapeTypeObj[ltnr].BasicSpriteCounter;
      for (let mut index: i32 =  0; index <= basicSpriteCounter1; index += 1)
      {
        if (this.game.Data.LandscapeTypeObj[ltnr].BasicSpriteRandom[index] == this.game.Data.LandscapeTypeObj[ltnr].BasicSpriteRandom[spnr])
          num1 += 1;
      }
      let mut num2: i32 =   Math.Round( VBMath.Rnd() *  num1 + 1.0);
      let mut num3: i32 =  0;
      let mut basicSpriteCounter2: i32 =  this.game.Data.LandscapeTypeObj[ltnr].BasicSpriteCounter;
      for (let mut index: i32 =  0; index <= basicSpriteCounter2; index += 1)
      {
        if (this.game.Data.LandscapeTypeObj[ltnr].BasicSpriteRandom[index] == this.game.Data.LandscapeTypeObj[ltnr].BasicSpriteRandom[spnr])
        {
          num3 += 1;
          if (num3 == num2)
            return index;
        }
      }
      return 0;
    }

    pub fn GetPreDef(predefnr: i32) -> i32
    {
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut preDef: i32 =  0; preDef <= unitCounter; preDef += 1)
      {
        if (this.game.Data.UnitObj[preDef].PreDef == predefnr)
          return preDef;
      }
      return -1;
    }

    pub fn LoadGameNow()
    {
      int[] numArray1 = new int[501];
      strArray: Vec<String> = new string[1000];
      bool[] flagArray1 = new bool[1000];
      bool[] flagArray2 = new bool[1000];
      bool[] flagArray3 = new bool[1000];
      bool[] flagArray4 = new bool[1000];
      int[] numArray2 = new int[1000];
      int[] numArray3 = new int[10000];
      int[] numArray4 = new int[1000];
      bool passwordsOn = this.game.Data.PasswordsOn;
      bool pbem = this.game.Data.PBEM;
      bool terrorMode = this.game.Data.TerrorMode;
      bool fowOn = this.game.Data.FOWOn;
      bool shrowdOn = this.game.Data.ShrowdOn;
      bool dontShowAiMove = this.game.Data.DontShowAIMove;
      str: String = this.game.AppPath + this.game.Data.LoadGame;
      GameClassSmall gameClassSmall;
      regimeCounter1: i32;
      if (System.IO.File.Exists(str))
      {
        gameClassSmall = GameClassSmall::new();
        let mut index1: i32 =  0;
        do
        {
          numArray1[index1] = this.game.Data.GameSlot[index1];
          index1 += 1;
        }
        while (index1 <= 399);
        regimeCounter1 = this.game.Data.RegimeCounter;
        let mut regimeCounter2: i32 =  this.game.Data.RegimeCounter;
        for (let mut index2: i32 =  0; index2 <= regimeCounter2; index2 += 1)
        {
          strArray[index2] = this.game.Data.RegimeObj[index2].PassWord;
          flagArray1[index2] = this.game.Data.RegimeObj[index2].AI;
          numArray2[index2] = this.game.Data.RegimeObj[index2].ProdBonus;
          numArray4[index2] = this.game.Data.RegimeObj[index2].ResPts;
          flagArray2[index2] = (uint) this.game.Data.RegimeObj[index2].AIHelpMove > 0U;
          flagArray3[index2] = (uint) this.game.Data.RegimeObj[index2].AIHelpCombat > 0U;
          flagArray4[index2] = (uint) this.game.Data.RegimeObj[index2].AIHelpStrategic > 0U;
        }
        gameClassSmall.HandyFunctionsObj.Unzip(str);
        gameClassSmall.Data = DataClass.deserialize(str);
        gameClassSmall.HandyFunctionsObj.ZipFile(str);
        if (Strings.Len(gameClassSmall.Data.MasterFile) > 0)
        {
          masterFile: String = gameClassSmall.Data.MasterFile;
          filename: String = this.game.HandyFunctionsObj.ReturnLongMaster(str, masterFile);
          gameClassSmall.HandyFunctionsObj.LoadMasterFile(filename);
        }
        let mut unitCounter1: i32 =  gameClassSmall.Data.UnitCounter;
        for (let mut index3: i32 =  0; index3 <= unitCounter1; index3 += 1)
          gameClassSmall.Data.UnitObj[index3].TempOldNr = -1;
        let mut regimeCounter3: i32 =  gameClassSmall.Data.RegimeCounter;
        for (let mut index4: i32 =  0; index4 <= regimeCounter3; index4 += 1)
        {
          if (index4 <= this.game.Data.RegimeCounter)
          {
            if (!this.game.Data.RegimeObj[index4].Sleep)
              gameClassSmall.Data.RegimeObj[index4].ResPts = numArray4[index4];
            if (this.game.Data.RegimeObj[index4].LoadResearchTransfer)
            {
              let mut researchCounter: i32 =  this.game.Data.ResearchCounter;
              for (let mut index5: i32 =  0; index5 <= researchCounter; index5 += 1)
              {
                gameClassSmall.Data.RegimeObj[index4].ResField[index5] = this.game.Data.RegimeObj[index4].ResField[index5];
                this.game.Data.RegimeObj[index4].LoadResearchTransfer = false;
              }
            }
            if (this.game.Data.RegimeObj[index4].LoadTransferHistorical)
            {
              let mut historicalUnitCounter1: i32 =  this.game.Data.HistoricalUnitCounter;
              for (let mut index6: i32 =  0; index6 <= historicalUnitCounter1; index6 += 1)
              {
                if (this.game.Data.HistoricalUnitObj[index6].TempRegime == index4)
                {
                  let mut num: i32 =  1;
                  if (index6 == 1315)
                    index6 = index6;
                  let mut historicalUnitCounter2: i32 =  gameClassSmall.Data.HistoricalUnitCounter;
                  for (let mut index7: i32 =  0; index7 <= historicalUnitCounter2; index7 += 1)
                  {
                    if (gameClassSmall.Data.HistoricalUnitObj[index7].ID == this.game.Data.HistoricalUnitObj[index6].ID)
                    {
                      numArray3[index6] = index7;
                      num = 0;
                    }
                  }
                  if (num == 1)
                  {
                    gameClassSmall.Data.AddHistoricalUnit();
                    gameClassSmall.Data.HistoricalUnitObj[gameClassSmall.Data.HistoricalUnitCounter] = this.game.Data.HistoricalUnitObj[index6].Clone();
                    if (gameClassSmall.Data.HistoricalIDCounter < this.game.Data.HistoricalIDCounter)
                      gameClassSmall.Data.HistoricalIDCounter = this.game.Data.HistoricalIDCounter;
                    gameClassSmall += 1.Data.HistoricalIDCounter;
                    gameClassSmall.Data.HistoricalUnitObj[gameClassSmall.Data.HistoricalUnitCounter].ID = gameClassSmall.Data.HistoricalIDCounter;
                    numArray3[index6] = gameClassSmall.Data.HistoricalUnitCounter;
                  }
                }
              }
              this.game.Data.RegimeObj[index4].LoadTransferHistorical = false;
            }
            if (this.game.Data.RegimeObj[index4].LoadTransferUnit)
            {
              let mut unitCounter2: i32 =  this.game.Data.UnitCounter;
              for (let mut index8: i32 =  0; index8 <= unitCounter2; index8 += 1)
              {
                if (this.game.Data.UnitObj[index8].PreDef == -1 & this.game.Data.UnitObj[index8].Regime == index4 & !this.game.Data.UnitObj[index8].IsHQ & this.game.Data.UnitObj[index8].HQ == -1)
                {
                  let mut unitCounter3: i32 =  this.game.Data.UnitCounter;
                  for (let mut index9: i32 =  0; index9 <= unitCounter3; index9 += 1)
                  {
                    if (this.game.Data.UnitObj[index9].PreDef == -1 & this.game.Data.UnitObj[index9].Regime == index4 & this.game.Data.UnitObj[index9].IsHQ)
                    {
                      this.game.Data.UnitObj[index8].HQ = index9;
                      break;
                    }
                  }
                }
              }
            }
            if (this.game.Data.RegimeObj[index4].LoadTransferUnit)
            {
              let mut num: i32 =  0;
              do
              {
                let mut unitCounter4: i32 =  this.game.Data.UnitCounter;
                for (let mut index10: i32 =  0; index10 <= unitCounter4; index10 += 1)
                {
                  if (this.game.Data.UnitObj[index10].PreDef == -1 & this.game.Data.UnitObj[index10].Regime == index4 & this.game.Data.UnitObj[index10].IsHQ)
                  {
                    let mut unitCounter5: i32 =  this.game.Data.UnitCounter;
                    for (let mut unr: i32 =  0; unr <= unitCounter5; unr += 1)
                    {
                      if (unr >= 150)
                        unr = unr;
                      if (this.game.Data.UnitObj[unr].PreDef == -1 & this.game.Data.UnitObj[unr].Regime == index4 & (unr == index10 | this.game.Data.UnitObj[unr].HQ == index10 & !this.game.Data.UnitObj[unr].IsHQ) && num == 0 & (this.game.HandyFunctionsObj.HasUnitNavySF(unr, this.game.Data) | this.game.HandyFunctionsObj.HasUnitAirSF(unr, this.game.Data) | this.game.Data.UnitObj[unr].SFCount == -1) | num == 1 & !this.game.HandyFunctionsObj.HasUnitNavySF(unr) & !this.game.HandyFunctionsObj.HasUnitAirSF(unr, this.game.Data) & this.game.Data.UnitObj[unr].SFCount > -1)
                      {
                        SimpleList simpleList = SimpleList::new();
                        let mut mapCounter: i32 =  this.game.Data.MapCounter;
                        for (let mut map: i32 =  0; map <= mapCounter; map += 1)
                        {
                          let mut mapWidth: i32 =  gameClassSmall.Data.MapObj[map].MapWidth;
                          for (let mut index11: i32 =  0; index11 <= mapWidth; index11 += 1)
                          {
                            let mut mapHeight: i32 =  gameClassSmall.Data.MapObj[map].MapHeight;
                            for (let mut index12: i32 =  0; index12 <= mapHeight; index12 += 1)
                            {
                              if (gameClassSmall.Data.MapObj[map].HexObj[index11, index12].Regime == index4 & gameClassSmall.Data.MapObj[map].HexObj[index11, index12].AreaCode[this.game.Data.RegimeObj[index4].LoadAreaSlot] > 0 && gameClassSmall.Data.MapObj[map].HexObj[index11, index12].UnitCounter + 2 <= this.game.Data.RegimeObj[index4].LoadPerHex | this.game.Data.UnitObj[unr].IsHQ | this.game.Data.UnitObj[unr].SFCount == -1 | this.game.HandyFunctionsObj.HasUnitAirSF(unr, this.game.Data) | this.game.HandyFunctionsObj.HasUnitNavySF(unr, this.game.Data) && !this.game.HandyFunctionsObj.HasUnitNavySF(unr, this.game.Data) | gameClassSmall.HandyFunctionsObj.IsHexHarbourOrSea(index11, index12, map, gameClassSmall.Data) && !this.game.HandyFunctionsObj.HasUnitAirSF(unr, this.game.Data) & this.game.Data.UnitObj[unr].SFCount > -1 | gameClassSmall.HandyFunctionsObj.IsHexAirfield(index11, index12, map, gameClassSmall.Data) && !this.game.Data.UnitObj[unr].IsHQ | gameClassSmall.Data.MapObj[0].HexObj[index11, index12].Location > -1)
                              {
                                let mut tweight: i32 =  gameClassSmall.Data.MapObj[map].HexObj[index11, index12].AreaCode[DrawMod.TGame.Data.RegimeObj[index4].LoadAreaSlot] * 1000 - (gameClassSmall.Data.MapObj[map].HexObj[index11, index12].UnitCounter + 1);
                                if (this.game.Data.UnitObj[unr].Historical > -1 & !this.game.HandyFunctionsObj.HasUnitAirSF(unr, this.game.Data) & !this.game.HandyFunctionsObj.HasUnitNavySF(unr, this.game.Data))
                                {
                                  let mut unitCounter6: i32 =  gameClassSmall.Data.MapObj[map].HexObj[index11, index12].UnitCounter;
                                  for (let mut index13: i32 =  0; index13 <= unitCounter6; index13 += 1)
                                  {
                                    let mut unit: i32 =  gameClassSmall.Data.MapObj[map].HexObj[index11, index12].UnitList[index13];
                                    if (gameClassSmall.Data.UnitObj[unit].Historical == numArray3[this.game.Data.UnitObj[unr].Historical])
                                      tweight += 50;
                                  }
                                }
                                simpleList.Add(index11 * 1000 + index12, tweight, index11, index12);
                              }
                            }
                          }
                        }
                        if (simpleList.Counter > -1)
                        {
                          simpleList.Sort();
                          gameClassSmall.Data.AddUnit(simpleList.Data1[simpleList.Counter], simpleList.Data2[simpleList.Counter], 0);
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Name = this.game.Data.UnitObj[unr].Name;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Red = this.game.Data.UnitObj[unr].Red;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Blue = this.game.Data.UnitObj[unr].Blue;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Green = this.game.Data.UnitObj[unr].Green;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].IsHQ = this.game.Data.UnitObj[unr].IsHQ;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].HQ = this.game.Data.UnitObj[unr].HQ;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Regime = this.game.Data.UnitObj[unr].Regime;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Historical = this.game.Data.UnitObj[unr].Historical;
                          if (gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Historical > -1)
                            gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Historical = numArray3[this.game.Data.UnitObj[unr].Historical];
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].HistoricalSubPart = this.game.Data.UnitObj[unr].HistoricalSubPart;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].PreDef = -1;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].PassengerCounter = -1;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].TempOldNr = unr;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Supply = this.game.Data.UnitObj[unr].Supply;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].SODefendPercent = this.game.Data.UnitObj[unr].SODefendPercent;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].SODoAS = this.game.Data.UnitObj[unr].SODoAS;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].SOInterceptRdnStop = this.game.Data.UnitObj[unr].SOInterceptRdnStop;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].SOSupReqPercent = this.game.Data.UnitObj[unr].SOSupReqPercent;
                          gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].SOReplacementPercent = this.game.Data.UnitObj[unr].SOReplacementPercent;
                          let mut historical1: i32 =  gameClassSmall.Data.UnitObj[gameClassSmall.Data.UnitCounter].Historical;
                          let mut historical2: i32 =  this.game.Data.UnitObj[unr].Historical;
                          if (historical1 > -1 & historical2 > -1 && !Information.IsNothing( this.game.Data.HistoricalUnitObj[historical2].CommanderName) && this.game.Data.HistoricalUnitObj[historical2].CommanderName.Length > 0)
                          {
                            gameClassSmall.Data.HistoricalUnitObj[historical1].CommanderName = this.game.Data.HistoricalUnitObj[historical2].CommanderName;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].Descript = this.game.Data.HistoricalUnitObj[historical2].Descript;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].CommanderFileName = this.game.Data.HistoricalUnitObj[historical2].CommanderFileName;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].CommanderSpriteID = this.game.Data.HistoricalUnitObj[historical2].CommanderSpriteID;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].OverdrawFileName = this.game.Data.HistoricalUnitObj[historical2].OverdrawFileName;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].OverdrawSpriteID = this.game.Data.HistoricalUnitObj[historical2].OverdrawSpriteID;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].StaffSize = this.game.Data.HistoricalUnitObj[historical2].StaffSize;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].CombatMod = this.game.Data.HistoricalUnitObj[historical2].CombatMod;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].MoraleMod = this.game.Data.HistoricalUnitObj[historical2].MoraleMod;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].Xp = this.game.Data.HistoricalUnitObj[historical2].Xp;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].TempVar1 = this.game.Data.HistoricalUnitObj[historical2].TempVar1;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].TempVar2 = this.game.Data.HistoricalUnitObj[historical2].TempVar2;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].TempVar3 = this.game.Data.HistoricalUnitObj[historical2].TempVar3;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].PP = this.game.Data.HistoricalUnitObj[historical2].PP;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].People = this.game.Data.HistoricalUnitObj[historical2].People;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].AutoEventCounter = this.game.Data.HistoricalUnitObj[historical2].AutoEventCounter;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].AutoEvent = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].AutoEventCounter + 1];
                            gameClassSmall.Data.HistoricalUnitObj[historical1].AutoChance = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].AutoEventCounter + 1];
                            let mut autoEventCounter: i32 =  gameClassSmall.Data.HistoricalUnitObj[historical1].AutoEventCounter;
                            for (let mut index14: i32 =  0; index14 <= autoEventCounter; index14 += 1)
                            {
                              gameClassSmall.Data.HistoricalUnitObj[historical1].AutoEvent[index14] = this.game.Data.HistoricalUnitObj[historical2].AutoEvent[index14];
                              gameClassSmall.Data.HistoricalUnitObj[historical1].AutoChance[index14] = this.game.Data.HistoricalUnitObj[historical2].AutoChance[index14];
                            }
                            gameClassSmall.Data.HistoricalUnitObj[historical1].DeckCardCounter = this.game.Data.HistoricalUnitObj[historical2].DeckCardCounter;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].DeckCard = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].DeckCardCounter + 1];
                            gameClassSmall.Data.HistoricalUnitObj[historical1].DeckChance = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].DeckCardCounter + 1];
                            let mut deckCardCounter: i32 =  gameClassSmall.Data.HistoricalUnitObj[historical1].DeckCardCounter;
                            for (let mut index15: i32 =  0; index15 <= deckCardCounter; index15 += 1)
                            {
                              gameClassSmall.Data.HistoricalUnitObj[historical1].DeckCard[index15] = this.game.Data.HistoricalUnitObj[historical2].DeckCard[index15];
                              gameClassSmall.Data.HistoricalUnitObj[historical1].DeckChance[index15] = this.game.Data.HistoricalUnitObj[historical2].DeckChance[index15];
                            }
                            gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarCount = this.game.Data.HistoricalUnitObj[historical2].HisVarCount;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarType = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarCount + 1];
                            gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarValue = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarCount + 1];
                            gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarNato = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarCount + 1];
                            let mut hisVarCount: i32 =  gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarCount;
                            for (let mut index16: i32 =  0; index16 <= hisVarCount; index16 += 1)
                            {
                              gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarType[index16] = this.game.Data.HistoricalUnitObj[historical2].HisVarType[index16];
                              gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarValue[index16] = this.game.Data.HistoricalUnitObj[historical2].HisVarValue[index16];
                              gameClassSmall.Data.HistoricalUnitObj[historical1].HisVarNato[index16] = this.game.Data.HistoricalUnitObj[historical2].HisVarNato[index16];
                            }
                            gameClassSmall.Data.HistoricalUnitObj[historical1].HandCardCounter = this.game.Data.HistoricalUnitObj[historical2].HandCardCounter;
                            gameClassSmall.Data.HistoricalUnitObj[historical1].HandCard = new int[gameClassSmall.Data.HistoricalUnitObj[historical1].HandCardCounter + 1];
                            let mut handCardCounter: i32 =  gameClassSmall.Data.HistoricalUnitObj[historical1].HandCardCounter;
                            for (let mut index17: i32 =  0; index17 <= handCardCounter; index17 += 1)
                              gameClassSmall.Data.HistoricalUnitObj[historical1].HandCard[index17] = this.game.Data.HistoricalUnitObj[historical2].HandCard[index17];
                          }
                          let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
                          for (let mut index18: i32 =  0; index18 <= sfCount; index18 += 1)
                          {
                            gameClassSmall.Data.AddSF(gameClassSmall.Data.UnitCounter);
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].Ap = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].Ap;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].DefMod = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].DefMod;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].EP = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].EP;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].Mor = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].Mor;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].OffMod = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].OffMod;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].People = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].People;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].Qty = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].Qty;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].Rdn = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].Rdn;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].Type = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].Type;
                            gameClassSmall.Data.SFObj[gameClassSmall.Data.SFCounter].Xp = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index18]].Xp;
                          }
                        }
                      }
                    }
                  }
                }
                num += 1;
              }
              while (num <= 1);
              int[] numArray5 = new int[gameClassSmall.Data.UnitCounter + 1];
              let mut unitCounter7: i32 =  gameClassSmall.Data.UnitCounter;
              for (let mut index19: i32 =  0; index19 <= unitCounter7; index19 += 1)
              {
                numArray5[index19] = 1;
                if (gameClassSmall.Data.UnitObj[index19].HQ > -1 & gameClassSmall.Data.UnitObj[index19].TempOldNr > -1)
                {
                  numArray5[index19] = 0;
                  let mut unitCounter8: i32 =  gameClassSmall.Data.UnitCounter;
                  for (let mut index20: i32 =  0; index20 <= unitCounter8; index20 += 1)
                  {
                    if (gameClassSmall.Data.UnitObj[index20].TempOldNr == gameClassSmall.Data.UnitObj[index19].HQ && gameClassSmall.Data.UnitObj[index20].Regime == gameClassSmall.Data.UnitObj[index19].Regime)
                    {
                      gameClassSmall.Data.UnitObj[index19].HQ = index20;
                      numArray5[index19] = 1;
                      break;
                    }
                  }
                }
              }
              let mut unitCounter9: i32 =  gameClassSmall.Data.UnitCounter;
              for (let mut index21: i32 =  0; index21 <= unitCounter9; index21 += 1)
              {
                if (numArray5[index21] == 0)
                  gameClassSmall.Data.UnitObj[index21].HQ = -1;
                gameClassSmall.Data.UnitObj[index21].TempOldNr = -1;
              }
              this.game.Data.RegimeObj[index4].LoadTransferUnit = false;
            }
          }
        }
        let mut historicalUnitCounter3: i32 =  gameClassSmall.Data.HistoricalUnitCounter;
        for (let mut index22: i32 =  0; index22 <= historicalUnitCounter3; index22 += 1)
          gameClassSmall.Data.HistoricalUnitObj[index22].Pool = false;
        let mut historicalUnitCounter4: i32 =  this.game.Data.HistoricalUnitCounter;
        for (let mut index23: i32 =  0; index23 <= historicalUnitCounter4; index23 += 1)
        {
          if (this.game.Data.HistoricalUnitObj[index23].Pool)
          {
            let mut historicalUnitCounter5: i32 =  gameClassSmall.Data.HistoricalUnitCounter;
            for (let mut index24: i32 =  0; index24 <= historicalUnitCounter5; index24 += 1)
            {
              if (gameClassSmall.Data.HistoricalUnitObj[index24].ID == this.game.Data.HistoricalUnitObj[index23].ID)
              {
                gameClassSmall.Data.HistoricalUnitObj[index24].Pool = true;
                let mut index25: i32 =  index24;
                let mut index26: i32 =  index23;
                if (index25 > -1 & index26 > -1 && !Information.IsNothing( this.game.Data.HistoricalUnitObj[index26].CommanderName) && this.game.Data.HistoricalUnitObj[index26].CommanderName.Length > 0)
                {
                  gameClassSmall.Data.HistoricalUnitObj[index25].CommanderName = this.game.Data.HistoricalUnitObj[index26].CommanderName;
                  gameClassSmall.Data.HistoricalUnitObj[index25].Descript = this.game.Data.HistoricalUnitObj[index26].Descript;
                  gameClassSmall.Data.HistoricalUnitObj[index25].CommanderFileName = this.game.Data.HistoricalUnitObj[index26].CommanderFileName;
                  gameClassSmall.Data.HistoricalUnitObj[index25].CommanderSpriteID = this.game.Data.HistoricalUnitObj[index26].CommanderSpriteID;
                  gameClassSmall.Data.HistoricalUnitObj[index25].OverdrawFileName = this.game.Data.HistoricalUnitObj[index26].OverdrawFileName;
                  gameClassSmall.Data.HistoricalUnitObj[index25].OverdrawSpriteID = this.game.Data.HistoricalUnitObj[index26].OverdrawSpriteID;
                  gameClassSmall.Data.HistoricalUnitObj[index25].StaffSize = this.game.Data.HistoricalUnitObj[index26].StaffSize;
                  gameClassSmall.Data.HistoricalUnitObj[index25].CombatMod = this.game.Data.HistoricalUnitObj[index26].CombatMod;
                  gameClassSmall.Data.HistoricalUnitObj[index25].MoraleMod = this.game.Data.HistoricalUnitObj[index26].MoraleMod;
                  gameClassSmall.Data.HistoricalUnitObj[index25].Xp = this.game.Data.HistoricalUnitObj[index26].Xp;
                  gameClassSmall.Data.HistoricalUnitObj[index25].TempVar1 = this.game.Data.HistoricalUnitObj[index26].TempVar1;
                  gameClassSmall.Data.HistoricalUnitObj[index25].TempVar2 = this.game.Data.HistoricalUnitObj[index26].TempVar2;
                  gameClassSmall.Data.HistoricalUnitObj[index25].TempVar3 = this.game.Data.HistoricalUnitObj[index26].TempVar3;
                  gameClassSmall.Data.HistoricalUnitObj[index25].PP = this.game.Data.HistoricalUnitObj[index26].PP;
                  gameClassSmall.Data.HistoricalUnitObj[index25].People = this.game.Data.HistoricalUnitObj[index26].People;
                  gameClassSmall.Data.HistoricalUnitObj[index25].AutoEventCounter = this.game.Data.HistoricalUnitObj[index26].AutoEventCounter;
                  gameClassSmall.Data.HistoricalUnitObj[index25].AutoEvent = new int[gameClassSmall.Data.HistoricalUnitObj[index25].AutoEventCounter + 1];
                  gameClassSmall.Data.HistoricalUnitObj[index25].AutoChance = new int[gameClassSmall.Data.HistoricalUnitObj[index25].AutoEventCounter + 1];
                  let mut autoEventCounter: i32 =  gameClassSmall.Data.HistoricalUnitObj[index25].AutoEventCounter;
                  for (let mut index27: i32 =  0; index27 <= autoEventCounter; index27 += 1)
                  {
                    gameClassSmall.Data.HistoricalUnitObj[index25].AutoEvent[index27] = this.game.Data.HistoricalUnitObj[index26].AutoEvent[index27];
                    gameClassSmall.Data.HistoricalUnitObj[index25].AutoChance[index27] = this.game.Data.HistoricalUnitObj[index26].AutoChance[index27];
                  }
                  gameClassSmall.Data.HistoricalUnitObj[index25].DeckCardCounter = this.game.Data.HistoricalUnitObj[index26].DeckCardCounter;
                  gameClassSmall.Data.HistoricalUnitObj[index25].DeckCard = new int[gameClassSmall.Data.HistoricalUnitObj[index25].DeckCardCounter + 1];
                  gameClassSmall.Data.HistoricalUnitObj[index25].DeckChance = new int[gameClassSmall.Data.HistoricalUnitObj[index25].DeckCardCounter + 1];
                  let mut deckCardCounter: i32 =  gameClassSmall.Data.HistoricalUnitObj[index25].DeckCardCounter;
                  for (let mut index28: i32 =  0; index28 <= deckCardCounter; index28 += 1)
                  {
                    gameClassSmall.Data.HistoricalUnitObj[index25].DeckCard[index28] = this.game.Data.HistoricalUnitObj[index26].DeckCard[index28];
                    gameClassSmall.Data.HistoricalUnitObj[index25].DeckChance[index28] = this.game.Data.HistoricalUnitObj[index26].DeckChance[index28];
                  }
                  gameClassSmall.Data.HistoricalUnitObj[index25].HisVarCount = this.game.Data.HistoricalUnitObj[index26].HisVarCount;
                  gameClassSmall.Data.HistoricalUnitObj[index25].HisVarType = new int[gameClassSmall.Data.HistoricalUnitObj[index25].HisVarCount + 1];
                  gameClassSmall.Data.HistoricalUnitObj[index25].HisVarValue = new int[gameClassSmall.Data.HistoricalUnitObj[index25].HisVarCount + 1];
                  gameClassSmall.Data.HistoricalUnitObj[index25].HisVarNato = new int[gameClassSmall.Data.HistoricalUnitObj[index25].HisVarCount + 1];
                  let mut hisVarCount: i32 =  gameClassSmall.Data.HistoricalUnitObj[index25].HisVarCount;
                  for (let mut index29: i32 =  0; index29 <= hisVarCount; index29 += 1)
                  {
                    gameClassSmall.Data.HistoricalUnitObj[index25].HisVarType[index29] = this.game.Data.HistoricalUnitObj[index26].HisVarType[index29];
                    gameClassSmall.Data.HistoricalUnitObj[index25].HisVarValue[index29] = this.game.Data.HistoricalUnitObj[index26].HisVarValue[index29];
                    gameClassSmall.Data.HistoricalUnitObj[index25].HisVarNato[index29] = this.game.Data.HistoricalUnitObj[index26].HisVarNato[index29];
                  }
                  gameClassSmall.Data.HistoricalUnitObj[index25].HandCardCounter = this.game.Data.HistoricalUnitObj[index26].HandCardCounter;
                  gameClassSmall.Data.HistoricalUnitObj[index25].HandCard = new int[gameClassSmall.Data.HistoricalUnitObj[index25].HandCardCounter + 1];
                  let mut handCardCounter: i32 =  gameClassSmall.Data.HistoricalUnitObj[index25].HandCardCounter;
                  for (let mut index30: i32 =  0; index30 <= handCardCounter; index30 += 1)
                    gameClassSmall.Data.HistoricalUnitObj[index25].HandCard[index30] = this.game.Data.HistoricalUnitObj[index26].HandCard[index30];
                }
              }
            }
          }
        }
        let mut actionCardCounter: i32 =  this.game.Data.ActionCardCounter;
        for (let mut index31: i32 =  0; index31 <= actionCardCounter; index31 += 1)
        {
          if (index31 <= gameClassSmall.Data.ActionCardCounter && Operators.CompareString(gameClassSmall.Data.ActionCardObj[index31].Title, this.game.Data.ActionCardObj[index31].Title, false) == 0)
            gameClassSmall.Data.ActionCardObj[index31].PPCost = this.game.Data.ActionCardObj[index31].PPCost;
        }
      }
      else
      {
        let mut num1: i32 =   Interaction.MsgBox( "File could not be found or op. is cancelled. Faulty event that tries to load new scenario. Scenario Bug.", Title: ( "Shadow Empire : Planetary Conquest"));
      }
      this.game.Data = gameClassSmall.Data;
      this.game.Data.MapLoop = this.game.Data.MapObj[0].MapLoop;
      this.game.EditObj = new EditClass(this.game.AppPath + "editobj.txt");
      if (this.game.Data.UseAI == 1)
        this.game.NewAIObj.LastRegime = -1;
      this.game.SelectX = -1;
      this.game.SelectY = -1;
      this.game.EditObj.Test = -1;
      this.game.EditObj.Phase = 0;
      BitmapStore.ReloadSomeGfx();
      BitmapStore.ReloadSystemGraphics(this.game.Data.SystemGfx);
      this.game.Data.LoadGraphics((Form1) null);
      DrawMod.TGame = this.game;
      this.game.CustomBitmapObj.MakeMiniMap(this.game.EditObj.MiniMap, 200, 150, false);
      this.game.EditObj.StratMap = new Bitmap(this.game.ScreenWidth, this.game.ScreenHeight - 305, PixelFormat.Format32bppPArgb);
      this.game.EditObj.StratMap.SetResolution( DrawMod.DPIx,  DrawMod.DPIy);
      this.game.CustomBitmapObj.MakeMiniMap(this.game.EditObj.StratMap, this.game.ScreenWidth, this.game.ScreenHeight - 305, false, true, false);
      SoundMod.StopWave();
      this.game.Data.GameID =  Math.Round( (VBMath.Rnd() * 1E+08f));
      this.game.HandyFunctionsObj.RedimStats();
      this.game.HandyFunctionsObj.DoResMod();
      let mut index32: i32 =  0;
      do
      {
        this.game.Data.GameSlot[index32] = numArray1[index32];
        index32 += 1;
      }
      while (index32 <= 399);
      if ( this.game.Data.RuleVar[344] == 1.0 & this.game.EditObj.HideUnit == 0)
        this.game.EditObj.HideUnit = 2;
      let mut regimeCounter4: i32 =  this.game.Data.RegimeCounter;
      for (let mut reg1: i32 =  0; reg1 <= regimeCounter4; reg1 += 1)
      {
        if (reg1 > regimeCounter1)
        {
          let mut num2: i32 =  regimeCounter1;
          for (let mut reg2: i32 =  0; reg2 <= num2; reg2 += 1)
          {
            if (this.game.Data.RegimeObj[reg1].UberRegime == reg2 | this.game.HandyFunctionsObj.IsAlliedOrSelf(reg1, reg2))
            {
              this.game.Data.RegimeObj[reg1].PassWord = strArray[reg2];
              this.game.Data.RegimeObj[reg1].AI = flagArray1[reg2];
              this.game.Data.RegimeObj[reg1].ProdBonus = numArray2[reg2];
              this.game.Data.RegimeObj[reg1].AIHelpMove = -(flagArray2[reg2] ? 1 : 0);
              this.game.Data.RegimeObj[reg1].AIHelpCombat = -(flagArray3[reg2] ? 1 : 0);
              this.game.Data.RegimeObj[reg1].AIHelpStrategic = -(flagArray4[reg2] ? 1 : 0);
              break;
            }
          }
        }
        else
        {
          this.game.Data.RegimeObj[reg1].PassWord = strArray[reg1];
          this.game.Data.RegimeObj[reg1].AI = flagArray1[reg1];
          this.game.Data.RegimeObj[reg1].ProdBonus = numArray2[reg1];
          this.game.Data.RegimeObj[reg1].AIHelpMove = -(flagArray2[reg1] ? 1 : 0);
          this.game.Data.RegimeObj[reg1].AIHelpCombat = -(flagArray3[reg1] ? 1 : 0);
          this.game.Data.RegimeObj[reg1].AIHelpStrategic = -(flagArray4[reg1] ? 1 : 0);
        }
        if (this.game.Data.RegimeObj[reg1].AIHelpMove > 0 && this.game.Data.RegimeObj[reg1].AI)
        {
          let mut regimeCounter5: i32 =  this.game.Data.RegimeCounter;
          for (let mut index33: i32 =  0; index33 <= regimeCounter5; index33 += 1)
          {
            if (this.game.Data.RegimeObj[index33].AI)
            {
              this.game.Data.RegimeObj[index33].AIHelpMove = this.game.Data.RegimeObj[reg1].AIHelpMove;
              this.game.Data.RegimeObj[index33].AIHelpCombat = this.game.Data.RegimeObj[reg1].AIHelpCombat;
              this.game.Data.RegimeObj[index33].AIHelpStrategic = this.game.Data.RegimeObj[reg1].AIHelpStrategic;
            }
          }
        }
      }
      this.game.Data.PasswordsOn = passwordsOn;
      this.game.Data.PBEM = pbem;
      this.game.Data.TerrorMode = terrorMode;
      this.game.Data.FOWOn = fowOn;
      this.game.Data.ShrowdOn = shrowdOn;
      this.game.Data.DontShowAIMove = dontShowAiMove;
      this.game.Data.Name = "New Name";
      this.game.Data.Round = 0;
      this.game.Data.Turn = -1;
      let mut mapCounter1: i32 =  this.game.Data.MapCounter;
      for (let mut index34: i32 =  0; index34 <= mapCounter1; index34 += 1)
      {
        let mut mapWidth: i32 =  this.game.Data.MapObj[index34].MapWidth;
        for (let mut index35: i32 =  0; index35 <= mapWidth; index35 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[index34].MapHeight;
          for (let mut index36: i32 =  0; index36 <= mapHeight; index36 += 1)
          {
            let mut regimeCounter6: i32 =  this.game.Data.RegimeCounter;
            for (let mut Index: i32 =  0; Index <= regimeCounter6; Index += 1)
            {
              this.game.Data.MapObj[index34].HexObj[index35, index36].set_LastLT(Index, -1);
              this.game.Data.MapObj[index34].HexObj[index35, index36].set_LastSpr(Index, -1);
              this.game.Data.MapObj[index34].HexObj[index35, index36].set_LastReg(Index, -1);
              this.game.Data.MapObj[index34].HexObj[index35, index36].set_SeeNow(Index, 0);
            }
          }
        }
      }
    }

    pub fn SaveBitmap(tmpbmp: Bitmap, s: String)
    {
      FileStream fileStream = new FileStream(this.game.AppPath + "logs/" + s + ".png", FileMode.Create);
      tmpbmp.Save((Stream) fileStream, ImageFormat.Png);
      fileStream.Close();
    }

    pub fn SaveBitmapAsPing(tmpbmp: Bitmap, s: String)
    {
      this.MakeDirIfNecc(s);
      FileStream fileStream = new FileStream(s, FileMode.Create);
      tmpbmp.Save((Stream) fileStream, ImageFormat.Png);
      fileStream.Close();
    }

    pub fn MakeDirIfNecc(s: String)
    {
      let mut num1: i32 =  0;
      let mut num2: i32 =  1;
      let mut num3: i32 =  0;
      let mut num4: i32 =  1;
      while (num4 == 1)
      {
        while (num2 == 1)
        {
          let mut num5: i32 =  Strings.InStr(num3 + 1, s, "/");
          if (Strings.InStr(num3 + 1, s, "\\") > 0 & (Strings.InStr(num3 + 1, s, "\\") < num5 | num5 == 0))
            num5 = Strings.InStr(num3 + 1, s, "\\");
          num3 = num5;
          if (num3 > num1 & num3 > 3)
            num2 = 0;
          if (num3 == 0)
            num2 = 0;
        }
        if (num3 > 0)
        {
          num1 = num3;
          num2 = 1;
          path: String = Strings.Left(s, num3 - 1);
          if (!Directory.Exists(path))
            Directory.CreateDirectory(path);
        }
        else
          num4 = 0;
      }
    }

    pub fn SaveBitmapAsJpeg(tmpbmp: Bitmap, s: String)
    {
      this.MakeDirIfNecc(s);
      FileStream fileStream = new FileStream(s, FileMode.Create);
      tmpbmp.Save((Stream) fileStream, ImageFormat.Jpeg);
      fileStream.Close();
    }

    pub fn GetFuelSlot949(currentSlot: i32, x: i32, y: i32) -> i32
    {
      str: String = "oil" + this.game.Data.RuleVar[949].ToString();
      if (x == -1 | y == -1)
        return currentSlot;
      let mut libVarCounter: i32 =  this.game.Data.LibVarCounter;
      for (let mut tSlotNr: i32 =  0; tSlotNr <= libVarCounter; tSlotNr += 1)
      {
        if (this.game.Data.LibVarObj[tSlotNr].libId.libSlot > -1 & this.game.Data.LibVarObj[tSlotNr].type == NewEnums.LibVarType.Hex && Operators.CompareString(Strings.Trim(Strings.LCase(this.game.Data.LibVarObj[tSlotNr].name)), Strings.Trim(Strings.LCase(str)), false) == 0)
        {
          let mut integer: i32 =  Conversions.ToInteger(this.game.Data.MapObj[0].HexObj[x, y].GetHexLibVarValue(tSlotNr).ToString());
          return integer > 0 ? integer : currentSlot;
        }
      }
      return currentSlot;
    }

    pub fn SaveBitmapAsBmp(tmpbmp: Bitmap, s: String)
    {
      this.MakeDirIfNecc(s);
      FileStream fileStream = new FileStream(s, FileMode.Create);
      tmpbmp.Save((Stream) fileStream, ImageFormat.Bmp);
      fileStream.Close();
    }

    ~HandyFunctionsclass() => base.Finalize();

    pub DependencyClass Libraries_CheckDependency(
       TData: DataClass,
      LibId: i32,
      bool canAdd)
    {
      DependencyClass dependencyClass = DependencyClass::new();
      dependencyClass.ok = true;
      if (canAdd)
      {
        let mut unitCounter: i32 =  TData.UnitCounter;
        for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
        {
          if (TData.UnitObj[index1].LibId.libSlot == LibId && TData.UnitObj[index1].PreDef > -1)
          {
            let mut sfCount: i32 =  TData.UnitObj[index1].SFCount;
            for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
            {
              let mut sf: i32 =  TData.UnitObj[index1].SFList[index2];
              let mut type: i32 =  TData.SFObj[sf].Type;
              bool flag = false;
              let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
              for (let mut index3: i32 =  0; index3 <= sfTypeCounter; index3 += 1)
              {
                if (this.game.Data.SFTypeObj[index3].LibId.libSlot > -1 && Operators.CompareString(this.game.Data.LibraryObj[this.game.Data.SFTypeObj[index3].LibId.libSlot].name, TData.LibraryObj[TData.SFTypeObj[type].LibId.libSlot].name, false) == 0)
                {
                  if (this.game.Data.SFTypeObj[index3].LibId.id == TData.SFTypeObj[type].Id)
                    flag = true;
                  if (this.game.Data.SFTypeObj[index3].LibId.id == TData.SFTypeObj[type].LibId.id)
                    flag = true;
                }
              }
              if (!flag)
              {
                dependencyClass.ok = false;
                dependencyClass.text = "Some or all troops & equipment from '" + TData.LibraryObj[TData.SFTypeObj[type].LibId.libSlot].name + "' have not been loaded yet. Please (re)load this library first.";
              }
            }
          }
        }
      }
      else if (!canAdd)
      {
        bool flag = true;
        let mut unitCounter: i32 =  this.game.Data.UnitCounter;
        for (let mut index4: i32 =  0; index4 <= unitCounter; index4 += 1)
        {
          let mut sfCount: i32 =  this.game.Data.UnitObj[index4].SFCount;
          for (let mut index5: i32 =  0; index5 <= sfCount; index5 += 1)
          {
            if (this.game.Data.SFTypeObj[this.game.Data.SFObj[this.game.Data.UnitObj[index4].SFList[index5]].Type].LibId.libSlot == LibId)
            {
              flag = false;
              dependencyClass.ok = false;
              dependencyClass.text = "Removing troops & equipment with removing library will cause unit (models) to have broken links.";
            }
          }
        }
        if (dependencyClass.ok)
        {
          let mut libVarCounter: i32 =  this.game.Data.LibVarCounter;
          for (let mut index6: i32 =  0; index6 <= libVarCounter; index6 += 1)
          {
            if (this.game.Data.LibVarObj[index6].instanceId.id > -1 & this.game.Data.LibVarObj[index6].type == NewEnums.LibVarType.SFtype && this.game.Data.LibVarObj[index6].instanceId.libSlot == LibId)
            {
              dependencyClass.warning = true;
              dependencyClass.text = "Removing troops & equipment with removing library will remove LibVars.";
            }
            if (this.game.Data.LibVarObj[index6].instanceId.id > -1 & this.game.Data.LibVarObj[index6].valueType == NewEnums.LibVarValueType.SFTypeId)
            {
              let mut index7: i32 =  this.game.Data.LibVarObj[index6].value;
              if (index7 > -1 && this.game.Data.SFTypeObj[index7].LibId.libSlot == LibId)
              {
                dependencyClass.ok = false;
                dependencyClass.text = "Removing troops & equipment with removing library will a libvar to have a broken link.";
              }
            }
          }
        }
      }
      if (!canAdd)
      {
        let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
        for (let mut index8: i32 =  0; index8 <= regimeCounter; index8 += 1)
        {
          if (this.game.Data.RegimeObj[index8].libId.libSlot == LibId)
          {
            let mut unitCounter: i32 =  this.game.Data.UnitCounter;
            for (let mut index9: i32 =  0; index9 <= unitCounter; index9 += 1)
            {
              if (this.game.Data.UnitObj[index9].Regime == index8 & this.game.Data.UnitObj[index9].LibId.libSlot != LibId)
              {
                dependencyClass.ok = false;
                dependencyClass.text = "Removing regime(s) by removing this library will cause units to have broken links.";
              }
            }
            let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
            for (let mut index10: i32 =  0; index10 <= historicalUnitCounter; index10 += 1)
            {
              if (this.game.Data.HistoricalUnitObj[index10].TempRegime == index8 & this.game.Data.HistoricalUnitObj[index10].LibId.libSlot != LibId)
              {
                dependencyClass.ok = false;
                dependencyClass.text = "Removing regime(s) by removing this library will cause historical units or officers to have broken links.";
              }
            }
            let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
            for (let mut index11: i32 =  0; index11 <= mapWidth; index11 += 1)
            {
              let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
              for (let mut index12: i32 =  0; index12 <= mapHeight; index12 += 1)
              {
                if (this.game.Data.MapObj[0].HexObj[index11, index12].Regime == index8)
                {
                  dependencyClass.ok = false;
                  dependencyClass.text = "Removing regime(s) by removing this library will cause hex ownership on map to have broken links.";
                }
              }
            }
          }
        }
      }
      if (canAdd)
      {
        let mut historicalUnitCounter: i32 =  TData.HistoricalUnitCounter;
        for (let mut index13: i32 =  0; index13 <= historicalUnitCounter; index13 += 1)
        {
          if (TData.HistoricalUnitObj[index13].LibId.libSlot == LibId)
          {
            let mut deckCardCounter: i32 =  TData.HistoricalUnitObj[index13].DeckCardCounter;
            for (let mut index14: i32 =  0; index14 <= deckCardCounter; index14 += 1)
            {
              let mut index15: i32 =  TData.HistoricalUnitObj[index13].DeckCard[index14];
              bool flag = false;
              let mut actionCardCounter: i32 =  this.game.Data.ActionCardCounter;
              for (let mut index16: i32 =  0; index16 <= actionCardCounter; index16 += 1)
              {
                if (this.game.Data.ActionCardObj[index16].LibId.libSlot > -1 && Operators.CompareString(this.game.Data.LibraryObj[this.game.Data.ActionCardObj[index16].LibId.libSlot].name, TData.LibraryObj[TData.ActionCardObj[index15].LibId.libSlot].name, false) == 0 && this.game.Data.ActionCardObj[index16].LibId.id == index15 & TData.ActionCardObj[index15].LibId.libSlot == -1 | this.game.Data.ActionCardObj[index16].LibId.id == TData.ActionCardObj[index15].LibId.id)
                  flag = true;
              }
              if (!flag)
              {
                dependencyClass.ok = false;
                dependencyClass.text = "Some or all cards with removing '" + TData.LibraryObj[TData.ActionCardObj[index15].LibId.libSlot].name + "' will cause officers to have broken links.";
              }
            }
          }
        }
      }
      else if (!canAdd)
      {
        let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter;
        for (let mut index17: i32 =  0; index17 <= historicalUnitCounter; index17 += 1)
        {
          if (this.game.Data.HistoricalUnitObj[index17].LibId.libSlot == LibId)
          {
            let mut deckCardCounter: i32 =  this.game.Data.HistoricalUnitObj[index17].DeckCardCounter;
            for (let mut index18: i32 =  0; index18 <= deckCardCounter; index18 += 1)
            {
              if (this.game.Data.ActionCardObj[this.game.Data.HistoricalUnitObj[index17].DeckCard[index18]].LibId.libSlot == LibId)
              {
                dependencyClass.ok = false;
                dependencyClass.text = "Removing cards by removing library will cause officers to have broken links.";
              }
            }
          }
        }
      }
      return dependencyClass;
    }

    pub fn SetAllReady(bool questions)
    {
      let mut regimeCounter1: i32 =  this.game.Data.RegimeCounter;
      for (let mut index: i32 =  0; index <= regimeCounter1; index += 1)
      {
        this.game.Data.RegimeObj[index].RemoveMap(0);
        this.game.Data.RegimeObj[index].AddMap(this.game.Data.MapObj[0].MapWidth, this.game.Data.MapObj[0].MapHeight);
      }
      let mut mapWidth1: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
        {
          if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Location > -1 & this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].LandscapeType].IsSea)
            this.game.Data.RemoveLoc(this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].Location);
          if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].LandscapeType].IsSea)
            this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index1, index2].VP = 0;
        }
      }
      bool[] flagArray = new bool[this.game.Data.SFCounter + 1];
      let mut unitCounter1: i32 =  this.game.Data.UnitCounter;
      for (let mut index3: i32 =  0; index3 <= unitCounter1; index3 += 1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[index3].SFCount;
        for (let mut index4: i32 =  0; index4 <= sfCount; index4 += 1)
          flagArray[this.game.Data.UnitObj[index3].SFList[index4]] = true;
      }
      for (let mut sfCounter: i32 =  this.game.Data.SFCounter; sfCounter >= 0; sfCounter += -1)
      {
        if (!flagArray[sfCounter])
          this.game.Data.RemoveSF(sfCounter);
        if (sfCounter % 30 == 0)
          Application.DoEvents();
      }
      bool flag;
      if (!questions)
        flag = true;
      else if (Interaction.MsgBox( "Set all units to highest entrenchment?", MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.Yes)
        flag = true;
      if (flag)
      {
        let mut Number: i32 =  0;
        let mut mapWidth2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapWidth;
        for (let mut index5: i32 =  0; index5 <= mapWidth2; index5 += 1)
        {
          let mut mapHeight: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].MapHeight;
          for (let mut index6: i32 =  0; index6 <= mapHeight; index6 += 1)
          {
            let mut unitCounter2: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index5, index6].UnitCounter;
            for (let mut index7: i32 =  0; index7 <= unitCounter2; index7 += 1)
            {
              let mut unit: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[index5, index6].UnitList[index7];
              let mut num1: i32 =  1;
              while (num1 == 1)
              {
                num1 = 0;
                let mut sfCount: i32 =  this.game.Data.UnitObj[unit].SFCount;
                for (let mut index8: i32 =  0; index8 <= sfCount; index8 += 1)
                {
                  let mut sf: i32 =  this.game.Data.UnitObj[unit].SFList[index8];
                  let mut num2: i32 =   Math.Round( this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index5, index6].LandscapeType].DefBonusMax[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup]);
                  if (this.game.Data.MapObj[0].HexObj[index5, index6].Location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[index5, index6].Location].Type].PictureLT > -1)
                    num2 =  Math.Round( ( num2 + this.game.Data.LandscapeTypeObj[this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[index5, index6].Location].Type].PictureLT].DefBonusMax[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup]));
                  if (num2 > this.game.Data.SFObj[sf].CurrentEntrench)
                  {
                    this.game.Data.SFObj[sf].CurrentEntrench = num2;
                    Number += 1;
                  }
                }
              }
            }
          }
        }
        if (Number > 0 & questions)
        {
          let mut num: i32 =   Interaction.MsgBox( ("Have reseted " + Conversion.Str( Number) + " subformations due to higher entrenchment available"));
        }
      }
      index9: i32;
      if (this.game.Data.SFCounter > -1)
      {
        let mut sfCounter: i32 =  this.game.Data.SFCounter;
        for (index9 = 0; index9 <= sfCounter; index9 += 1)
        {
          this.game.Data.SFObj[index9].Ap = 100;
          this.game.Data.SFObj[index9].Rdn = 100;
        }
      }
      if (this.game.Data.LocCounter > -1)
      {
        let mut locCounter: i32 =  this.game.Data.LocCounter;
        for (index9 = 0; index9 <= locCounter; index9 += 1)
          this.game.Data.LocObj[index9].StructuralPts = this.game.Data.LocTypeObj[this.game.Data.LocObj[index9].Type].StructuralPts;
      }
      if (this.game.Data.UnitCounter > -1)
      {
        let mut unitCounter3: i32 =  this.game.Data.UnitCounter;
        for (index9 = 0; index9 <= unitCounter3; index9 += 1)
        {
          let mut num: i32 =  0;
          this.game.Data.UnitObj[index9].SODefendPercent = 50;
          this.game.Data.UnitObj[index9].SOSupReqPercent = 100;
          let mut sfCount: i32 =  this.game.Data.UnitObj[index9].SFCount;
          for (let mut index10: i32 =  0; index10 <= sfCount; index10 += 1)
          {
            let mut sf: i32 =  this.game.Data.UnitObj[index9].SFList[index10];
            if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 1)
              num += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].SupplyCarry;
            else if (this.game.Data.Product <= 5)
              num += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].BasicSupplyNeed;
            else
              num += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].SupplyCarry;
          }
          this.game.Data.UnitObj[index9].Supply = num;
          if ( this.game.Data.RuleVar[435] > 0.0)
            this.game.Data.UnitObj[index9].Fuel = this.UnitMaximumFuelReserve(index9);
        }
      }
      if (this.game.Data.RegimeCounter > -1)
      {
        let mut regimeCounter2: i32 =  this.game.Data.RegimeCounter;
        for (index9 = 0; index9 <= regimeCounter2; index9 += 1)
        {
          let mut unitCounter4: i32 =  this.game.Data.UnitCounter;
          for (let mut index11: i32 =  0; index11 <= unitCounter4; index11 += 1)
          {
            if (this.game.Data.UnitObj[index11].PreDef > -1 && this.game.Data.UnitObj[index11].Regime == index9)
            {
              if (this.game.Data.UnitObj[index11].Historical > -1)
              {
                let mut historical: i32 =  this.game.Data.UnitObj[index11].Historical;
                if (this.game.Data.UnitObj[index11].HistoricalSubPart > -1)
                {
                  let mut subPart: i32 =  this.game.Data.HistoricalUnitObj[historical].SubParts[this.game.Data.UnitObj[index11].HistoricalSubPart];
                  if (subPart > -1)
                  {
                    let mut preDef: i32 =  this.game.HandyFunctionsObj.GetPreDef(subPart);
                    let mut sfCount: i32 =  this.game.Data.UnitObj[index11].SFCount;
                    for (let mut index12: i32 =  0; index12 <= sfCount; index12 += 1)
                    {
                      if (index12 <= this.game.Data.UnitObj[preDef].SFCount && this.game.Data.SFObj[this.game.Data.UnitObj[index11].SFList[index12]].People == this.game.Data.SFObj[this.game.Data.UnitObj[preDef].SFList[index12]].People)
                        this.game.Data.SFObj[this.game.Data.UnitObj[index11].SFList[index12]].Mor = this.game.Data.SFObj[this.game.Data.UnitObj[preDef].SFList[index12]].Mor;
                    }
                  }
                }
              }
              else
              {
                let mut sfCount: i32 =  this.game.Data.UnitObj[index11].SFCount;
                for (let mut index13: i32 =  0; index13 <= sfCount; index13 += 1)
                {
                  if (this.game.Data.SFObj[this.game.Data.UnitObj[index11].SFList[index13]].People > this.game.Data.PeopleCounter)
                    this.game.Data.SFObj[this.game.Data.UnitObj[index11].SFList[index13]].People = 0;
                  this.game.Data.SFObj[this.game.Data.UnitObj[index11].SFList[index13]].Mor =  Math.Round( this.game.Data.RegimeObj[this.game.Data.UnitObj[index11].Regime].BaseMorale / 100.0 *  this.game.Data.PeopleObj[this.game.Data.SFObj[this.game.Data.UnitObj[index11].SFList[index13]].People].BaseMorale[this.game.Data.PeopleObj[this.game.Data.RegimeObj[index9].People].PeopleGroup]);
                }
              }
            }
          }
          let mut locCounter: i32 =  this.game.Data.LocCounter;
          for (let mut index14: i32 =  0; index14 <= locCounter; index14 += 1)
          {
            if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.Data.LocObj[index14].X, this.game.Data.LocObj[index14].Y].Regime != index9)
              ;
          }
          this.game.ProcessingObj.DoEntrench(index9, true);
        }
      }
      let mut unitCounter5: i32 =  this.game.Data.UnitCounter;
      for (let mut unr: i32 =  0; unr <= unitCounter5; unr += 1)
      {
        if (!this.game.Data.UnitObj[unr].IsHQ)
        {
          this.game.Data.UnitObj[unr].Supply = this.game.HandyFunctionsObj.UnitSupplyStore(unr);
          this.game.Data.UnitObj[unr].StockpileCurrent = this.game.HandyFunctionsObj.GetMaxStockpile(unr);
          if ( this.game.Data.RuleVar[434] > 0.0)
            this.game.Data.UnitObj[index9].SupplyConsume = 100;
        }
      }
      if (!( this.game.Data.RuleVar[455] > 0.0 & this.game.Data.RegimeCounter > -1))
        return;
      this.game.HandyFunctionsObj.MakeFuzzyOwner(true, false, 0);
    }

    pub fn Libraries_ClearUpAllRemnants()
    {
      for (let mut historicalUnitCounter: i32 =  this.game.Data.HistoricalUnitCounter; historicalUnitCounter >= 0; historicalUnitCounter += -1)
      {
        if (this.game.Data.HistoricalUnitObj[historicalUnitCounter].LibId.libSlot == -1 & !this.game.Data.HistoricalUnitObj[historicalUnitCounter].Model & this.game.Data.HistoricalUnitObj[historicalUnitCounter].ModelMaster == -1)
          this.game.Data.RemoveHistoricalUnit(historicalUnitCounter);
      }
      game: GameClassClass;
      for (let mut unitCounter: i32 =  this.game.Data.UnitCounter; unitCounter >= 0; unitCounter += -1)
      {
        if (this.game.Data.UnitObj[unitCounter].PreDef == -1 & this.game.Data.UnitObj[unitCounter].Historical == -1)
        {
          data: DataClass = this.game.Data;
          let mut nr: i32 =  unitCounter;
          gameClass = (GameClass) null;
           let mut local: GameClass =  gameClass;
          data.RemoveUnit(nr,  local);
        }
      }
      for (let mut historicalUnitCounter1: i32 =  this.game.Data.HistoricalUnitCounter; historicalUnitCounter1 >= 0; historicalUnitCounter1 += -1)
      {
        if (this.game.Data.HistoricalUnitObj[historicalUnitCounter1].OffLibId.libSlot > -1)
        {
          for (let mut historicalUnitCounter2: i32 =  this.game.Data.HistoricalUnitCounter; historicalUnitCounter2 >= 0; historicalUnitCounter2 += -1)
          {
            if (this.game.Data.HistoricalUnitObj[historicalUnitCounter2].LibId.libSlot == this.game.Data.HistoricalUnitObj[historicalUnitCounter1].OffLibId.libSlot && this.game.Data.HistoricalUnitObj[historicalUnitCounter2].LibId.id == this.game.Data.HistoricalUnitObj[historicalUnitCounter1].OffLibId.id)
            {
              this.game.ProcessingObj.SwapOfficer(this.game.Data.UnitObj[this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitCounter1)].Regime, historicalUnitCounter1, historicalUnitCounter2, this.game.HandyFunctionsObj.GetUnitByHistorical(historicalUnitCounter1));
              this.game.Data.RemoveHistoricalUnit(historicalUnitCounter2);
            }
          }
        }
      }
      let mut historicalUnitCounter3: i32 =  this.game.Data.HistoricalUnitCounter;
      for (let mut index1: i32 =  0; index1 <= historicalUnitCounter3; index1 += 1)
      {
        if (this.game.Data.HistoricalUnitObj[index1].ModelMaster > -1)
        {
          let mut modelMaster: i32 =  this.game.Data.HistoricalUnitObj[index1].ModelMaster;
          this.game.Data.HistoricalUnitObj[index1].Counter = this.game.Data.HistoricalUnitObj[modelMaster].Counter;
          this.game.Data.HistoricalUnitObj[index1].Green = this.game.Data.HistoricalUnitObj[modelMaster].Green;
          this.game.Data.HistoricalUnitObj[index1].Red = this.game.Data.HistoricalUnitObj[modelMaster].Red;
          this.game.Data.HistoricalUnitObj[index1].SmallGfx = this.game.Data.HistoricalUnitObj[modelMaster].SmallGfx;
          this.game.Data.HistoricalUnitObj[index1].Blue = this.game.Data.HistoricalUnitObj[modelMaster].Blue;
          this.game.Data.HistoricalUnitObj[index1].Type = this.game.Data.HistoricalUnitObj[modelMaster].Type;
          this.game.Data.HistoricalUnitObj[index1].TempRegime = this.game.Data.HistoricalUnitObj[modelMaster].TempRegime;
          this.game.Data.HistoricalUnitObj[index1].People = this.game.Data.HistoricalUnitObj[modelMaster].People;
          this.game.Data.HistoricalUnitObj[index1].UsePeopleGfx = this.game.Data.HistoricalUnitObj[modelMaster].UsePeopleGfx;
          this.game.Data.HistoricalUnitObj[index1].UseModelCounter = this.game.Data.HistoricalUnitObj[modelMaster].UseModelCounter;
          this.game.Data.HistoricalUnitObj[index1].UseRomans = this.game.Data.HistoricalUnitObj[modelMaster].UseRomans;
          let mut index2: i32 =  0;
          do
          {
            this.game.Data.HistoricalUnitObj[index1].SubParts[index2] = this.game.Data.HistoricalUnitObj[modelMaster].SubParts[index2];
            this.game.Data.HistoricalUnitObj[index1].Designation[index2] = this.game.Data.HistoricalUnitObj[modelMaster].Designation[index2];
            this.game.Data.HistoricalUnitObj[index1].DesignationSmall[index2] = this.game.Data.HistoricalUnitObj[modelMaster].DesignationSmall[index2];
            if (this.game.Data.HistoricalUnitObj[index1].SubParts[index2] > -1)
            {
              let mut unitCounter: i32 =  this.game.Data.UnitCounter;
              for (let mut unr: i32 =  0; unr <= unitCounter; unr += 1)
              {
                if (this.game.Data.UnitObj[unr].Historical == index1 & this.game.Data.UnitObj[unr].HistoricalSubPart == index2)
                {
                  let mut hq: i32 =  this.game.Data.UnitObj[unr].HQ;
                  DrawMod.TGame.HandyFunctionsObj.CopyUnit(unr, this.game.HandyFunctionsObj.GetPreDef(this.game.Data.HistoricalUnitObj[index1].SubParts[index2]), false);
                  this.game.Data.UnitObj[unr].HQ = hq;
                  break;
                }
              }
            }
            index2 += 1;
          }
          while (index2 <= 9);
        }
      }
      for (let mut unitCounter: i32 =  this.game.Data.UnitCounter; unitCounter >= 0; unitCounter += -1)
      {
        if (this.game.Data.UnitObj[unitCounter].PreDef == -1 && this.game.Data.UnitObj[unitCounter].Historical > -1 && this.game.Data.UnitObj[unitCounter].HistoricalSubPart > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unitCounter].Historical].SubParts[this.game.Data.UnitObj[unitCounter].HistoricalSubPart] == -1)
        {
          data: DataClass = this.game.Data;
          let mut nr: i32 =  unitCounter;
          gameClass = (GameClass) null;
           let mut local: GameClass =  gameClass;
          data.RemoveUnit(nr,  local);
        }
      }
    }

    pub fn Export()
    {
      arySrc: Vec<String> = new string[30000];
      strArray1: Vec<String> = new string[1000];
      strArray2: Vec<String> = new string[1000];
      let mut index1: i32 =  -1;
      let mut index2: i32 =  -1;
      FileName: String = this.game.HandyFunctionsObj.SaveSomething("DC Zip package files(dczip)|*.dczip|Regular ZIP file(zip)|*.zip", "Save as .dczip or .zip file", this.game.AppPath, false);
      let mut num1: i32 =  1;
      path: String;
      while (Interaction.MsgBox( ("Add a file (scenario, game menu mod txt file) under '" + this.game.AppPath + "'."), MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.Yes)
      {
        path = this.game.HandyFunctionsObj.LoadSomething("All files|*.*", "Add a file (scenario, game menu mod txt file)", this.game.AppPath, false);
        if (!System.IO.File.Exists(path))
        {
          if (Interaction.MsgBox( "Added! Do you want to add another single file or try again?", MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.No)
            break;
        }
        else
        {
          index2 += 1;
          strArray1[index2] = path;
          index1 += 1;
          arySrc[index1] = path;
          num1 += 1;
          if (Interaction.MsgBox( "Added! Do you want to add another single file?", MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.No)
            break;
        }
      }
label_10:
      while (true)
      {
        if (Interaction.MsgBox( ("Add a directory (with sounds or scenarios) directly under '" + this.game.AppPath + "'. For example '" + this.game.AppPath + "mysounds'"), MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.Yes)
        {
          path = Interaction.InputBox("Give directory full path. Must be directly under '" + this.game.AppPath + "'. For example '" + this.game.AppPath + "mysounds'. Keep in mind subdirectories are not packed. ", "Shadow Empire : Planetary Conquest", this.game.AppPath);
          if (!Directory.Exists(path))
          {
            let mut num2: i32 =   Interaction.MsgBox( "Dir not found.", Title: ( "Shadow Empire : Planetary Conquest"));
          }
          else
            break;
        }
        else
          goto label_11;
      }
      foreach (FileInfo file in new DirectoryInfo(path).GetFiles("*.*"))
      {
        index1 += 1;
        arySrc[index1] = path + "/" + file.Name;
      }
      goto label_10;
label_11:
      if (this.game.Data.SystemGfx.Length > 0 & Operators.CompareString(this.game.Data.SystemGfx, "systemgraphics", false) != 0 & Operators.CompareString(this.game.Data.SystemGfx, "dc3modgraphics", false) != 0)
      {
        let mut num3: i32 =  1;
        do
        {
          if (num3 == 1)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "/cat1/";
          if (num3 == 2)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "SMALL/cat1/";
          if (num3 == 3)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "BIG/cat1";
          if (num3 == 4)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "/cat2/";
          if (num3 == 5)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "SMALL/cat2/";
          if (num3 == 6)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "BIG/cat2";
          if (num3 == 7)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "/cat3/";
          if (num3 == 8)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "SMALL/cat3/";
          if (num3 == 9)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "BIG/cat3";
          if (num3 == 10)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx;
          if (num3 == 11)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "SMALL";
          if (num3 == 12)
            path = this.game.AppPath + "graphics/" + this.game.Data.SystemGfx + "BIG";
          if (Directory.Exists(path))
          {
            foreach (FileInfo file in new DirectoryInfo(path).GetFiles("*.*"))
            {
              index1 += 1;
              arySrc[index1] = path + "/" + file.Name;
            }
          }
          num3 += 1;
        }
        while (num3 <= 12);
      }
      else if (this.game.ModSystemGraphicsDirectory.Length > 0 & Operators.CompareString(DrawMod.TGame.ModSystemGraphicsDirectory, "systemgraphics", false) != 0 & Operators.CompareString(DrawMod.TGame.ModSystemGraphicsDirectory, "dc3modgraphics", false) != 0)
      {
        let mut num4: i32 =  1;
        do
        {
          if (num4 == 1)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "/cat1/";
          if (num4 == 2)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "SMALL/cat1/";
          if (num4 == 3)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "BIG/cat1";
          if (num4 == 4)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "/cat2/";
          if (num4 == 5)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "SMALL/cat2/";
          if (num4 == 6)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "BIG/cat2";
          if (num4 == 7)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "/cat3/";
          if (num4 == 8)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "SMALL/cat3/";
          if (num4 == 9)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "BIG/cat3";
          if (num4 == 10)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory;
          if (num4 == 11)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "SMALL";
          if (num4 == 12)
            path = this.game.AppPath + "graphics/" + this.game.ModSystemGraphicsDirectory + "BIG";
          if (Directory.Exists(path))
          {
            foreach (FileInfo file in new DirectoryInfo(path).GetFiles("*.*"))
            {
              index1 += 1;
              arySrc[index1] = path + "/" + file.Name;
            }
          }
          num4 += 1;
        }
        while (num4 <= 12);
      }
      let mut counter: i32 =  BitmapStore.Counter;
      for (let mut index3: i32 =  0; index3 <= counter; index3 += 1)
      {
        if (!BitmapStore.tmpIsSystem[index3] | this.game.ModNatoCounters.Length > 0 & Strings.InStr(BitmapStore.tmpFileName[index3], this.game.ModNatoCounters) > 0)
        {
          let mut num5: i32 =  1;
          String1: String = (this.game.AppPath + "graphics/" + BitmapStore.tmpFileName[index3]).Replace("\\", "/");
          if (Strings.InStr(String1, "graphics/systemgraphics/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/systemgraphicsBIG/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/systemgraphicsSMALL/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/dc3modgraphics/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/dc3modgraphicsBIG/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/dc3modgraphicsSMALL/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/DC3/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/DC3BIG/") > 0)
            num5 = 0;
          if (Strings.InStr(String1, "graphics/DC3SMALL/") > 0)
            num5 = 0;
          if ("shadow".Length > 0)
          {
            if (Strings.InStr(String1, "graphics/shadow/") > 0)
              num5 = 0;
            if (Strings.InStr(String1, "graphics/shadowBIG/") > 0)
              num5 = 0;
            if (Strings.InStr(String1, "graphics/shadowSMALL/") > 0)
              num5 = 0;
          }
          if (num5 == 1 && System.IO.File.Exists(this.game.AppPath + "graphics/" + BitmapStore.tmpFileName[index3]))
          {
            index1 += 1;
            arySrc[index1] = this.game.AppPath + "graphics/" + BitmapStore.tmpFileName[index3];
            if (BitmapStore.tmpIsBig[index3])
            {
              let mut index4: i32 =  index1 + 1;
              arySrc[index4] = this.game.AppPath + "graphics/" + BitmapStore.MakeBigString(BitmapStore.tmpFileName[index3]);
              index1 = index4 + 1;
              arySrc[index1] = this.game.AppPath + "graphics/" + BitmapStore.MakeSmallString(BitmapStore.tmpFileName[index3]);
            }
          }
        }
      }
      slist: Vec<String> = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc, (Array) new string[index1 + 1]);
      let mut num6: i32 =  index1;
      for (let mut index5: i32 =  0; index5 <= num6; index5 += 1)
        slist[index5] = slist[index5].Replace("\\", "/");
      strArray3: Vec<String> = new string[1000];
      let mut index6: i32 =  -1;
      let mut num7: i32 =  index1;
      for (let mut index7: i32 =  0; index7 <= num7; index7 += 1)
      {
        str: String = slist[index7];
        Right: String = str.Substring(0, str.LastIndexOf("/"));
        let mut num8: i32 =  1;
        let mut num9: i32 =  index6;
        for (let mut index8: i32 =  0; index8 <= num9; index8 += 1)
        {
          if (Operators.CompareString(strArray3[index8], Right, false) == 0)
            num8 = 0;
        }
        if (num8 == 1)
        {
          index6 += 1;
          strArray3[index6] = Right;
        }
      }
      let mut num10: i32 =   Interaction.MsgBox( "This can take a while. Please leave the application running. Keep in mind that graphics from the at2, default, systemgraphics and modgraphics directory are never included since they are presumed to be present on all ATGold installs. Press OK to start.", Title: ( "Shadow Empire : Planetary Conquest"));
      this.game.FormRef.Cursor = Cursors.WaitCursor;
      let mut num11: i32 =  index6;
      for (let mut index9: i32 =  0; index9 <= num11; index9 += 1)
        strArray3[index9] = strArray3[index9].Replace("\\", "/");
      if (Directory.Exists(this.game.AppPath + "packagingzip"))
        Directory.Delete(this.game.AppPath + "packagingzip/", true);
      Application.DoEvents();
      Directory.CreateDirectory(this.game.AppPath + "packagingzip");
      Application.DoEvents();
      str1: String = this.game.AppPath.Replace("\\", "/");
      str2: String = str1.Substring(0, str1.LastIndexOf("/"));
      oldValue: String = str2.Substring(str2.LastIndexOf("/") + 1) + "/";
      let mut num12: i32 =  index6;
      for (let mut index10: i32 =  0; index10 <= num12; index10 += 1)
      {
        Directory.CreateDirectory(strArray3[index10].Replace(oldValue, oldValue + "packagingzip/"));
        Application.DoEvents();
      }
      let mut num13: i32 =  index1;
      for (let mut index11: i32 =  0; index11 <= num13; index11 += 1)
      {
        str3: String = slist[index11];
        let mut num14: i32 =  0;
        destFileName: String = str3.Replace(oldValue, oldValue + "packagingzip/");
        if (System.IO.File.Exists(slist[index11]))
        {
          while (num14 < 99)
          {
            try
            {
              Application.DoEvents();
              System.IO.File.Copy(slist[index11], destFileName, true);
              Application.DoEvents();
              num14 = 99;
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              num14 += 1;
              Application.DoEvents();
              ProjectData.ClearProjectError();
            }
          }
        }
      }
      this.game.HandyFunctionsObj.ZipFileExport2(FileName, slist, this.game.AppPath + "packagingzip/");
      Directory.Delete(this.game.AppPath + "packagingzip/", true);
      Application.DoEvents();
      this.game.FormRef.Cursor = Cursors.Default;
      let mut num15: i32 =   Interaction.MsgBox( "Export completed.", Title: ( "Shadow Empire : Planetary Conquest"));
    }

    pub fn ExportModLibraryEditor(libName: String)
    {
      arySrc: Vec<String> = new string[30000];
      strArray1: Vec<String> = new string[1000];
      strArray2: Vec<String> = new string[1000];
      let mut index1: i32 =  -1;
      let mut index2: i32 =  -1;
      str1: String = this.game.HandyFunctionsObj.SaveSomething("SE1 Zip package files(se1zip)|*.se1zip|Regular ZIP file(zip)|*.zip", "Save as .se1zip or .zip file", this.game.AppPath, false);
      if (Information.IsNothing( str1))
        return;
      if (Interaction.MsgBox( ("Did you save your Mod Library before pressing the Se1zip button?" + this.game.AppPath + "/" + this.game.ModSoundDir + "'. "), MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.No)
        return;
      let mut num1: i32 =  1;
      bool flag = true;
      str2: String;
      while (flag)
      {
        str2 = this.game.HandyFunctionsObj.LoadSomething("All files|*.*", "Add the savefile of your Mod Library please.", this.game.AppPath, false);
        flag = false;
        if (!System.IO.File.Exists(str2))
        {
          if (Interaction.MsgBox( "Not found. try again?", MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") != MsgBoxResult.No)
            flag = true;
          else
            break;
        }
        else
        {
          index2 += 1;
          strArray1[index2] = str2;
          index1 += 1;
          arySrc[index1] = str2;
          num1 += 1;
        }
      }
      slist: Vec<String> = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc, (Array) new string[index1 + 1]);
      let mut num2: i32 =  index1;
      for (let mut index3: i32 =  0; index3 <= num2; index3 += 1)
        slist[index3] = slist[index3].Replace("\\", "/");
      strArray3: Vec<String> = new string[1000];
      let mut index4: i32 =  -1;
      let mut num3: i32 =  index1;
      for (let mut index5: i32 =  0; index5 <= num3; index5 += 1)
      {
        str3: String = slist[index5];
        str2 = str3.Substring(0, str3.LastIndexOf("/"));
        let mut num4: i32 =  1;
        let mut num5: i32 =  index4;
        for (let mut index6: i32 =  0; index6 <= num5; index6 += 1)
        {
          if (Operators.CompareString(strArray3[index6], str2, false) == 0)
            num4 = 0;
        }
        if (num4 == 1)
        {
          index4 += 1;
          strArray3[index4] = str2;
        }
      }
      let mut num6: i32 =   Interaction.MsgBox( "This can take a while. Please leave the application running. Keep in mind that graphics from the at2, default, systemgraphics and modgraphics directory are never included since they are presumed to be present on all ATGold installs. Press OK to start.", Title: ( "Shadow Empire : Planetary Conquest"));
      this.game.FormRef.Cursor = Cursors.WaitCursor;
      let mut num7: i32 =  index4;
      for (let mut index7: i32 =  0; index7 <= num7; index7 += 1)
        strArray3[index7] = strArray3[index7].Replace("\\", "/");
      if (Directory.Exists(this.game.AppPath + "packagingzip"))
        Directory.Delete(this.game.AppPath + "packagingzip/", true);
      Application.DoEvents();
      Directory.CreateDirectory(this.game.AppPath + "packagingzip");
      Application.DoEvents();
      Directory.CreateDirectory(this.game.AppPath + "packagingzip/graphics");
      Application.DoEvents();
      let mut num8: i32 =  1;
      do
      {
        str4: String;
        if (num8 == 1)
        {
          str2 = this.game.AppPath + "graphics/" + libName.ToLower();
          str4 = libName.ToLower();
        }
        if (num8 == 2)
        {
          str2 = this.game.AppPath + "graphics/" + libName.ToLower() + "BIG";
          str4 = libName.ToLower() + "BIG";
        }
        if (num8 == 3)
        {
          str2 = this.game.AppPath + "graphics/" + libName.ToLower() + "SMALL";
          str4 = libName.ToLower() + "SMALL";
        }
        str2 = str2.Replace("\\", "/");
        str4 = str4.Replace("\\", "/");
        this.CopyDirectory(str2, this.game.AppPath + "packagingzip/graphics/" + str4);
        num8 += 1;
      }
      while (num8 <= 3);
      str5: String = this.game.AppPath.Replace("\\", "/");
      str6: String = str5.Substring(0, str5.LastIndexOf("/"));
      oldValue: String = str6.Substring(str6.LastIndexOf("/") + 1) + "/";
      let mut num9: i32 =  index4;
      for (let mut index8: i32 =  0; index8 <= num9; index8 += 1)
      {
        Directory.CreateDirectory(strArray3[index8].Replace(oldValue, oldValue + "packagingzip/"));
        Application.DoEvents();
      }
      let mut num10: i32 =  index1;
      for (let mut index9: i32 =  0; index9 <= num10; index9 += 1)
      {
        str7: String = slist[index9];
        let mut num11: i32 =  0;
        str8: String = str7.Replace(oldValue, oldValue + "packagingzip/");
        if (System.IO.File.Exists(slist[index9]))
        {
          while (num11 < 99)
          {
            try
            {
              Application.DoEvents();
              System.IO.File.Copy(slist[index9], str8, true);
              FileAttributes attributes = System.IO.File.GetAttributes(str8);
              if ((attributes & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
              {
                FileAttributes fileAttributes = HandyFunctionsclass.RemoveAttribute(attributes, FileAttributes.ReadOnly);
                System.IO.File.SetAttributes(str8, fileAttributes);
              }
              Application.DoEvents();
              num11 = 99;
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              num11 += 1;
              Application.DoEvents();
              ProjectData.ClearProjectError();
            }
          }
        }
      }
      this.game.HandyFunctionsObj.ZipFileExport2(str1, slist, this.game.AppPath + "packagingzip/");
      Directory.Delete(this.game.AppPath + "packagingzip/", true);
      Application.DoEvents();
      this.game.FormRef.Cursor = Cursors.Default;
      let mut num12: i32 =   Interaction.MsgBox( "Export completed.", Title: ( "Shadow Empire : Planetary Conquest"));
    }

    pub fn CopyDirectory(sourcePath: String, destinationPath: String)
    {
      DirectoryInfo directoryInfo = new DirectoryInfo(sourcePath);
      if (!Directory.Exists(destinationPath))
        Directory.CreateDirectory(destinationPath);
      foreach (FileSystemInfo fileSystemInfo in directoryInfo.GetFileSystemInfos())
      {
        str: String = Path.Combine(destinationPath, fileSystemInfo.Name);
        if (fileSystemInfo is FileInfo)
          System.IO.File.Copy(fileSystemInfo.FullName, str, true);
        else
          this.CopyDirectory(fileSystemInfo.FullName, str);
      }
    }

    pub fn ExportSimpleEditor()
    {
      arySrc: Vec<String> = new string[30000];
      strArray1: Vec<String> = new string[1000];
      strArray2: Vec<String> = new string[1000];
      let mut index1: i32 =  -1;
      let mut index2: i32 =  -1;
      str1: String = this.game.HandyFunctionsObj.SaveSomething("DC Zip package files(dczip)|*.dczip|Regular ZIP file(zip)|*.zip", "Save as .dczip or .zip file", this.game.AppPath, false);
      if (Information.IsNothing( str1))
        return;
      let mut num1: i32 =   Interaction.MsgBox( "Most important: First select the scenario file you have currently open please", Title: ( "Shadow Empire : Planetary Conquest"));
      let mut num2: i32 =  1;
      bool flag = true;
      while (flag)
      {
        path: String = this.game.HandyFunctionsObj.LoadSomething("All files|*.*", "Add a file (scenario, game menu mod txt file)", this.game.AppPath, false);
        if (!System.IO.File.Exists(path))
        {
          if (Interaction.MsgBox( "Not found. try again?", MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.No)
            break;
        }
        else
        {
          index2 += 1;
          strArray1[index2] = path;
          index1 += 1;
          arySrc[index1] = path;
          num2 += 1;
        }
        Prompt: String = "Add another file (game menu mod, text file, pdf) under '" + this.game.AppPath + "' to the DCZIP?";
        flag = false;
        if (Interaction.MsgBox( Prompt, MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.Yes)
          flag = true;
      }
label_13:
      path1: String;
      while (true)
      {
        if (Interaction.MsgBox( ("Add a directory directly under '" + this.game.AppPath + "/" + this.game.ModSoundDir + "'. "), MsgBoxStyle.YesNo,  "Shadow Empire : Planetary Conquest") == MsgBoxResult.Yes)
        {
          path1 = Interaction.InputBox("Give directory name. Must be directly under '" + this.game.AppPath + "/" + this.game.ModSoundDir + "/'. For example 'mysounds'. Keep in mind subdirectories of specified directory are not packed. ", "Shadow Empire : Planetary Conquest", this.game.AppPath + "/" + this.game.ModSoundDir + "/");
          if (!Directory.Exists(path1))
          {
            let mut num3: i32 =   Interaction.MsgBox( "Dir not found. Please try again.", Title: ( "Shadow Empire : Planetary Conquest"));
          }
          else
            break;
        }
        else
          goto label_14;
      }
      foreach (FileInfo file in new DirectoryInfo(path1).GetFiles("*.*"))
      {
        index1 += 1;
        arySrc[index1] = path1 + "/" + file.Name;
      }
      goto label_13;
label_14:
      let mut counter: i32 =  BitmapStore.Counter;
      for (let mut index3: i32 =  0; index3 <= counter; index3 += 1)
      {
        if (!BitmapStore.tmpIsSystem[index3] | this.game.ModNatoCounters.Length > 0 & Strings.InStr(BitmapStore.tmpFileName[index3], this.game.ModNatoCounters) > 0)
        {
          let mut num4: i32 =  1;
          String1: String = (this.game.AppPath + "graphics/" + BitmapStore.tmpFileName[index3]).Replace("\\", "/");
          if (Strings.InStr(String1, "graphics/systemgraphics/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/systemgraphicsBIG/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/systemgraphicsSMALL/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/communitymodgraphics/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/communitymodgraphicsBIG/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/communitymodgraphicsSMALL/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/ardennesmodgraphics/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/ardennesmodgraphicsBIG/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/ardennesmodgraphicsSMALL/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/community/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/communityBIG/") > 0)
            num4 = 0;
          if (Strings.InStr(String1, "graphics/communitySMALL/") > 0)
            num4 = 0;
          if ("shadow".Length > 0)
          {
            if (Strings.InStr(String1, "graphics/shadow/") > 0)
              num4 = 0;
            if (Strings.InStr(String1, "graphics/shadowBIG/") > 0)
              num4 = 0;
            if (Strings.InStr(String1, "graphics/shadowSMALL/") > 0)
              num4 = 0;
          }
          if (num4 == 1 && System.IO.File.Exists(this.game.AppPath + "graphics/" + BitmapStore.tmpFileName[index3]))
          {
            index1 += 1;
            arySrc[index1] = this.game.AppPath + "graphics/" + BitmapStore.tmpFileName[index3];
            if (BitmapStore.tmpIsBig[index3])
            {
              let mut index4: i32 =  index1 + 1;
              arySrc[index4] = this.game.AppPath + "graphics/" + BitmapStore.MakeBigString(BitmapStore.tmpFileName[index3]);
              index1 = index4 + 1;
              arySrc[index1] = this.game.AppPath + "graphics/" + BitmapStore.MakeSmallString(BitmapStore.tmpFileName[index3]);
            }
          }
        }
      }
      slist: Vec<String> = (string[]) Microsoft.VisualBasic.CompilerServices.Utils.CopyArray((Array) arySrc, (Array) new string[index1 + 1]);
      let mut num5: i32 =  index1;
      for (let mut index5: i32 =  0; index5 <= num5; index5 += 1)
        slist[index5] = slist[index5].Replace("\\", "/");
      strArray3: Vec<String> = new string[1000];
      let mut index6: i32 =  -1;
      let mut num6: i32 =  index1;
      for (let mut index7: i32 =  0; index7 <= num6; index7 += 1)
      {
        str2: String = slist[index7];
        Right: String = str2.Substring(0, str2.LastIndexOf("/"));
        let mut num7: i32 =  1;
        let mut num8: i32 =  index6;
        for (let mut index8: i32 =  0; index8 <= num8; index8 += 1)
        {
          if (Operators.CompareString(strArray3[index8], Right, false) == 0)
            num7 = 0;
        }
        if (num7 == 1)
        {
          index6 += 1;
          strArray3[index6] = Right;
        }
      }
      let mut num9: i32 =   Interaction.MsgBox( "This can take a while. Please leave the application running. Keep in mind that graphics from the at2, default, systemgraphics and modgraphics directory are never included since they are presumed to be present on all ATGold installs. Press OK to start.", Title: ( "Shadow Empire : Planetary Conquest"));
      this.game.FormRef.Cursor = Cursors.WaitCursor;
      let mut num10: i32 =  index6;
      for (let mut index9: i32 =  0; index9 <= num10; index9 += 1)
        strArray3[index9] = strArray3[index9].Replace("\\", "/");
      if (Directory.Exists(this.game.AppPath + "packagingzip"))
        Directory.Delete(this.game.AppPath + "packagingzip/", true);
      Application.DoEvents();
      Directory.CreateDirectory(this.game.AppPath + "packagingzip");
      Application.DoEvents();
      str3: String = this.game.AppPath.Replace("\\", "/");
      str4: String = str3.Substring(0, str3.LastIndexOf("/"));
      oldValue: String = str4.Substring(str4.LastIndexOf("/") + 1) + "/";
      let mut num11: i32 =  index6;
      for (let mut index10: i32 =  0; index10 <= num11; index10 += 1)
      {
        Directory.CreateDirectory(strArray3[index10].Replace(oldValue, oldValue + "packagingzip/"));
        Application.DoEvents();
      }
      let mut num12: i32 =  index1;
      for (let mut index11: i32 =  0; index11 <= num12; index11 += 1)
      {
        str5: String = slist[index11];
        let mut num13: i32 =  0;
        str6: String = str5.Replace(oldValue, oldValue + "packagingzip/");
        if (System.IO.File.Exists(slist[index11]))
        {
          while (num13 < 99)
          {
            try
            {
              Application.DoEvents();
              System.IO.File.Copy(slist[index11], str6, true);
              FileAttributes attributes = System.IO.File.GetAttributes(str6);
              if ((attributes & FileAttributes.ReadOnly) == FileAttributes.ReadOnly)
              {
                FileAttributes fileAttributes = HandyFunctionsclass.RemoveAttribute(attributes, FileAttributes.ReadOnly);
                System.IO.File.SetAttributes(str6, fileAttributes);
              }
              Application.DoEvents();
              num13 = 99;
            }
            catch (Exception ex)
            {
              ProjectData.SetProjectError(ex);
              num13 += 1;
              Application.DoEvents();
              ProjectData.ClearProjectError();
            }
          }
        }
      }
      this.game.HandyFunctionsObj.ZipFileExport2(str1, slist, this.game.AppPath + "packagingzip/");
      Directory.Delete(this.game.AppPath + "packagingzip/", true);
      Application.DoEvents();
      this.game.FormRef.Cursor = Cursors.Default;
      let mut num14: i32 =   Interaction.MsgBox( "Export completed.", Title: ( "Shadow Empire : Planetary Conquest"));
    }

    pub static FileAttributes RemoveAttribute(
      FileAttributes attributes,
      FileAttributes attributesToRemove)
    {
      return attributes & ~attributesToRemove;
    }

    pub SimpleStringList CombatPreviewStats(targetX: i32, targetY: i32)
    {
      int[] numArray1 = new int[100];
      int[] numArray2 = new int[100];
      int[] numArray3 = new int[100];
      int[] numArray4 = new int[100];
      SimpleStringList simpleStringList1 = SimpleStringList::new();
      SimpleStringList simpleStringList2 = SimpleStringList::new();
      if (this.game.EditObj.TempUnitList.counter == -1)
        return simpleStringList1;
      this.game.TempCombat = new CombatClass(this.game, true);
      Coordinate Target;
      Target.x = targetX;
      Target.y = targetY;
      Target.onmap = true;
      DrawMod.RandyNumber = new Random( Math.Round( (this.game.Data.GameID * (this.game.SelectX + 1)) /  (this.game.SelectY + 1)));
      this.game.TempCombat.Init(Target, 1, this.game.EditObj.TempUnitList, this.game.EditObj.OrderType);
      DrawMod.RandyNumber = new Random( Math.Round( (this.game.Data.GameID * (this.game.SelectX + 1)) /  (this.game.SelectY + 1)));
      if (this.game.Data.Product == 6)
      {
        let mut num1: i32 =  1;
        if (this.game.EditObj.TempUnitList.counter > -1)
        {
          let mut num2: i32 =  0;
          let mut counter: i32 =  this.game.EditObj.TempUnitList.counter;
          for (let mut index: i32 =  0; index <= counter; index += 1)
          {
            let mut lowestAp: i32 =  this.game.HandyFunctionsObj.GetLowestAp(this.game.EditObj.TempUnitList.unr[index]);
            if (lowestAp > num2)
              num2 = lowestAp;
          }
          num1 =  Math.Round(Math.Floor( num2 / 10.0));
          if (num1 < 1)
            num1 = 1;
        }
        let mut num3: i32 =  num1;
        for (let mut index: i32 =  1; index <= num3; index += 1)
        {
          this.game.TempCombat.SetConcentricBonus();
          this.game.TempCombat.DoSteps();
          this.game.TempCombat.CheckBreakthrough();
          this.game.TempCombat.CheckSafeRetreat();
          this.game.TempCombat.CheckOrderlyUnitRetreat();
          this.game.TempCombat.CheckPanicUnitRetreat();
          this.game.TempCombat.CheckCapitulation(true);
          this.game.TempCombat.CheckOutOfAP();
        }
      }
      else
        this.game.TempCombat.DoSteps();
      DrawMod.RandyNumber = Random::new();
      VBMath.Randomize();
      let mut tdata3: i32 =  0;
      do
      {
        let mut num4: i32 =  0;
        let mut num5: i32 =  0;
        let mut num6: i32 =  0;
        let mut num7: i32 =  0;
        let mut num8: i32 =  0;
        let mut num9: i32 =  0;
        let mut num10: i32 =  0;
        let mut num11: i32 =  0;
        let mut num12: i32 =  0;
        let mut num13: i32 =  0;
        let mut num14: i32 =  0;
        let mut num15: i32 =  0;
        let mut num16: i32 =  0;
        let mut num17: i32 =  0;
        let mut num18: i32 =  0;
        let mut num19: i32 =  0;
        let mut num20: i32 =  0;
        let mut num21: i32 =  0;
        let mut num22: i32 =  0;
        let mut num23: i32 =  0;
        let mut num24: i32 =  0;
        let mut num25: i32 =  0;
        let mut num26: i32 =  0;
        let mut num27: i32 =  0;
        SimpleList[] simpleListArray1 = new SimpleList[2]
        {
          SimpleList::new(),
          SimpleList::new()
        };
        SimpleList[] simpleListArray2 = new SimpleList[2]
        {
          SimpleList::new(),
          SimpleList::new()
        };
        SimpleList[] simpleListArray3 = new SimpleList[2]
        {
          SimpleList::new(),
          SimpleList::new()
        };
        SimpleList[] simpleListArray4 = new SimpleList[2]
        {
          SimpleList::new(),
          SimpleList::new()
        };
        SimpleList[] simpleListArray5 = new SimpleList[2]
        {
          SimpleList::new(),
          SimpleList::new()
        };
        SimpleList[] simpleListArray6 = new SimpleList[2]
        {
          SimpleList::new(),
          SimpleList::new()
        };
        SimpleList[] simpleListArray7 = new SimpleList[2]
        {
          SimpleList::new(),
          SimpleList::new()
        };
        SimpleList[] simpleListArray8 = new SimpleList[2];
        SimpleList[] simpleListArray9 = new SimpleList[2];
        simpleListArray8[0] = SimpleList::new();
        simpleListArray8[1] = SimpleList::new();
        simpleListArray9[0] = SimpleList::new();
        simpleListArray9[1] = SimpleList::new();
        SimpleList[,] simpleListArray10 = new SimpleList[40, 2];
        SimpleList[,] simpleListArray11 = new SimpleList[40, 2];
        let mut index1: i32 =  0;
        do
        {
          numArray1[index1] = 0;
          numArray2[index1] = 0;
          numArray3[index1] = 0;
          numArray4[index1] = 0;
          simpleListArray10[index1, 0] = SimpleList::new();
          simpleListArray11[index1, 0] = SimpleList::new();
          simpleListArray10[index1, 1] = SimpleList::new();
          simpleListArray11[index1, 1] = SimpleList::new();
          index1 += 1;
        }
        while (index1 <= 39);
        let mut repCounter: i32 =  this.game.TempCombat.RepCounter;
        for (let mut index2: i32 =  0; index2 <= repCounter; index2 += 1)
        {
          let mut num28: i32 =  this.game.TempCombat.RepFrom[index2];
          if (num28 >= 10000 & this.game.TempCombat.RepType[index2] == 1)
          {
            let mut index3: i32 =  num28 - 10000;
            let mut isfType: i32 =  this.game.TempCombat.IList[index3].ISFType;
            let mut d: i32 =  0;
            let mut num29: i32 =  0;
            if (this.game.TempCombat.IList[index3].IAttacker == 1)
            {
              let mut index4: i32 =  0;
              do
              {
                if (this.game.Data.SFTypeObj[isfType].AttackPower[index4] > d)
                  d = this.game.Data.SFTypeObj[isfType].AttackPower[index4];
                if (this.game.Data.SFTypeObj[isfType].HitPoints[index4] > num29)
                  num29 = this.game.Data.SFTypeObj[isfType].HitPoints[index4];
                index4 += 1;
              }
              while (index4 <= 19);
            }
            else
            {
              let mut index5: i32 =  0;
              do
              {
                if (this.game.Data.SFTypeObj[isfType].AttackPowerDef[index5] > d)
                  d = this.game.Data.SFTypeObj[isfType].AttackPowerDef[index5];
                if (this.game.Data.SFTypeObj[isfType].HitPointsDef[index5] > num29)
                  num29 = this.game.Data.SFTypeObj[isfType].HitPointsDef[index5];
                index5 += 1;
              }
              while (index5 <= 19);
            }
            if (d < 1)
              d = 1;
            if (num29 < 1)
              num29 = 1;
            let mut tvalue: i32 =   Math.Round(  Math.Round(Math.Max(1.0, Math.Max(1.0, Math.Sqrt( d) *  this.game.Data.SFTypeObj[isfType].Attacks + 1.0) *  num29)) / 100.0);
            if (tvalue < 1)
              tvalue = 1;
            if (this.game.TempCombat.IList[index3].IAttacker == tdata3)
            {
              let mut tid: i32 =  isfType;
              if (Strings.InStr(this.game.TempCombat.RepTitle[index2], "=>") > 0)
              {
                let mut index6: i32 =  0;
                do
                {
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Landscape", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    num4 += tvalue;
                    num5 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    if (simpleListArray1[tdata3].FindNr(tid) == -1)
                      simpleListArray1[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray1[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray1[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Concentric", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    num8 += tvalue;
                    num9 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Readiness", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    num12 += tvalue;
                    if (tdata3 == 0)
                      tdata3 = tdata3;
                    if ( Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) < 0)
                      tdata3 = tdata3;
                    num13 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    if (simpleListArray4[tdata3].FindNr(tid) == -1)
                      simpleListArray4[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray4[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray4[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Experience", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    num16 += tvalue;
                    if (tdata3 == 0)
                      tdata3 = tdata3;
                    num17 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    if (simpleListArray5[tdata3].FindNr(tid) == -1)
                      simpleListArray5[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray5[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray5[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Supply", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    num24 += tvalue;
                    num20 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Ammunition Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    num26 += tvalue;
                    num22 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    if (simpleListArray8[tdata3].FindNr(tid) == -1)
                      simpleListArray8[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray8[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray8[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Fuel Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    num27 += tvalue;
                    num23 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    if (simpleListArray9[tdata3].FindNr(tid) == -1)
                      simpleListArray9[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray9[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray9[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (this.game.TempCombat.CombatType == 3 | this.game.TempCombat.CombatType == 4)
                  {
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Direct Fire Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray5 = numArray2;
                      int[] numArray6 = numArray5;
                      let mut index7: i32 =  10;
                      let mut index8: i32 =  index7;
                      let mut num30: i32 =  numArray5[index7] + tvalue;
                      numArray6[index8] = num30;
                      int[] numArray7 = numArray1;
                      int[] numArray8 = numArray7;
                      let mut index9: i32 =  10;
                      let mut index10: i32 =  index9;
                      let mut num31: i32 =  numArray7[index9] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray8[index10] = num31;
                      if (simpleListArray10[10, tdata3].FindNr(tid) == -1)
                        simpleListArray10[10, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[10, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[10, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Indirect Fire LOS Bonus", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray9 = numArray2;
                      int[] numArray10 = numArray9;
                      let mut index11: i32 =  11;
                      let mut index12: i32 =  index11;
                      let mut num32: i32 =  numArray9[index11] + tvalue;
                      numArray10[index12] = num32;
                      int[] numArray11 = numArray1;
                      int[] numArray12 = numArray11;
                      let mut index13: i32 =  11;
                      let mut index14: i32 =  index13;
                      let mut num33: i32 =  numArray11[index13] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray12[index14] = num33;
                      if (simpleListArray10[11, tdata3].FindNr(tid) == -1)
                        simpleListArray10[11, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[11, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[11, tdata3].AddData(tid, 1, tvalue);
                    }
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Weather", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray13 = numArray2;
                    int[] numArray14 = numArray13;
                    let mut index15: i32 =  12;
                    let mut index16: i32 =  index15;
                    let mut num34: i32 =  numArray13[index15] + tvalue;
                    numArray14[index16] = num34;
                    int[] numArray15 = numArray1;
                    int[] numArray16 = numArray15;
                    let mut index17: i32 =  12;
                    let mut index18: i32 =  index17;
                    let mut num35: i32 =  numArray15[index17] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray16[index18] = num35;
                    if (simpleListArray10[12, tdata3].FindNr(tid) == -1)
                      simpleListArray10[12, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[12, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[12, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Max attacked", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray17 = numArray2;
                    int[] numArray18 = numArray17;
                    let mut index19: i32 =  13;
                    let mut index20: i32 =  index19;
                    let mut num36: i32 =  numArray17[index19] + tvalue;
                    numArray18[index20] = num36;
                    int[] numArray19 = numArray1;
                    int[] numArray20 = numArray19;
                    let mut index21: i32 =  13;
                    let mut index22: i32 =  index21;
                    let mut num37: i32 =  numArray19[index21] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray20[index22] = num37;
                    if (simpleListArray10[13, tdata3].FindNr(tid) == -1)
                      simpleListArray10[13, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[13, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[13, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "HQ", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray21 = numArray2;
                    int[] numArray22 = numArray21;
                    let mut index23: i32 =  14;
                    let mut index24: i32 =  index23;
                    let mut num38: i32 =  numArray21[index23] + tvalue;
                    numArray22[index24] = num38;
                    int[] numArray23 = numArray1;
                    int[] numArray24 = numArray23;
                    let mut index25: i32 =  14;
                    let mut index26: i32 =  index25;
                    let mut num39: i32 =  numArray23[index25] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray24[index26] = num39;
                    if (simpleListArray10[14, tdata3].FindNr(tid) == -1)
                      simpleListArray10[14, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[14, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[14, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Special", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray25 = numArray2;
                    int[] numArray26 = numArray25;
                    let mut index27: i32 =  15;
                    let mut index28: i32 =  index27;
                    let mut num40: i32 =  numArray25[index27] + tvalue;
                    numArray26[index28] = num40;
                    int[] numArray27 = numArray1;
                    int[] numArray28 = numArray27;
                    let mut index29: i32 =  15;
                    let mut index30: i32 =  index29;
                    let mut num41: i32 =  numArray27[index29] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray28[index30] = num41;
                    if (simpleListArray10[15, tdata3].FindNr(tid) == -1)
                      simpleListArray10[15, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[15, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[15, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Divisional", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray29 = numArray2;
                    int[] numArray30 = numArray29;
                    let mut index31: i32 =  16;
                    let mut index32: i32 =  index31;
                    let mut num42: i32 =  numArray29[index31] + tvalue;
                    numArray30[index32] = num42;
                    int[] numArray31 = numArray1;
                    int[] numArray32 = numArray31;
                    let mut index33: i32 =  16;
                    let mut index34: i32 =  index33;
                    let mut num43: i32 =  numArray31[index33] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray32[index34] = num43;
                    if (simpleListArray10[16, tdata3].FindNr(tid) == -1)
                      simpleListArray10[16, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[16, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[16, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "AI Bonus", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray33 = numArray2;
                    int[] numArray34 = numArray33;
                    let mut index35: i32 =  17;
                    let mut index36: i32 =  index35;
                    let mut num44: i32 =  numArray33[index35] + tvalue;
                    numArray34[index36] = num44;
                    int[] numArray35 = numArray1;
                    int[] numArray36 = numArray35;
                    let mut index37: i32 =  17;
                    let mut index38: i32 =  index37;
                    let mut num45: i32 =  numArray35[index37] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray36[index38] = num45;
                    if (simpleListArray10[17, tdata3].FindNr(tid) == -1)
                      simpleListArray10[17, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[17, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[17, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Overstack", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray37 = numArray2;
                    int[] numArray38 = numArray37;
                    let mut index39: i32 =  21;
                    let mut index40: i32 =  index39;
                    let mut num46: i32 =  numArray37[index39] + tvalue;
                    numArray38[index40] = num46;
                    int[] numArray39 = numArray1;
                    int[] numArray40 = numArray39;
                    let mut index41: i32 =  21;
                    let mut index42: i32 =  index41;
                    let mut num47: i32 =  numArray39[index41] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray40[index42] = num47;
                    if (simpleListArray10[21, tdata3].FindNr(tid) == -1)
                      simpleListArray10[21, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[21, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[21, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Overstack Art", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray41 = numArray2;
                    int[] numArray42 = numArray41;
                    let mut index43: i32 =  22;
                    let mut index44: i32 =  index43;
                    let mut num48: i32 =  numArray41[index43] + tvalue;
                    numArray42[index44] = num48;
                    int[] numArray43 = numArray1;
                    int[] numArray44 = numArray43;
                    let mut index45: i32 =  22;
                    let mut index46: i32 =  index45;
                    let mut num49: i32 =  numArray43[index45] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray44[index46] = num49;
                    if (simpleListArray10[22, tdata3].FindNr(tid) == -1)
                      simpleListArray10[22, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[22, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[22, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Night penalty", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                  {
                    int[] numArray45 = numArray2;
                    int[] numArray46 = numArray45;
                    let mut index47: i32 =  23;
                    let mut index48: i32 =  index47;
                    let mut num50: i32 =  numArray45[index47] + tvalue;
                    numArray46[index48] = num50;
                    int[] numArray47 = numArray1;
                    int[] numArray48 = numArray47;
                    let mut index49: i32 =  23;
                    let mut index50: i32 =  index49;
                    let mut num51: i32 =  numArray47[index49] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                    numArray48[index50] = num51;
                    if (simpleListArray10[23, tdata3].FindNr(tid) == -1)
                      simpleListArray10[23, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray10[23, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                    simpleListArray10[23, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (this.game.Data.Product == 7)
                  {
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Posture Combat Bonus", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray49 = numArray2;
                      int[] numArray50 = numArray49;
                      let mut index51: i32 =  8;
                      let mut index52: i32 =  index51;
                      let mut num52: i32 =  numArray49[index51] + tvalue;
                      numArray50[index52] = num52;
                      int[] numArray51 = numArray1;
                      int[] numArray52 = numArray51;
                      let mut index53: i32 =  8;
                      let mut index54: i32 =  index53;
                      let mut num53: i32 =  numArray51[index53] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray52[index54] = num53;
                      if (simpleListArray10[8, tdata3].FindNr(tid) == -1)
                        simpleListArray10[8, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[8, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[8, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Profile Combat Bonus", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray53 = numArray2;
                      int[] numArray54 = numArray53;
                      let mut index55: i32 =  9;
                      let mut index56: i32 =  index55;
                      let mut num54: i32 =  numArray53[index55] + tvalue;
                      numArray54[index56] = num54;
                      int[] numArray55 = numArray1;
                      int[] numArray56 = numArray55;
                      let mut index57: i32 =  9;
                      let mut index58: i32 =  index57;
                      let mut num55: i32 =  numArray55[index57] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray56[index58] = num55;
                      if (simpleListArray10[9, tdata3].FindNr(tid) == -1)
                        simpleListArray10[9, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[9, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[9, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Strings.InStr(this.game.TempCombat.RepCom[index6, 0, index2], "Skill") > 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray57 = numArray2;
                      int[] numArray58 = numArray57;
                      let mut index59: i32 =  29;
                      let mut index60: i32 =  index59;
                      let mut num56: i32 =  numArray57[index59] + tvalue;
                      numArray58[index60] = num56;
                      int[] numArray59 = numArray1;
                      int[] numArray60 = numArray59;
                      let mut index61: i32 =  29;
                      let mut index62: i32 =  index61;
                      let mut num57: i32 =  numArray59[index61] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray60[index62] = num57;
                      if (simpleListArray10[29, tdata3].FindNr(tid) == -1)
                        simpleListArray10[29, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[29, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[29, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Unit Feat Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray61 = numArray2;
                      int[] numArray62 = numArray61;
                      let mut index63: i32 =  30;
                      let mut index64: i32 =  index63;
                      let mut num58: i32 =  numArray61[index63] + tvalue;
                      numArray62[index64] = num58;
                      int[] numArray63 = numArray1;
                      int[] numArray64 = numArray63;
                      let mut index65: i32 =  30;
                      let mut index66: i32 =  index65;
                      let mut num59: i32 =  numArray63[index65] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray64[index66] = num59;
                      if (simpleListArray10[30, tdata3].FindNr(tid) == -1)
                        simpleListArray10[30, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[30, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[30, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Weapon Matrix Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray65 = numArray2;
                      int[] numArray66 = numArray65;
                      let mut index67: i32 =  31;
                      let mut index68: i32 =  index67;
                      let mut num60: i32 =  numArray65[index67] + tvalue;
                      numArray66[index68] = num60;
                      int[] numArray67 = numArray1;
                      int[] numArray68 = numArray67;
                      let mut index69: i32 =  31;
                      let mut index70: i32 =  index69;
                      let mut num61: i32 =  numArray67[index69] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray68[index70] = num61;
                      if (simpleListArray10[31, tdata3].FindNr(tid) == -1)
                        simpleListArray10[31, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[31, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[31, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index6, 0, index2], "Callibre Matrix Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index6, 1, index2], "?", false) != 0)
                    {
                      int[] numArray69 = numArray2;
                      int[] numArray70 = numArray69;
                      let mut index71: i32 =  32;
                      let mut index72: i32 =  index71;
                      let mut num62: i32 =  numArray69[index71] + tvalue;
                      numArray70[index72] = num62;
                      int[] numArray71 = numArray1;
                      int[] numArray72 = numArray71;
                      let mut index73: i32 =  32;
                      let mut index74: i32 =  index73;
                      let mut num63: i32 =  numArray71[index73] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])) * tvalue;
                      numArray72[index74] = num63;
                      if (simpleListArray10[32, tdata3].FindNr(tid) == -1)
                        simpleListArray10[32, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray10[32, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index6, 1, index2])));
                      simpleListArray10[32, tdata3].AddData(tid, 1, tvalue);
                    }
                  }
                  index6 += 1;
                }
                while (index6 <= 30);
              }
              if (Strings.InStr(this.game.TempCombat.RepTitle[index2], "<=") > 0)
              {
                let mut index75: i32 =  0;
                do
                {
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "River", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    num6 += tvalue;
                    num7 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    if (simpleListArray2[tdata3].FindNr(tid) == -1)
                      simpleListArray2[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray2[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray2[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Entrenchment", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    num10 += tvalue;
                    if (tdata3 == 0)
                      tdata3 = tdata3;
                    num11 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    if (simpleListArray3[tdata3].FindNr(tid) == -1)
                      simpleListArray3[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray3[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray3[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Readiness", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    num14 += tvalue;
                    if (tdata3 == 0)
                      tdata3 = tdata3;
                    num15 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    if (simpleListArray6[tdata3].FindNr(tid) == -1)
                      simpleListArray6[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray6[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray6[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Experience", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    num18 += tvalue;
                    if (tdata3 == 0)
                      tdata3 = tdata3;
                    num19 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    if (simpleListArray7[tdata3].FindNr(tid) == -1)
                      simpleListArray7[tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray7[tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray7[tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Supply", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    num25 += tvalue;
                    num21 +=  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Divisional", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    int[] numArray73 = numArray4;
                    int[] numArray74 = numArray73;
                    let mut index76: i32 =  16;
                    let mut index77: i32 =  index76;
                    let mut num64: i32 =  numArray73[index76] + tvalue;
                    numArray74[index77] = num64;
                    int[] numArray75 = numArray3;
                    int[] numArray76 = numArray75;
                    let mut index78: i32 =  16;
                    let mut index79: i32 =  index78;
                    let mut num65: i32 =  numArray75[index78] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    numArray76[index79] = num65;
                    if (simpleListArray11[16, tdata3].FindNr(tid) == -1)
                      simpleListArray11[16, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray11[16, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray11[16, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "AI Bonus", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    int[] numArray77 = numArray4;
                    int[] numArray78 = numArray77;
                    let mut index80: i32 =  17;
                    let mut index81: i32 =  index80;
                    let mut num66: i32 =  numArray77[index80] + tvalue;
                    numArray78[index81] = num66;
                    int[] numArray79 = numArray3;
                    int[] numArray80 = numArray79;
                    let mut index82: i32 =  17;
                    let mut index83: i32 =  index82;
                    let mut num67: i32 =  numArray79[index82] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    numArray80[index83] = num67;
                    if (simpleListArray11[17, tdata3].FindNr(tid) == -1)
                      simpleListArray11[17, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray11[17, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray11[17, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (((Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Defender is Hidden", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0 ? 1 : 0) & 0) != 0)
                  {
                    int[] numArray81 = numArray4;
                    int[] numArray82 = numArray81;
                    let mut index84: i32 =  18;
                    let mut index85: i32 =  index84;
                    let mut num68: i32 =  numArray81[index84] + tvalue;
                    numArray82[index85] = num68;
                    int[] numArray83 = numArray3;
                    int[] numArray84 = numArray83;
                    let mut index86: i32 =  18;
                    let mut index87: i32 =  index86;
                    let mut num69: i32 =  numArray83[index86] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    numArray84[index87] = num69;
                    if (simpleListArray11[18, tdata3].FindNr(tid) == -1)
                      simpleListArray11[18, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray11[18, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray11[18, tdata3].AddData(tid, 1, tvalue);
                  }
                  if ((Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Defender has highground", false) == 0 | Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Attacker has highground", false) == 0) & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    int[] numArray85 = numArray4;
                    int[] numArray86 = numArray85;
                    let mut index88: i32 =  19;
                    let mut index89: i32 =  index88;
                    let mut num70: i32 =  numArray85[index88] + tvalue;
                    numArray86[index89] = num70;
                    int[] numArray87 = numArray3;
                    int[] numArray88 = numArray87;
                    let mut index90: i32 =  19;
                    let mut index91: i32 =  index90;
                    let mut num71: i32 =  numArray87[index90] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    numArray88[index91] = num71;
                    if (simpleListArray11[19, tdata3].FindNr(tid) == -1)
                      simpleListArray11[19, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray11[19, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray11[19, tdata3].AddData(tid, 1, tvalue);
                  }
                  if ((Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Very close combat", false) == 0 | Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Close combat", false) == 0) & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    int[] numArray89 = numArray4;
                    int[] numArray90 = numArray89;
                    let mut index92: i32 =  20;
                    let mut index93: i32 =  index92;
                    let mut num72: i32 =  numArray89[index92] + tvalue;
                    numArray90[index93] = num72;
                    int[] numArray91 = numArray3;
                    int[] numArray92 = numArray91;
                    let mut index94: i32 =  20;
                    let mut index95: i32 =  index94;
                    let mut num73: i32 =  numArray91[index94] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    numArray92[index95] = num73;
                    if (simpleListArray11[20, tdata3].FindNr(tid) == -1)
                      simpleListArray11[20, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray11[20, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray11[20, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Overstack", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                  {
                    int[] numArray93 = numArray4;
                    int[] numArray94 = numArray93;
                    let mut index96: i32 =  21;
                    let mut index97: i32 =  index96;
                    let mut num74: i32 =  numArray93[index96] + tvalue;
                    numArray94[index97] = num74;
                    int[] numArray95 = numArray3;
                    int[] numArray96 = numArray95;
                    let mut index98: i32 =  21;
                    let mut index99: i32 =  index98;
                    let mut num75: i32 =  numArray95[index98] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                    numArray96[index99] = num75;
                    if (simpleListArray11[21, tdata3].FindNr(tid) == -1)
                      simpleListArray11[21, tdata3].Add(tid, 0, CheckExistence: false);
                    simpleListArray11[21, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                    simpleListArray11[21, tdata3].AddData(tid, 1, tvalue);
                  }
                  if (this.game.Data.Product == 7)
                  {
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Posture Combat Bonus", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                    {
                      int[] numArray97 = numArray4;
                      int[] numArray98 = numArray97;
                      let mut index100: i32 =  8;
                      let mut index101: i32 =  index100;
                      let mut num76: i32 =  numArray97[index100] + tvalue;
                      numArray98[index101] = num76;
                      int[] numArray99 = numArray3;
                      int[] numArray100 = numArray99;
                      let mut index102: i32 =  8;
                      let mut index103: i32 =  index102;
                      let mut num77: i32 =  numArray99[index102] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                      numArray100[index103] = num77;
                      if (simpleListArray11[8, tdata3].FindNr(tid) == -1)
                        simpleListArray11[8, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray11[8, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                      simpleListArray11[8, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Strings.InStr(this.game.TempCombat.RepCom[index75, 3, index2], "Skill") > 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                    {
                      int[] numArray101 = numArray4;
                      int[] numArray102 = numArray101;
                      let mut index104: i32 =  29;
                      let mut index105: i32 =  index104;
                      let mut num78: i32 =  numArray101[index104] + tvalue;
                      numArray102[index105] = num78;
                      int[] numArray103 = numArray3;
                      int[] numArray104 = numArray103;
                      let mut index106: i32 =  29;
                      let mut index107: i32 =  index106;
                      let mut num79: i32 =  numArray103[index106] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                      numArray104[index107] = num79;
                      if (simpleListArray11[29, tdata3].FindNr(tid) == -1)
                        simpleListArray11[29, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray11[29, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                      simpleListArray11[29, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Unit Feat Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                    {
                      int[] numArray105 = numArray4;
                      int[] numArray106 = numArray105;
                      let mut index108: i32 =  30;
                      let mut index109: i32 =  index108;
                      let mut num80: i32 =  numArray105[index108] + tvalue;
                      numArray106[index109] = num80;
                      int[] numArray107 = numArray3;
                      int[] numArray108 = numArray107;
                      let mut index110: i32 =  30;
                      let mut index111: i32 =  index110;
                      let mut num81: i32 =  numArray107[index110] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                      numArray108[index111] = num81;
                      if (simpleListArray11[30, tdata3].FindNr(tid) == -1)
                        simpleListArray11[30, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray11[30, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                      simpleListArray11[30, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Weapon Matrix Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                    {
                      int[] numArray109 = numArray4;
                      int[] numArray110 = numArray109;
                      let mut index112: i32 =  31;
                      let mut index113: i32 =  index112;
                      let mut num82: i32 =  numArray109[index112] + tvalue;
                      numArray110[index113] = num82;
                      int[] numArray111 = numArray3;
                      int[] numArray112 = numArray111;
                      let mut index114: i32 =  31;
                      let mut index115: i32 =  index114;
                      let mut num83: i32 =  numArray111[index114] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                      numArray112[index115] = num83;
                      if (simpleListArray11[31, tdata3].FindNr(tid) == -1)
                        simpleListArray11[31, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray11[31, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                      simpleListArray11[31, tdata3].AddData(tid, 1, tvalue);
                    }
                    if (Operators.CompareString(this.game.TempCombat.RepCom[index75, 3, index2], "Callibre Matrix Mod", false) == 0 & Operators.CompareString(this.game.TempCombat.RepCom[index75, 4, index2], "?", false) != 0)
                    {
                      int[] numArray113 = numArray4;
                      int[] numArray114 = numArray113;
                      let mut index116: i32 =  32;
                      let mut index117: i32 =  index116;
                      let mut num84: i32 =  numArray113[index116] + tvalue;
                      numArray114[index117] = num84;
                      int[] numArray115 = numArray3;
                      int[] numArray116 = numArray115;
                      let mut index118: i32 =  32;
                      let mut index119: i32 =  index118;
                      let mut num85: i32 =  numArray115[index118] +  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])) * tvalue;
                      numArray116[index119] = num85;
                      if (simpleListArray11[32, tdata3].FindNr(tid) == -1)
                        simpleListArray11[32, tdata3].Add(tid, 0, CheckExistence: false);
                      simpleListArray11[32, tdata3].AddWeight(tid, tvalue *  Math.Round(Conversion.Val(this.game.TempCombat.RepCom[index75, 4, index2])));
                      simpleListArray11[32, tdata3].AddData(tid, 1, tvalue);
                    }
                  }
                  index75 += 1;
                }
                while (index75 <= 30);
              }
            }
          }
        }
        let mut num86: i32 =  num4 <= 0 ? 0 :  Math.Round( num5 /  num4);
        tid1: String = "Landscape modifier of ";
        str1: String;
        if (tdata3 == 1)
        {
          tid1 += "Offensive Attack Values";
          str1 = "attack into";
        }
        if (tdata3 == 0)
        {
          tid1 += "Defensive Attack Values";
          str1 = "defend";
        }
        str2: String = "The Landscape modifier for the Attack Values of the Troops having to " + str1 + " the Landscape: '" + this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[targetX, targetY].LandscapeType].Name + "'.";
        let mut counter1: i32 =  simpleListArray1[tdata3].Counter;
        tdata2_1: i32;
        for (let mut index120: i32 =  0; index120 <= counter1; index120 += 1)
        {
          let mut tdata5: i32 =  simpleListArray1[tdata3].Id[index120];
          tdata2_1 = simpleListArray1[tdata3].Weight[index120];
          let mut tweight: i32 =  simpleListArray1[tdata3].Data1[index120];
          tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
          str3: String = str2 + "\r\n";
          str4: String = "-";
          if (tdata2_1 > 0)
            str4 = "+" + tdata2_1.ToString() + "%";
          if (tdata2_1 < 0)
            str4 = tdata2_1.ToString() + "%";
          if (tdata2_1 == 0)
            str2 = str3 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
          else
            str2 = str3 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str4 + ".";
          simpleStringList2.Add(tid1, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
        }
        let mut tdata1_1: i32 =  1;
        let mut tdata2_2: i32 =  num86;
        let mut tdata4_1: i32 =  num4;
        simpleStringList1.Add(tid1 + "#" + str2, 1, tdata1_1, tdata2_2, tdata3, tdata4_1);
        if (tdata3 == 1)
        {
          let mut num87: i32 =  num6 <= 0 ? 0 :  Math.Round( num7 /  num6);
          tid2: String = "River modifier of ";
          if (tdata3 == 1)
            tid2 += "Hitpoints";
          str5: String = "The River modifier of the Hitpoints for attacking over it.";
          let mut counter2: i32 =  simpleListArray2[tdata3].Counter;
          for (let mut index121: i32 =  0; index121 <= counter2; index121 += 1)
          {
            let mut tdata5: i32 =  simpleListArray2[tdata3].Id[index121];
            tdata2_1 = simpleListArray2[tdata3].Weight[index121];
            let mut tweight: i32 =  simpleListArray2[tdata3].Data1[index121];
            tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
            str6: String = str5 + "\r\n";
            str7: String = "-";
            if (tdata2_1 > 0)
              str7 = "+" + tdata2_1.ToString() + "%";
            if (tdata2_1 < 0)
              str7 = tdata2_1.ToString() + "%";
            if (tdata2_1 == 0)
              str5 = str6 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
            else
              str5 = str6 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str7 + ".";
            simpleStringList2.Add(tid2, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
          }
          let mut tdata1_2: i32 =  2;
          let mut tdata2_3: i32 =  num87;
          let mut tdata4_2: i32 =  num6;
          simpleStringList1.Add(tid2 + "#" + str5, 1, tdata1_2, tdata2_3, tdata3, tdata4_2);
        }
        if (tdata3 == 1)
        {
          let mut num88: i32 =  num8 <= 0 ? 0 :  Math.Round( num9 /  num8);
          str8: String = "Concentric attack modifier for offensive Attack Values ";
          str9: String = "From the more sides you attack, the more bonus you'll get.";
          let mut tdata1_3: i32 =  3;
          let mut tdata2_4: i32 =  num88;
          let mut tdata4_3: i32 =  1;
          simpleStringList1.Add(str8 + "#" + str9, 1, tdata1_3, tdata2_4, tdata3, tdata4_3);
        }
        let mut num89: i32 =  num10 <= 0 ? 0 :  Math.Round( num11 /  num10);
        tid3: String = "Entrenchment modifier of ";
        if (tdata3 == 1)
          tid3 += "Hitpoints";
        str10: String = "The Units entrenchment levels will give them protection and thus a modifier to their Hitpoints.";
        let mut counter3: i32 =  simpleListArray3[tdata3].Counter;
        for (let mut index122: i32 =  0; index122 <= counter3; index122 += 1)
        {
          let mut tdata5: i32 =  simpleListArray3[tdata3].Id[index122];
          tdata2_1 = simpleListArray3[tdata3].Weight[index122];
          let mut tweight: i32 =  simpleListArray3[tdata3].Data1[index122];
          tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
          str11: String = str10 + "\r\n";
          str12: String = "-";
          if (tdata2_1 > 0)
            str12 = "+" + tdata2_1.ToString() + "%";
          if (tdata2_1 < 0)
            str12 = tdata2_1.ToString() + "%";
          if (tdata2_1 == 0)
            str10 = str11 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
          else
            str10 = str11 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str12 + ".";
          simpleStringList2.Add(tid3, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
        }
        let mut tdata1_4: i32 =  4;
        let mut tdata2_5: i32 =  num89;
        let mut tdata4_4: i32 =  num10;
        simpleStringList1.Add(tid3 + "#" + str10, 1, tdata1_4, tdata2_5, tdata3, tdata4_4);
        let mut num90: i32 =  !(num13 > 0 & num12 > 0) ? (!(num13 < 0 & num12 > 0) ? (num12 <= 0 ? 0 :  Math.Round( num13 /  num12)) : Math.Min(-1,  Math.Round( num13 /  num12))) : Math.Max(1,  Math.Round( num13 /  num12));
        tid4: String = "Readiness modifier on Attack Values";
        str13: String = "The Readiness levels modify the Attack Values and the Hitpoints of Troops. ";
        let mut counter4: i32 =  simpleListArray4[tdata3].Counter;
        for (let mut index123: i32 =  0; index123 <= counter4; index123 += 1)
        {
          let mut tdata5: i32 =  simpleListArray4[tdata3].Id[index123];
          tdata2_1 = simpleListArray4[tdata3].Weight[index123];
          let mut tweight: i32 =  simpleListArray4[tdata3].Data1[index123];
          tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
          str14: String = str13 + "\r\n";
          str15: String = "-";
          if (tdata2_1 > 0)
            str15 = "+" + tdata2_1.ToString() + "%";
          if (tdata2_1 < 0)
            str15 = tdata2_1.ToString() + "%";
          if (tdata2_1 == 0)
            str13 = str14 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
          else
            str13 = str14 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str15 + ".";
          simpleStringList2.Add(tid4, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
        }
        let mut tdata1_5: i32 =  5;
        let mut tdata2_6: i32 =  num90;
        let mut tdata4_5: i32 =  num12;
        simpleStringList1.Add(tid4 + "#" + str13, 1, tdata1_5, tdata2_6, tdata3, tdata4_5);
        let mut num91: i32 =  num14 <= 0 ? 0 :  Math.Round( num15 /  num14);
        tid5: String = "Readiness modifier on Hitpoints";
        str16: String = "The Readiness levels modify the Attack Values and the Hitpoints of Troops. ";
        let mut counter5: i32 =  simpleListArray6[tdata3].Counter;
        for (let mut index124: i32 =  0; index124 <= counter5; index124 += 1)
        {
          let mut tdata5: i32 =  simpleListArray6[tdata3].Id[index124];
          tdata2_1 = simpleListArray6[tdata3].Weight[index124];
          let mut tweight: i32 =  simpleListArray6[tdata3].Data1[index124];
          tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
          str17: String = str16 + "\r\n";
          str18: String = "-";
          if (tdata2_1 > 0)
            str18 = "+" + tdata2_1.ToString() + "%";
          if (tdata2_1 < 0)
            str18 = tdata2_1.ToString() + "%";
          if (tdata2_1 == 0)
            str16 = str17 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
          else
            str16 = str17 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str18 + ".";
          simpleStringList2.Add(tid5, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
        }
        let mut tdata1_6: i32 =  5;
        let mut tdata2_7: i32 =  num91;
        let mut tdata4_6: i32 =  num14;
        simpleStringList1.Add(tid5 + "#" + str16, 1, tdata1_6, tdata2_7, tdata3, tdata4_6);
        let mut num92: i32 =  num16 <= 0 ? 0 :  Math.Round( num17 /  num16);
        tid6: String = "Experience modifier on Attack Values";
        str19: String = "The Experience levels modify the Attack Values and the Hitpoints of Troops. ";
        let mut counter6: i32 =  simpleListArray5[tdata3].Counter;
        for (let mut index125: i32 =  0; index125 <= counter6; index125 += 1)
        {
          let mut tdata5: i32 =  simpleListArray5[tdata3].Id[index125];
          tdata2_1 = simpleListArray5[tdata3].Weight[index125];
          let mut tweight: i32 =  simpleListArray5[tdata3].Data1[index125];
          tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
          str20: String = str19 + "\r\n";
          str21: String = "-";
          if (tdata2_1 > 0)
            str21 = "+" + tdata2_1.ToString() + "%";
          if (tdata2_1 < 0)
            str21 = tdata2_1.ToString() + "%";
          if (tdata2_1 == 0)
            str19 = str20 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
          else
            str19 = str20 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str21 + ".";
          simpleStringList2.Add(tid6, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
        }
        let mut tdata1_7: i32 =  6;
        let mut tdata2_8: i32 =  num92;
        let mut tdata4_7: i32 =  num16;
        simpleStringList1.Add(tid6 + "#" + str19, 1, tdata1_7, tdata2_8, tdata3, tdata4_7);
        let mut num93: i32 =  num18 <= 0 ? 0 :  Math.Round( num19 /  num18);
        tid7: String = "Experience modifier on Hitpoints";
        str22: String = "The Experience levels modify the Attack Values and the Hitpoints of Troops. ";
        let mut counter7: i32 =  simpleListArray7[tdata3].Counter;
        for (let mut index126: i32 =  0; index126 <= counter7; index126 += 1)
        {
          let mut tdata5: i32 =  simpleListArray7[tdata3].Id[index126];
          tdata2_1 = simpleListArray7[tdata3].Weight[index126];
          let mut tweight: i32 =  simpleListArray7[tdata3].Data1[index126];
          tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
          str23: String = str22 + "\r\n";
          str24: String = "-";
          if (tdata2_1 > 0)
            str24 = "+" + tdata2_1.ToString() + "%";
          if (tdata2_1 < 0)
            str24 = tdata2_1.ToString() + "%";
          if (tdata2_1 == 0)
            str22 = str23 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
          else
            str22 = str23 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str24 + ".";
          simpleStringList2.Add(tid7, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
        }
        let mut tdata1_8: i32 =  6;
        let mut tdata2_9: i32 =  num93;
        let mut tdata4_8: i32 =  num18;
        simpleStringList1.Add(tid7 + "#" + str22, 1, tdata1_8, tdata2_9, tdata3, tdata4_8);
        let mut num94: i32 =  num24 <= 0 ? 0 :  Math.Round( num20 /  num24);
        num22 = num26 <= 0 ? 0 :  Math.Round( num22 /  num26);
        let mut num95: i32 =  num27 <= 0 ? 0 :  Math.Round( num23 /  num27);
        let mut num96: i32 =   Math.Round( (100 + num94) * ( (100 + num22) / 100.0) * ( (100 + num95) / 100.0)) - 100;
        tid8: String = "Supply/Ammo/Fuel modifier of ";
        if (tdata3 == 1)
        {
          tid8 += "Offensive Attack Values";
          str1 = "attack into";
        }
        if (tdata3 == 0)
        {
          tid8 += "Defensive Attack Values";
          str1 = "defend";
        }
        str25: String = "Supply Consumption, Ammunition and Fuel Modifiers can impose a heavy negative modifier on the Attack Values.\r\n";
        if (num24 > 0 | num26 > 0 | num27 > 0)
        {
          str25 = str25 + "The Supply Consumption modifier is " + num94.ToString() + "%\r\n" + "The Ammunition modifier is " + num22.ToString() + "%\r\n" + "The Fuel modifier is " + num95.ToString() + "%\r\n" + "=> The combined modifier of the above is: " + num96.ToString() + "%.\r\n";
          let mut counter8: i32 =  simpleListArray8[tdata3].Counter;
          for (let mut index127: i32 =  0; index127 <= counter8; index127 += 1)
          {
            if (index127 == 0)
              str25 += "\r\nAMMUNITION MODIFIERS:";
            let mut tdata5: i32 =  simpleListArray8[tdata3].Id[index127];
            tdata2_1 = simpleListArray8[tdata3].Weight[index127];
            let mut tweight: i32 =  simpleListArray8[tdata3].Data1[index127];
            tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
            str26: String = str25 + "\r\n";
            str27: String = "-";
            if (tdata2_1 > 0)
              str27 = "+" + tdata2_1.ToString() + "%";
            if (tdata2_1 < 0)
              str27 = tdata2_1.ToString() + "%";
            if (tdata2_1 == 0)
              str25 = str26 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
            else
              str25 = str26 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str27 + ".";
            simpleStringList2.Add(tid8, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
          }
          let mut counter9: i32 =  simpleListArray9[tdata3].Counter;
          for (let mut index128: i32 =  0; index128 <= counter9; index128 += 1)
          {
            if (index128 == 0)
              str25 += "\r\n\r\nFUEL MODIFIERS:";
            let mut tdata5: i32 =  simpleListArray9[tdata3].Id[index128];
            tdata2_1 = simpleListArray9[tdata3].Weight[index128];
            let mut tweight: i32 =  simpleListArray9[tdata3].Data1[index128];
            tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
            str28: String = str25 + "\r\n";
            str29: String = "-";
            if (tdata2_1 > 0)
              str29 = "+" + tdata2_1.ToString() + "%";
            if (tdata2_1 < 0)
              str29 = tdata2_1.ToString() + "%";
            if (tdata2_1 == 0)
              str25 = str28 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
            else
              str25 = str28 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str29 + ".";
            simpleStringList2.Add(tid8, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
          }
        }
        let mut tdata1_9: i32 =  7;
        let mut tdata2_10: i32 =  num96;
        let mut tdata4_9: i32 =  num24;
        simpleStringList1.Add(tid8 + "#" + str25, 1, tdata1_9, tdata2_10, tdata3, tdata4_9);
        let mut num97: i32 =  num24 <= 0 ? 0 :  Math.Round( num94 /  num24);
        tid9: String = "Supply modifier on Hitpoints";
        str30: String = "Supply Consumption can impose a heavy negative modifier on the Hitpoints.\r\n";
        if (num24 > 0)
          str30 = str30 + "The Supply Consumption modifier is " + num97.ToString() + "%\r\n";
        let mut tdata1_10: i32 =  7;
        let mut tdata2_11: i32 =  num97;
        let mut tdata4_10: i32 =  num24;
        simpleStringList1.Add(tid9 + "#" + str30, 1, tdata1_10, tdata2_11, tdata3, tdata4_10);
        let mut index129: i32 =  8;
        do
        {
          bool flag1;
          if (!(this.game.TempCombat.CombatType == 3 | this.game.TempCombat.CombatType == 4))
          {
            flag1 = true;
            if (index129 == 10 | index129 == 11)
              flag1 = false;
          }
          else
            flag1 = true;
          if (index129 >= 24 & index129 <= 28)
            flag1 = false;
          if (index129 >= 18 & index129 <= 20)
            flag1 = false;
          if (flag1)
          {
            numArray1[index129] = numArray2[index129] <= 0 ? 0 :  Math.Round( numArray1[index129] /  numArray2[index129]);
            if (index129 == 8)
            {
              tid9 = "Posture modifier for Attack Values";
              str30 = "The Posture your Formation(s) are set to can significantly alter the performance. For good or for bad.";
            }
            if (index129 == 9)
            {
              tid9 = "Profile modifier for Attack Values";
              str30 = "Some Regime Feats give a direct Combat Bonus.";
            }
            if (index129 == 10)
            {
              tid9 = "Direct Fire LOS modifier for Attack Values";
              str30 = "This modifier is heavily impact by interrupted or semi-blocked line of sight and visibility by the Unit in question.";
            }
            if (index129 == 11)
            {
              tid9 = "Indirect Fire LOS Bonus modifier for Attack Values";
              str30 = "If you have good line of sight by any Unit on the target Indirect fire gets a bonus.";
            }
            if (index129 == 12)
            {
              tid9 = "Weather/Global modifier for Attack Values";
              str30 = "This modifier is based on Global or Weather settings and applies to everybody.";
            }
            if (index129 == 13)
            {
              tid9 = "Max Attacked (Attack saturation) modifier for Attack Values";
              str30 = "This modifier turns negative if you are committing to much firepower on a to little quantity of targets.";
            }
            if (index129 == 14)
            {
              tid9 = "HQ / Staff / Officer Bonus modifier for Attack Values";
              str30 = "Depends on four factors: HQ Power (distance), Staff : Troops ratio, Officer Staff Points : Staff ratio and Officer Rating.";
            }
            if (index129 == 15)
            {
              tid9 = "Special modifier for Attack Values";
              str30 = "This modifier is usual created by playing Card on Units or by Scripted events.";
            }
            if (index129 == 16)
            {
              tid9 = "Multi-Unit cooperation modifier for Attack Values";
              str30 = "When multiple subunits of the same unit are close to eachother this modifier is applied.";
            }
            if (index129 == 17)
            {
              tid9 = "AI Bonus modifier for Attack Values";
              str30 = "The AI can get a Bonus to provide more challenge to the player.";
            }
            if (index129 == 18)
            {
              tid9 = "Hidden modifier for Attack Values";
              str30 = "If a target is not visible to the enemy a big penalty is applied. Get Recon up to reduce this.";
            }
            if (index129 == 19)
            {
              tid9 = "Highground modifier for Attack Values";
              str30 = "Attacking up hill gives penalties, attacking downhill gives bonuses.";
            }
            if (index129 == 20)
            {
              tid9 = "Close combat modifier for Attack Values";
              str30 = "Some trooptypes are vulnerable to assault.";
            }
            if (index129 == 21)
            {
              tid9 = "Regular Overstack modifier for Attack Values";
              str30 = "This modifier is applied if you are attacking with more Stack Points than can tactically be optimally deployed.";
            }
            if (index129 == 22)
            {
              tid9 = "Artillery Overstack modifier for Attack Values";
              str30 = "If too many rounds are fired a saturation effect can appear. Check the Artillery Stack Points for this.";
            }
            if (index129 == 23)
            {
              tid9 = "Night Penalty modifier for Attack Values";
              str30 = "This modifier is applied during Night Turns.";
            }
            if (index129 == 29)
            {
              tid9 = "Leader Skill modifiers for Attack Values";
              str30 = "Your OHQ and SHQ Leaders can excert a positive influence on the performance of your Troops.";
            }
            if (index129 == 30)
            {
              tid9 = "Unit Feat modifiers for Attack Values";
              str30 = "Unit Feats can help your Troops in combat while embedding with them.";
            }
            if (index129 == 31)
            {
              tid9 = "Weapon Matrix modifier for Attack Values";
              str30 = "Some weapons are specially powerful or weak versus certain types of armour";
            }
            if (index129 == 32)
            {
              tid9 = "Callibre Matrix modifier for Attack Values";
              str30 = "Some armours require weapons to have a certain callibre to penetrate them well.";
            }
            let mut counter10: i32 =  simpleListArray10[index129, tdata3].Counter;
            for (let mut index130: i32 =  0; index130 <= counter10; index130 += 1)
            {
              let mut tdata5: i32 =  simpleListArray10[index129, tdata3].Id[index130];
              tdata2_1 = simpleListArray10[index129, tdata3].Weight[index130];
              let mut tweight: i32 =  simpleListArray10[index129, tdata3].Data1[index130];
              tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
              str31: String = str30 + "\r\n";
              str32: String = "-";
              if (tdata2_1 > 0)
                str32 = "+" + tdata2_1.ToString() + "%";
              if (tdata2_1 < 0)
                str32 = tdata2_1.ToString() + "%";
              if (tdata2_1 == 0)
                str30 = str31 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
              else
                str30 = str31 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str32 + ".";
              simpleStringList2.Add(tid9, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
            }
            let mut tdata1_11: i32 =  index129;
            let mut tdata2_12: i32 =  numArray1[index129];
            let mut tdata4_11: i32 =  numArray2[index129];
            bool flag2 = true;
            if (index129 == 22 & tdata4_11 == 0)
              flag2 = false;
            if (index129 == 10)
              tdata1_11 = 11;
            if (index129 == 11)
              tdata1_11 = 10;
            if ( this.game.Data.RuleVar[419] < 1.0 && index129 == 10 | index129 == 11)
              flag2 = false;
            if (flag2)
              simpleStringList1.Add(tid9 + "#" + str30, 1, tdata1_11, tdata2_12, tdata3, tdata4_11, CheckExistence: false);
          }
          index129 += 1;
        }
        while (index129 <= 32);
        let mut index131: i32 =  8;
        do
        {
          bool flag3 = true;
          if (-(flag3 ? 1 : 0) >= 9 & -(flag3 ? 1 : 0) <= 15)
            flag3 = false;
          if (index131 >= 22 & index131 <= 28)
            flag3 = false;
          if (flag3)
          {
            numArray3[index131] = numArray4[index131] <= 0 ? 0 :  Math.Round( numArray3[index131] /  numArray4[index131]);
            if (index131 == 8)
            {
              tid9 = "Posture modifier on Hitpoints";
              str30 = "The Posture your Formation(s) are set to can significantly alter the performance. For good or for bad.";
            }
            if (index131 == 9)
            {
              tid9 = "Profile modifier for Attack Values";
              str30 = "Some Regime Feats give a direct Combat Bonus.";
            }
            if (index131 == 16)
            {
              tid9 = "Multi-Unit cooperation modifier on Hitpoints";
              str30 = "When multiple subunits of the same unit are close to eachother this modifier is applied.";
            }
            if (index131 == 17)
            {
              tid9 = "AI Bonus modifier on Hitpoints";
              str30 = "The AI can get a Bonus to provide more challenge to the player.";
            }
            if (index131 == 18)
            {
              tid9 = "Hidden modifier on Hitpoints";
              str30 = "If a target is not visible to the enemy a big penalty is applied. Get Recon up to reduce this.";
            }
            if (index131 == 19)
            {
              tid9 = "Highground modifier on Hitpoints";
              str30 = "Attacking up hill gives penalties, attacking downhill gives bonuses.";
            }
            if (index131 == 20)
            {
              tid9 = "Close combat modifier on Hitpoints";
              str30 = "Some trooptypes are vulnerable to assault.";
            }
            if (index131 == 21)
            {
              tid9 = "Regular Overstack modifier on Hitpoints";
              str30 = "This modifier is applied if you are attacking with more Stack Points than can tactically be optimally deployed.";
            }
            if (index131 == 22)
            {
              tid9 = "Artillery Overstack modifier on Hitpoints";
              str30 = "If to many rounds are fired a saturation effect can appear. Check the Artillery Stack Points for this.";
            }
            if (index131 == 29)
            {
              tid9 = "Leader Skill modifiers on Hitpoints";
              str30 = "Your OHQ and SHQ Leaders can excert a positive influence on the performance of your Troops.";
            }
            if (index131 == 30)
            {
              tid9 = "Unit Feat modifiers on Hitpoints";
              str30 = "Unit Feats can help your Troops in combat while embedding with them.";
            }
            if (index131 == 31)
            {
              tid9 = "Weapon Matrix modifier on Hitpoints";
              str30 = "Some weapons are specially powerful or weak versus certain types of armour";
            }
            if (index131 == 32)
            {
              tid9 = "Callibre Matrix modifier on Hitpoints";
              str30 = "Some armours require weapons to have a certain callibre to penetrate them well.";
            }
            let mut counter11: i32 =  simpleListArray11[index131, tdata3].Counter;
            for (let mut index132: i32 =  0; index132 <= counter11; index132 += 1)
            {
              let mut tdata5: i32 =  simpleListArray11[index131, tdata3].Id[index132];
              tdata2_1 = simpleListArray11[index131, tdata3].Weight[index132];
              let mut tweight: i32 =  simpleListArray11[index131, tdata3].Data1[index132];
              tdata2_1 = tweight <= 0 ? 0 :  Math.Round( tdata2_1 /  tweight);
              str33: String = str30 + "\r\n";
              str34: String = "-";
              if (tdata2_1 > 0)
                str34 = "+" + tdata2_1.ToString() + "%";
              if (tdata2_1 < 0)
                str34 = tdata2_1.ToString() + "%";
              if (tdata2_1 == 0)
                str30 = str33 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " there is NO modifier.";
              else
                str30 = str33 + "For " + this.game.Data.SFTypeObj[tdata5].Name + " its " + str34 + ".";
              if (tdata2_1 < -200)
                tdata2_1 = tdata2_1;
              simpleStringList2.Add(tid9, tweight, -1, tdata2_1, tdata3, tdata5: tdata5, CheckExistence: false);
            }
            let mut tdata1_12: i32 =  index131;
            let mut tdata2_13: i32 =  numArray3[index131];
            let mut tdata4_12: i32 =  numArray4[index131];
            bool flag4 = true;
            if (index131 == 19 & tdata4_12 == 0)
              flag4 = false;
            if (index131 == 20 & tdata4_12 == 0)
              flag4 = false;
            if (flag4)
              simpleStringList1.Add(tid9 + "#" + str30, 1, tdata1_12, tdata2_13, tdata3, tdata4_12, CheckExistence: false);
          }
          index131 += 1;
        }
        while (index131 <= 32);
        tdata3 += 1;
      }
      while (tdata3 <= 1);
      float[] numArray117 = new float[2]{ 100f, 100f };
      let mut counter12: i32 =  simpleStringList1.Counter;
      for (let mut index133: i32 =  0; index133 <= counter12; index133 += 1)
      {
        simpleStringList1.Weight[index133] = simpleStringList1.Data1[index133];
        bool flag = false;
        let mut num98: i32 =  0;
        let mut num99: i32 =  0;
        let mut counter13: i32 =  simpleStringList2.Counter;
        for (let mut index134: i32 =  0; index134 <= counter13; index134 += 1)
        {
          if (simpleStringList1.Data3[index133] == simpleStringList2.Data3[index134] && Strings.InStr(simpleStringList1.Id[index133], simpleStringList2.Id[index134] + "#") > 0)
          {
            flag = true;
            num99 += simpleStringList2.Weight[index134];
            num98 += simpleStringList2.Weight[index134] * simpleStringList2.Data2[index134];
            index133 = index133;
          }
        }
        if (simpleStringList1.Data2[index133] != 0 & simpleStringList1.Data4[index133] > 0)
        {
          if (flag)
          {
            let mut num100: i32 =   Math.Round( num98 /  num99);
            if (num100 < -100)
              num100 = num100;
            numArray117[simpleStringList1.Data3[index133]] = numArray117[simpleStringList1.Data3[index133]] * ( (100 + num100) / 100f);
          }
          else
            numArray117[simpleStringList1.Data3[index133]] = numArray117[simpleStringList1.Data3[index133]] * ( (100 + simpleStringList1.Data2[index133]) / 100f);
        }
      }
      simpleStringList1.Sort();
      numArray117[0] = numArray117[0] - 100f;
      numArray117[1] = numArray117[1] - 100f;
      simpleStringList1.Add("Cumulative modifier#All the estimated modifiers multiplied with eachother.", 1, 24,  Math.Round( numArray117[0]), tdata4: 1, CheckExistence: false);
      simpleStringList1.Add("Cumulative modifier#All the estimated modifiers multiplied with eachother.", 1, 24,  Math.Round( numArray117[1]), 1, 1, CheckExistence: false);
      int[] numArray118 = new int[2]{ 0, 0 };
      let mut icounter1: i32 =  this.game.TempCombat.ICounter;
      for (let mut index135: i32 =  0; index135 <= icounter1; index135 += 1)
      {
        if (this.game.TempCombat.IList[index135].AttackCount > 0 | this.game.TempCombat.CombatType == 1 & this.game.Data.SFTypeObj[this.game.TempCombat.IList[index135].ISFType].Attacks > 0)
        {
          let mut iattacker: i32 =  this.game.TempCombat.IList[index135].IAttacker;
          let mut isfType: i32 =  this.game.TempCombat.IList[index135].ISFType;
          let mut attacks: i32 =  this.game.Data.SFTypeObj[isfType].Attacks;
          let mut d: i32 =  0;
          let mut num101: i32 =  0;
          if (iattacker == 1)
          {
            let mut index136: i32 =  0;
            do
            {
              if (this.game.Data.SFTypeObj[isfType].AttackPower[index136] > d)
                d = this.game.Data.SFTypeObj[isfType].AttackPower[index136];
              if (this.game.Data.SFTypeObj[isfType].HitPoints[index136] > num101)
                num101 = this.game.Data.SFTypeObj[isfType].HitPoints[index136];
              index136 += 1;
            }
            while (index136 <= 19);
          }
          else
          {
            let mut index137: i32 =  0;
            do
            {
              if (this.game.Data.SFTypeObj[isfType].AttackPowerDef[index137] > d)
                d = this.game.Data.SFTypeObj[isfType].AttackPowerDef[index137];
              if (this.game.Data.SFTypeObj[isfType].HitPointsDef[index137] > num101)
                num101 = this.game.Data.SFTypeObj[isfType].HitPointsDef[index137];
              index137 += 1;
            }
            while (index137 <= 19);
          }
          if (d < 1)
            d = 1;
          if (num101 < 1)
            num101 = 1;
          let mut num102: i32 =   Math.Round( attacks * Math.Sqrt( d) *  num101 / 100.0);
          int[] numArray119 = numArray118;
          int[] numArray120 = numArray119;
          let mut index138: i32 =  iattacker;
          let mut index139: i32 =  index138;
          let mut num103: i32 =  numArray119[index138] + num102;
          numArray120[index139] = num103;
        }
      }
      simpleStringList1.Add("Defensive Power#A rough estimate of the defensive value of the forces.", 1, 27, numArray118[0], tdata4: 1, CheckExistence: false);
      simpleStringList1.Add("Offensive Power#A rough estimate of the offensive value of the forces.", 1, 25, numArray118[1], 1, 1, CheckExistence: false);
      numArray118[0] =  Math.Round( ( numArray118[0] *  ((100.0 +  numArray117[0]) / 100.0)));
      numArray118[1] =  Math.Round( ( numArray118[1] *  ((100.0 +  numArray117[1]) / 100.0)));
      simpleStringList1.Add("Modified Defensive Power#A rough estimate of the defensive value of the forces modified with all the estimated modifiers.", 1, 28, numArray118[0], tdata4: 1, CheckExistence: false);
      simpleStringList1.Add("Modified Offensive Power#A rough estimate of the offensive value of the forces modified with all the estimated modifiers.", 1, 26, numArray118[1], 1, 1, CheckExistence: false);
      let mut ucounter: i32 =  this.game.TempCombat.UCounter;
      for (let mut index140: i32 =  0; index140 <= ucounter; index140 += 1)
      {
        let mut num104: i32 =  0;
        let mut num105: i32 =  0;
        let mut icounter2: i32 =  this.game.TempCombat.ICounter;
        for (let mut index141: i32 =  0; index141 <= icounter2; index141 += 1)
        {
          if (this.game.TempCombat.IList[index141].IUlistNr == index140 && this.game.Data.SFTypeObj[this.game.TempCombat.IList[index141].ISFType].ArtRange > 0)
          {
            num104 += 1;
            num105 =  Math.Round( ( num105 + this.game.TempCombat.IList[index141].ILisAmmoMod * 100f));
          }
        }
        if (num104 > 0)
        {
          let mut tweight: i32 =   Math.Round( num105 /  num104);
          simpleStringList1.Add("Ammo Modifier", tweight, -1, this.game.TempCombat.UList[index140].UNr, CheckExistence: false);
        }
      }
      this.game.TempCombat = (CombatClass) null;
      return simpleStringList1;
    }

    pub NeighboursExtra GetLisTraffic(x: i32, y: i32)
    {
      NeighboursExtra lisTraffic = NeighboursExtra::new();
      let mut num1: i32 =  this.game.Data.RegimeObj[this.game.Data.Turn].Trafic[0].Value[x, y];
      lisTraffic.data[0] = 0;
      lisTraffic.data[1] = 0;
      lisTraffic.data[2] = 0;
      lisTraffic.data[3] = 0;
      lisTraffic.data[4] = 0;
      lisTraffic.data[5] = 0;
      if (num1 <= 1000000)
        return lisTraffic;
      num1.ToString();
      lisTraffic.data[0] =  Math.Round(Conversion.Val(Strings.Mid(Conversions.ToString(num1), 2, 1)));
      lisTraffic.data[1] =  Math.Round(Conversion.Val(Strings.Mid(Conversions.ToString(num1), 3, 1)));
      lisTraffic.data[2] =  Math.Round(Conversion.Val(Strings.Mid(Conversions.ToString(num1), 4, 1)));
      lisTraffic.data[3] =  Math.Round(Conversion.Val(Strings.Mid(Conversions.ToString(num1), 5, 1)));
      lisTraffic.data[4] =  Math.Round(Conversion.Val(Strings.Mid(Conversions.ToString(num1), 6, 1)));
      lisTraffic.data[5] =  Math.Round(Conversion.Val(Strings.Mid(Conversions.ToString(num1), 7, 1)));
      let mut num2: i32 =   Math.Round(Conversion.Val(Strings.Mid(Conversions.ToString(num1), 1, 1)));
      if (num2 == 8)
      {
        lisTraffic.truck = false;
        lisTraffic.rail = false;
        lisTraffic.pull = false;
      }
      if (num2 == 2)
      {
        lisTraffic.truck = true;
        lisTraffic.rail = false;
        lisTraffic.pull = false;
      }
      if (num2 == 3)
      {
        lisTraffic.truck = false;
        lisTraffic.rail = true;
        lisTraffic.pull = false;
      }
      if (num2 == 4)
      {
        lisTraffic.truck = false;
        lisTraffic.rail = false;
        lisTraffic.pull = true;
      }
      if (num2 == 5)
      {
        lisTraffic.truck = true;
        lisTraffic.rail = true;
        lisTraffic.pull = false;
      }
      if (num2 == 6)
      {
        lisTraffic.truck = true;
        lisTraffic.rail = false;
        lisTraffic.pull = true;
      }
      if (num2 == 7)
      {
        lisTraffic.truck = false;
        lisTraffic.rail = true;
        lisTraffic.pull = true;
      }
      if (num2 == 1)
      {
        lisTraffic.truck = true;
        lisTraffic.rail = true;
        lisTraffic.pull = true;
      }
      return lisTraffic;
    }

    pub fn SetLisTraffic(x: i32, y: i32, NeighboursExtra neigh)
    {
      let mut num1: i32 =  1000000;
      let mut num2: i32 =  1;
      if (!neigh.truck & !neigh.rail & !neigh.pull)
        num2 = 8;
      if (neigh.truck & !neigh.rail & !neigh.pull)
        num2 = 2;
      if (!neigh.truck & neigh.rail & !neigh.pull)
        num2 = 3;
      if (!neigh.truck & !neigh.rail & neigh.pull)
        num2 = 4;
      if (neigh.truck & neigh.rail & !neigh.pull)
        num2 = 5;
      if (neigh.truck & !neigh.rail & neigh.pull)
        num2 = 6;
      if (!neigh.truck & neigh.rail & neigh.pull)
        num2 = 7;
      if (neigh.truck & neigh.rail & neigh.pull)
        num2 = 1;
      let mut num3: i32 =  num1 * num2 + 100000 * neigh.data[0] + 10000 * neigh.data[1] + 1000 * neigh.data[2] + 100 * neigh.data[3] + 10 * neigh.data[4] + 1 * neigh.data[5];
      this.game.Data.RegimeObj[this.game.Data.Turn].Trafic[0].Value[x, y] = num3;
    }

    pub fn Air_CheckSizeStatOf(let mut unr: i32 =  -1, let mut sfnr: i32 =  -1, let mut sftypeNr: i32 =  -1) -> i32
    {
      let mut num1: i32 =  0;
      if (unr > -1)
      {
        let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount;
        for (let mut index: i32 =  0; index <= sfCount; index += 1)
        {
          sfnr = this.game.Data.UnitObj[unr].SFList[index];
          sftypeNr = this.game.Data.SFObj[sfnr].Type;
          let mut num2: i32 =  this.game.Data.SFTypeObj[sftypeNr].SFTypeVar[22];
          if (num2 > num1)
            num1 = num2;
        }
      }
      else if (sfnr > -1)
      {
        sftypeNr = this.game.Data.SFObj[sfnr].Type;
        num1 = this.game.Data.SFTypeObj[sftypeNr].SFTypeVar[22];
      }
      else if (sftypeNr > -1)
        num1 = this.game.Data.SFTypeObj[sftypeNr].SFTypeVar[22];
      return num1;
    }

    pub fn Air_GetRandomizedRoundingDam(number: i32, damPercent: i32) -> i32
    {
      float num1 =  (number * damPercent) / 100f;
      let mut randomizedRoundingDam: i32 =   Math.Round(Math.Floor( (number * damPercent) / 100.0));
      float num2 = num1 -  randomizedRoundingDam;
      if ( ( DrawMod.RandyNumber.Next(0, 100) / 100f) <=  num2)
        randomizedRoundingDam += 1;
      return randomizedRoundingDam;
    }

    pub OrderResult Air_applyDamToUnit(unr: i32, damPercent: i32)
    {
      let mut num1: i32 =  0;
      for (let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount; sfCount >= 0; sfCount += -1)
      {
        let mut qty: i32 =  this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[sfCount]].Qty;
        num1 += qty;
      }
      for (let mut sfCount: i32 =  this.game.Data.UnitObj[unr].SFCount; sfCount >= 0; sfCount += -1)
      {
        let mut sf: i32 =  this.game.Data.UnitObj[unr].SFList[sfCount];
        let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
        let mut num2: i32 =  this.Air_GetRandomizedRoundingDam(qty, damPercent);
        if (num2 >= num1)
          num2 = num1 - 1;
        let mut num3: i32 =  qty - num2;
        num1 -= num2;
        if (num3 <= 0)
          this.game.Data.RemoveSF(sf);
        else
          this.game.Data.SFObj[sf].Qty = num3;
      }
      OrderResult unit;
      return unit;
    }

    pub fn Air_LogUpdateForAll(regnr: i32, prefix: String, suffix: String)
    {
      let mut stringListById1: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut stringListById2: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 535, 0, 0));
      let mut id: i32 =  this.game.Data.RegimeObj[this.game.Data.Turn].id;
      let mut length: i32 =  this.game.Data.StringListObj[stringListById1].Length;
      for (let mut index: i32 =  0; index <= length; index += 1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index, 0])) == id &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index, 9])) > -1)
        {
          let mut num1: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index, 5]));
          let mut num2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index, 6]));
          let mut num3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index, 6]));
          if (num2 > 0)
          {
            s2: String = prefix + num1.ToString() + suffix;
            s3: String = "";
            this.game.Data.StringListObj[stringListById2].AddRowWithData(id.ToString(), num3.ToString(), s2, s3);
          }
        }
      }
    }

    pub fn Air_getNextTurnAirPoints(regNr: i32, abNumber: i32) -> i32
    {
      let mut nextTurnAirPoints: i32 =  0;
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index1: i32 =  0; index1 <= unitCounter; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].Regime == regNr && this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].X > -1)
        {
          let mut historical: i32 =  this.game.Data.UnitObj[index1].Historical;
          if (historical > -1 && this.game.Data.HistoricalUnitObj[historical].GiveHisVarValue(55) > 0)
          {
            let mut toX: i32 =  this.game.Data.HistoricalUnitObj[historical].GiveHisVarValue(56);
            let mut toY: i32 =  this.game.Data.HistoricalUnitObj[historical].GiveHisVarValue(57);
            let mut airBridgeRowNr: i32 =  this.Air_getAirBridgeRowNr(this.game.Data.RegimeObj[regNr].id, this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, toX, toY);
            if (airBridgeRowNr > -1 &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airBridgeRowNr, 8])) == abNumber)
            {
              let mut sfCount: i32 =  this.game.Data.UnitObj[index1].SFCount;
              for (let mut index2: i32 =  0; index2 <= sfCount; index2 += 1)
              {
                let mut sf: i32 =  this.game.Data.UnitObj[index1].SFList[index2];
                let mut qty: i32 =  this.game.Data.SFObj[sf].Qty;
                let mut type: i32 =  this.game.Data.SFObj[sf].Type;
                if (this.game.Data.SFTypeObj[type].Theater == 2)
                  nextTurnAirPoints += this.game.Data.SFTypeObj[type].CarryCap * qty;
              }
            }
          }
        }
      }
      return nextTurnAirPoints;
    }

    pub fn Air_getAirBridgeRowNr(regId: i32, fromX: i32, fromY: i32, toX: i32, toY: i32) -> i32
    {
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
      for (let mut airBridgeRowNr: i32 =  0; airBridgeRowNr <= length; airBridgeRowNr += 1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airBridgeRowNr, 0])) == regId &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airBridgeRowNr, 9])) > -1)
        {
          let mut num1: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airBridgeRowNr, 1]));
          let mut num2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airBridgeRowNr, 2]));
          let mut num3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airBridgeRowNr, 3]));
          let mut num4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airBridgeRowNr, 4]));
          if (num1 == fromX & num2 == fromY && num3 == toX & num4 == toY)
            return airBridgeRowNr;
        }
      }
      return -1;
    }

    pub SimpleList Air_getListofAirBridgeRows(zoneId: i32)
    {
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut id: i32 =  this.game.Data.RegimeObj[this.game.Data.Turn].id;
      SimpleList listofAirBridgeRows = SimpleList::new();
      data: DataClass = this.game.Data;
      str: String = "Zones";
       local: String =  str;
      let mut libVar: i32 =  data.FindLibVar( local, "SE_Data");
      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
      for (let mut index1: i32 =  0; index1 <= length; index1 += 1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 0])) == id &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 9])) > -1)
        {
          let mut index2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 1]));
          let mut index3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 2]));
          let mut index4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 3]));
          let mut index5: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 4]));
          let mut tweight: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 5]));
          let mut tid: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 8]));
          if (this.game.Data.MapObj[0].HexObj[index2, index3].GetHexLibVarValue(libVar) == zoneId)
          {
            let mut nr: i32 =  listofAirBridgeRows.FindNr(tid);
            if (nr > -1)
              listofAirBridgeRows.Data1[nr] = 3;
            else
              listofAirBridgeRows.Add(tid, tweight, 1, CheckExistence: false);
          }
          if (this.game.Data.MapObj[0].HexObj[index4, index5].GetHexLibVarValue(libVar) == zoneId)
          {
            let mut nr: i32 =  listofAirBridgeRows.FindNr(tid);
            if (nr > -1)
              listofAirBridgeRows.Data1[nr] = 3;
            else
              listofAirBridgeRows.Add(tid, tweight, 2, CheckExistence: false);
          }
        }
      }
      return listofAirBridgeRows;
    }

    pub Air_removeLisFromAirBridge: bool(fromX: i32, fromY: i32, toX: i32, toY: i32, lisRemove: i32)
    {
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut id: i32 =  this.game.Data.RegimeObj[this.game.Data.Turn].id;
      let mut num1: i32 =  0;
      if (lisRemove >= 1)
      {
        bool flag = false;
        SimpleList simpleList = SimpleList::new();
        let mut length1: i32 =  this.game.Data.StringListObj[stringListById].Length;
        for (let mut tid: i32 =  0; tid <= length1; tid += 1)
        {
          if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 0])) == id)
          {
            if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 1])) == fromX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 2])) == fromY &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 3])) == toX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 4])) == toY)
            {
              let mut num2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 5]));
              if (num2 > 0)
              {
                num1 += num2;
                simpleList.Add(tid, 1);
              }
            }
            if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 1])) == toX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 2])) == toY &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 3])) == fromX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 4])) == fromY)
            {
              let mut num3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 5]));
              if (num3 > 0)
              {
                num1 += num3;
                simpleList.Add(tid, 1);
              }
            }
          }
        }
        if (num1 >= 1)
        {
          float num4 =  lisRemove /  num1;
          let mut length2: i32 =  this.game.Data.StringListObj[stringListById].Length;
          for (let mut index: i32 =  0; index <= length2; index += 1)
          {
            if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 0])) == id &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 1])) == fromX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 2])) == fromY &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 3])) == toX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 4])) == toY)
            {
              let mut num5: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 5]));
              if (num5 > 0)
              {
                let mut num6: i32 =   Math.Round( num5 - Math.Ceiling( num5 *  num4));
                if (num6 < 1)
                {
                  num6 = 0;
                  flag = true;
                }
                this.game.Data.StringListObj[stringListById].Data[index, 5] = num6.ToString();
              }
            }
          }
          return flag;
        }
      }
      bool flag1;
      return flag1;
    }

    pub object Air_getLisFromAirBridge(fromX: i32, fromY: i32, toX: i32, toY: i32)
    {
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut id: i32 =  this.game.Data.RegimeObj[this.game.Data.Turn].id;
      let mut lisFromAirBridge: i32 =  0;
      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
      for (let mut index: i32 =  0; index <= length; index += 1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 0])) == id)
        {
          if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 1])) == fromX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 2])) == fromY &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 3])) == toX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 4])) == toY)
          {
            let mut num: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 5]));
            if (num > 0)
              lisFromAirBridge += num;
          }
          if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 1])) == toX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 2])) == toY &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 3])) == fromX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 4])) == fromY)
          {
            let mut num: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 5]));
            if (num > 0)
              lisFromAirBridge += num;
          }
        }
      }
      return  lisFromAirBridge;
    }

    pub fn Air_GetDamForAirBridge(fromX: i32, fromY: i32, toX: i32, toY: i32) -> i32
    {
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut id: i32 =  this.game.Data.RegimeObj[this.game.Data.Turn].id;
      let mut num1: i32 =  0;
      let mut num2: i32 =  0;
      SimpleList simpleList = SimpleList::new();
      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
      for (let mut tid: i32 =  0; tid <= length; tid += 1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 0])) == id)
        {
          if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 1])) == fromX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 2])) == fromY &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 3])) == toX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 4])) == toY)
          {
            let mut num3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 5]));
            if (num3 > 0)
            {
              num1 += num3;
              let mut num4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 7]));
              num2 += num4 * num3;
              simpleList.Add(tid, 1);
            }
          }
          if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 1])) == toX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 2])) == toY &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 3])) == fromX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 4])) == fromY)
          {
            let mut num5: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 5]));
            if (num5 > 0)
            {
              num1 += num5;
              let mut num6: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 7]));
              num2 += num6 * num5;
              simpleList.Add(tid, 1);
            }
          }
        }
      }
      if (num1 < 1)
      {
        damForAirBridge: i32;
        return damForAirBridge;
      }
      let mut damForAirBridge1: i32 =   Math.Round(Math.Ceiling( num2 /  num1));
      if (damForAirBridge1 > 100)
        damForAirBridge1 = 100;
      if (damForAirBridge1 < 0)
        damForAirBridge1 = 0;
      return damForAirBridge1;
    }

    pub fn ClearTempLisJumps()
    {
      let mut mapWidth: i32 =  this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 =  0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 =  this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 =  0; index2 <= mapHeight; index2 += 1)
          this.game.Data.MapObj[0].HexObj[index1, index2].tempLISjumps = (SimpleList) null;
      }
    }

    pub fn SetTempLisJumps(regNr: i32, sizeOfContent: i32)
    {
      this.ClearTempLisJumps();
      if (!this.game.EventRelatedObj.Helper_AirEnabled() || regNr < 0 || regNr > this.game.Data.RegimeCounter)
        return;
      let mut id: i32 =  this.game.Data.RegimeObj[regNr].id;
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(DrawMod.TGame.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
      for (let mut tid: i32 =  0; tid <= length; tid += 1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 0])) == id &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 9])) == 1 &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 10])) >= sizeOfContent)
        {
          let mut index1: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 1]));
          let mut index2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 2]));
          let mut index3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 3]));
          let mut index4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 4]));
          if (Information.IsNothing( this.game.Data.MapObj[0].HexObj[index1, index2].tempLISjumps))
            this.game.Data.MapObj[0].HexObj[index1, index2].tempLISjumps = SimpleList::new();
          if (Information.IsNothing( this.game.Data.MapObj[0].HexObj[index3, index4].tempLISjumps))
            this.game.Data.MapObj[0].HexObj[index3, index4].tempLISjumps = SimpleList::new();
          this.game.Data.MapObj[0].HexObj[index1, index2].tempLISjumps.Add(tid, 1);
          this.game.Data.MapObj[0].HexObj[index3, index4].tempLISjumps.Add(tid, 1);
        }
      }
    }

    pub fn SetCycleOrder(unr: i32) -> i32
    {
      long num = 0;
      let mut shq: i32 =  this.game.EventRelatedObj.GetSHQ(unr);
      let mut ohq: i32 =  this.game.EventRelatedObj.GetOHQ(unr);
      id: i32;
      if (this.game.Data.UnitObj[unr].Historical > -1)
        id = this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].ID;
      if (shq > -1)
        num += (long) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[shq].Historical].ID * 100000000L;
      if (ohq > -1)
        num += (long) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[ohq].Historical].ID * 5000000L;
      if (id > -1 & ohq != id)
        num += (long) id;
      this.game.Data.UnitObj[unr].cycleOrder = num;
      if (num < 1L)
        num = num;
      return  num;
    }

    pub fn NextCycleUnit(unr: i32, bool nextMode) -> i32
    {
      long num1 = 999999999999999;
      let mut num2: i32 =  -1;
      long num3 = 0;
      let mut num4: i32 =  -1;
      long num5 = 0;
      if (unr > -1 && this.game.Data.UnitObj[unr].cycleOrder < -1L)
        num5 = -1L;
      long num6;
      if (unr > -1)
        num6 = Math.Abs(this.game.Data.UnitObj[unr].cycleOrder);
      long num7 = 999999999999999;
      let mut num8: i32 =  -1;
      long num9 = 999999999999999;
      let mut num10: i32 =  -1;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut unr1: i32 =  0; unr1 <= unitCounter; unr1 += 1)
      {
        if (this.game.Data.UnitObj[unr1].Regime == this.game.Data.Turn && this.game.Data.UnitObj[unr1].PreDef == -1 && this.game.Data.UnitObj[unr1].Historical > -1)
        {
          if (this.game.Data.UnitObj[unr1].cycleOrder == 0L)
            this.SetCycleOrder(unr1);
          if (this.game.Data.UnitObj[unr1].cycleOrder > 0L && !this.game.Data.UnitObj[unr1].DidAttack & !this.game.Data.UnitObj[unr1].DidMove & !this.game.Data.UnitObj[unr1].DidHQ && this.GetLowestAp(unr1) > 0)
          {
            long cycleOrder = this.game.Data.UnitObj[unr1].cycleOrder;
            if (cycleOrder < num1)
            {
              num1 = cycleOrder;
              num2 = unr1;
            }
            if (cycleOrder > num3)
            {
              num3 = cycleOrder;
              num4 = unr1;
            }
            if (cycleOrder > num6)
            {
              long num11 = cycleOrder - num6;
              if (num11 < num7)
              {
                num7 = num11;
                num8 = unr1;
              }
            }
            else if (cycleOrder < num6)
            {
              long num12 = num6 - cycleOrder;
              if (num12 < num9)
              {
                num9 = num12;
                num10 = unr1;
              }
            }
          }
        }
      }
      if (num6 <= 0L)
        return num2;
      return nextMode ? (num8 > -1 ? num8 : num2) : (num10 > -1 ? num10 : num4);
    }

    pub GetLandscapeMouseOverText: String()
    {
      let mut landscapeType: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].LandscapeType;
      let mut location: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].Location;
      str1: String = "";
      Left1: String = "";
      Left2: String = "";
      SimpleList simpleList1 = SimpleList::new();
      SimpleList simpleList2 = SimpleList::new();
      let mut roadTypeCounter: i32 =  this.game.Data.RoadTypeCounter;
      for (let mut index1: i32 =  0; index1 <= roadTypeCounter; index1 += 1)
      {
        str2: String = "";
        let mut index2: i32 =  0;
        do
        {
          if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].RoadType[index2] == index1)
          {
            if (str2.Length > 0)
              str2 += ",";
            if (index2 == 0)
              str2 += "N";
            if (index2 == 1)
              str2 += "NE";
            if (index2 == 2)
              str2 += "SE";
            if (index2 == 3)
              str2 += "S";
            if (index2 == 4)
              str2 += "SW";
            if (index2 == 5)
              str2 += "NW";
          }
          index2 += 1;
        }
        while (index2 <= 5);
        let mut index3: i32 =  0;
        do
        {
          if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].RoadType[index3] == index1)
          {
            if (Left1.Length > 0)
              Left1 += ", ";
            if (Operators.CompareString(Left1, "", false) == 0)
              Left1 = "Roads present: ";
            Left1 += this.game.Data.RoadTypeObj[index1].Name;
            if (str2.Length > 0)
              Left1 = Left1 + "(" + str2 + ")";
            simpleList1.Add(index1, 0, index1);
            index3 = 999;
          }
          index3 += 1;
        }
        while (index3 <= 5);
      }
      let mut riverTypeCounter: i32 =  this.game.Data.RiverTypeCounter;
      for (let mut index4: i32 =  0; index4 <= riverTypeCounter; index4 += 1)
      {
        str3: String = "";
        let mut index5: i32 =  0;
        do
        {
          if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].RiverType[index5] == index4)
          {
            if (str3.Length > 0)
              str3 += ",";
            if (index5 == 0)
              str3 += "N";
            if (index5 == 1)
              str3 += "NE";
            if (index5 == 2)
              str3 += "SE";
            if (index5 == 3)
              str3 += "S";
            if (index5 == 4)
              str3 += "SW";
            if (index5 == 5)
              str3 += "NW";
          }
          index5 += 1;
        }
        while (index5 <= 5);
        if ( this.game.Data.RiverTypeObj[index4].BridgeCostModifier >= 0.0)
        {
          let mut index6: i32 =  0;
          do
          {
            if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].RiverType[index6] == index4)
            {
              if (Left2.Length > 0)
                Left2 += ", ";
              if (Operators.CompareString(Left2, "", false) == 0)
                Left2 = "Rivers present: ";
              Left2 += this.game.Data.RiverTypeObj[index4].Name;
              if (str3.Length > 0)
                Left2 = Left2 + "(" + str3 + ")";
              simpleList2.Add(index4, 0, index4);
              index6 = 999;
            }
            index6 += 1;
          }
          while (index6 <= 5);
        }
      }
      str4: String = "";
      let mut index7: i32 =  0;
      do
      {
        if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Bridge[index7])
        {
          if (str4.Length > 0)
            str4 += ",";
          if (index7 == 0)
            str4 += "N";
          if (index7 == 1)
            str4 += "NE";
          if (index7 == 2)
            str4 += "SE";
          if (index7 == 3)
            str4 += "S";
          if (index7 == 4)
            str4 += "SW";
          if (index7 == 5)
            str4 += "NW";
        }
        index7 += 1;
      }
      while (index7 <= 5);
      if (str4.Length > 0)
        Left2 = Left2 + "\r\nBRIDGES PRESENT: " + str4;
      if (Left2.Length > 0)
      {
        if (Left1.Length > 0)
          Left1 += "\r\n";
        Left1 += Left2;
      }
      if (Left1.Length > 0 & this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location > -1)
        Left1 = Left1 + "\r\n" + "Location present: " + this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location].Type].Name + "(VP=" + this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].VP.ToString() + ")";
      if (Left1.Length > 0)
        str1 = str1 + Left1 + "\r\n" + "Recon Points: " + this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].MaxRecon.ToString() + "\r\n" + "Minimum recon for unit info: " + ( Math.Round( this.game.Data.RuleVar[55])).ToString() + "\r\n" + "Minimum recon for full unit info " + ( Math.Round( this.game.Data.RuleVar[56])).ToString() + "\r\n" + "\r\n";
      bool[] flagArray = new bool[100];
      int[] numArray = new int[100];
      let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
      for (let mut index8: i32 =  0; index8 <= sfTypeCounter; index8 += 1)
      {
        if (this.game.Data.SFTypeObj[index8].MoveType > -1 && !this.game.Data.SFTypeObj[index8].DontShowInList & this.game.Data.SFTypeObj[index8].Name.Length > 1 & Strings.InStr(Strings.LCase(this.game.Data.SFTypeObj[index8].Name), Strings.LCase("N/A")) <= 0)
        {
          flagArray[this.game.Data.SFTypeObj[index8].MoveType] = true;
          if (this.game.Data.SFTypeObj[index8].UnitGroup > -1 & numArray[this.game.Data.SFTypeObj[index8].UnitGroup] == 0)
            numArray[this.game.Data.SFTypeObj[index8].UnitGroup] = index8;
        }
      }
      str5: String = str1 + "Landscape: " + this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].LandscapeType].Name + "\r\n\r\n" + "TROOPTYPE" + Strings.Space(14) + "ATT-MOD" + Strings.Space(3) + "DEF-MOD" + Strings.Space(3) + "A-ENTR" + Strings.Space(4) + "MX-ENTR" + Strings.Space(3) + "CROSS-RIV\r\n";
      let mut index9: i32 =  0;
      do
      {
        if (Information.IsNothing( this.game.Data.TempString[index9 + 400]))
          this.game.Data.TempString[index9 + 400] = "";
        if (this.game.Data.TempString[index9 + 400].Length > 1 & numArray[index9] > 0)
        {
          str6: String = this.game.Data.TempString[index9 + 400];
          if (str6.Length > 21)
            str6 = Strings.Left(str6, 21);
          str7: String = str5 + str6 + Strings.Space(23 - str6.Length);
          let mut index10: i32 =  numArray[index9];
          let mut Number1: i32 =   Math.Round( (this.game.Data.SFTypeObj[index10].CombatModAtt[landscapeType] * 100f)) - 100;
          if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location > -1)
          {
            let mut pictureLt: i32 =  this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location].Type].PictureLT;
            if (pictureLt > -1)
              Number1 =  Math.Round( ( Number1 * this.game.Data.SFTypeObj[index10].CombatModAtt[pictureLt]));
          }
          str8: String = Strings.Trim(Conversion.Str( Number1)) + "%";
          if (Number1 > 0)
            str8 = "+" + str8;
          if (str8.Length > 6)
            str8 = Strings.Left(str8, 6);
          str9: String = str7 + str8 + Strings.Space(10 - str8.Length);
          let mut Number2: i32 =   Math.Round( (this.game.Data.SFTypeObj[index10].CombatModDef[landscapeType] * 100f)) - 100;
          if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location > -1)
          {
            let mut pictureLt: i32 =  this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location].Type].PictureLT;
            if (pictureLt > -1)
              Number2 =  Math.Round( ( Number2 * this.game.Data.SFTypeObj[index10].CombatModDef[pictureLt]));
          }
          str10: String = Strings.Trim(Conversion.Str( Number2)) + "%";
          if (Number2 > 0)
            str10 = "+" + str10;
          if (str10.Length > 6)
            str10 = Strings.Left(str10, 6);
          str11: String = str9 + str10 + Strings.Space(10 - str10.Length);
          let mut Number3: i32 =   Math.Round( this.game.Data.LandscapeTypeObj[landscapeType].DefBonus[index9]);
          if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location > -1)
          {
            let mut pictureLt: i32 =  this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location].Type].PictureLT;
            if (pictureLt > -1)
              Number3 =  Math.Round( ( Number3 + this.game.Data.LandscapeTypeObj[pictureLt].DefBonus[index9]));
          }
          str12: String = Strings.Trim(Conversion.Str( Number3));
          if (str12.Length > 6)
            str12 = Strings.Left(str12, 6);
          str13: String = str11 + str12 + Strings.Space(10 - str12.Length);
          let mut Number4: i32 =   Math.Round( this.game.Data.LandscapeTypeObj[landscapeType].DefBonusMax[index9]);
          if (this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location > -1)
          {
            let mut pictureLt: i32 =  this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].Location].Type].PictureLT;
            if (pictureLt > -1)
              Number4 =  Math.Round( ( Number4 + this.game.Data.LandscapeTypeObj[pictureLt].DefBonusMax[index9]));
          }
          str14: String = Strings.Trim(Conversion.Str( Number4));
          if (str14.Length > 6)
            str14 = Strings.Left(str14, 6);
          str15: String = str13 + str14 + Strings.Space(10 - str14.Length);
          str16: String = "";
          let mut counter: i32 =  simpleList2.Counter;
          for (let mut index11: i32 =  0; index11 <= counter; index11 += 1)
          {
            str17: String = "-" + Strings.Trim(Conversion.Str(  Math.Round( (this.game.Data.RiverTypeObj[simpleList2.Data1[index11]].AttackPenalty[index9] * 100f)))) + "%";
            if (Operators.CompareString(str16, "", false) != 0)
              str16 += "/";
            str16 += str17;
          }
          if (simpleList2.Counter == -1)
            str16 += "-";
          if (str16.Length > 22)
            str16 = Strings.Left(str16, 22);
          str5 = str15 + str16 + "\r\n";
        }
        index9 += 1;
      }
      while (index9 <= 99);
      Left3: String = str5 + "\r\n" + "MOVETYPE" + Strings.Space(15) + "AP COST" + Strings.Space(3) + "ROAD" + Strings.Space(16) + "RIVER\r\n";
      flagArray[9] = true;
      flagArray[10] = true;
      flagArray[11] = true;
      flagArray[12] = true;
      let mut index12: i32 =  0;
      do
      {
        if (this.game.Data.TempString[index12].Length > 1 & flagArray[index12])
        {
          str18: String = this.game.Data.TempString[index12];
          if (str18.Length > 21)
            str18 = Strings.Left(str18, 21);
          str19: String = Left3 + str18 + Strings.Space(23 - str18.Length);
          str20: String = Strings.Trim(Conversion.Str( this.game.Data.LandscapeTypeObj[landscapeType].MoveCost[index12]));
          if (this.game.Data.LandscapeTypeObj[landscapeType].MoveCost[index12] >= 999)
            str20 = "NA";
          if (str20.Length > 6)
            str20 = Strings.Left(str20, 6);
          str21: String = str19 + str20 + Strings.Space(10 - str20.Length);
          str22: String = "";
          let mut counter1: i32 =  simpleList1.Counter;
          for (let mut index13: i32 =  0; index13 <= counter1; index13 += 1)
          {
            let mut index14: i32 =  simpleList1.Data1[index13];
            str23: String = Strings.Trim(Conversion.Str( this.game.Data.RoadTypeObj[index14].MoveCostOverrule[index12]));
            if (this.game.Data.RoadTypeObj[index14].MoveCostOverrule[index12] >= 999)
              str23 = "NA";
            if (Operators.CompareString(str22, "", false) != 0)
              str22 += "/";
            str22 += str23;
          }
          if (simpleList1.Counter == -1)
            str22 += "-";
          if (str22.Length > 19)
            str22 = Strings.Left(str22, 18);
          str24: String = str21 + str22 + Strings.Space(20 - str22.Length);
          str25: String = "";
          let mut counter2: i32 =  simpleList2.Counter;
          for (let mut index15: i32 =  0; index15 <= counter2; index15 += 1)
          {
            let mut index16: i32 =  simpleList2.Data1[index15];
            str26: String = "+" + Strings.Trim(Conversion.Str( this.game.Data.RiverTypeObj[index16].MovePenalty[index12]));
            if (this.game.Data.RiverTypeObj[index16].MovePenalty[index12] >= 999)
              str26 = "NA";
            if (Operators.CompareString(str25, "", false) != 0)
              str25 += "/";
            str25 += str26;
          }
          if (simpleList2.Counter == -1)
            str25 += "-";
          if (str25.Length > 22)
            str25 = Strings.Left(str25, 22);
          Left3 = str24 + str25 + "\r\n";
        }
        index12 += 1;
      }
      while (index12 <= 99);
      let mut Number5: i32 =  this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].get_BattleStack(this.game.EditObj.RealTurn);
      if (Number5 > 0)
      {
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "regular battlestack = " + Strings.Trim(Conversion.Str( Number5));
      }
      let mut Number6: i32 =  this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].get_BattleStackArt(this.game.EditObj.RealTurn);
      if (Number6 > 0)
      {
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "artillery battlestack = " + Strings.Trim(Conversion.Str( Number6));
      }
      let mut Number7: i32 =  this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].get_BattleStackAir(this.game.EditObj.RealTurn);
      if (Number7 > 0)
      {
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "air battlestack = " + Strings.Trim(Conversion.Str( Number7));
      }
      let mut Number8: i32 =  this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].get_BattlePenalty(this.game.EditObj.RealTurn);
      if (Number8 > 0)
      {
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "battle penalty in AP = " + Strings.Trim(Conversion.Str( Number8));
      }
      let mut num1: i32 =  0;
      let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
      for (let mut index17: i32 =  0; index17 <= regimeCounter; index17 += 1)
      {
        let mut num2: i32 =  0;
        if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.EditObj.RealTurn, index17) && this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].get_ZocPts(index17) > 0 && this.game.HandyFunctionsObj.VisibleEnemyUnitsInOrAroundHEx(this.game.SelectX, this.game.SelectY, 0, this.game.EditObj.RealTurn))
          num2 =  Math.Round( ( num2 + this.game.Data.RuleVar[323]));
        if (num2 > num1)
          num1 = num2;
      }
      let mut Number9: i32 =  num1;
      if (Number9 > 0)
      {
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "ZOC penalty in AP = " + Strings.Trim(Conversion.Str( Number9));
      }
      let mut Number10: i32 =  this.game.Data.MapObj[0].HexObj[this.game.SelectX, this.game.SelectY].get_APPenalty(this.game.EditObj.RealTurn);
      if (Number10 > 0)
      {
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "enemy terrain penalty in AP = " + Strings.Trim(Conversion.Str( Number10));
      }
      if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_SupplyLost(this.game.EditObj.RealTurn) > 0)
      {
        let mut Number11: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_SupplyLost(this.game.EditObj.RealTurn);
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "Supply lost in hex = " + Strings.Trim(Conversion.Str( Number11));
      }
      if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_PowerPointsLost(this.game.EditObj.RealTurn) > 0)
      {
        let mut Number12: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_PowerPointsLost(this.game.EditObj.RealTurn);
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "Power points lost in hex = " + Strings.Trim(Conversion.Str( Number12));
      }
      if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_SupplyKilled(this.game.EditObj.RealTurn) > 0)
      {
        let mut Number13: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_SupplyKilled(this.game.EditObj.RealTurn);
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "Supply points destroyed by you = " + Strings.Trim(Conversion.Str( Number13));
      }
      if (this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_PowerPointsKilled(this.game.EditObj.RealTurn) > 0)
      {
        let mut Number14: i32 =  this.game.Data.MapObj[this.game.EditObj.MapSelected].HexObj[this.game.SelectX, this.game.SelectY].get_PowerPointsKilled(this.game.EditObj.RealTurn);
        if (Operators.CompareString(Left3, "", false) != 0)
          Left3 += "\r\n";
        Left3 = Left3 + "Power points destroyed by you = " + Strings.Trim(Conversion.Str( Number14));
      }
      return Left3;
    }

    pub LIS_AutoReinforceRulesValid: bool(unr: i32)
    {
      if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[DrawMod.TGame.HandyFunctionsObj.GetStringListByID(DrawMod.TGame.EventRelatedObj.CheckStringlistID("SE_Data", 143, 0, 0))].GetData(0, this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].id, 1))) == 1)
        return true;
      let mut historical: i32 =  this.game.Data.UnitObj[unr].Historical;
      return historical <= -1 || this.game.Data.HistoricalUnitObj[historical].GiveHisVarValue(11) <= 0;
    }

    pub CustomMouseOverLookups: String(texty: String, currentName: String)
    {
      bool flag = true;
      while (flag)
      {
        let mut num1: i32 =  0;
        flag = false;
        Start1: i32;
        if (num1 == 0)
        {
          Start1 = Strings.InStr(1, texty, "<PROFILEREGIMEFEATS.");
          if (Start1 > 0)
            num1 = 1;
        }
        if (num1 == 0)
        {
          Start1 = Strings.InStr(1, texty, "<PROFILESTRATAGEMS.");
          if (Start1 > 0)
            num1 = 2;
        }
        if (num1 == 0)
        {
          Start1 = Strings.InStr(1, texty, "<PROFILESURPRESSION.");
          if (Start1 > 0)
            num1 = 3;
        }
        if (num1 == 0)
        {
          Start1 = Strings.InStr(1, texty, "<REGIMEFEATSETUP.");
          if (Start1 > 0)
            num1 = 4;
        }
        if (num1 == 0)
        {
          Start1 = Strings.InStr(1, texty, "<REGIMEFEATTURN.");
          if (Start1 > 0)
            num1 = 5;
        }
        if (num1 == 0)
        {
          Start1 = Strings.InStr(1, texty, "<REGIMEFEATUNITFEATS.");
          if (Start1 > 0)
            num1 = 6;
        }
        oldValue1: String;
        newValue: String;
        if (num1 > 0)
        {
          let mut Start2: i32 =  Strings.InStr(Start1, texty, ".");
          let mut num2: i32 =  Strings.InStr(Start2, texty, ">");
          str1: String = Strings.Mid(texty, Start2 + 1, num2 - Start2 - 1);
          oldValue1 = Strings.Mid(texty, Start1, num2 - Start1 + 1);
          newValue = "";
          if (Operators.CompareString(str1, "current", false) == 0)
            str1 = currentName.ToLower();
          let mut Start3: i32 =  Strings.InStr(str1, "{", CompareMethod.Text);
          if (Start3 >= 1)
          {
            let mut num3: i32 =  Strings.InStr(str1, "}", CompareMethod.Text);
            oldValue2: String = Strings.Mid(str1, Start3, num3 - Start3 + 1);
            str1 = str1.Replace(oldValue2, "");
          }
          if (num1 == 1)
          {
            let mut stringListById1: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 387, 0, 0));
            let mut stringListById2: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 277, 0, 0));
            let mut stringListById3: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 402, 0, 0));
            let mut stringListById4: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 390, 0, 0));
            Left: String = "";
            let mut length1: i32 =  this.game.Data.StringListObj[stringListById1].Length;
            for (let mut index1: i32 =  0; index1 <= length1; index1 += 1)
            {
              if (Operators.CompareString(this.game.Data.StringListObj[stringListById1].Data[index1, 5].ToLower(), str1, false) == 0)
              {
                str2: String = this.game.Data.StringListObj[stringListById1].Data[index1, 3];
                let mut num4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index1, 0]));
                let mut num5: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index1, 20]));
                let mut num6: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index1, 21]));
                let mut num7: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].Data[index1, 23]));
                if (num5 < 1)
                  Left = Left + "• " + str2 + "\r\n";
                else
                  Left = Left + "• " + str2 + " (Gain at " + str1 + " " + num5.ToString() + " and " + num7.ToString() + " turns the highest)\r\n";
                let mut length2: i32 =  this.game.Data.StringListObj[stringListById4].Length;
                for (let mut index2: i32 =  0; index2 <= length2; index2 += 1)
                {
                  let mut num8: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById4].Data[index2, 0]));
                  if (num4 == num8)
                  {
                    str3: String = this.game.Data.StringListObj[stringListById4].Data[index2, 5];
                    if (str3.Length > 1)
                      Left = Left + "\t• " + str3 + "\r\n";
                  }
                }
                let mut length3: i32 =  this.game.Data.StringListObj[stringListById2].Length;
                for (let mut index3: i32 =  0; index3 <= length3; index3 += 1)
                {
                  if (Strings.InStr(this.game.Data.StringListObj[stringListById2].Data[index3, 6], "REGIMEFEAT." + num4.ToString()) > 0)
                    Left = Left + "\t• Stratagem: " + this.game.Data.StringListObj[stringListById2].Data[index3, 1] + "\r\n";
                }
                let mut length4: i32 =  this.game.Data.StringListObj[stringListById3].Length;
                for (let mut index4: i32 =  0; index4 <= length4; index4 += 1)
                {
                  if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById3].Data[index4, 1])) == num4)
                    Left = Left + "\t• Unit Feat: " + this.game.Data.StringListObj[stringListById3].Data[index4, 2] + "\r\n";
                }
              }
            }
            if (Operators.CompareString(Left, "", false) == 0)
              Left = "• None\r\n";
            newValue = Left;
          }
          if (num1 == 2)
          {
            let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 277, 0, 0));
            SimpleList simpleList1 = SimpleList::new();
            SimpleList simpleList2 = SimpleList::new();
            let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
            for (let mut tid: i32 =  0; tid <= length; tid += 1)
            {
              lower1: String = this.game.Data.StringListObj[stringListById].Data[tid, 6].ToLower();
              str4: String = this.game.Data.StringListObj[stringListById].Data[tid, 10];
              let mut num9: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[tid, 11]));
              lower2: String = str1.ToLower();
              if (Strings.InStr(lower1, lower2) > 0)
              {
                strArray: Vec<String> = lower1.Replace(">=", ">").Split('>', ';');
                let mut upperBound: i32 =  strArray.GetUpperBound(0);
                for (let mut index: i32 =  0; index <= upperBound; index += 1)
                {
                  if (Strings.InStr(strArray[index], lower2) > 0)
                  {
                    let mut tweight: i32 =   Math.Round(Conversion.Val(strArray[index + 1]));
                    let mut tdata1: i32 =  0;
                    num10: i32;
                    if (num10 >= tweight)
                      tdata1 = 1;
                    simpleList1.Add(tid, tweight, tdata1);
                  }
                }
              }
              if (num9 == 11 && Operators.CompareString(str4.ToLower(), lower2, false) == 0)
                simpleList2.Add(tid, 1);
            }
            simpleList1.Sort();
            Left: String = "";
            let mut counter1: i32 =  simpleList1.Counter;
            for (let mut index: i32 =  0; index <= counter1; index += 1)
            {
              let mut num11: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[simpleList1.Id[index], 5]));
              Left = Left + "• At profile score " + simpleList1.Weight[index].ToString() + " unlock of '" + this.game.Data.StringListObj[stringListById].Data[simpleList1.Id[index], 1].ToUpper() + "'.\r\n";
            }
            let mut counter2: i32 =  simpleList2.Counter;
            for (let mut index: i32 =  0; index <= counter2; index += 1)
              Left = Left + "• Happy Factions supporting this Profile give '" + this.game.Data.StringListObj[stringListById].Data[simpleList2.Id[index], 1].ToUpper() + "'.\r\n";
            if (Operators.CompareString(Left, "", false) == 0)
              Left = "• None\r\n";
            newValue = Left;
          }
          if (num1 == 3)
          {
            let mut stringListById: i32 =  DrawMod.TGame.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 256, 0, 0));
            str5: String = "";
            str6: String = "";
            let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
            for (let mut index: i32 =  0; index <= length; index += 1)
            {
              str7: String = this.game.Data.StringListObj[stringListById].Data[index, 0];
              str8: String = this.game.Data.StringListObj[stringListById].Data[index, 1];
              switch ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index, 2])))
              {
                case 1:
                  if (Operators.CompareString(Strings.LCase(str7), str1, false) == 0)
                  {
                    str5 = str5 + "• This profile limits the '" + str8 + "' profile.\r\n";
                    break;
                  }
                  if (Operators.CompareString(Strings.LCase(str8), str1, false) == 0)
                  {
                    str6 = str6 + "• '" + str7 + "' limits this profile.\r\n";
                    break;
                  }
                  break;
                case 11:
                  if (Operators.CompareString(Strings.LCase(str8), str1, false) == 0)
                  {
                    str5 = str5 + "• Low '" + str7 + "' rating (<50) defends this profile against suppression.\r\n";
                    break;
                  }
                  break;
                case 12:
                  if (Operators.CompareString(Strings.LCase(str8), str1, false) == 0)
                  {
                    str5 = str5 + "• High '" + str7 + "' rating (>50) defends this profile against suppression.\r\n";
                    break;
                  }
                  break;
              }
            }
            Left: String = str5 + str6;
            if (Operators.CompareString(Left, "", false) == 0)
              Left = "• None\r\n";
            newValue = Left;
          }
          if (num1 == 4)
          {
            let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 387, 0, 0));
            this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 390, 0, 0));
            Left: String = "";
            let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
            for (let mut index: i32 =  0; index <= length; index += 1)
            {
              if (Operators.CompareString(this.game.Data.StringListObj[stringListById].Data[index, 3].ToLower(), str1, false) == 0)
              {
                str9: String = this.game.Data.StringListObj[stringListById].Data[index, 16];
                str10: String = this.game.Data.StringListObj[stringListById].Data[index, 17];
                str11: String = this.game.Data.StringListObj[stringListById].Data[index, 18];
                if (str9.Length > 1)
                  Left = Left + "• " + str9 + "\r\n";
                if (str10.Length > 1)
                  Left = Left + "• " + str10 + "\r\n";
                if (str11.Length > 1)
                  Left = Left + "• " + str11 + "\r\n";
              }
            }
            if (Operators.CompareString(Left, "", false) == 0)
              Left = "• None\r\n";
            newValue = Left;
          }
          if (num1 == 5)
          {
            let mut stringListById5: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 387, 0, 0));
            let mut stringListById6: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 390, 0, 0));
            Left: String = "";
            let mut num12: i32 =  -1;
            let mut length5: i32 =  this.game.Data.StringListObj[stringListById5].Length;
            for (let mut index5: i32 =  0; index5 <= length5; index5 += 1)
            {
              if (Operators.CompareString(this.game.Data.StringListObj[stringListById5].Data[index5, 3].ToLower(), str1, false) == 0)
              {
                num12 = Conversions.ToInteger(this.game.Data.StringListObj[stringListById5].Data[index5, 0]);
                let mut length6: i32 =  this.game.Data.StringListObj[stringListById6].Length;
                for (let mut index6: i32 =  0; index6 <= length6; index6 += 1)
                {
                  let mut num13: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById6].Data[index6, 0]));
                  if (num12 == num13)
                  {
                    str12: String = this.game.Data.StringListObj[stringListById6].Data[index6, 5];
                    if (str12.Length > 1)
                      Left = Left + "• " + str12 + "\r\n";
                  }
                }
              }
            }
            let mut stringListById7: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 277, 0, 0));
            if (num12 > 0)
            {
              let mut length7: i32 =  this.game.Data.StringListObj[stringListById7].Length;
              for (let mut index: i32 =  0; index <= length7; index += 1)
              {
                if (Strings.InStr(Strings.UCase(this.game.Data.StringListObj[stringListById7].Data[index, 6].ToLower()), "REGIMEFEAT." + num12.ToString()) > 0)
                {
                  str13: String = this.game.Data.StringListObj[stringListById7].Data[index, 1];
                  Left = Left + "• Unlocks Stratagem '" + str13 + "'\r\n";
                }
              }
            }
            if (Operators.CompareString(Left, "", false) == 0)
              Left = "• None\r\n";
            newValue = Left;
          }
          if (num1 == 6)
          {
            let mut stringListById8: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 387, 0, 0));
            let mut stringListById9: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 402, 0, 0));
            Left: String = "";
            let mut length8: i32 =  this.game.Data.StringListObj[stringListById8].Length;
            for (let mut index7: i32 =  0; index7 <= length8; index7 += 1)
            {
              if (Operators.CompareString(this.game.Data.StringListObj[stringListById8].Data[index7, 3].ToLower(), str1, false) == 0)
              {
                let mut integer: i32 =  Conversions.ToInteger(this.game.Data.StringListObj[stringListById8].Data[index7, 0]);
                let mut length9: i32 =  this.game.Data.StringListObj[stringListById9].Length;
                for (let mut index8: i32 =  0; index8 <= length9; index8 += 1)
                {
                  let mut num14: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById9].Data[index8, 1]));
                  if (integer == num14)
                  {
                    str14: String = this.game.Data.StringListObj[stringListById9].Data[index8, 2];
                    str15: String = this.game.Data.StringListObj[stringListById9].Data[index8, 3];
                    str16: String = this.game.Data.StringListObj[stringListById9].Data[index8, 4];
                    if (str14.Length > 1)
                      Left = Left + "• " + str14 + " (Max feat:troops ratio 1:" + str15 + "00, Acquire chance: " + str16 + "% per " + str15 + "00 troops)\r\n";
                  }
                }
              }
            }
            if (Operators.CompareString(Left, "", false) == 0)
              Left = "• None\r\n";
            newValue = Left;
          }
        }
        if (num1 > 0)
        {
          flag = true;
          texty = texty.Replace(oldValue1, newValue);
        }
      }
      return texty;
    }

    pub SimpleStringList UnitPopupUdsButtons()
    {
      SimpleStringList simpleStringList = SimpleStringList::new();
      let mut eventByLib: i32 =  this.game.EventRelatedObj.CheckGetEventByLib("SE_Present", 548, 0, 0);
      simpleStringList.Add("Formation Admin", 1, eventByLib, 548);
      return simpleStringList;
    }

    pub UnitPopupUdsButtons_MouseOver: String(id: i32) => id == 548 ? "Formation administration allows changing the Formation Type and setting Quality Levels" : "";

    pub fn UnitPopupUdsButtons_SetIO(id: i32)
    {
      if (id != 548)
        return;
      this.game.EventRelatedObj.IO_AddClear();
      this.game.EventRelatedObj.IO_AddHidden("UNIT", this.game.EditObj.UnitSelected);
    }

    pub void UnitCausesHexOwnershipChange(
      regnr: i32,
      x: i32,
      y: i32,
      ox: i32,
      oy: i32,
      bool ZoneBorderMode = false)
    {
      let mut stringListById1: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 123, 0, 0));
      let mut stringListById2: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 148, 0, 0));
      let mut stringListById3: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 144, 0, 0));
      data1: DataClass = this.game.Data;
      str1: String = "Zones";
       local1: String =  str1;
      let mut libVar1: i32 =  data1.FindLibVar( local1, "SE_Data");
      if (x < 0)
        return;
      if (ox < 0)
      {
        let mut tfacing: i32 =  1;
        do
        {
          Coordinate coordinate = this.HexNeighbour(x, y, 0, tfacing);
          if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime == regnr)
          {
            ox = coordinate.x;
            oy = coordinate.y;
            break;
          }
          tfacing += 1;
        }
        while (tfacing <= 6);
      }
      if (ox < 0 || regnr == -1)
        return;
      let mut hexLibVarValue1: i32 =  this.game.Data.MapObj[0].HexObj[ox, oy].GetHexLibVarValue(libVar1);
      let mut hexLibVarValue2: i32 =  this.game.Data.MapObj[0].HexObj[x, y].GetHexLibVarValue(libVar1);
      if (hexLibVarValue1 == 222 | hexLibVarValue2 == 222)
        ox = ox;
      bool flag1 = false;
      let mut num1: i32 =  0;
      let mut num2: i32 =  -1;
      let mut num3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue1, 10)));
      let mut num4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue1, 11)));
      if (num3 == ox & num4 == oy && this.game.Data.MapObj[0].HexObj[ox, oy].Location > -1)
        flag1 = true;
      num1 = !(hexLibVarValue1 < 1 & this.game.Data.MapObj[0].HexObj[ox, oy].Regime > -1) ? (flag1 ? this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[ox, oy].Regime].id :  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue1, 8)))) : this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[ox, oy].Regime].id;
      if (this.game.Data.MapObj[0].HexObj[ox, oy].Regime == -1)
        return;
      let mut id1: i32 =  this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[ox, oy].Regime].id;
      num2 = this.game.HandyFunctionsObj.GetRegimeByID(id1);
      let mut num5: i32 =  0;
      if (hexLibVarValue2 > 0)
        num5 =  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue2, 8)));
      let mut id2: i32 =  this.game.Data.RegimeObj[regnr].id;
      if (x == 106 & y == 22)
        x = x;
      if (id2 != id1)
        return;
      bool flag2 = false;
      if (hexLibVarValue2 > 0)
      {
        let mut num6: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue2, 10)));
        let mut num7: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue2, 11)));
        if (num6 == x & num7 == y && this.game.Data.MapObj[0].HexObj[x, y].Location > -1)
          flag2 = true;
      }
      if (!flag2)
      {
        if (id2 != num5 & hexLibVarValue1 <= 0)
          this.game.Data.MapObj[0].HexObj[x, y].SetHexLibVarValue(libVar1, 0);
        if ((id2 != num5 | ZoneBorderMode) & hexLibVarValue1 > 0)
        {
          this.game.Data.MapObj[0].HexObj[x, y].SetHexLibVarValue(libVar1, hexLibVarValue1);
          data2: DataClass = this.game.Data;
          str2: String = "freeFolk";
           local2: String =  str2;
          let mut libVar2: i32 =  data2.FindLibVar( local2, "SE_Data");
          let mut hexLibVarValue3: i32 =  this.game.Data.MapObj[0].HexObj[x, y].GetHexLibVarValue(libVar2);
          let mut stringListById4: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 160, 0, 0));
          if (hexLibVarValue1 > 0 & hexLibVarValue3 > 0)
          {
            let mut setValue1: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById4].GetData2(0, hexLibVarValue1, 1, "freeFolk", 2))) + hexLibVarValue3;
            this.game.Data.StringListObj[stringListById4].SetData2(0, hexLibVarValue1, 1, "freeFolk", 2, setValue1);
            if (hexLibVarValue2 > 0)
            {
              let mut setValue2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById4].GetData2(0, hexLibVarValue2, 1, "freeFolk", 2))) - hexLibVarValue3;
              if (setValue2 < 0)
                setValue2 = 0;
              this.game.Data.StringListObj[stringListById4].SetData2(0, hexLibVarValue2, 1, "freeFolk", 2, setValue2);
            }
          }
        }
        if (id2 != num5 | ZoneBorderMode)
        {
          let mut length: i32 =  this.game.Data.StringListObj[stringListById2].Length;
          for (let mut index: i32 =  0; index <= length; index += 1)
          {
            if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById2].Data[index, 3])) == x &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById2].Data[index, 4])) == y)
            {
              this.game.Data.StringListObj[stringListById2].Data[index, 0] = hexLibVarValue1.ToString();
              this.game.Data.StringListObj[stringListById2].Data[index, 14] = 0.ToString();
            }
          }
        }
      }
      if (flag2 & hexLibVarValue1 > 0)
      {
        let mut stringListById5: i32 =  DrawMod.TGame.HandyFunctionsObj.GetStringListByID(DrawMod.TGame.EventRelatedObj.CheckStringlistID("SE_Data", 288, 0, 0));
        let mut oldX: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue1, 10)));
        let mut oldY: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, hexLibVarValue1, 11)));
        this.game.EventRelatedObj.Helper_NewZone_Extend(x, y, oldX, oldY);
        this.game.Data.StringListObj[stringListById5].SetData3(0, this.game.Data.RegimeObj[regnr].id, 1, hexLibVarValue2, 2, "conqueredDuringTurn", 3, 1, true);
      }
      for (let mut length: i32 =  this.game.Data.StringListObj[stringListById2].Length; length >= 0; length += -1)
      {
        let mut index1: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById2].Data[length, 3]));
        let mut index2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById2].Data[length, 4]));
        if (index1 == x & index2 == y)
        {
          let mut num8: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById2].Data[length, 7]));
          let mut idValue: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById2].Data[length, 1]));
          let mut num9: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById3].GetData(0, idValue, 4)));
          if (this.game.Data.MapObj[0].HexObj[index1, index2].Regime != regnr && num8 > 0 | num9 == 5)
          {
            this.game.Data.StringListObj[stringListById2].RemoveRow(length);
            this.game.EventRelatedObj.Helper_SetLocationTypeForHex(index1, index2, index1, index2);
          }
        }
      }
      if (this.game.Data.MapObj[0].HexObj[x, y].Regime == regnr)
        return;
      str3: String = "SE_Data";
      data3: DataClass = this.game.Data;
      str4: String = "truckPoints";
       local3: String =  str4;
      libName1: String = str3;
      let mut libVar3: i32 =  data3.FindLibVar( local3, libName1);
      index3: i32;
      index4: i32;
      if (this.game.Data.MapObj[0].HexObj[index3, index4].GetHexLibVarValue(libVar3) > 0)
        this.game.Data.MapObj[0].HexObj[index3, index4].SetHexLibVarValue(libVar3, 0);
      data4: DataClass = this.game.Data;
      str5: String = "truckFreeAp";
       local4: String =  str5;
      libName2: String = str3;
      let mut libVar4: i32 =  data4.FindLibVar( local4, libName2);
      if (this.game.Data.MapObj[0].HexObj[index3, index4].GetHexLibVarValue(libVar4) > 0)
        this.game.Data.MapObj[0].HexObj[index3, index4].SetHexLibVarValue(libVar4, 0);
      data5: DataClass = this.game.Data;
      str6: String = "maglevPoints";
       local5: String =  str6;
      libName3: String = str3;
      let mut libVar5: i32 =  data5.FindLibVar( local5, libName3);
      if (this.game.Data.MapObj[0].HexObj[index3, index4].GetHexLibVarValue(libVar5) > 0)
        this.game.Data.MapObj[0].HexObj[index3, index4].SetHexLibVarValue(libVar5, 0);
      data6: DataClass = this.game.Data;
      str7: String = "maglevFreeAp";
       local6: String =  str7;
      libName4: String = str3;
      let mut libVar6: i32 =  data6.FindLibVar( local6, libName4);
      if (this.game.Data.MapObj[0].HexObj[index3, index4].GetHexLibVarValue(libVar6) <= 0)
        return;
      this.game.Data.MapObj[0].HexObj[index3, index4].SetHexLibVarValue(libVar6, 0);
    }

    pub fn GameLoop_SleepingRegime()
    {
      if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[DrawMod.TGame.HandyFunctionsObj.GetStringListByID(DrawMod.TGame.EventRelatedObj.CheckStringlistID("SE_Data", 143, 0, 0))].GetData(0, this.game.Data.RegimeObj[this.game.Data.Turn].id, 1))) != 2)
        return;
      new Shadow_Minor( this.game.DC2AIObj).Run();
    }

    pub ShowStatsOfRegime: bool(regSlot: i32)
    {
      let mut num: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 143, 0, 0))].GetData(0, this.game.Data.RegimeObj[regSlot].id, 1)));
      return this.game.Data.Turn == regSlot || num == 1 && (!this.game.Data.ShrowdOn || !this.game.Data.FOWOn || this.game.Data.Winner > -1 || this.game.Data.RegimeObj[this.game.Data.Turn].Sleep);
    }

    pub ShowStatsOfSFTypeGroup: bool(sfTypeGroupNr: i32)
    {
      if (this.game.Data.FOWOn & this.game.Data.ShrowdOn & this.game.Data.Winner == -1 & !this.game.Data.RegimeObj[this.game.Data.Turn].Sleep)
      {
        bool flag1 = false;
        let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
        for (let mut index1: i32 =  0; index1 <= regimeCounter; index1 += 1)
        {
          let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
          for (let mut index2: i32 =  0; index2 <= sfTypeCounter; index2 += 1)
          {
            if (this.game.Data.SFTypeObj[index2].UnitGroup == sfTypeGroupNr)
            {
              bool flag2 = false;
              if (this.game.Data.Turn == index1)
                flag2 = true;
              if (flag2)
              {
                let mut round: i32 =  this.game.Data.Round;
                for (let mut index3: i32 =  1; index3 <= round; index3 += 1)
                {
                  if (this.game.Data.RegimeObj[index1].SPresent[index2, index3] > 0)
                    flag1 = true;
                }
              }
              if (flag1)
                return true;
            }
          }
        }
      }
      else
      {
        let mut stringListById1: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 143, 0, 0));
        let mut stringListById2: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 275, 0, 0));
        bool flag3 = false;
        let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
        for (let mut index4: i32 =  0; index4 <= regimeCounter; index4 += 1)
        {
          let mut sfTypeCounter: i32 =  this.game.Data.SFTypeCounter;
          for (let mut index5: i32 =  0; index5 <= sfTypeCounter; index5 += 1)
          {
            if (this.game.Data.SFTypeObj[index5].UnitGroup == sfTypeGroupNr)
            {
              bool flag4 = false;
              let mut num: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, this.game.Data.RegimeObj[index4].id, 1)));
              if (this.game.Data.Turn == index4)
                flag4 = true;
              if (!this.game.Data.FOWOn)
                flag4 = true;
              if (!this.game.Data.ShrowdOn)
                flag4 = true;
              if (this.game.Data.Winner > -1)
                flag4 = true;
              if (this.game.Data.RegimeObj[this.game.Data.Turn].Sleep)
                flag4 = true;
              if (Conversions.ToInteger(this.game.Data.StringListObj[stringListById2].GetData3(0, this.game.Data.RegimeObj[this.game.Data.Turn].id, 1, this.game.Data.RegimeObj[index4].id, 2, "recon", 3)) >= 50)
                flag4 = true;
              if (num != 1)
                flag4 = false;
              if (flag4)
              {
                let mut round: i32 =  this.game.Data.Round;
                for (let mut index6: i32 =  1; index6 <= round; index6 += 1)
                {
                  if (this.game.Data.RegimeObj[index4].SPresent[index5, index6] > 0)
                    flag3 = true;
                }
              }
              if (flag3)
                return true;
            }
          }
        }
      }
      return false;
    }

    pub ShowStatsOfSFType: bool(sfTypeNr: i32)
    {
      if (this.game.Data.FOWOn & this.game.Data.ShrowdOn & this.game.Data.Winner == -1 & !this.game.Data.RegimeObj[this.game.Data.Turn].Sleep)
      {
        bool flag1 = false;
        let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
        for (let mut index1: i32 =  0; index1 <= regimeCounter; index1 += 1)
        {
          bool flag2 = false;
          if (this.game.Data.Turn == index1)
            flag2 = true;
          if (flag2)
          {
            let mut round: i32 =  this.game.Data.Round;
            for (let mut index2: i32 =  1; index2 <= round; index2 += 1)
            {
              if (this.game.Data.RegimeObj[index1].SPresent[sfTypeNr, index2] > 0)
                return true;
            }
          }
        }
        let mut round1: i32 =  this.game.Data.Round;
        for (let mut index: i32 =  1; index <= round1; index += 1)
        {
          if (this.game.Data.RegimeObj[this.game.Data.Turn].SKills[sfTypeNr, index] > 0)
            return true;
        }
        if (flag1)
          return true;
      }
      else
      {
        let mut stringListById1: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 143, 0, 0));
        let mut stringListById2: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 275, 0, 0));
        bool flag3 = false;
        let mut regimeCounter: i32 =  this.game.Data.RegimeCounter;
        for (let mut index3: i32 =  0; index3 <= regimeCounter; index3 += 1)
        {
          bool flag4 = false;
          let mut num: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById1].GetData(0, this.game.Data.RegimeObj[index3].id, 1)));
          if (this.game.Data.Turn == index3)
            flag4 = true;
          if (!this.game.Data.FOWOn)
            flag4 = true;
          if (!this.game.Data.ShrowdOn)
            flag4 = true;
          if (this.game.Data.RegimeObj[this.game.Data.Turn].Sleep)
            flag4 = true;
          if (Conversions.ToInteger(this.game.Data.StringListObj[stringListById2].GetData3(0, this.game.Data.RegimeObj[this.game.Data.Turn].id, 1, this.game.Data.RegimeObj[index3].id, 2, "recon", 3)) >= 50)
            flag4 = true;
          if (this.game.Data.Winner > -1)
            flag4 = true;
          if (num != 1)
            flag4 = false;
          if (flag4)
          {
            let mut round: i32 =  this.game.Data.Round;
            for (let mut index4: i32 =  1; index4 <= round; index4 += 1)
            {
              if (this.game.Data.RegimeObj[index3].SPresent[sfTypeNr, index4] > 0)
                return true;
            }
          }
        }
        if (flag3)
          return true;
      }
      return false;
    }

    pub Air_GetColor: Color(airRowNr: i32)
    {
      color: Color = Color.Black;
      if (airRowNr < 0)
        return color;
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut num1: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airRowNr, 9]));
      let mut num2: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airRowNr, 7]));
      let mut num3: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airRowNr, 11]));
      let mut num4: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[airRowNr, 6]));
      if (num1 == 0)
        color = Color.FromArgb( byte.MaxValue, 128, 128, 128);
      else if (num2 > 0 & num4 >= num3)
        color = Color.FromArgb( byte.MaxValue, 130, 0, 0);
      else if (num2 < 1 & num3 > num4)
        color = Color.FromArgb( byte.MaxValue, 0, 130, 0);
      else if (num2 > 0 & num3 > num4)
        color = Color.FromArgb( byte.MaxValue, 150, 90, 30);
      return color;
    }

    pub fn AirBridgeInput(unr: i32, sourceX: i32, sourceY: i32, targetX: i32, targetY: i32) -> i32
    {
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 534, 0, 0));
      let mut num1: i32 =  0;
      let mut historical1: i32 =  this.game.Data.UnitObj[unr].Historical;
      let mut num2: i32 =  this.game.Data.HistoricalUnitObj[historical1].GiveHisVarValue(55);
      let mut num3: i32 =  this.game.Data.HistoricalUnitObj[historical1].GiveHisVarValue(56);
      let mut num4: i32 =  this.game.Data.HistoricalUnitObj[historical1].GiveHisVarValue(57);
      let mut row: i32 =  -1;
      let mut index1: i32 =  -1;
      int[] numArray1 = new int[10000];
      let mut num5: i32 =  0;
      let mut length: i32 =  this.game.Data.StringListObj[stringListById].Length;
      for (let mut index2: i32 =  0; index2 <= length; index2 += 1)
      {
        if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 0])) == this.game.Data.RegimeObj[this.game.Data.Turn].id)
        {
          let mut num6: i32 =   Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 8]));
          if (num6 > 0)
          {
            int[] numArray2 = numArray1;
            int[] numArray3 = numArray2;
            let mut index3: i32 =  num6;
            let mut index4: i32 =  index3;
            let mut num7: i32 =  numArray2[index3] + 1;
            numArray3[index4] = num7;
            if (num6 > num5)
              num5 = num6;
          }
          if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 1])) == sourceX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 2])) == sourceY)
          {
            if ( Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 3])) == targetX &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 4])) == targetY)
              row = index2;
            if (num2 > 0 &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 3])) == num3 &&  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index2, 4])) == num4)
              index1 = index2;
          }
        }
      }
      if (num3 == targetX & num4 == targetY)
        index1 = -1;
      let mut num8: i32 =  -1;
      let mut num9: i32 =  num5;
      for (let mut index5: i32 =  1; index5 <= num9; index5 += 1)
      {
        if (numArray1[index5] < 1)
        {
          num8 = index5;
          break;
        }
      }
      if (num8 == -1)
        num8 = num5 + 1;
      let mut num10: i32 =  -1;
      if (row > -1)
        num10 =  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[row, 9]));
      let mut num11: i32 =  -1;
      if (index1 > -1)
        num11 =  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].Data[index1, 9]));
      let mut num12: i32 =  0;
      let mut num13: i32 =  0;
      let mut unitCounter: i32 =  this.game.Data.UnitCounter;
      for (let mut index6: i32 =  0; index6 <= unitCounter; index6 += 1)
      {
        if (this.game.Data.UnitObj[index6].Regime == this.game.Data.Turn & index6 != unr && this.game.Data.UnitObj[index6].X == sourceX && this.game.Data.UnitObj[index6].Y == sourceY)
        {
          let mut historical2: i32 =  this.game.Data.UnitObj[index6].Historical;
          if (this.game.Data.HistoricalUnitObj[historical2].GiveHisVarValue(55) == 1)
          {
            if (this.game.Data.HistoricalUnitObj[historical2].GiveHisVarValue(56) == targetX && this.game.Data.HistoricalUnitObj[historical2].GiveHisVarValue(57) == targetY)
              num12 += 1;
            if (index1 > -1 && this.game.Data.HistoricalUnitObj[historical2].GiveHisVarValue(56) == num3 && this.game.Data.HistoricalUnitObj[historical2].GiveHisVarValue(57) == num4)
              num13 += 1;
          }
        }
      }
      if (num3 == targetX & num4 == targetY)
      {
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(55, 0);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(56, 0);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(57, 0);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(58, 0);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(59, 0);
        if (row > -1 && num10 == 0 && num12 < 1)
          this.game.Data.StringListObj[stringListById].RemoveRow(row);
      }
      else
      {
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(55, 1);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(56, targetX);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(57, targetY);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(58, 0);
        this.game.Data.HistoricalUnitObj[historical1].SetHisVarValue(59, 0);
        if (row > -1)
        {
          if (num10 == -1)
            this.game.Data.StringListObj[stringListById].Data[row, 9] = "0";
        }
        else
          this.game.Data.StringListObj[stringListById].AddRowWithData(this.game.Data.RegimeObj[this.game.Data.Turn].id.ToString(), sourceX.ToString(), sourceY.ToString(), targetX.ToString(), targetY.ToString(), "0", "0", "0", num8.ToString(), "0", "0");
      }
      if (index1 > -1 && num11 == 0 && num13 < 1)
        this.game.Data.StringListObj[stringListById].Data[index1, 9] = "-1";
      return num1;
    }

    pub void MovementSpecialCoordSet(
      curRegSlot: i32,
      tarX: i32,
      tarY: i32,
       Coordinate tcoord,
      bool forRecon)
    {
      let mut stringListById: i32 =  this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 143, 0, 0));
      if (curRegSlot == this.game.Data.MapObj[0].HexObj[tarX, tarY].Regime || this.game.Data.MapObj[0].HexObj[tarX, tarY].Regime == -1 & forRecon)
        return;
      if (this.game.Data.RegimeObj[curRegSlot].RegimeRel[this.game.Data.MapObj[0].HexObj[tarX, tarY].Regime] == 1 & !forRecon)
      {
        tcoord.y = 2;
      }
      else
      {
        if (this.game.Data.RegimeObj[curRegSlot].RegimeRel[this.game.Data.MapObj[0].HexObj[tarX, tarY].Regime] != 0 ||  Math.Round(Conversion.Val(this.game.Data.StringListObj[stringListById].GetData(0, this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[tarX, tarY].Regime].id, 1))) != 2 ||  Math.Round(Conversion.Val(this.game.Data.StringListObj[this.game.HandyFunctionsObj.GetStringListByID(this.game.EventRelatedObj.CheckStringlistID("SE_Data", 275, 0, 0))].GetData3(0, this.game.Data.RegimeObj[this.game.Data.Turn].id, 1, this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[tarX, tarY].Regime].id, 2, "dipClear", 3))) >= 1)
          return;
        if (this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[tarX, tarY].Regime].Sleep)
        {
          if (this.game.HandyFunctionsObj.VisibleEnemyUnitsInHex(tarX, tarY, 0, this.game.Data.Turn) | !forRecon & this.game.Data.MapObj[0].HexObj[tarX, tarY].Location > -1)
          {
            tcoord.y = 2;
          }
          else
          {
            if (!(this.game.HandyFunctionsObj.HasHexRoad(tarX, tarY, 0) &  this.game.Data.RuleVar[901] >= 2.0 & !forRecon))
              return;
            tcoord.y = 2;
          }
        }
        else if (this.game.HandyFunctionsObj.VisibleEnemyUnitsInHex(tarX, tarY, 0, this.game.Data.Turn) | !forRecon & this.game.Data.MapObj[0].HexObj[tarX, tarY].Location > -1)
        {
          tcoord.y = 2;
        }
        else
        {
          if (!(this.game.HandyFunctionsObj.HasHexRoad(tarX, tarY, 0) &  this.game.Data.RuleVar[901] >= 2.0 & !forRecon))
            return;
          tcoord.y = 2;
        }
      }
    }

    pub fn GetSFTypeCombatValueScore(typ: i32) -> i32
    {
      let mut index1: i32 =  typ;
      let mut attacks: i32 =  this.game.Data.SFTypeObj[index1].Attacks;
      let mut d: i32 =  0;
      let mut num: i32 =  0;
      let mut index2: i32 =  0;
      do
      {
        if (this.game.Data.SFTypeObj[index1].AttackPower[index2] > d)
          d = this.game.Data.SFTypeObj[index1].AttackPower[index2];
        if (this.game.Data.SFTypeObj[index1].HitPoints[index2] > num)
          num = this.game.Data.SFTypeObj[index1].HitPoints[index2];
        index2 += 1;
      }
      while (index2 <= 19);
      let mut index3: i32 =  0;
      do
      {
        if (this.game.Data.SFTypeObj[index1].AttackPowerDef[index3] > d)
          d = this.game.Data.SFTypeObj[index1].AttackPowerDef[index3];
        if (this.game.Data.SFTypeObj[index1].HitPointsDef[index3] > num)
          num = this.game.Data.SFTypeObj[index1].HitPointsDef[index3];
        index3 += 1;
      }
      while (index3 <= 19);
      if (d < 1)
        d = 1;
      if (num < 1)
        num = 1;
      return  Math.Round( attacks * Math.Sqrt( d) *  num / 100.0);
    }

    pub GetSFTypeCombatValueScoreString: String(typ: i32) => "";

    pub fn GetSFTypeProdCostScore(typ: i32) -> i32 => 0 + this.game.Data.SFTypeObj[typ].SFTypeVar[61] + this.game.Data.SFTypeObj[typ].SFTypeVar[62] + this.game.Data.SFTypeObj[typ].SFTypeVar[63] * 2 + this.game.Data.SFTypeObj[typ].SFTypeVar[64] * 4 + this.game.Data.SFTypeObj[typ].SFTypeVar[65] * 8 + this.game.Data.SFTypeObj[typ].SFTypeVar[66] * 6 + this.game.Data.SFTypeObj[typ].SFTypeVar[67] * 2;

    pub GetSFTypeProdCostScoreString: String(typ: i32) => "";
  }
}
