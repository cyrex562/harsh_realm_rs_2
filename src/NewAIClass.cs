// Decompiled with JetBrains decompiler
// Type: WindowsApplication1.NewAIClass
// Assembly: WindowsApplication1, Version=1.0.8020.28903, Culture=neutral, PublicKeyToken=null
// MVID: F52869E5-0850-48AD-BBBE-68E7A4900AFE
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Shadow Empire\ShadowEmpire.exe

using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.CompilerServices;
using System.Windows.Forms;

namespace WindowsApplication1
{
  public class NewAIClass
  {
    public Coordinate AAM1;
    public Coordinate AAM2;
    public Coordinate CMS1;
    public Coordinate CMS2;
    public bool FullLog;
    public bool DetailLog;
    public bool ScreenyLog;
    public bool MovingIn;
    public SimpleList MarkerList;
    public SimpleList ArtMarkerList;
    public SimpleList AirMarkerList;
    public SimpleList EngineerMarkerList;
    public int OpGroup;
    public int AverageVP;
    public int AverageSupplyPercentage;
    public int[,] ptemp;
    public int[,] ptemp2;
    public int[,] ptemp3;
    public int[] atemp;
    public int[] atemp2;
    public bool[] ptempb;
    public int[] stemp;
    public MapMatrix2Boolean pmatrix;
    public int[,] TscoreMatrix;
    public int[,] TscoreCounterMatrix;
    public int[] AreaClosestEnemy;
    public int[,] SupplyMatrix;
    public int[,] SupplyCounterMatrix;
    public int[,] SupplyTempOwnerMatrix;
    public int[,] SupplyMatrixReal;
    public int[,] SupplyMatrixPrognosis;
    public int[,] SupplyMatrixPrognosisEasyRoads;
    public int[,] DistanceFromSuppliedHex;
    public int[,] BottleNeckMatrix;
    public Coordinate[,] SupplyMatrixRealCameFrom;
    public Coordinate[,] SupplyMatrixPrognosisCameFrom;
    public int[,] SupplyMatrixOpHQReal;
    public int[,] SupplyMatrixOpHQPrognosis;
    public Coordinate[,] SupplyMatrixOpHQRealCameFrom;
    public Coordinate[,] SupplyMatrixOpHQPrognosisCameFrom;
    public int[,] DistFromFrontline;
    public int[,] FullAdvanceMatrix;
    public int[,] SupplyMatrixEnemyReal;
    public int[,] SupplyMatrixEnemyPrognosis;
    public Coordinate[,] SupplyMatrixEnemyRealCameFrom;
    public Coordinate[,] SupplyMatrixEnemyPrognosisCameFrom;
    public int[,] SupplyMatrixDistance;
    public int[,] AdvanceAxisMatrix;
    public int[,] HexOccupyMatrix;
    public int[,] FighterMatrix;
    public int[,,] MoveMatrix;
    public sCoordinate[,,] MoveMatrixCameFrom;
    public int[] MoveMatrixUnit;
    public Coordinate[] MoveMatrixCloseRoad;
    public bool Attacker;
    public bool Meeting;
    public int[] AreaSupplyBorderCount;
    public int[,] AreaSupplyBorder;
    public int[,] AreaSupplyBorderEither;
    public int[,] AreasupplyborderSea;
    public int[] RandomAreaNeighbourCount;
    public int[,] RandomAreaNeighbour;
    public int[,,] EnemyMatrix;
    public sCoordinate[,,] EnemyMatrixCameFrom;
    public int[] EnemyMatrixUnit;
    public sCoordinate[,,] EnemyMatrix2CameFrom;
    public int[,,] EnemyMatrix2;
    public int[,] FriendlyPowerDispersed;
    public int[,] EnemyPowerDispersed;
    public int[] MoveMatrixUnitMarker;
    public int[] TempMoveMatrixUnitMarker;
    public int MoveMatrixCounter;
    public int EnemyMatrixCounter;
    public bool MadeMove;
    public int MoveAndAttackRound;
    public SimpleList BestMove;
    public SimpleList[] HistoryMove;
    public int HistoryMoveCounter;
    public SimpleList HistoryScoreList;
    public float[,] CombatMatrix;
    public int[,] tArea;
    public int[,] DistToTArea;
    public int[,] DistFromTArea;
    public int[,] FrontlineArea;
    public int[,] EnemyFrontlineArea;
    public int FrontlineCount;
    public int[,] TempOwner;
    public int[,] TempCounterOwner;
    public int AreaCount;
    public int RealAreaCount;
    public int[] AreaGroup;
    public int[] AreaExtraVP;
    public int[] OldExtraVP;
    public int AreaGroupRound;
    public int AreaGroupCount;
    public int CurrentAreaGroup;
    public int[,] AreaMatrixNarrow;
    public int[,] AreaMatrixWide;
    public int[,] AreaBorderNoBridge;
    public bool[] AreaIsExtra;
    public int[,] AreaBroadBorder;
    public int[,] AreaNarrowBorder;
    public int[,] AreaBorder;
    public int[,] AreaWideBorder;
    public int[,] HisAreaDistance;
    public int[,] HisAreaDistanceFriendly;
    public Coordinate[] AreaCenter;
    public SimpleList[] AreaBridges;
    public int[] AreaFuzzyVP;
    public int[] AreaDefensive;
    public int[] CorpsStrength;
    public int[] AreaStrength;
    public SimpleList BestStrategy;
    public bool tempextraaivp;
    public int LastRegime;
    public int[,] CounterAttackPossible;
    public bool[] CorpsStrategic;
    public int[] CorpsLoc;
    public int[] CorpsTarget;
    public int[] CorpsSource;
    public int[] CorpsMove;
    public int[] CorpsTopGroup;
    public bool[] CorpsEngineer;
    public int[] AreaOwner;
    public int[] AreaEnemy;
    public int[] AreaStartEnemy;
    public int[] AreaIsHistoricalArea;
    public int[] AreaCounterPower;
    public int[,] AreaCounterDirections;
    public int[,] AreaCounterRegime;
    public int[] AreaCounterStep;
    public int[] AverageAreaEntrench;
    public int[] CorpsMoveProgress;
    public int[] CorpsStance;
    public int[] CorpsStartLoc;
    public int[] CorpsFirstAreaBattle;
    public float[] CorpsTopRatio;
    public int[] CorpsBottleneck;
    public int[] CorpsOldDefend;
    public int[] TempGroupHQ;
    public int[] CorpsTempStrength;
    public int[] FriendlySupply;
    public int[] StartFriendlySupply;
    public int[] EnemySupply;
    public int[,] AreaSteps;
    public int[] CorpsEntrench;
    public int[] EnemySupplyGone;
    public int[] StartEnemySupplyGone;
    public int[] CorpsAirStrength;
    public int[] CorpsTempAirStrength;
    public int[] CorpsAirEffect;
    public int[] corpsstartStrength;
    public int[] CorpsLandStrength;
    public int[] CorpsPowerLeft;
    public int[] CorpsAttack;
    public int[] CorpsDefend;
    public SimpleList TempTroops;
    public int TempTotVP;
    public int TempCurVP;
    private SimpleList TempPowerAbove;
    public int GlobalVar;
    public int GroupCounter;
    public int[] GroupType;
    public int[] GroupHis;
    public string[] GroupName;
    public int[] GroupAttack;
    public int[] GroupDefend;
    public int[] GroupFallBack;
    public int[] GroupFollowUp;
    public int[] TempGroupTarget;
    public int[] GroupHQNeed;
    public int ErsatzGroupCounter;
    public int TempAverageHQPower;
    public int SeaCount;
    public int[,] SeaBorder;
    public int[,] SeaMatrix;
    public int ATTACK_MINIMUM_ACTUAL_ATTACK;
    public float ATTACKERRATIO;
    public int DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE;
    public int DIFFICULTY_LEVEL_STRATEGY_MOVES;
    private const int ATTACK_STYLE_DEFENSIVE = 1;
    private const int ATTACK_STYLE_NORMAL = 2;
    private const int ATTACK_STYLE_OFFENSIVE = 3;
    private const int STRATEGY_MOVETYPE = 3;
    private const int STRATEGY_MOVEDIVIDER = 20;
    private const int STRATEGY_AIRMOVECOST = 4;
    private const int STRATEGY_MINIMUMEPATURN = 50;
    private const float STRATEGY_AVAILABLEFORSTRATEGIC = 2f;
    private const int STRATEGY_MOUNTAINLT = 6;
    public const int CATEGORY_NORMAL = 1;
    public const int CATEGORY_ARTILLERY = 2;
    public const int CATEGORY_AIR = 3;
    public const int CATEGORY_ENGINEER = 4;
    public const int CATEGORY_FLAK = 5;
    public const int CATEGORY_CARGO = 6;
    public const int CATEGORY_NAVAL = 7;
    public const int CATEGORY_AIRTRANSPORT = 8;
    public float CONST_ARTMULTI;
    public float CONST_AIRMULTI;
    public float CONST_LANDDEFMULTI;
    public const int ROLESTAFF = 1;
    public const int ROLELANDCAP = 2;
    public const int ROLESEACAP = 3;
    public const int ROLEAIRCAP = 4;
    public const int ROLEENGINEER = 5;
    public const int ROLEINFANTRY = 6;
    public const int ROLEINFANTRYSUPPORT = 7;
    public const int ROLEARTILLERY = 8;
    public const int ROLEMOBILIZER = 9;
    public const int ROLEARMOUR = 10;
    public const int ROLEPARATROOP = 11;
    public const int ROLEAA = 12;
    public const int ROLEFIGHTER = 13;
    public const int ROLETACTICALBOMBER = 14;
    public const int ROLESTRATEGICBOMBER = 15;
    public const int ROLETRANSPORTER = 16;
    public const int ROLECARGOSHIP = 17;
    public const int ROLESEASUPRIORITY = 18;
    public const int ROLERAIDER = 19;
    public int[] StrTempCorps;
    public float[] StrTempCorpsMod;
    public int StrTempCorpsCounter;
    public int[] StrCurSides;
    public int StrConsistSame;
    public int StrConsistDifferent;
    public int[,] StrCounterAttack;
    public int[] StrLandEnemySupply;
    public int[] StartStrLandEnemySupply;
    public int[] StrOrigAreaOwner;
    public int[] StrAreaEntrench;
    public int[] StrAreaNegPow;
    public GameClass game;
    public string[] LogTxt;
    public int LogCounter;
    public string[] LogTxt2;
    public int LogCounter2;

    public void MakeFighterCoverage(bool alllog)
    {
      this.FighterMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (alllog)
        this.AddLog("MAKE FIGHTER COVERAGE (of enemy fighters! not our own)");
      if (alllog)
        this.AddLog("");
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn & this.game.Data.UnitObj[unr].PreDef == -1 && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.UnitObj[unr].Regime, this.game.Data.Turn) && this.game.HandyFunctionsObj.HasUnitAirSF(unr))
        {
          int aiRolePercent = this.GetAIRolePercent(unr, 13);
          if (aiRolePercent > 0)
          {
            int increaseap = (int) Math.Round((double) ((float) this.game.HandyFunctionsObj.GetLowestAirRdn(unr, true) * this.game.Data.RuleVar[147]));
            if (increaseap > 0)
            {
              if (alllog)
                this.AddLog("Enemy unit is adding to enemy fighter coverage: " + this.game.Data.UnitObj[unr].Name);
              this.game.HandyFunctionsObj.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, false, PredictAirOnly: true, attack: true, increaseap: increaseap, OnlyFrontline: true);
              int mapWidth = this.game.Data.MapObj[0].MapWidth;
              for (int index1 = 0; index1 <= mapWidth; ++index1)
              {
                int mapHeight = this.game.Data.MapObj[0].MapHeight;
                for (int index2 = 0; index2 <= mapHeight; ++index2)
                {
                  if (this.game.EditObj.TempValue[0].Value[index1, index2] <= increaseap)
                  {
                    int num1 = (int) Math.Round((double) this.GetUnitPower(unr, true, Theater: 2) * ((double) aiRolePercent / 100.0));
                    int[,] fighterMatrix = this.FighterMatrix;
                    int[,] numArray = fighterMatrix;
                    int index3 = index1;
                    int index4 = index3;
                    int index5 = index2;
                    int index6 = index5;
                    int num2 = fighterMatrix[index3, index5] + num1;
                    numArray[index4, index6] = num2;
                  }
                }
              }
            }
          }
        }
      }
      if (!this.ScreenyLog)
        return;
      if (alllog)
        this.AddLog("Screenshot has been made.");
      this.Screenshot(1, "EnemyFighterMatrix", ref this.FighterMatrix);
    }

    public void MakeAreaMatrix(bool tlog)
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      int[] numArray4 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray5 = new int[this.game.Data.AreaCounter + 1];
      bool flag = true;
      this.AreaCount = 0;
      this.SeaCount = 0;
      if (tlog)
        this.AddLog("MAKEAREAMATRIX");
      if (tlog)
        this.AddLog("");
      this.SeaMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      Coordinate coordinate1;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight1 = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight1; ++index2)
        {
          if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index1, index2].LandscapeType].IsSea && this.SeaMatrix[index1, index2] == 0)
          {
            ++this.SeaCount;
            this.SeaMatrix[index1, index2] = this.SeaCount;
            int num = 1;
            while (num == 1)
            {
              num = 0;
              int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
              for (int cx = 0; cx <= mapWidth2; ++cx)
              {
                int mapHeight2 = this.game.Data.MapObj[0].MapHeight;
                for (int cy = 0; cy <= mapHeight2; ++cy)
                {
                  if (this.SeaMatrix[cx, cy] == this.SeaCount && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[cx, cy].LandscapeType].IsSea && this.SeaMatrix[cx, cy] == this.SeaCount)
                  {
                    int tfacing = 1;
                    do
                    {
                      coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                      if (coordinate1.onmap && this.SeaMatrix[coordinate1.x, coordinate1.y] == 0 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
                      {
                        this.SeaMatrix[coordinate1.x, coordinate1.y] = this.SeaCount;
                        num = 1;
                      }
                      ++tfacing;
                    }
                    while (tfacing <= 6);
                  }
                }
              }
            }
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SEA ZONES");
      if (tlog)
        this.AddLog("(note that sea zone count of 0 = no sea zones)");
      if (tlog)
        this.AddLog("Sea Zone Count: " + Strings.Trim(Conversion.Str((object) this.SeaCount)));
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "SEA_ZONES", ref this.SeaMatrix);
      }
      int[] numArray6 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray7 = new int[this.game.Data.AreaCounter + 1];
      int[,] tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray8 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
      for (int x = 0; x <= mapWidth3; ++x)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int y = 0; y <= mapHeight; ++y)
        {
          int num1 = 0;
          this.AreaMatrixNarrow[x, y] = 0;
          this.AreaMatrixWide[x, y] = 0;
          int areaCounter = this.game.Data.AreaCounter;
          for (int area = 0; area <= areaCounter; ++area)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num1 = 1;
              if (numArray6[area] == 0)
              {
                ++this.AreaCount;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                numArray6[area] = this.AreaCount;
                this.AreaCenter[numArray6[area]].x = x;
                this.AreaCenter[numArray6[area]].y = y;
                this.AreaCenter[numArray6[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray6[area]].x, this.AreaCenter[numArray6[area]].y].Location == -1)
              {
                this.AreaCenter[numArray6[area]].x = x;
                this.AreaCenter[numArray6[area]].y = y;
              }
              numArray8[x, y] = 1;
              tObj[x, y] = numArray6[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray7[area])
              {
                this.AreaCenter[numArray6[area]].x = x;
                this.AreaCenter[numArray6[area]].y = y;
                this.AreaCenter[numArray6[area]].onmap = true;
                numArray7[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num1 == 0)
          {
            int num2 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 & (double) this.game.Data.RuleVar[357] == 1.0)
              num2 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num2 = 1;
            if (num2 == 1)
            {
              ++this.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray8[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAS");
      if (tlog)
        this.AddLog("(note that area count of 0 = no areas)");
      if (tlog)
        this.AddLog("Area Count: " + Strings.Trim(Conversion.Str((object) this.AreaCount)));
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAS", ref tObj);
      }
      this.AreaBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaWideBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaBroadBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaNarrowBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaBorderNoBridge = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaIsHistoricalArea = new int[this.AreaCount + 1];
      int num3 = 1;
      int num4 = 0;
      for (; num3 >= -1; --num3)
      {
        ++num4;
        int mapWidth4 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth4; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray8[cx, cy] == num4)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray8[coordinate1.x, coordinate1.y] == 0)
                {
                  if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                  {
                    if (!this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                    {
                      tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                      numArray8[coordinate1.x, coordinate1.y] = numArray8[cx, cy] + 1;
                      num3 = 1;
                    }
                  }
                  else if (this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] <= -1 && !this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                  {
                    tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                    numArray8[coordinate1.x, coordinate1.y] = numArray8[cx, cy] + 2;
                    num3 = 1;
                  }
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      int mapWidth5 = this.game.Data.MapObj[0].MapWidth;
      for (int index3 = 0; index3 <= mapWidth5; ++index3)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index4 = 0; index4 <= mapHeight; ++index4)
          this.AreaMatrixWide[index3, index4] = tObj[index3, index4];
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX WIDE");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_WIDE", ref this.AreaMatrixWide);
      }
      int areaCount1 = this.AreaCount;
      for (int index5 = 1; index5 <= areaCount1; ++index5)
      {
        int areaCount2 = this.AreaCount;
        for (int index6 = 1; index6 <= areaCount2; ++index6)
        {
          this.AreaBorder[index5, index6] = 0;
          this.AreaWideBorder[index5, index6] = 0;
          this.AreaNarrowBorder[index5, index6] = 0;
        }
      }
      int mapWidth6 = this.game.Data.MapObj[0].MapWidth;
      for (int cx = 0; cx <= mapWidth6; ++cx)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int cy = 0; cy <= mapHeight; ++cy)
        {
          if (tObj[cx, cy] > 0)
          {
            int tfacing = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[cx, cy] != tObj[coordinate1.x, coordinate1.y])
              {
                if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1 | (double) this.game.Data.RuleVar[385] == 1.0 && this.AreaBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] && numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] < 40 | (double) this.game.Data.RuleVar[385] == 0.0)
                {
                  this.AreaBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                  this.AreaBorder[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                }
                if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[cx, cy].LandscapeType].IsSea && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea && this.AreaWideBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaWideBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] && numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] < 40 | (double) this.game.Data.RuleVar[385] == 0.0)
                {
                  this.AreaWideBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                  this.AreaWideBorder[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                }
              }
              ++tfacing;
            }
            while (tfacing <= 6);
          }
        }
      }
      int areaCount3 = this.AreaCount;
      for (int index7 = 1; index7 <= areaCount3; ++index7)
      {
        int areaCount4 = this.AreaCount;
        for (int index8 = 1; index8 <= areaCount4; ++index8)
          this.AreaBroadBorder[index7, index8] = this.AreaBorder[index7, index8];
      }
      int areaCount5 = this.AreaCount;
      for (int index9 = 1; index9 <= areaCount5; ++index9)
      {
        int areaCount6 = this.AreaCount;
        for (int index10 = 1; index10 <= areaCount6; ++index10)
        {
          if (index9 != index10)
          {
            int areaCount7 = this.AreaCount;
            for (int index11 = 1; index11 <= areaCount7; ++index11)
            {
              if (this.AreaBroadBorder[index9, index11] > 0 & this.AreaBroadBorder[index10, index11] > 0 & (this.AreaBroadBorder[index9, index10] == 0 | this.AreaBroadBorder[index9, index10] > this.AreaBroadBorder[index9, index11] + this.AreaBroadBorder[index10, index11]) && this.AreaBroadBorder[index9, index11] + this.AreaBroadBorder[index10, index11] < 15)
                this.AreaBroadBorder[index9, index10] = (int) Math.Round((double) this.AreaBroadBorder[index9, index11] + (double) this.AreaBroadBorder[index10, index11] * 0.7);
            }
          }
        }
      }
      this.AreaCount = 0;
      int[] numArray9 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray10 = new int[this.game.Data.AreaCounter + 1];
      tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray11 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth7 = this.game.Data.MapObj[0].MapWidth;
      for (int x = 0; x <= mapWidth7; ++x)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int y = 0; y <= mapHeight; ++y)
        {
          int num5 = 0;
          int areaCounter = this.game.Data.AreaCounter;
          for (int area = 0; area <= areaCounter; ++area)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num5 = 1;
              if (numArray9[area] == 0)
              {
                ++this.AreaCount;
                this.AreaIsHistoricalArea[this.AreaCount] = area;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                numArray9[area] = this.AreaCount;
                this.AreaCenter[numArray9[area]].x = x;
                this.AreaCenter[numArray9[area]].y = y;
                this.AreaCenter[numArray9[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray9[area]].x, this.AreaCenter[numArray9[area]].y].Location == -1)
              {
                this.AreaCenter[numArray9[area]].x = x;
                this.AreaCenter[numArray9[area]].y = y;
              }
              numArray11[x, y] = 1;
              tObj[x, y] = numArray9[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray10[area])
              {
                this.AreaCenter[numArray9[area]].x = x;
                this.AreaCenter[numArray9[area]].y = y;
                this.AreaCenter[numArray9[area]].onmap = true;
                numArray10[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num5 == 0)
          {
            int num6 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 & (double) this.game.Data.RuleVar[357] == 1.0)
              num6 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num6 = 1;
            if (num6 == 1)
            {
              ++this.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray11[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      int mapWidth8 = this.game.Data.MapObj[0].MapWidth;
      for (int index12 = 0; index12 <= mapWidth8; ++index12)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index13 = 0; index13 <= mapHeight; ++index13)
        {
          if (tObj[index12, index13] > 0 && this.game.Data.MapObj[0].HexObj[index12, index13].Regime != this.game.Data.MapObj[0].HexObj[this.AreaCenter[tObj[index12, index13]].x, this.AreaCenter[tObj[index12, index13]].y].Regime)
          {
            tObj[index12, index13] = 0;
            numArray11[index12, index13] = 0;
          }
        }
      }
      int num7 = 2;
      int num8 = 0;
      while (num7 >= 0)
      {
        --num7;
        ++num8;
        int mapWidth9 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth9; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray11[cx, cy] == num8)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray11[coordinate1.x, coordinate1.y] == 0 && this.game.Data.MapObj[0].HexObj[cx, cy].Regime == this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime && !this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                {
                  if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                  {
                    tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                    numArray11[coordinate1.x, coordinate1.y] = numArray11[cx, cy] + 1;
                    num7 = 2;
                  }
                  else if (this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] <= -1)
                  {
                    tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                    numArray11[coordinate1.x, coordinate1.y] = numArray11[cx, cy] + 3;
                    num7 = 2;
                  }
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      int mapWidth10 = this.game.Data.MapObj[0].MapWidth;
      for (int index14 = 0; index14 <= mapWidth10; ++index14)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index15 = 0; index15 <= mapHeight; ++index15)
          this.AreaMatrixNarrow[index14, index15] = tObj[index14, index15];
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NARROW");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_NARROW", ref this.AreaMatrixNarrow);
      }
      int mapWidth11 = this.game.Data.MapObj[0].MapWidth;
      for (int cx = 0; cx <= mapWidth11; ++cx)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int cy = 0; cy <= mapHeight; ++cy)
        {
          if (tObj[cx, cy] > 0)
          {
            int tfacing = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[cx, cy] != tObj[coordinate1.x, coordinate1.y] && this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1 | (double) this.game.Data.RuleVar[385] == 1.0 && this.AreaNarrowBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaNarrowBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y] && numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y] < 40 | (double) this.game.Data.RuleVar[385] == 0.0)
              {
                this.AreaNarrowBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y];
                this.AreaNarrowBorder[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y];
              }
              ++tfacing;
            }
            while (tfacing <= 6);
          }
        }
      }
      this.AreaCount = 0;
      int[] numArray12 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray13 = new int[this.game.Data.AreaCounter + 1];
      tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray14 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth12 = this.game.Data.MapObj[0].MapWidth;
      for (int x = 0; x <= mapWidth12; ++x)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int y = 0; y <= mapHeight; ++y)
        {
          int num9 = 0;
          int areaCounter = this.game.Data.AreaCounter;
          for (int area = 0; area <= areaCounter; ++area)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num9 = 1;
              if (numArray12[area] == 0)
              {
                ++this.AreaCount;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                this.AreaBridges[this.AreaCount] = new SimpleList();
                numArray12[area] = this.AreaCount;
                this.AreaCenter[numArray12[area]].x = x;
                this.AreaCenter[numArray12[area]].y = y;
                this.AreaCenter[numArray12[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray12[area]].x, this.AreaCenter[numArray12[area]].y].Location == -1)
              {
                this.AreaCenter[numArray12[area]].x = x;
                this.AreaCenter[numArray12[area]].y = y;
              }
              numArray14[x, y] = 1;
              tObj[x, y] = numArray12[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray13[area])
              {
                this.AreaCenter[numArray12[area]].x = x;
                this.AreaCenter[numArray12[area]].y = y;
                this.AreaCenter[numArray12[area]].onmap = true;
                numArray13[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num9 == 0)
          {
            int num10 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 & (double) this.game.Data.RuleVar[357] == 1.0)
              num10 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num10 = 1;
            if (num10 == 1)
            {
              ++this.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray14[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaBridges[this.AreaCount] = new SimpleList();
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      int num11 = 1;
      int num12 = 0;
      while (num11 == 1)
      {
        num11 = 0;
        ++num12;
        int mapWidth13 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth13; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray14[cx, cy] == num12)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray14[coordinate1.x, coordinate1.y] == 0 && this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] == -1 && this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                {
                  tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                  numArray14[coordinate1.x, coordinate1.y] = numArray14[cx, cy] + 1;
                  num11 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      int mapWidth14 = this.game.Data.MapObj[0].MapWidth;
      for (int cx = 0; cx <= mapWidth14; ++cx)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int cy = 0; cy <= mapHeight; ++cy)
        {
          if (tObj[cx, cy] > 0)
          {
            int tfacing = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[cx, cy] != tObj[coordinate1.x, coordinate1.y] && (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1 | (double) this.game.Data.RuleVar[385] == 1.0) & this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] == -1 && this.AreaBorderNoBridge[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaBorderNoBridge[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y] && numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y] < 40 | (double) this.game.Data.RuleVar[385] == 0.0)
              {
                this.AreaBorderNoBridge[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y];
                this.AreaBorderNoBridge[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y];
              }
              ++tfacing;
            }
            while (tfacing <= 6);
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NO BRIDGE (temporary)");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_NO_BRIDGE_TEMP", ref tObj);
      }
      this.AreaCount = 0;
      int[] numArray15 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray16 = new int[this.game.Data.AreaCounter + 1];
      tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray17 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth15 = this.game.Data.MapObj[0].MapWidth;
      for (int x = 0; x <= mapWidth15; ++x)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int y = 0; y <= mapHeight; ++y)
        {
          int num13 = 0;
          int areaCounter = this.game.Data.AreaCounter;
          for (int area = 0; area <= areaCounter; ++area)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num13 = 1;
              if (numArray15[area] == 0)
              {
                ++this.AreaCount;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                this.AreaBridges[this.AreaCount] = new SimpleList();
                numArray15[area] = this.AreaCount;
                this.AreaCenter[numArray15[area]].x = x;
                this.AreaCenter[numArray15[area]].y = y;
                this.AreaCenter[numArray15[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray15[area]].x, this.AreaCenter[numArray15[area]].y].Location == -1)
              {
                this.AreaCenter[numArray15[area]].x = x;
                this.AreaCenter[numArray15[area]].y = y;
              }
              numArray17[x, y] = 1;
              tObj[x, y] = numArray15[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray16[area])
              {
                this.AreaCenter[numArray15[area]].x = x;
                this.AreaCenter[numArray15[area]].y = y;
                this.AreaCenter[numArray15[area]].onmap = true;
                numArray16[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num13 == 0)
          {
            int num14 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 & (double) this.game.Data.RuleVar[357] == 1.0)
              num14 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num14 = 1;
            if (num14 == 1)
            {
              ++this.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray17[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaBridges[this.AreaCount] = new SimpleList();
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      int mapWidth16 = this.game.Data.MapObj[0].MapWidth;
      for (int index16 = 0; index16 <= mapWidth16; ++index16)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index17 = 0; index17 <= mapHeight; ++index17)
        {
          if (tObj[index16, index17] > 0 && !(index16 == this.AreaCenter[tObj[index16, index17]].x & index17 == this.AreaCenter[tObj[index16, index17]].y))
          {
            tObj[index16, index17] = 0;
            numArray17[index16, index17] = 0;
          }
        }
      }
      int num15 = 1;
      int num16 = 0;
      while (num15 == 1)
      {
        num15 = 0;
        ++num16;
        int mapWidth17 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth17; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray17[cx, cy] == num16)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray17[coordinate1.x, coordinate1.y] == 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[tObj[cx, cy]].x, this.AreaCenter[tObj[cx, cy]].y].Regime) != this.GetGameDataTurn() && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) != this.GetGameDataTurn() | this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] == -1 && !this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) && this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                {
                  tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                  numArray17[coordinate1.x, coordinate1.y] = numArray17[cx, cy] + 1;
                  num15 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      int mapWidth18 = this.game.Data.MapObj[0].MapWidth;
      for (int index18 = 0; index18 <= mapWidth18; ++index18)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index19 = 0; index19 <= mapHeight; ++index19)
        {
          if (numArray17[index18, index19] > 0)
            numArray17[index18, index19] = 1;
        }
      }
      int num17 = 1;
      int num18 = 0;
      while (num17 == 1)
      {
        num17 = 0;
        ++num18;
        int mapWidth19 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth19; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray17[cx, cy] == num18)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray17[coordinate1.x, coordinate1.y] == 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[tObj[cx, cy]].x, this.AreaCenter[tObj[cx, cy]].y].Regime) == this.GetGameDataTurn())
                {
                  tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                  numArray17[coordinate1.x, coordinate1.y] = numArray17[cx, cy] + 1;
                  num17 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      int mapWidth20 = this.game.Data.MapObj[0].MapWidth;
      for (int index20 = 0; index20 <= mapWidth20; ++index20)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index21 = 0; index21 <= mapHeight; ++index21)
        {
          if (tObj[index20, index21] > 0)
          {
            int tfacing = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index20, index21, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[index20, index21] != tObj[coordinate1.x, coordinate1.y] && !(this.game.Data.MapObj[0].HexObj[index20, index21].RoadType[tfacing - 1] > -1 & this.game.Data.MapObj[0].HexObj[index20, index21].RiverType[tfacing - 1] == -1) && this.game.Data.MapObj[0].HexObj[index20, index21].RoadType[tfacing - 1] > -1 & this.game.Data.MapObj[0].HexObj[index20, index21].RiverType[tfacing - 1] > -1 & tObj[coordinate1.x, coordinate1.y] > 0)
                this.AreaBridges[tObj[index20, index21]].Add(tObj[coordinate1.x, coordinate1.y], 0, index20, index21, coordinate1.x, coordinate1.y);
              ++tfacing;
            }
            while (tfacing <= 6);
          }
        }
      }
      this.RealAreaCount = this.AreaCount;
      int num19 = 1;
      this.AreaIsExtra = new bool[this.AreaCount + 1];
      int num20 = -1;
      int[,] numArray18 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray19 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      while (num19 == 1)
      {
        num19 = 0;
        ++num20;
        int mapWidth21 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth21; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            int num21 = 4;
            if (this.AreaMatrixNarrow[cx, cy] > 0 & this.game.Data.MapObj[0].HexObj[cx, cy].Regime != this.GetGameDataTurn() | numArray18[cx, cy] > 0 & numArray18[cx, cy] < num21 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[cx, cy].LandscapeType].IsSea && numArray18[cx, cy] == num20)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea && numArray18[coordinate1.x, coordinate1.y] == 0 && !(this.AreaMatrixNarrow[coordinate1.x, coordinate1.y] == 0 & this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == this.GetGameDataTurn()) && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime, this.game.Data.MapObj[0].HexObj[cx, cy].Regime) | num20 < num21)
                {
                  numArray19[coordinate1.x, coordinate1.y] = 1;
                  numArray18[coordinate1.x, coordinate1.y] = num20 + 1;
                  num19 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      int mapWidth22 = this.game.Data.MapObj[0].MapWidth;
      for (int x1 = 0; x1 <= mapWidth22; ++x1)
      {
        int mapHeight3 = this.game.Data.MapObj[0].MapHeight;
        for (int y1 = 0; y1 <= mapHeight3; ++y1)
        {
          if (this.AreaMatrixNarrow[x1, y1] == 0 & this.AreaMatrixWide[x1, y1] > 0 & numArray19[x1, y1] == 0)
          {
            if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[x1, y1].LandscapeType].IsSea)
            {
              ++this.AreaCount;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaIsExtra = (bool[]) Utils.CopyArray((Array) this.AreaIsExtra, (Array) new bool[this.AreaCount + 1]);
              this.AreaBridges[this.AreaCount] = new SimpleList();
              this.AreaIsExtra[this.AreaCount] = true;
              this.AreaCenter[this.AreaCount].x = x1;
              this.AreaCenter[this.AreaCount].y = y1;
              this.AreaCenter[this.AreaCount].onmap = true;
              tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
              int[,] numArray20 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
              numArray20[x1, y1] = 1;
              tObj[x1, y1] = 1;
              this.AreaMatrixNarrow[x1, y1] = this.AreaCount;
              this.AreaMatrixWide[x1, y1] = this.AreaCount;
              int num22 = 1;
              int num23 = 0;
              while (num22 == 1)
              {
                num22 = 0;
                ++num23;
                int mapWidth23 = this.game.Data.MapObj[0].MapWidth;
                for (int cx = 0; cx <= mapWidth23; ++cx)
                {
                  int mapHeight4 = this.game.Data.MapObj[0].MapHeight;
                  for (int cy = 0; cy <= mapHeight4; ++cy)
                  {
                    if (numArray20[cx, cy] == num23 & numArray19[cx, cy] == 0)
                    {
                      int tfacing1 = 1;
                      do
                      {
                        coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing1);
                        if (coordinate1.onmap)
                        {
                          if (numArray20[coordinate1.x, coordinate1.y] == 0 & numArray19[coordinate1.x, coordinate1.y] == 0 && this.AreaMatrixNarrow[coordinate1.x, coordinate1.y] == 0 & this.AreaMatrixWide[coordinate1.x, coordinate1.y] > 0 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea && this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == this.game.Data.MapObj[0].HexObj[cx, cy].Regime)
                          {
                            tObj[coordinate1.x, coordinate1.y] = 1;
                            numArray20[coordinate1.x, coordinate1.y] = num23 + 1;
                            this.AreaMatrixNarrow[coordinate1.x, coordinate1.y] = this.AreaCount;
                            this.AreaMatrixWide[coordinate1.x, coordinate1.y] = this.AreaCount;
                            num22 = 1;
                          }
                          if (this.GetGameDataTurn() != this.GetRegime(this.game.Data.MapObj[0].HexObj[x1, y1].Regime) && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
                          {
                            int tfacing2 = 1;
                            do
                            {
                              Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                              if (coordinate2.onmap && numArray20[coordinate2.x, coordinate2.y] == 0 & numArray19[coordinate2.x, coordinate2.y] == 0 && this.AreaMatrixNarrow[coordinate2.x, coordinate2.y] == 0 & this.AreaMatrixWide[coordinate2.x, coordinate2.y] > 0 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == this.game.Data.MapObj[0].HexObj[cx, cy].Regime)
                              {
                                tObj[coordinate2.x, coordinate2.y] = 1;
                                numArray20[coordinate2.x, coordinate2.y] = num23 + 1;
                                this.AreaMatrixNarrow[coordinate2.x, coordinate2.y] = this.AreaCount;
                                this.AreaMatrixWide[coordinate2.x, coordinate2.y] = this.AreaCount;
                                num22 = 1;
                              }
                              ++tfacing2;
                            }
                            while (tfacing2 <= 6);
                          }
                        }
                        ++tfacing1;
                      }
                      while (tfacing1 <= 6);
                    }
                  }
                }
              }
            }
          }
          else if (this.AreaMatrixNarrow[x1, y1] == 0 & this.AreaMatrixWide[x1, y1] > 0 & numArray19[x1, y1] == 1)
          {
            int num24 = -1;
            int num25 = 9999;
            int mapWidth24 = this.game.Data.MapObj[0].MapWidth;
            for (int x2 = 0; x2 <= mapWidth24; ++x2)
            {
              int mapHeight5 = this.game.Data.MapObj[0].MapHeight;
              for (int y2 = 0; y2 <= mapHeight5; ++y2)
              {
                int index = this.AreaMatrixWide[x2, y2];
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetRegime(this.game.Data.MapObj[0].HexObj[x1, y1].Regime))
                {
                  int num26 = this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0, 9);
                  if (num26 > 0 & num26 < 10 && num26 < num25)
                  {
                    num25 = num26;
                    num24 = index;
                  }
                }
              }
            }
            if (num24 > -1)
            {
              this.AreaMatrixNarrow[x1, y1] = num24;
              this.AreaMatrixWide[x1, y1] = num24;
            }
          }
        }
      }
      tObj = new int[this.AreaCount + 1, this.AreaCount + 1];
      int[,] numArray21 = new int[this.AreaCount + 1, this.AreaCount + 1];
      int upperBound1 = this.AreaBorder.GetUpperBound(0);
      for (int index22 = 0; index22 <= upperBound1; ++index22)
      {
        int upperBound2 = this.AreaBorder.GetUpperBound(0);
        for (int index23 = 0; index23 <= upperBound2; ++index23)
        {
          tObj[index22, index23] = this.AreaBorder[index22, index23];
          numArray21[index22, index23] = this.AreaWideBorder[index22, index23];
        }
      }
      this.AreaBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaWideBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      int areaCount8 = this.AreaCount;
      for (int index24 = 0; index24 <= areaCount8; ++index24)
      {
        int areaCount9 = this.AreaCount;
        for (int index25 = 0; index25 <= areaCount9; ++index25)
        {
          this.AreaBorder[index24, index25] = tObj[index24, index25];
          this.AreaWideBorder[index24, index25] = numArray21[index24, index25];
        }
      }
      tObj = new int[this.AreaCount + 1, this.AreaCount + 1];
      int[,] numArray22 = new int[this.AreaCount + 1, this.AreaCount + 1];
      int upperBound3 = this.AreaNarrowBorder.GetUpperBound(0);
      for (int index26 = 0; index26 <= upperBound3; ++index26)
      {
        int upperBound4 = this.AreaNarrowBorder.GetUpperBound(0);
        for (int index27 = 0; index27 <= upperBound4; ++index27)
        {
          tObj[index26, index27] = this.AreaBroadBorder[index26, index27];
          numArray22[index26, index27] = this.AreaNarrowBorder[index26, index27];
        }
      }
      this.AreaBroadBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaNarrowBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      int areaCount10 = this.AreaCount;
      for (int index28 = 0; index28 <= areaCount10; ++index28)
      {
        int areaCount11 = this.AreaCount;
        for (int index29 = 0; index29 <= areaCount11; ++index29)
        {
          this.AreaBroadBorder[index28, index29] = tObj[index28, index29];
          this.AreaNarrowBorder[index28, index29] = numArray22[index28, index29];
        }
      }
      tObj = new int[this.AreaCount + 1, this.AreaCount + 1];
      int upperBound5 = this.AreaBorderNoBridge.GetUpperBound(0);
      for (int index30 = 0; index30 <= upperBound5; ++index30)
      {
        int upperBound6 = this.AreaBorderNoBridge.GetUpperBound(0);
        for (int index31 = 0; index31 <= upperBound6; ++index31)
          tObj[index30, index31] = this.AreaBorderNoBridge[index30, index31];
      }
      this.AreaBorderNoBridge = new int[this.AreaCount + 1, this.AreaCount + 1];
      int areaCount12 = this.AreaCount;
      for (int index32 = 0; index32 <= areaCount12; ++index32)
      {
        int areaCount13 = this.AreaCount;
        for (int index33 = 0; index33 <= areaCount13; ++index33)
          this.AreaBorderNoBridge[index32, index33] = tObj[index32, index33];
      }
      this.AreaIsExtra = (bool[]) Utils.CopyArray((Array) this.AreaIsExtra, (Array) new bool[this.AreaCount + 1]);
      int areaCount14 = this.AreaCount;
      for (int index = 1; index <= areaCount14; ++index)
      {
        if (this.AreaIsExtra[index])
        {
          tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
          numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
        }
      }
      int mapWidth25 = this.game.Data.MapObj[0].MapWidth;
      for (int cx = 0; cx <= mapWidth25; ++cx)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int cy = 0; cy <= mapHeight; ++cy)
        {
          if (this.AreaMatrixNarrow[cx, cy] > 0)
          {
            int index34 = this.AreaMatrixNarrow[cx, cy];
            if (this.AreaIsExtra[index34])
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap)
                {
                  int index35 = this.AreaMatrixNarrow[coordinate1.x, coordinate1.y];
                  if (index35 > 0 & !this.AreaIsExtra[index35])
                  {
                    int num27 = this.game.HandyFunctionsObj.Distance(this.AreaCenter[index34].x, this.AreaCenter[index34].y, 0, this.AreaCenter[index35].x, this.AreaCenter[index35].y, 0);
                    if (this.AreaBorder[index34, index35] == 0 | num27 < this.AreaBorder[index34, index35])
                    {
                      this.AreaBorder[index34, index35] = num27;
                      this.AreaWideBorder[index34, index35] = num27;
                      if (num27 > this.AreaBroadBorder[index34, index35])
                      {
                        this.AreaBroadBorder[index34, index35] = num27;
                        this.AreaBroadBorder[index35, index34] = num27;
                      }
                      this.AreaNarrowBorder[index34, index35] = num27;
                      this.AreaBorderNoBridge[index34, index35] = num27;
                      this.AreaBorder[index35, index34] = num27;
                      this.AreaWideBorder[index35, index34] = num27;
                      this.AreaNarrowBorder[index35, index34] = num27;
                      this.AreaBorderNoBridge[index35, index34] = num27;
                    }
                  }
                }
                ++tfacing;
              }
              while (tfacing <= 6);
              int num28 = cx - 8;
              int num29 = cx + 8;
              for (int index36 = num28; index36 <= num29; ++index36)
              {
                int num30 = cy - 8;
                int num31 = cy - 8;
                for (int index37 = num30; index37 <= num31; ++index37)
                {
                  if (index36 >= 0 & index36 <= this.game.Data.MapObj[0].MapWidth && index37 >= 0 & index37 <= this.game.Data.MapObj[0].MapHeight)
                  {
                    int index38 = this.AreaMatrixNarrow[index36, index37];
                    if (index38 > 0 & !this.AreaIsExtra[index38])
                    {
                      int num32 = this.game.HandyFunctionsObj.Distance(this.AreaCenter[index34].x, this.AreaCenter[index34].y, 0, this.AreaCenter[index38].x, this.AreaCenter[index38].y, 0);
                      if (num32 > this.AreaBroadBorder[index34, index38])
                      {
                        this.AreaBroadBorder[index34, index38] = num32;
                        this.AreaBroadBorder[index38, index34] = num32;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NARROW + WIDE AFTER EXTRA AREAS");
      if (tlog)
        this.AddLog("Real Area Count = " + Strings.Trim(Conversion.Str((object) this.RealAreaCount)));
      if (tlog)
        this.AddLog("(total) Area Count = " + Strings.Trim(Conversion.Str((object) this.AreaCount)));
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshots has been made.");
        this.Screenshot(1, "AREAMATRIX_NARROW_AFTER_EXTRA_AREA", ref this.AreaMatrixNarrow);
        this.Screenshot(1, "AREAMATRIX_WIDE_AFTER_EXTRA_AREA", ref this.AreaMatrixWide);
      }
      int mapWidth26 = this.game.Data.MapObj[0].MapWidth;
      for (int index39 = 0; index39 <= mapWidth26; ++index39)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index40 = 0; index40 <= mapHeight; ++index40)
        {
          if (this.AreaMatrixNarrow[index39, index40] == 0 & this.AreaMatrixWide[index39, index40] > 0 & numArray19[index39, index40] == 1)
            this.AreaMatrixNarrow[index39, index40] = this.AreaMatrixWide[index39, index40];
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NARROW AFTER GIVING ANY 0 SETTINGS THE AREAMATRIX WIDE SETTING ");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_NARROW_AFTER_WIDECHECK", ref this.AreaMatrixNarrow);
      }
      this.SeaBorder = new int[this.SeaCount + 1, this.AreaCount + 1];
      int mapWidth27 = this.game.Data.MapObj[0].MapWidth;
      for (int cx = 0; cx <= mapWidth27; ++cx)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int cy = 0; cy <= mapHeight; ++cy)
        {
          if (this.SeaMatrix[cx, cy] > 0)
          {
            int tfacing = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && this.SeaMatrix[coordinate1.x, coordinate1.y] == 0 & this.AreaMatrixWide[coordinate1.x, coordinate1.y] > 0 && this.game.HandyFunctionsObj.IsHexPort(coordinate1.x, coordinate1.y, 0))
              {
                int[,] seaBorder = this.SeaBorder;
                int[,] numArray23 = seaBorder;
                int[,] seaMatrix = this.SeaMatrix;
                int[,] numArray24 = seaMatrix;
                int index41 = cx;
                int index42 = index41;
                int index43 = cy;
                int index44 = index43;
                int index45 = numArray24[index42, index44];
                int[,] areaMatrixWide = this.AreaMatrixWide;
                int[,] numArray25 = areaMatrixWide;
                int x = coordinate1.x;
                int index46 = x;
                int y = coordinate1.y;
                int index47 = y;
                int index48 = numArray25[index46, index47];
                int num33 = seaBorder[seaMatrix[index41, index43], areaMatrixWide[x, y]] + 1;
                numArray23[index45, index48] = num33;
              }
              ++tfacing;
            }
            while (tfacing <= 6);
          }
        }
      }
      this.AreaStrength = new int[this.AreaCount + 1];
      this.AreaFuzzyVP = new int[this.AreaCount + 1];
      int[] numArray26 = new int[this.AreaCount + 1];
      int num34 = 1;
      do
      {
        int areaCount15 = this.AreaCount;
        for (int index49 = 1; index49 <= areaCount15; ++index49)
        {
          if (num34 == 1)
          {
            this.AreaFuzzyVP[index49] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index49].x, this.AreaCenter[index49].y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index49].x, this.AreaCenter[index49].y];
            numArray26[index49] = this.AreaFuzzyVP[index49];
          }
          else
          {
            int num35 = 0;
            int num36 = 0;
            if (index49 == 47)
              index49 = index49;
            int areaCount16 = this.AreaCount;
            for (int index50 = 1; index50 <= areaCount16; ++index50)
            {
              if ((this.AreaBorder[index49, index50] > 0 | index49 == index50) & numArray26[index50] >= numArray26[index49])
              {
                if (index49 == index50)
                {
                  num35 += 10 * numArray26[index50];
                  num36 += 10;
                }
                else if (this.AreaBorder[index49, index50] <= 5)
                {
                  num35 += 10 * numArray26[index50];
                  num36 += 10;
                }
                else if (this.AreaBorder[index49, index50] <= 10)
                {
                  num35 += 6 * numArray26[index50];
                  num36 += 6;
                }
                else if (this.AreaBorder[index49, index50] <= 15)
                {
                  num35 += 3 * numArray26[index50];
                  num36 += 3;
                }
              }
            }
            if (num36 > 0)
              this.AreaFuzzyVP[index49] = Math.Max(0, (int) Math.Round((double) num35 / (double) num36));
          }
        }
        ++num34;
      }
      while (num34 <= 2);
      int areaCount17 = this.AreaCount;
      for (int index = 0; index <= areaCount17; ++index)
      {
        if (this.AreaFuzzyVP[index] < 1)
          this.AreaFuzzyVP[index] = 1;
      }
      this.AreaDefensive = new int[this.AreaCount + 1];
      if (!Information.IsNothing((object) this.game.Data.RegimeObj[this.GetGameDataTurn()].AIDefense[0]))
      {
        int mapWidth28 = this.game.Data.MapObj[0].MapWidth;
        for (int index51 = 0; index51 <= mapWidth28; ++index51)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int index52 = 0; index52 <= mapHeight; ++index52)
          {
            int num37 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIDefense[0].Value[index51, index52];
            if (num37 > this.AreaDefensive[this.AreaMatrixNarrow[index51, index52]])
              this.AreaDefensive[this.AreaMatrixNarrow[index51, index52]] = num37;
          }
        }
      }
      this.CorpsTopRatio = new float[this.AreaCount + 1];
      if (!tlog)
        return;
      this.AddLog("");
      this.AddLog("AREA DATA CREATED:");
      int areaCount18 = this.AreaCount;
      for (int index53 = 1; index53 <= areaCount18; ++index53)
      {
        this.AddLog("");
        this.AddLog(Strings.Trim(Conversion.Str((object) index53)) + ", " + this.GetAreaName(index53, false) + " , " + Conversion.Str((object) this.AreaFuzzyVP[index53]) + " fuzzy VP, " + Strings.Trim(Conversion.Str((object) this.game.Data.MapObj[0].HexObj[this.AreaCenter[index53].x, this.AreaCenter[index53].y].VP)));
        this.AddLog("AreaDefensive is set to: " + Strings.Trim(Conversion.Str((object) this.AreaDefensive[index53])));
        this.AddLog("");
        this.AddLog("BRIDGES TOO:");
        int counter = this.AreaBridges[index53].Counter;
        for (int index54 = 0; index54 <= counter; ++index54)
          this.AddLog("* " + this.GetAreaName(this.AreaBridges[index53].Id[index54]));
        this.AddLog("");
        this.AddLog("SEABORDER TOO:");
        int seaCount = this.SeaCount;
        for (int Number = 1; Number <= seaCount; ++Number)
        {
          if (this.SeaBorder[Number, index53] > 0)
            this.AddLog("* Connection to Sea # " + Conversion.Str((object) Number));
        }
        this.AddLog("");
        this.AddLog("REGULAR BORDERS MATRIX:");
        int areaCount19 = this.AreaCount;
        for (int nr = 1; nr <= areaCount19; ++nr)
        {
          if (this.AreaBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str((object) this.AreaBorder[index53, nr])));
        }
        this.AddLog("");
        this.AddLog("NARROW BORDERS MATRIX:");
        int areaCount20 = this.AreaCount;
        for (int nr = 1; nr <= areaCount20; ++nr)
        {
          if (this.AreaNarrowBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str((object) this.AreaNarrowBorder[index53, nr])));
        }
        this.AddLog("");
        this.AddLog("BROAD BORDERS MATRIX:");
        int areaCount21 = this.AreaCount;
        for (int nr = 1; nr <= areaCount21; ++nr)
        {
          if (this.AreaBroadBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str((object) this.AreaBroadBorder[index53, nr])));
        }
        this.AddLog("");
        this.AddLog("NO BRIDGE BORDERS MATRIX:");
        int areaCount22 = this.AreaCount;
        for (int nr = 1; nr <= areaCount22; ++nr)
        {
          if (this.AreaBorder[index53, nr] > 0 | this.AreaNarrowBorder[index53, nr] > 0 | this.AreaBroadBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str((object) this.AreaBorderNoBridge[index53, nr])));
        }
      }
    }

    public void ResetExtraAreaMemory(bool tlog)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("RESET EXTRA AREA MEMORY:");
      int num1 = 0;
      do
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int Number = 0; Number <= unitCounter; ++Number)
        {
          if (this.game.Data.UnitObj[Number].X > -1 & this.game.Data.UnitObj[Number].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[Number].Regime) == this.GetGameDataTurn())
          {
            int num2;
            switch (num1)
            {
              case 0:
                num2 = this.game.Data.UnitObj[Number].AIAttack;
                break;
              case 1:
                num2 = this.game.Data.UnitObj[Number].AIFollowup;
                break;
              case 2:
                num2 = this.game.Data.UnitObj[Number].AIDefend;
                break;
              case 3:
                num2 = this.game.Data.UnitObj[Number].AIFallback;
                break;
            }
            if (num2 > this.RealAreaCount)
            {
              switch (num1)
              {
                case 0:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str((object) Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIAttack is set to attack an extra area");
                    break;
                  }
                  break;
                case 1:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str((object) Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIFollowUp is set to attack an extra area");
                    break;
                  }
                  break;
                case 2:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str((object) Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIDefend is set to attack an extra area");
                    break;
                  }
                  break;
                case 3:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str((object) Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIFallBack is set to attack an extra area");
                    break;
                  }
                  break;
              }
              int[] numArray2 = new int[this.AreaCount + 1];
              int mapWidth = this.game.Data.MapObj[0].MapWidth;
              for (int index1 = 0; index1 <= mapWidth; ++index1)
              {
                int mapHeight = this.game.Data.MapObj[0].MapHeight;
                for (int index2 = 0; index2 <= mapHeight; ++index2)
                {
                  if (this.AreaMatrixNarrow[index1, index2] > this.RealAreaCount && this.game.Data.RegimeObj[this.GetGameDataTurn()].OldAINarrow[0].Value[index1, index2] == this.game.Data.UnitObj[Number].AIAttack)
                  {
                    int[] numArray3 = numArray2;
                    int[] numArray4 = numArray3;
                    int[,] areaMatrixNarrow = this.AreaMatrixNarrow;
                    int[,] numArray5 = areaMatrixNarrow;
                    int index3 = index1;
                    int index4 = index3;
                    int index5 = index2;
                    int index6 = index5;
                    int index7 = numArray5[index4, index6];
                    int num3 = numArray3[areaMatrixNarrow[index3, index5]] + 1;
                    numArray4[index7] = num3;
                  }
                }
              }
              int nr = 0;
              int num4 = 0;
              int areaCount = this.AreaCount;
              for (int index = 0; index <= areaCount; ++index)
              {
                if (numArray2[index] > num4)
                {
                  num4 = numArray2[index];
                  nr = index;
                }
              }
              if (nr > 0)
              {
                if (num1 == 0)
                  this.game.Data.UnitObj[Number].AIAttack = nr;
                if (num1 == 1)
                  this.game.Data.UnitObj[Number].AIFollowup = nr;
                if (num1 == 2)
                  this.game.Data.UnitObj[Number].AIDefend = nr;
                if (num1 == 3)
                  this.game.Data.UnitObj[Number].AIFallback = nr;
                this.AddLog(Strings.Trim(Conversion.Str((object) Number)) + ", " + this.game.Data.UnitObj[Number].Name + " has been given area " + this.GetAreaName(nr));
              }
              else
              {
                if (num1 == 0)
                  this.game.Data.UnitObj[Number].AIAttack = -1;
                if (num1 == 1)
                  this.game.Data.UnitObj[Number].AIFollowup = -1;
                if (num1 == 2)
                  this.game.Data.UnitObj[Number].AIDefend = -1;
                if (num1 == 3)
                  this.game.Data.UnitObj[Number].AIFallback = -1;
                this.AddLog(Strings.Trim(Conversion.Str((object) Number)) + ", " + this.game.Data.UnitObj[Number].Name + " is set to attack -1");
              }
            }
          }
        }
        ++num1;
      }
      while (num1 <= 3);
    }

    public void MakeDistanceEnemyToArea(bool tlog)
    {
      int powerPointsAbsolute = this.GetAverageEnemyUnitPowerPointsAbsolute();
      int num1 = 8;
      this.AreaClosestEnemy = new int[this.AreaCount + 1];
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("MAKE DISTANCE ENEMY TO AREA:");
      int areaCount = this.AreaCount;
      for (int nr = 1; nr <= areaCount; ++nr)
      {
        int x = this.AreaCenter[nr].x;
        int y = this.AreaCenter[nr].y;
        int Number = 99;
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
        {
          this.AreaClosestEnemy[nr] = 0;
        }
        else
        {
          int num2 = x - num1;
          int num3 = x + num1;
          for (int x2 = num2; x2 <= num3; ++x2)
          {
            int num4 = y - num1;
            int num5 = y + num1;
            for (int y2 = num4; y2 <= num5; ++y2)
            {
              if (x2 > -1 & y2 > -1 & x2 <= this.game.Data.MapObj[0].MapWidth & y2 <= this.game.Data.MapObj[0].MapHeight && this.GetRegime(this.game.Data.MapObj[0].HexObj[x2, y2].Regime) != this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter > -1)
              {
                int num6 = 0;
                int unitCounter = this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter;
                for (int index = 0; index <= unitCounter; ++index)
                {
                  if ((double) this.GetUnitPower(this.game.Data.MapObj[0].HexObj[x2, y2].UnitList[index], false) > (double) powerPointsAbsolute / 10.0)
                  {
                    num6 = 1;
                    break;
                  }
                }
                if (num6 == 1)
                {
                  int num7 = this.game.HandyFunctionsObj.Distance(x, y, 0, x2, y2, 0);
                  if (num7 < Number)
                    Number = num7;
                }
              }
            }
          }
          this.AreaClosestEnemy[nr] = Number;
          if (tlog)
            this.AddLog(this.GetAreaName(nr) + " => " + Strings.Trim(Conversion.Str((object) Number)));
        }
      }
    }

    public void MakeGroups(bool tlog)
    {
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("MAKE GROUPS:");
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      this.CorpsSource = new int[this.GroupCounter + 1];
      this.CorpsTopGroup = new int[this.GroupCounter + 1];
      int areaCount1 = this.AreaCount;
      for (int index = 1; index <= areaCount1; ++index)
        numArray3[index] = -1;
      if (this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupCounter > 0)
      {
        this.GroupCounter = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupCounter;
        this.GroupType = new int[this.GroupCounter + 1];
        this.GroupHis = new int[this.GroupCounter + 1];
        this.GroupName = new string[this.GroupCounter + 1];
        this.GroupAttack = new int[this.GroupCounter + 1];
        this.GroupDefend = new int[this.GroupCounter + 1];
        this.GroupFallBack = new int[this.GroupCounter + 1];
        this.GroupFollowUp = new int[this.GroupCounter + 1];
        this.TempGroupTarget = new int[this.GroupCounter + 1];
        this.CorpsLoc = new int[this.GroupCounter + 1];
        this.CorpsTopGroup = new int[this.GroupCounter + 1];
        if (tlog)
          this.AddLog("");
        if (tlog)
          this.AddLog("IMPORT GROUPS FROM REGIME MEMORY");
        int groupCounter1 = this.GroupCounter;
        for (int Number = 0; Number <= groupCounter1; ++Number)
        {
          this.GroupType[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupType[Number];
          this.GroupName[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupName[Number];
          this.GroupHis[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupHis[Number];
          this.GroupAttack[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastAttack[Number];
          this.GroupDefend[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastDefend[Number];
          this.GroupFollowUp[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFollowUp[Number];
          this.GroupFallBack[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFallBack[Number];
          this.CorpsTopGroup[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AICorpsTopGroup[Number];
          if (tlog)
            this.AddLog(Strings.Trim(Conversion.Str((object) Number)) + ", " + this.GroupName[Number] + ", Type=" + Strings.Trim(Conversion.Str((object) this.GroupType[Number])));
        }
        if (tlog)
          this.AddLog("");
        if (tlog)
          this.AddLog("RESET UNITS THAT ARE SET TO NON-EXISTING GROUP");
        int unitCounter1 = this.game.Data.UnitCounter;
        for (int index = 0; index <= unitCounter1; ++index)
        {
          if (this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].PreDef == -1)
          {
            if (this.game.Data.UnitObj[index].AIGroup > this.GroupCounter)
            {
              this.game.Data.UnitObj[index].AIGroup = -1;
              if (tlog)
                this.AddLog(this.game.Data.UnitObj[index].Name + " has been reset to group -1");
            }
            int hq = this.game.Data.UnitObj[index].HQ;
            if (hq > -1 && this.GetRegime(this.game.Data.UnitObj[hq].Regime) != this.GetGameDataTurn())
              this.game.Data.UnitObj[index].HQ = -1;
          }
        }
        if (tlog)
          this.AddLog("");
        if (tlog)
          this.AddLog("REMOVE GROUPS DUE TO NO UNITS LEFT ASSIGNED TO IT");
        for (int groupCounter2 = this.GroupCounter; groupCounter2 >= 0; groupCounter2 += -1)
        {
          if (this.GetGroupHQ(groupCounter2) == -1)
          {
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str((object) groupCounter2)) + ", " + this.GroupName[groupCounter2] + " is being removed.");
            int num1 = groupCounter2;
            int num2 = this.GroupCounter - 1;
            for (int index = num1; index <= num2; ++index)
            {
              this.GroupType[index] = this.GroupType[index + 1];
              this.GroupName[index] = this.GroupName[index + 1];
              this.GroupAttack[index] = this.GroupAttack[index + 1];
              this.GroupDefend[index] = this.GroupDefend[index + 1];
              this.GroupFallBack[index] = this.GroupFallBack[index + 1];
              this.GroupFollowUp[index] = this.GroupFollowUp[index + 1];
              this.GroupHis[index] = this.GroupHis[index + 1];
            }
            --this.GroupCounter;
            int unitCounter2 = this.game.Data.UnitCounter;
            for (int index = 0; index <= unitCounter2; ++index)
            {
              if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup >= groupCounter2 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
                --this.game.Data.UnitObj[index].AIGroup;
            }
          }
        }
      }
      else if (this.game.Data.Round <= 1)
      {
        this.GroupType = new int[this.game.Data.UnitCounter + 1];
        this.GroupHis = new int[this.game.Data.UnitCounter + 1];
        this.GroupName = new string[this.game.Data.UnitCounter + 1];
        this.GroupAttack = new int[this.game.Data.UnitCounter + 1];
        this.GroupDefend = new int[this.game.Data.UnitCounter + 1];
        this.GroupFallBack = new int[this.game.Data.UnitCounter + 1];
        this.GroupFollowUp = new int[this.game.Data.UnitCounter + 1];
        this.TempGroupTarget = new int[this.GroupCounter + 1];
        this.CorpsLoc = new int[this.GroupCounter + 1];
        this.CorpsTopGroup = new int[this.GroupCounter + 1];
        int areaCount2 = this.AreaCount;
        for (int index = 0; index <= areaCount2; ++index)
          numArray2[index] = -1;
        this.GroupCounter = -1;
        int unitCounter = this.game.Data.UnitCounter;
        for (int index = 0; index <= unitCounter; ++index)
        {
          if (this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
            this.game.Data.UnitObj[index].AIGroup = -1;
        }
      }
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("START MAKING GROUPS AND ASSIGNING UNITS");
      }
      this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[991]);
      int unitCounter3 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter3; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup == -1 && this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].Historical > -1 && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.Data.UnitObj[unr].IsHQ)
        {
          int historical = this.game.Data.UnitObj[unr].Historical;
          ++this.GroupCounter;
          this.GroupType[this.GroupCounter] = this.game.Data.HistoricalUnitObj[historical].Type;
          this.GroupHis[this.GroupCounter] = historical;
          this.CorpsTopGroup[this.GroupCounter] = -1;
          this.GroupName[this.GroupCounter] = this.game.Data.UnitObj[unr].Name;
          this.game.Data.UnitObj[unr].AIGroup = this.GroupCounter;
          int index = this.AreaMatrixWide[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
          if (index > 0 & this.GroupType[this.GroupCounter] <= 5)
            numArray3[index] = this.GroupCounter;
          if (tlog)
            this.AddLog("(A) Created Historical Group on " + this.game.Data.UnitObj[unr].Name + ", type=" + Strings.Trim(Conversion.Str((object) this.GroupType[this.GroupCounter])));
        }
      }
      int unitCounter4 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter4; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[unr].AIGroup == -1 && !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
        {
          int index1 = this.game.Data.UnitObj[unr].HQ;
          if (this.game.Data.UnitObj[unr].IsHQ)
            index1 = -1;
          if (index1 > -1)
          {
            if (this.game.Data.UnitObj[index1].AIGroup > -1 && this.GroupType[this.game.Data.UnitObj[index1].AIGroup] <= 5 | this.game.HandyFunctionsObj.HasUnitAirSF(unr))
            {
              int historical = this.game.Data.UnitObj[index1].Historical;
              if (historical > -1)
              {
                int group = this.GetGroup(historical);
                if (group > -1)
                {
                  int x1 = this.game.Data.UnitObj[unr].X;
                  int y1 = this.game.Data.UnitObj[unr].Y;
                  int x2 = this.game.Data.UnitObj[index1].X;
                  int y2 = this.game.Data.UnitObj[index1].Y;
                  int num = 0;
                  if (this.AreaMatrixWide[x1, y1] == this.AreaMatrixWide[x2, y2])
                    num = 1;
                  if (this.AreaMatrixNarrow[x1, y1] == this.AreaMatrixWide[x2, y2])
                    num = 1;
                  if (this.AreaMatrixWide[x1, y1] == this.AreaMatrixNarrow[x2, y2])
                    num = 1;
                  if (this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0) <= 5)
                    num = 1;
                  if (this.game.HandyFunctionsObj.HasUnitAirSF(unr))
                    num = 1;
                  if (num == 1)
                  {
                    if (tlog)
                      this.AddLog("(A2) " + this.game.Data.UnitObj[unr].Name + " has been added to group " + Strings.Trim(Conversion.Str((object) group)) + " of HQ: " + this.game.Data.UnitObj[index1].Name);
                    this.game.Data.UnitObj[unr].AIGroup = group;
                  }
                }
              }
            }
          }
          else if (this.game.Data.UnitObj[unr].HQ == -1 & !this.game.Data.UnitObj[unr].IsHQ)
          {
            int index2 = this.AreaMatrixWide[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
            if (index2 < 1)
              index2 = this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
            if (index2 > 0 && numArray3[index2] > -1)
              this.game.Data.UnitObj[unr].AIGroup = numArray3[index2];
          }
        }
      }
      int groupCounter3 = this.GroupCounter;
      for (int index = 0; index <= groupCounter3; ++index)
      {
        if (this.GroupType[index] <= 5)
        {
          int groupHq = this.GetGroupHQ(index);
          if (groupHq > -1)
          {
            int unitCounter5 = this.game.Data.UnitCounter;
            for (int unr = 0; unr <= unitCounter5; ++unr)
            {
              if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X > -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == -1 & !this.game.Data.UnitObj[unr].IsHQ && !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
              {
                int x3 = this.game.Data.UnitObj[unr].X;
                int y3 = this.game.Data.UnitObj[unr].Y;
                int x4 = this.game.Data.UnitObj[groupHq].X;
                int y4 = this.game.Data.UnitObj[groupHq].Y;
                int num = 0;
                if (this.AreaMatrixWide[x3, y3] == this.AreaMatrixWide[x4, y4])
                  num = 1;
                if (this.AreaMatrixNarrow[x3, y3] == this.AreaMatrixWide[x4, y4])
                  num = 1;
                if (this.AreaMatrixWide[x3, y3] == this.AreaMatrixNarrow[x4, y4])
                  num = 1;
                if (this.GroupType[index] == 1 & this.game.HandyFunctionsObj.Distance(x3, y3, 0, x4, y4, 0) <= 5)
                  num = 1;
                else if ((double) this.game.Data.RuleVar[888] == 1.0 & this.GroupType[index] == 5 & this.game.Data.UnitObj[unr].HQ == groupHq)
                  num = 1;
                if (this.game.HandyFunctionsObj.HasUnitAirSF(unr))
                  num = 1;
                if (num == 1)
                {
                  this.game.Data.UnitObj[unr].AIGroup = index;
                  if (tlog)
                    this.AddLog("(B) " + this.game.Data.UnitObj[unr].Name + " has been added to group: " + Strings.Trim(Conversion.Str((object) index)) + ", " + this.GroupName[index]);
                }
              }
            }
          }
        }
      }
      int groupCounter4 = this.GroupCounter;
      int index3;
      for (index3 = 0; index3 <= groupCounter4; ++index3)
      {
        if (this.GroupType[index3] == 1)
        {
          int groupHq = this.GetGroupHQ(index3);
          if (groupHq > -1)
          {
            int index4 = this.AreaMatrixNarrow[this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y];
            if (index4 > -1)
            {
              numArray2[index4] = index3;
              numArray1[index4] = 1;
            }
          }
        }
      }
      int unitCounter6 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter6; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.Data.UnitObj[unr].AIGroup == -1)
        {
          int x = this.game.Data.UnitObj[unr].X;
          int y = this.game.Data.UnitObj[unr].Y;
          int nr = this.AreaMatrixNarrow[x, y];
          if (nr < 1)
            nr = this.AreaMatrixWide[x, y];
          if (nr > 0)
          {
            if (numArray1[nr] == 0)
            {
              ++this.GroupCounter;
              this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
              this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
              this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
              this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
              this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
              this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
              this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
              this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
              this.CorpsTopGroup[this.GroupCounter] = -1;
              this.GroupType[this.GroupCounter] = 1;
              this.GroupHis[this.GroupCounter] = -1;
              this.GroupName[this.GroupCounter] = "KAMPFGRUPPE " + this.GetAreaName(nr, false);
              this.game.Data.UnitObj[unr].AIGroup = this.GroupCounter;
              numArray1[nr] = 1;
              numArray2[nr] = this.GroupCounter;
              if (tlog)
                this.AddLog("(C) " + this.game.Data.UnitObj[unr].Name + " has been used to base a kampfgruppe on: " + Strings.Trim(Conversion.Str((object) index3)) + " , " + this.GroupName[index3]);
            }
            else if (numArray2[nr] > -1)
            {
              this.game.Data.UnitObj[unr].AIGroup = numArray2[nr];
              if (tlog)
                this.AddLog("(C) " + this.game.Data.UnitObj[unr].Name + " is added to existing kampfgruppe: " + Strings.Trim(Conversion.Str((object) numArray2[nr])) + " , " + this.GroupName[numArray2[nr]]);
            }
          }
        }
      }
      int[] numArray4 = new int[2];
      if ((double) this.game.Data.RuleVar[889] > 0.0)
      {
        int groupCounter5 = this.GroupCounter;
        for (int index5 = 0; index5 <= groupCounter5; ++index5)
        {
          if (this.GroupType[index5] == 5)
          {
            int[] numArray5 = new int[this.game.Data.UnitCounter + 1];
            SimpleList simpleList = new SimpleList();
            int unitCounter7 = this.game.Data.UnitCounter;
            for (int index6 = 0; index6 <= unitCounter7; ++index6)
            {
              if (this.game.Data.UnitObj[index6].X > -1 & this.game.Data.UnitObj[index6].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index6].AIGroup == index5)
              {
                int historical = this.game.Data.UnitObj[index6].Historical;
                if (historical > -1 && this.game.Data.HistoricalUnitObj[historical].Type == 2)
                {
                  numArray5[index6] = 1;
                  int tweight = 1;
                  int unitCounter8 = this.game.Data.UnitCounter;
                  for (int index7 = 0; index7 <= unitCounter8; ++index7)
                  {
                    if (this.game.Data.UnitObj[index7].PreDef == -1 & this.game.Data.UnitObj[index7].X > -1 & this.game.Data.UnitObj[index7].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index7].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index7].AIGroup == index5 && historical == this.game.Data.UnitObj[index7].Historical)
                    {
                      numArray5[index7] = 1;
                      ++tweight;
                    }
                  }
                  simpleList.Add(historical, tweight);
                }
              }
            }
            if (simpleList.Counter > 0)
            {
              int counter = simpleList.Counter;
              for (int index8 = 0; index8 <= counter; ++index8)
              {
                int index9 = simpleList.Id[index8];
                if (simpleList.Weight[index8] > 1)
                {
                  ++this.GroupCounter;
                  this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
                  this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
                  this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
                  this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
                  this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
                  this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
                  this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
                  this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
                  this.GroupType[this.GroupCounter] = 2;
                  this.GroupHis[this.GroupCounter] = index9;
                  this.CorpsTopGroup[this.GroupCounter] = index5;
                  this.GroupName[this.GroupCounter] = "Subcorps " + this.game.Data.HistoricalUnitObj[index9].Name;
                  int unitCounter9 = this.game.Data.UnitCounter;
                  for (int index10 = 0; index10 <= unitCounter9; ++index10)
                  {
                    if (this.game.Data.UnitObj[index10].Historical == index9)
                      this.game.Data.UnitObj[index10].AIGroup = this.GroupCounter;
                  }
                  if (tlog)
                    this.AddLog("(D) Created Subcorps Group on " + this.GroupName[this.GroupCounter] + ", type=" + Strings.Trim(Conversion.Str((object) this.GroupType[this.GroupCounter])));
                }
              }
            }
          }
        }
      }
      if (this.GroupCounter > -1)
      {
        this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
        this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
        this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
        this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
        this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
        this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
        this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
        this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
        this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
      }
      this.CorpsStrength = new int[this.GroupCounter + 1];
      this.CorpsAirStrength = new int[this.GroupCounter + 1];
      this.CorpsTempAirStrength = new int[this.GroupCounter + 1];
    }

    public void MakeCorpsAndAreaAssesment(bool tlog)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      this.HisAreaDistance = new int[this.GroupCounter + 1, this.AreaCount + 1];
      this.HisAreaDistanceFriendly = new int[this.GroupCounter + 1, this.AreaCount + 1];
      this.CorpsStartLoc = new int[this.GroupCounter + 1];
      this.CorpsEngineer = new bool[this.GroupCounter + 1];
      this.CorpsLandStrength = new int[this.GroupCounter + 1];
      this.CorpsAirStrength = new int[this.GroupCounter + 1];
      this.CorpsBottleneck = new int[this.GroupCounter + 1];
      this.CorpsOldDefend = new int[this.GroupCounter + 1];
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("CORPS STRENGTH ASSESMENT");
      }
      int groupCounter1 = this.GroupCounter;
      for (int grp = 0; grp <= groupCounter1; ++grp)
      {
        this.CorpsOldDefend[grp] = -1;
        int Number1 = 0;
        int Number2 = 0;
        int num1 = 0;
        int num2 = 0;
        int num3 = 1;
        SimpleList simpleList = new SimpleList();
        int unitCounter = this.game.Data.UnitCounter;
        for (int unr = 0; unr <= unitCounter; ++unr)
        {
          if (this.game.Data.UnitObj[unr].AIBottleneck > 0)
            unr = unr;
          if (this.game.Data.UnitObj[unr].PreDef == -1 && !this.game.Data.UnitObj[unr].IsHQ & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup == grp)
          {
            int unitPower = this.GetUnitPower(unr, true, Theater: 0);
            if (this.game.Data.UnitObj[unr].TempCategory == 1)
              num3 += unitPower;
            int num4 = unitPower + (int) Math.Round((double) unitPower * ((double) this.GetAIRolePercent(unr, 10) / 200.0));
            int num5 = num4 + (int) Math.Round((double) num4 * ((double) this.GetAIRolePercent(unr, 8) / 100.0));
            Number1 += num5;
            Number2 += this.GetUnitPower(unr, true, Theater: 2);
            num1 += this.game.HandyFunctionsObj.GetUnitEPGrowth(unr);
            if (this.game.Data.UnitObj[unr].TempCategory == 1)
            {
              int[] corpsLandStrength = this.CorpsLandStrength;
              int[] numArray4 = corpsLandStrength;
              int index1 = grp;
              int index2 = index1;
              int num6 = corpsLandStrength[index1] + num5;
              numArray4[index2] = num6;
            }
            if (this.game.Data.UnitObj[unr].AIBottleneck > 0)
              num2 += this.game.Data.UnitObj[unr].AIBottleneck * num5;
            int aiDefend = this.game.Data.UnitObj[unr].AIDefend;
            if (aiDefend > -1)
            {
              int nr = simpleList.FindNr(aiDefend);
              if (nr == -1)
              {
                simpleList.Add(aiDefend, 1);
              }
              else
              {
                int[] weight = simpleList.Weight;
                int[] numArray5 = weight;
                int index3 = nr;
                int index4 = index3;
                int num7 = weight[index3] + 1;
                numArray5[index4] = num7;
              }
            }
          }
        }
        if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 1.0)
          Number1 = (int) Math.Round((double) ((float) Number1 * (1f / this.game.Data.RegimeObj[this.game.Data.Turn].AIConservative)));
        this.CorpsStrength[grp] = Number1;
        this.CorpsBottleneck[grp] = (int) Math.Round((double) num2 / (double) num3) >= 10 ? ((int) Math.Round((double) num2 / (double) num3) >= 20 ? ((int) Math.Round((double) num2 / (double) num3) >= 30 ? ((int) Math.Round((double) num2 / (double) num3) >= 50 ? ((int) Math.Round((double) num2 / (double) num3) >= 80 ? 15 : 25) : 40) : 60) : 75) : 0;
        simpleList.Sort();
        this.CorpsOldDefend[grp] = -1;
        if (simpleList.Counter > -1)
          this.CorpsOldDefend[grp] = simpleList.Id[simpleList.Counter];
        this.CorpsAirStrength[grp] = Number2;
        if (num1 >= 50)
          this.CorpsEngineer[grp] = true;
        this.CorpsStartLoc[grp] = this.GetStartArea(grp);
        Coordinate averageCorpsUnitCoord1 = this.GetAverageCorpsUnitCoord(grp);
        if (tlog)
        {
          this.AddLog("");
          this.AddLog(this.GroupName[grp] + " ==> STARTLOC = " + this.GetAreaName(this.GetStartArea(grp)) + " ... CORPSSTRENGTH=" + Conversion.Str((object) Number1) + ", CORPSAIRSTRENGTH=" + Conversion.Str((object) Number2) + "  Engineer=" + Conversion.Str((object) this.CorpsEngineer[grp]) + "   (avgloc=" + Conversion.Str((object) averageCorpsUnitCoord1.x) + "," + Conversion.Str((object) averageCorpsUnitCoord1.y) + ")");
        }
        if (tlog)
        {
          this.AddLog("");
          this.AddLog(this.GroupName[grp] + " ==> OLDDEFENDAREA = " + this.GetAreaName(this.CorpsOldDefend[grp]) + " ... BOTTLENECK=" + Conversion.Str((object) this.CorpsBottleneck[grp]));
        }
        Coordinate averageCorpsUnitCoord2 = this.GetAverageCorpsUnitCoord(grp, ReturnRoadHex: true);
        int moveTypeCorpsUnit = this.GetAverageMoveTypeCorpsUnit(grp);
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, moveTypeCorpsUnit, 0, 600, averageCorpsUnitCoord2.x, averageCorpsUnitCoord2.y, 0, dontenterenemy: false, NoBridgePenalty: true);
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("HISAREADISTANCE:");
        }
        int areaCount1 = this.AreaCount;
        for (int nr = 1; nr <= areaCount1; ++nr)
        {
          this.HisAreaDistance[grp, nr] = this.game.EditObj.TempValue[0].Value[this.AreaCenter[nr].x, this.AreaCenter[nr].y];
          if (this.HisAreaDistance[grp, nr] < 9999 && tlog)
            this.AddLog(this.GetAreaName(nr) + " => AP cost = " + Conversion.Str((object) this.HisAreaDistance[grp, nr]));
        }
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, moveTypeCorpsUnit, 0, 600, averageCorpsUnitCoord2.x, averageCorpsUnitCoord2.y, 0, NoBridgePenalty: true);
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("HISAREADISTANCE FRIENDLY:");
        }
        int areaCount2 = this.AreaCount;
        for (int nr = 1; nr <= areaCount2; ++nr)
        {
          this.HisAreaDistanceFriendly[grp, nr] = this.game.EditObj.TempValue[0].Value[this.AreaCenter[nr].x, this.AreaCenter[nr].y];
          if (this.HisAreaDistanceFriendly[grp, nr] < 9999 && tlog)
            this.AddLog(this.GetAreaName(nr) + " => AP cost (friendly) = " + Conversion.Str((object) this.HisAreaDistance[grp, nr]));
        }
      }
      this.AreaStrength = new int[this.AreaCount + 1];
      int[] numArray6 = new int[this.AreaCount + 1];
      int[] numArray7 = new int[this.AreaCount + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index5 = 0; index5 <= mapWidth1; ++index5)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index6 = 0; index6 <= mapHeight; ++index6)
        {
          int num8 = this.AreaMatrixNarrow[index5, index6];
          if (num8 > 0)
          {
            int unitCounter = this.game.Data.MapObj[0].HexObj[index5, index6].UnitCounter;
            for (int index7 = 0; index7 <= unitCounter; ++index7)
            {
              int unit = this.game.Data.MapObj[0].HexObj[index5, index6].UnitList[index7];
              if (this.GetRegime(this.game.Data.UnitObj[unit].Regime) != this.GetGameDataTurn())
              {
                int unitPower = this.GetUnitPower(unit, false, WithoutEntrench: true);
                int[] areaStrength = this.AreaStrength;
                int[] numArray8 = areaStrength;
                int index8 = num8;
                int index9 = index8;
                int num9 = areaStrength[index8] + unitPower;
                numArray8[index9] = num9;
                if (this.game.Data.UnitObj[unit].LastSupplyPercent > -1)
                {
                  int[] numArray9 = numArray6;
                  int[] numArray10 = numArray9;
                  int index10 = num8;
                  int index11 = index10;
                  int num10 = numArray9[index10] + unitPower * this.game.Data.UnitObj[unit].LastSupplyPercent;
                  numArray10[index11] = num10;
                }
              }
            }
          }
        }
      }
      this.StartEnemySupplyGone = new int[this.AreaCount + 1];
      int areaCount3 = this.AreaCount;
      for (int index12 = 1; index12 <= areaCount3; ++index12)
      {
        this.StartEnemySupplyGone[index12] = 0;
        if (this.AreaStrength[index12] > 0 & this.game.Data.Round > 1)
        {
          int num = (int) Math.Round((double) numArray6[index12] / (double) this.AreaStrength[index12]);
          if (num < 10)
            this.StartEnemySupplyGone[index12] = 2;
          else if (num < 50)
            this.StartEnemySupplyGone[index12] = 1;
        }
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index12].x, this.AreaCenter[index12].y].Regime) != this.GetGameDataTurn())
        {
          int num11 = 0;
          int areaCount4 = this.AreaCount;
          for (int index13 = 1; index13 <= areaCount4; ++index13)
          {
            if (this.AreaNarrowBorder[index13, index12] > 0 & this.AreaNarrowBorder[index13, index12] < 99 & index13 != index12 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index13].x, this.AreaCenter[index13].y].Regime) != this.GetGameDataTurn())
              ++num11;
          }
          if (num11 > 0)
          {
            int areaCount5 = this.AreaCount;
            for (int index14 = 1; index14 <= areaCount5; ++index14)
            {
              if (this.AreaNarrowBorder[index14, index12] > 0 & this.AreaNarrowBorder[index14, index12] < 99 & index14 != index12 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index14].x, this.AreaCenter[index14].y].Regime) != this.GetGameDataTurn())
              {
                int[] numArray11 = numArray1;
                int[] numArray12 = numArray11;
                int index15 = index14;
                int index16 = index15;
                int num12 = numArray11[index15] + (int) Math.Round((double) this.AreaStrength[index12] / 3.0 / (double) num11);
                numArray12[index16] = num12;
                int[] numArray13 = numArray1;
                int[] numArray14 = numArray13;
                int index17 = index12;
                int index18 = index17;
                int num13 = numArray13[index17] - (int) Math.Round((double) this.AreaStrength[index12] / 3.0 / (double) num11);
                numArray14[index18] = num13;
              }
            }
          }
        }
      }
      int areaCount6 = this.AreaCount;
      for (int index19 = 1; index19 <= areaCount6; ++index19)
      {
        int[] areaStrength = this.AreaStrength;
        int[] numArray15 = areaStrength;
        int index20 = index19;
        int index21 = index20;
        int num = areaStrength[index20] + numArray1[index19];
        numArray15[index21] = num;
      }
      this.AddLog("AREA STRENGTH ASSESMENT");
      this.AreaSupplyBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreasupplyborderSea = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaSupplyBorderEither = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaSupplyBorderCount = new int[this.AreaCount + 1];
      if (tlog)
        this.AddLog("SUPPLYBORDER:");
      int areaCount7 = this.AreaCount;
      for (int nr = 1; nr <= areaCount7; ++nr)
      {
        this.AreaSupplyBorderCount[nr] = -1;
        int areaCount8 = this.AreaCount;
        for (int index22 = 1; index22 <= areaCount8; ++index22)
        {
          int num14 = 0;
          if (this.AreaNarrowBorder[nr, index22] > 0)
          {
            num14 = 1;
            int[] supplyBorderCount = this.AreaSupplyBorderCount;
            int[] numArray16 = supplyBorderCount;
            int index23 = nr;
            int index24 = index23;
            int num15 = supplyBorderCount[index23] + 1;
            numArray16[index24] = num15;
            this.AreaSupplyBorder[nr, this.AreaSupplyBorderCount[nr]] = index22;
            this.AreaSupplyBorderEither[nr, this.AreaSupplyBorderCount[nr]] = index22;
            if (tlog)
              this.AddLog("SUPPLY BORDER: " + this.GetAreaName(nr) + "," + this.GetAreaName(index22));
          }
          if (this.AreaSeaConnect(nr, index22))
          {
            if (num14 == 0)
            {
              int[] supplyBorderCount = this.AreaSupplyBorderCount;
              int[] numArray17 = supplyBorderCount;
              int index25 = nr;
              int index26 = index25;
              int num16 = supplyBorderCount[index25] + 1;
              numArray17[index26] = num16;
            }
            this.AreasupplyborderSea[nr, this.AreaSupplyBorderCount[nr]] = index22;
            this.AreaSupplyBorderEither[nr, this.AreaSupplyBorderCount[nr]] = index22;
            if (tlog)
              this.AddLog("SUPPLY BORDER SEA/ EITHER: " + this.GetAreaName(nr) + "," + this.GetAreaName(index22));
          }
        }
      }
      if (tlog)
        this.AddLog("AREASTRENGTH:");
      int upperBound = this.AreaStrength.GetUpperBound(0);
      for (int Number = 1; Number <= upperBound; ++Number)
      {
        string hexName = this.game.HandyFunctionsObj.GetHexName(this.AreaCenter[Number].x, this.AreaCenter[Number].y, 0);
        if (this.AreaStrength[Number] > 0 & tlog)
          this.AddLog(Conversion.Str((object) Number) + ") " + hexName + " ==> " + Conversion.Str((object) this.AreaStrength[Number]) + ", EnemySupplyGone = " + Conversion.Str((object) this.StartEnemySupplyGone[Number]));
      }
      this.AreaSteps = new int[this.AreaCount + 1, this.AreaCount + 1];
      int areaCount9 = this.AreaCount;
      for (int from = 1; from <= areaCount9; ++from)
      {
        int areaCount10 = this.AreaCount;
        for (int too = 1; too <= areaCount10; ++too)
          this.AreaSteps[from, too] = from == too ? 9999 : this.GetAreaBorderSteps(from, too, 20);
      }
      int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
      int num17;
      int num18;
      for (int index27 = 0; index27 <= mapWidth2; ++index27)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index28 = 0; index28 <= mapHeight; ++index28)
        {
          if (this.game.Data.MapObj[0].HexObj[index27, index28].VP > 0 | this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index27, index28] > 0)
          {
            num17 += this.game.Data.MapObj[0].HexObj[index27, index28].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index27, index28];
            ++num18;
          }
          if (this.AreaMatrixNarrow[index27, index28] == 0)
            this.AreaMatrixNarrow[index27, index28] = this.AreaMatrixWide[index27, index28];
        }
      }
      this.AverageAreaEntrench = new int[this.AreaCount + 1];
      int areaCount11 = this.AreaCount;
      for (int Area = 1; Area <= areaCount11; ++Area)
        this.AverageAreaEntrench[Area] = this.GetAverageAreaEntrench(Area);
      this.AverageVP = num18 != 0 ? (int) Math.Round((double) num17 / (double) num18) : 0;
      this.TempGroupHQ = new int[this.GroupCounter + 1];
      int groupCounter2 = this.GroupCounter;
      for (int grp = 0; grp <= groupCounter2; ++grp)
        this.TempGroupHQ[grp] = this.GetGroupHQ(grp);
    }

    public void ReOrderGroups(bool alllog)
    {
      int[] arySrc = new int[this.GroupCounter + 1];
      this.CorpsStrength = new int[this.GroupCounter + 1];
      this.MakeTempCategories(false);
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      this.FriendlySupply = new int[this.AreaCount + 1];
      this.EnemySupply = new int[this.AreaCount + 1];
      this.atemp2 = new int[this.AreaCount + 1];
      if (alllog)
      {
        this.AddLog("REORDER GROUPS");
        this.AddLog("");
      }
      if (alllog)
        this.AddLog("");
      if (alllog)
        this.AddLog("Supply Providing Areas:");
      int num1;
      int num2;
      if ((double) this.game.Data.RuleVar[335] > 0.0)
      {
        int num3 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num3 * 4)))] > 0)
          {
            int nr = this.AreaMatrixWide[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num3 * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num3 * 4)))]];
            num1 = 0;
            if (nr > 0 && nr > 0 & this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime) == this.GetGameDataTurn())
            {
              num1 = 1;
              this.atemp2[nr] = 1;
              this.FriendlySupply[nr] = 1;
              if (alllog)
                this.AddLog(this.GetAreaName(nr));
            }
            num2 = 0;
          }
          ++num3;
        }
        while (num3 <= 3);
      }
      else
      {
        int areaCount = this.AreaCount;
        for (int index = 0; index <= areaCount; ++index)
        {
          if (this.IsAreaSupplySource(index, this.game.Data.Turn))
          {
            num1 = 1;
            this.atemp2[index] = 1;
            this.FriendlySupply[index] = 1;
            if (alllog)
              this.AddLog(this.GetAreaName(index));
          }
        }
      }
      if (alllog)
        this.AddLog("");
      if (alllog)
        this.AddLog("Areas in supply:");
      while (num1 == 1)
      {
        num1 = 0;
        ++num2;
        int areaCount = this.AreaCount;
        for (int nr = 1; nr <= areaCount; ++nr)
        {
          if (this.atemp2[nr] == num2)
          {
            int num4 = this.AreaSupplyBorderCount[nr];
            for (int index1 = 0; index1 <= num4; ++index1)
            {
              int index2 = this.AreaSupplyBorderEither[nr, index1];
              if (this.atemp2[index2] == 0 && (this.AreaNarrowBorder[nr, index2] > 0 | this.AreaSeaConnect(nr, index2)) & nr != index2 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime) == this.GetGameDataTurn())
              {
                this.atemp2[index2] = this.atemp2[nr] + 1;
                num1 = 1;
                this.FriendlySupply[index2] = 1;
                if (alllog)
                  this.AddLog(this.GetAreaName(index2));
              }
            }
          }
        }
      }
      if (alllog)
        this.AddLog("");
      if (alllog)
        this.AddLog("Re-ordering of groups:");
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter1; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index].AIGroup > -1 & !this.game.Data.UnitObj[index].IsHQ & this.game.Data.UnitObj[index].TempCategory == 1 && this.game.Data.UnitObj[index].AIGroup > this.GroupCounter)
        {
          this.GroupCounter = this.game.Data.UnitObj[index].AIGroup;
          this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
          this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
          this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
          this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
          this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
          this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
          this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
          this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
          this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
          this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
          arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
        }
      }
      int unitCounter2 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter2; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup > -1 & !this.game.Data.UnitObj[unr].IsHQ & this.game.Data.UnitObj[unr].TempCategory == 1)
        {
          if (this.game.Data.UnitObj[unr].TempGroup == -1)
          {
            int[] numArray3 = arySrc;
            int[] numArray4 = numArray3;
            int aiGroup1 = this.game.Data.UnitObj[unr].AIGroup;
            int index3 = aiGroup1;
            int num5 = numArray3[aiGroup1] + 1;
            numArray4[index3] = num5;
            int[] corpsStrength = this.CorpsStrength;
            int[] numArray5 = corpsStrength;
            int aiGroup2 = this.game.Data.UnitObj[unr].AIGroup;
            int index4 = aiGroup2;
            int num6 = corpsStrength[aiGroup2] + this.GetUnitPower(unr, false);
            numArray5[index4] = num6;
          }
          else
          {
            int[] numArray6 = arySrc;
            int[] numArray7 = numArray6;
            int tempGroup1 = this.game.Data.UnitObj[unr].TempGroup;
            int index5 = tempGroup1;
            int num7 = numArray6[tempGroup1] + 1;
            numArray7[index5] = num7;
            int[] corpsStrength = this.CorpsStrength;
            int[] numArray8 = corpsStrength;
            int tempGroup2 = this.game.Data.UnitObj[unr].TempGroup;
            int index6 = tempGroup2;
            int num8 = corpsStrength[tempGroup2] + this.GetUnitPower(unr, false);
            numArray8[index6] = num8;
          }
        }
      }
      int areaCount1 = this.AreaCount;
      for (int index = 1; index <= areaCount1; ++index)
        this.AreaOwner[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime;
      for (int groupCounter1 = this.GroupCounter; groupCounter1 >= 0; groupCounter1 += -1)
      {
        if (this.GroupType[groupCounter1] < 1 | (this.GroupType[groupCounter1] == 1 | this.GroupType[groupCounter1] == 5) & (double) this.game.Data.RuleVar[800] == 1.0)
        {
          int groupCounter2 = this.GroupCounter;
          for (int index7 = 0; index7 <= groupCounter2; ++index7)
          {
            if (this.CorpsSource[groupCounter1] == this.CorpsSource[index7] & groupCounter1 != index7 & this.GroupType[index7] <= 5 && arySrc[groupCounter1] + arySrc[index7] <= 40 && this.CorpsTarget[groupCounter1] == this.CorpsTarget[index7] & this.CorpsStartLoc[groupCounter1] == this.CorpsStartLoc[index7])
            {
              int index8;
              int grp;
              if (this.GroupType[index7] < 5)
              {
                index8 = index7;
                grp = groupCounter1;
              }
              else
              {
                index8 = groupCounter1;
                grp = index7;
              }
              int groupHq = this.GetGroupHQ(grp);
              if (groupHq > -1 && !this.HasThisHQNoSplit(groupHq))
              {
                if (alllog)
                  this.AddLog("REMOVING group " + this.GroupName[index8] + " by adding it to " + this.GroupName[grp]);
                if (alllog)
                  this.AddLog("we do this when a kampfgruppe (not a corps) is exactly mirroring a regular corps or other kampfgruppe group in defend and attack");
                int[] numArray9 = arySrc;
                int[] numArray10 = numArray9;
                int index9 = grp;
                int index10 = index9;
                int num9 = numArray9[index9] + arySrc[index8];
                numArray10[index10] = num9;
                int unitCounter3 = this.game.Data.UnitCounter;
                for (int index11 = 0; index11 <= unitCounter3; ++index11)
                {
                  if (this.game.Data.UnitObj[index11].PreDef == -1 && this.game.Data.UnitObj[index11].AIGroup == index8 | this.game.Data.UnitObj[index11].AIGroup == grp & this.game.Data.UnitObj[index11].TempGroup == index8 && this.GetRegime(this.game.Data.UnitObj[index11].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index11].PreDef == -1)
                  {
                    this.game.Data.UnitObj[index11].AIGroup = grp;
                    this.game.Data.UnitObj[index11].TempGroup = -1;
                    this.game.Data.UnitObj[index11].AIAttack = this.game.Data.UnitObj[groupHq].AIAttack;
                    this.game.Data.UnitObj[index11].AIDefend = this.game.Data.UnitObj[groupHq].AIDefend;
                    this.game.Data.UnitObj[index11].AIFollowup = this.game.Data.UnitObj[groupHq].AIFollowup;
                    this.game.Data.UnitObj[index11].AIFallback = this.game.Data.UnitObj[groupHq].AIFallback;
                    this.game.Data.UnitObj[index11].AIAttackStyle = this.game.Data.UnitObj[groupHq].AIAttackStyle;
                    this.game.Data.UnitObj[index11].AILeftFlank = this.game.Data.UnitObj[groupHq].AILeftFlank;
                    this.game.Data.UnitObj[index11].AIRightFlank = this.game.Data.UnitObj[groupHq].AIRightFlank;
                  }
                }
                int unitCounter4 = this.game.Data.UnitCounter;
                for (int index12 = 0; index12 <= unitCounter4; ++index12)
                {
                  if (this.game.Data.UnitObj[index12].PreDef == -1 && this.game.Data.UnitObj[index12].AIGroup != grp & this.game.Data.UnitObj[index12].TempGroup == index8 && this.GetRegime(this.game.Data.UnitObj[index12].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index12].PreDef == -1)
                    this.game.Data.UnitObj[index12].TempGroup = -1;
                }
                int[] corpsStrength = this.CorpsStrength;
                int[] numArray11 = corpsStrength;
                int index13 = grp;
                int index14 = index13;
                int num10 = corpsStrength[index13] + this.CorpsStrength[index8];
                numArray11[index14] = num10;
                int num11 = index8;
                int num12 = this.GroupCounter - 1;
                for (int index15 = num11; index15 <= num12; ++index15)
                {
                  this.GroupType[index15] = this.GroupType[index15 + 1];
                  this.GroupName[index15] = this.GroupName[index15 + 1];
                  this.GroupHis[index15] = this.GroupHis[index15 + 1];
                  this.CorpsTarget[index15] = this.CorpsTarget[index15 + 1];
                  this.CorpsSource[index15] = this.CorpsSource[index15 + 1];
                  this.CorpsStrength[index15] = this.CorpsStrength[index15 + 1];
                  this.CorpsEngineer[index15] = this.CorpsEngineer[index15 + 1];
                  this.CorpsStance[index15] = this.CorpsStance[index15 + 1];
                  this.CorpsStartLoc[index15] = this.CorpsStartLoc[index15 + 1];
                  this.CorpsLandStrength[index15] = this.CorpsLandStrength[index15 + 1];
                }
                --this.GroupCounter;
                int unitCounter5 = this.game.Data.UnitCounter;
                for (int index16 = 0; index16 <= unitCounter5; ++index16)
                {
                  if (this.game.Data.UnitObj[index16].PreDef == -1)
                  {
                    if (this.game.Data.UnitObj[index16].AIGroup >= index8 & this.GetRegime(this.game.Data.UnitObj[index16].Regime) == this.GetGameDataTurn())
                      --this.game.Data.UnitObj[index16].AIGroup;
                    if (this.game.Data.UnitObj[index16].AILeftFlank >= index8 & this.GetRegime(this.game.Data.UnitObj[index16].Regime) == this.GetGameDataTurn())
                      --this.game.Data.UnitObj[index16].AILeftFlank;
                    if (this.game.Data.UnitObj[index16].AIRightFlank >= index8 & this.GetRegime(this.game.Data.UnitObj[index16].Regime) == this.GetGameDataTurn())
                      --this.game.Data.UnitObj[index16].AIRightFlank;
                  }
                }
                break;
              }
            }
          }
        }
      }
      int groupCounter3 = this.GroupCounter;
      for (int index = 0; index <= groupCounter3; ++index)
        arySrc[index] = 0;
      int unitCounter6 = this.game.Data.UnitCounter;
      for (int index17 = 0; index17 <= unitCounter6; ++index17)
      {
        if (this.game.Data.UnitObj[index17].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index17].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index17].AIGroup > -1 & !this.game.Data.UnitObj[index17].IsHQ & this.game.Data.UnitObj[index17].TempCategory == 1)
        {
          if (this.game.Data.UnitObj[index17].TempGroup == -1)
          {
            int[] numArray12 = arySrc;
            int[] numArray13 = numArray12;
            int aiGroup = this.game.Data.UnitObj[index17].AIGroup;
            int index18 = aiGroup;
            int num13 = numArray12[aiGroup] + 1;
            numArray13[index18] = num13;
          }
          else
          {
            int[] numArray14 = arySrc;
            int[] numArray15 = numArray14;
            int tempGroup = this.game.Data.UnitObj[index17].TempGroup;
            int index19 = tempGroup;
            int num14 = numArray14[tempGroup] + 1;
            numArray15[index19] = num14;
          }
        }
      }
      int num15;
      float ratioOnArea;
      if ((double) this.game.Data.RuleVar[827] == 0.0 | (double) this.game.Data.RuleVar[827] == 2.0 & this.Attacker)
      {
        int areaCount2 = this.AreaCount;
        for (int index20 = 1; index20 <= areaCount2; ++index20)
        {
          if (this.GetRegime(this.AreaOwner[index20]) == this.GetGameDataTurn())
          {
            int areaCount3 = this.AreaCount;
            for (int index21 = 1; index21 <= areaCount3; ++index21)
            {
              if (this.AreaStartEnemy[index21] > 0 & this.AreaOwner[index21] > -1 & this.FriendlySupply[index21] == this.FriendlySupply[index20] && this.AreaNarrowBorder[index20, index21] > 0 & this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.AreaOwner[index21]))
              {
                int num16 = 0;
                int groupCounter4 = this.GroupCounter;
                for (int index22 = 0; index22 <= groupCounter4; ++index22)
                {
                  if (this.CorpsSource[index22] == index20 | this.CorpsTarget[index22] == index20 | this.CorpsStartLoc[index22] == index20)
                    num16 = 1;
                }
                if (num16 == 0)
                {
                  SimpleList simpleList1 = new SimpleList();
                  int groupCounter5 = this.GroupCounter;
                  for (int index23 = 0; index23 <= groupCounter5; ++index23)
                  {
                    if (this.CorpsSource[index23] > -1 & this.CorpsStrength[index23] > 0 & arySrc[index23] > 3 && !this.HasThisHQNoSplit(this.GetGroupHQ(index23)) && this.GetAbsoluteTempUnits(index23) < 1)
                    {
                      int areaStep = this.AreaSteps[this.CorpsSource[index23], index20];
                      if (areaStep > 0 & (areaStep <= 1 & this.Attacker | areaStep <= 2 & !this.Attacker))
                      {
                        int num17 = this.CorpsStrength[index23];
                        simpleList1.Add(index23, num17 * areaStep);
                      }
                    }
                  }
                  if (simpleList1.Counter > -1)
                  {
                    simpleList1.Sort();
                    int index24 = simpleList1.Id[0];
                    ++this.GroupCounter;
                    this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
                    this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
                    this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
                    this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
                    this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
                    this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
                    arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
                    this.GroupName[this.GroupCounter] = "ALARMGROUP " + this.GetAreaName(index20, false);
                    this.GroupType[this.GroupCounter] = 1;
                    this.GroupHis[this.GroupCounter] = -1;
                    this.CorpsSource[this.GroupCounter] = index20;
                    this.CorpsTopGroup[this.GroupCounter] = -1;
                    this.CorpsTarget[this.GroupCounter] = -1;
                    this.CorpsStrength[this.GroupCounter] = 0;
                    this.CorpsStance[this.GroupCounter] = 1;
                    this.CorpsEngineer[this.GroupCounter] = false;
                    int groupCounter6 = this.GroupCounter;
                    if (alllog)
                      this.AddLog("SPLITTING group " + this.GroupName[index24] + " and creating " + this.GroupName[groupCounter6]);
                    if (alllog)
                      this.AddLog("we do this when there is a threatened area with no group defending this.");
                    SimpleList simpleList2 = new SimpleList();
                    int unitCounter7 = this.game.Data.UnitCounter;
                    for (int tid = 0; tid <= unitCounter7; ++tid)
                    {
                      if (this.game.Data.UnitObj[tid].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[tid].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[tid].AIGroup == index24 & !this.game.Data.UnitObj[tid].IsHQ && this.game.Data.UnitObj[tid].TempCategory != 3)
                      {
                        int tweight = 100 * this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y, 0, this.AreaCenter[index20].x, this.AreaCenter[index20].y, 0);
                        if (this.game.Data.UnitObj[tid].TempCategory == 1)
                          tweight = (int) Math.Round((double) tweight / 10.0);
                        simpleList2.Add(tid, tweight);
                      }
                    }
                    int num18 = 0;
                    int num19 = 0;
                    int num20 = 0;
                    int num21 = 0;
                    num15 = 0;
                    ratioOnArea = this.GetRatioOnArea(index20);
                    simpleList2.Sort();
                    if (simpleList2.Counter > -1)
                    {
                      int counter1 = simpleList2.Counter;
                      for (int index25 = 0; index25 <= counter1; ++index25)
                      {
                        if (simpleList2.Data1[index25] != 1)
                        {
                          ++num19;
                          if ((double) num18 <= (double) this.CorpsStrength[index24] / 3.0 & num18 * 2 <= this.GetEnemyOnArea(index20))
                          {
                            if (this.game.Data.UnitObj[simpleList2.Id[index25]].Historical > -1)
                            {
                              int counter2 = simpleList2.Counter;
                              for (int index26 = 0; index26 <= counter2; ++index26)
                              {
                                if (simpleList2.Data1[index26] != 1 && this.game.Data.UnitObj[simpleList2.Id[index25]].Historical == this.game.Data.UnitObj[simpleList2.Id[index26]].Historical && (double) num18 <= (double) this.CorpsStrength[index24] / 3.0 & num18 * 2 < this.GetEnemyOnArea(index20))
                                {
                                  ++num21;
                                  num18 += this.GetUnitPower(simpleList2.Id[index25], false);
                                  num20 += this.GetUnitPower(simpleList2.Id[index25], false);
                                  if (alllog)
                                    this.AddLog("SPLITTING HIS.UNIT " + this.game.Data.UnitObj[simpleList2.Id[index26]].Name);
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIGroup = groupCounter6;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIAttack = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIDefend = index20;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIFollowup = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIFallback = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AILeftFlank = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIRightFlank = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIAttackStyle = 1;
                                  simpleList2.Data1[index26] = 1;
                                }
                              }
                            }
                            else
                            {
                              num18 += this.GetUnitPower(simpleList2.Id[index25], false);
                              num20 += this.GetUnitPower(simpleList2.Id[index25], false);
                              ++num21;
                              if (alllog)
                                this.AddLog("SPLITTING UNIT " + this.game.Data.UnitObj[simpleList2.Id[index25]].Name);
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIGroup = groupCounter6;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIAttack = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIDefend = index20;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIFollowup = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIFallback = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AILeftFlank = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIRightFlank = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIAttackStyle = 1;
                              simpleList2.Data1[index25] = 1;
                            }
                          }
                        }
                      }
                    }
                    if (num21 == 0)
                    {
                      if (alllog)
                        this.AddLog("IMMEDIATLY REMOVING AGAIN BCAUESE WE COULD FIND NO UNITS");
                      --this.GroupCounter;
                    }
                    int[] numArray16 = arySrc;
                    int[] numArray17 = numArray16;
                    int index27 = index24;
                    int index28 = index27;
                    int num22 = numArray16[index27] - num21;
                    numArray17[index28] = num22;
                    int[] corpsStrength = this.CorpsStrength;
                    int[] numArray18 = corpsStrength;
                    int index29 = index24;
                    int index30 = index29;
                    int num23 = corpsStrength[index29] - num20;
                    numArray18[index30] = num23;
                    if (0 > this.CorpsStrength[index24])
                      this.CorpsStrength[index24] = 0;
                  }
                }
              }
            }
          }
        }
      }
      if ((double) this.game.Data.RuleVar[827] == 0.0 && this.Attacker)
      {
        int areaCount4 = this.AreaCount;
        for (int index31 = 1; index31 <= areaCount4; ++index31)
        {
          if (this.GetRegime(this.AreaOwner[index31]) != this.GetGameDataTurn())
          {
            int areaCount5 = this.AreaCount;
            for (int nr = 1; nr <= areaCount5; ++nr)
            {
              if (this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.AreaOwner[index31]) & this.AreaNarrowBorder[index31, nr] > 0)
              {
                int num24 = 0;
                int groupCounter7 = this.GroupCounter;
                for (int index32 = 0; index32 <= groupCounter7; ++index32)
                {
                  if (this.GroupType[index32] <= 5 & this.CorpsSource[index32] == nr & this.CorpsTarget[index32] == index31)
                    num24 = 1;
                  if (this.GroupType[index32] <= 5 & this.CorpsSource[index32] == nr & (this.CorpsTarget[index32] == -1 | this.CorpsTarget[index32] == nr))
                    num24 = 1;
                }
                if (num24 == 0 & (double) this.GetRatioOnArea(index31) < 2.5)
                {
                  SimpleList simpleList3 = new SimpleList();
                  int groupCounter8 = this.GroupCounter;
                  for (int index33 = 0; index33 <= groupCounter8; ++index33)
                  {
                    if (this.CorpsSource[index33] > -1 & this.CorpsStrength[index33] > 0 & arySrc[index33] > 3 && !this.HasThisHQNoSplit(this.GetGroupHQ(index33)) && this.GetAbsoluteTempUnits(index33) < 1)
                    {
                      int areaStep = this.AreaSteps[this.CorpsSource[index33], index31];
                      if (areaStep > 0 & areaStep <= 1)
                      {
                        int num25 = this.CorpsStrength[index33];
                        simpleList3.Add(index33, (int) Math.Round((double) num25 / (double) areaStep));
                      }
                    }
                  }
                  if (simpleList3.Counter > -1)
                  {
                    simpleList3.Sort();
                    int index34 = simpleList3.Id[simpleList3.Counter];
                    ++this.GroupCounter;
                    this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
                    this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
                    this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
                    this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
                    this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
                    this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
                    arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
                    this.GroupName[this.GroupCounter] = "DETACHMENT" + this.GetAreaName(index31, false);
                    this.GroupType[this.GroupCounter] = 1;
                    this.CorpsTopGroup[this.GroupCounter] = -1;
                    this.GroupHis[this.GroupCounter] = -1;
                    this.CorpsSource[this.GroupCounter] = nr;
                    this.CorpsTarget[this.GroupCounter] = index31;
                    this.CorpsStrength[this.GroupCounter] = 0;
                    this.CorpsStance[this.GroupCounter] = 3;
                    this.CorpsEngineer[this.GroupCounter] = false;
                    int groupCounter9 = this.GroupCounter;
                    if (alllog)
                      this.AddLog("SPLITTING group " + this.GroupName[index34] + " and creating " + this.GroupName[groupCounter9] + ", Corps source = " + this.GetAreaName(nr) + ", Corps target = " + this.GetAreaName(index31));
                    SimpleList simpleList4 = new SimpleList();
                    int unitCounter8 = this.game.Data.UnitCounter;
                    for (int tid = 0; tid <= unitCounter8; ++tid)
                    {
                      if (this.game.Data.UnitObj[tid].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[tid].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[tid].AIGroup == index34 & !this.game.Data.UnitObj[tid].IsHQ && this.game.Data.UnitObj[tid].TempCategory != 3)
                      {
                        int tweight = 100 * this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y, 0, this.AreaCenter[index31].x, this.AreaCenter[index31].y, 0);
                        if (this.game.Data.UnitObj[tid].TempCategory == 1)
                          tweight = (int) Math.Round((double) tweight / 10.0);
                        simpleList4.Add(tid, tweight);
                      }
                    }
                    int num26 = 0;
                    int num27 = 0;
                    int num28 = 0;
                    int num29 = 0;
                    num15 = 0;
                    ratioOnArea = this.GetRatioOnArea(index31);
                    simpleList4.Sort();
                    if (simpleList4.Counter > -1)
                    {
                      int counter3 = simpleList4.Counter;
                      for (int index35 = 0; index35 <= counter3; ++index35)
                      {
                        if (simpleList4.Data1[index35] != 1)
                        {
                          ++num27;
                          if ((double) num26 <= (double) this.CorpsStrength[index34] / 3.0 & num26 * 2 < this.GetEnemyOnArea(index31))
                          {
                            if (this.game.Data.UnitObj[simpleList4.Id[index35]].Historical > -1)
                            {
                              int counter4 = simpleList4.Counter;
                              for (int index36 = 0; index36 <= counter4; ++index36)
                              {
                                if (simpleList4.Data1[index36] != 1 && this.game.Data.UnitObj[simpleList4.Id[index35]].Historical == this.game.Data.UnitObj[simpleList4.Id[index36]].Historical)
                                {
                                  ++num29;
                                  num26 += this.GetUnitPower(simpleList4.Id[index35], false);
                                  num28 += this.GetUnitPower(simpleList4.Id[index35], false);
                                  if (alllog)
                                    this.AddLog("SPLITTING HIS.UNIT " + this.game.Data.UnitObj[simpleList4.Id[index36]].Name);
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIGroup = groupCounter9;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIAttack = index31;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIDefend = nr;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIFollowup = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIFallback = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AILeftFlank = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIRightFlank = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIAttackStyle = 3;
                                  simpleList4.Data1[index36] = 1;
                                }
                              }
                            }
                            else
                            {
                              num26 += this.GetUnitPower(simpleList4.Id[index35], false);
                              num28 += this.GetUnitPower(simpleList4.Id[index35], false);
                              ++num29;
                              if (alllog)
                                this.AddLog("SPLITTING UNIT " + this.game.Data.UnitObj[simpleList4.Id[index35]].Name);
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIGroup = groupCounter9;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIAttack = index31;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIDefend = nr;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIFollowup = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIFallback = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AILeftFlank = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIRightFlank = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIAttackStyle = 3;
                              simpleList4.Data1[index35] = 1;
                            }
                          }
                        }
                      }
                    }
                    if (num29 == 0)
                    {
                      if (alllog)
                        this.AddLog("IMMEDIATLY REMOVING AGAIN BCAUESE WE COULD FIND NO UNITS");
                      --this.GroupCounter;
                    }
                    int[] numArray19 = arySrc;
                    int[] numArray20 = numArray19;
                    int index37 = index34;
                    int index38 = index37;
                    int num30 = numArray19[index37] - num29;
                    numArray20[index38] = num30;
                    int[] corpsStrength = this.CorpsStrength;
                    int[] numArray21 = corpsStrength;
                    int index39 = index34;
                    int index40 = index39;
                    int num31 = corpsStrength[index39] - num28;
                    numArray21[index40] = num31;
                    if (0 > this.CorpsStrength[index34])
                      this.CorpsStrength[index34] = 0;
                  }
                }
              }
            }
          }
        }
      }
      int groupCounter10 = this.GroupCounter;
      for (int grp = 0; grp <= groupCounter10; ++grp)
      {
        if (this.GroupType[grp] > 5 & arySrc[grp] > 1 && !this.HasThisHQNoSplit(this.GetGroupHQ(grp)) && this.GetAbsoluteTempUnits(grp) < 1)
        {
          int index41 = grp;
          ++this.GroupCounter;
          this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
          this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
          this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
          this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
          this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
          this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
          this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
          this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
          this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
          arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
          this.GroupName[this.GroupCounter] = "REINFORCEMENTS " + this.GetAreaName(this.CorpsSource[grp]);
          this.GroupType[this.GroupCounter] = 1;
          this.GroupHis[this.GroupCounter] = -1;
          this.CorpsTopGroup[this.GroupCounter] = -1;
          this.CorpsSource[this.GroupCounter] = this.CorpsSource[grp];
          this.CorpsTarget[this.GroupCounter] = -1;
          this.CorpsStrength[this.GroupCounter] = 0;
          this.CorpsStance[this.GroupCounter] = 1;
          this.CorpsEngineer[this.GroupCounter] = false;
          int groupCounter11 = this.GroupCounter;
          if (alllog)
            this.AddLog("SPLITTING group " + this.GroupName[index41] + " and creating " + this.GroupName[groupCounter11]);
          SimpleList simpleList = new SimpleList();
          int unitCounter9 = this.game.Data.UnitCounter;
          for (int tid = 0; tid <= unitCounter9; ++tid)
          {
            if (this.game.Data.UnitObj[tid].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[tid].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[tid].AIGroup == index41 & !this.game.Data.UnitObj[tid].IsHQ)
            {
              int tweight = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y, 0, this.AreaCenter[grp].x, this.AreaCenter[grp].y, 0);
              simpleList.Add(tid, tweight);
            }
          }
          int num32 = 0;
          int num33 = 0;
          simpleList.Sort();
          if (simpleList.Counter > -1)
          {
            int counter = simpleList.Counter;
            for (int index42 = 0; index42 <= counter; ++index42)
            {
              num32 += this.GetUnitPower(simpleList.Id[index42], false);
              ++num33;
              if (alllog)
                this.AddLog("SPLITTING UNIT " + this.game.Data.UnitObj[simpleList.Id[index42]].Name);
              this.game.Data.UnitObj[simpleList.Id[index42]].AIGroup = groupCounter11;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIAttack = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIDefend = this.CorpsSource[grp];
              this.game.Data.UnitObj[simpleList.Id[index42]].AIFollowup = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIFallback = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AILeftFlank = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIRightFlank = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIAttackStyle = 1;
            }
          }
          int[] numArray22 = arySrc;
          int[] numArray23 = numArray22;
          int index43 = index41;
          int index44 = index43;
          int num34 = numArray22[index43] - num33;
          numArray23[index44] = num34;
          int[] corpsStrength = this.CorpsStrength;
          int[] numArray24 = corpsStrength;
          int index45 = index41;
          int index46 = index45;
          int num35 = corpsStrength[index45] - num32;
          numArray24[index46] = num35;
          if (0 > this.CorpsStrength[index41])
            this.CorpsStrength[index41] = 0;
        }
      }
      int groupCounter12 = this.GroupCounter;
      for (int index47 = 0; index47 <= groupCounter12; ++index47)
      {
        if (alllog)
          this.AddLog("");
        if (alllog)
          this.AddLog(this.GroupName[index47] + " (" + Conversion.Str((object) this.GroupType[index47]) + ")");
        int unitCounter10 = this.game.Data.UnitCounter;
        for (int index48 = 0; index48 <= unitCounter10; ++index48)
        {
          if (this.game.Data.UnitObj[index48].PreDef == -1 && this.game.Data.UnitObj[index48].X > -1 & this.GetRegime(this.game.Data.UnitObj[index48].Regime) == this.GetGameDataTurn())
          {
            if (this.game.Data.UnitObj[index48].AIGroup == index47)
            {
              if (this.game.Data.UnitObj[index48].TempGroup != -1 | this.game.Data.UnitObj[index48].TempGroup == index47)
              {
                if (alllog)
                  this.AddLog("(-)" + this.game.Data.UnitObj[index48].Name);
              }
              else if (alllog)
                this.AddLog("-" + this.game.Data.UnitObj[index48].Name);
            }
            else if (this.game.Data.UnitObj[index48].TempGroup == index47 && alllog)
              this.AddLog("( " + this.game.Data.UnitObj[index48].Name + " )");
          }
        }
      }
      if (!alllog)
        return;
      this.AddLog("");
    }

    public void ChangingHQs(bool alllog)
    {
      int[] numArray1 = new int[this.game.Data.UnitCounter + 1];
      object[,] objArray = new object[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (alllog)
        this.AddLog("CHANGING HQS");
      if (alllog)
        this.AddLog("");
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
          objArray[index1, index2] = (object) 9999;
      }
      if ((double) this.game.Data.RuleVar[335] > 0.0)
      {
        int num1 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num1 * 4)))] > 0)
          {
            if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num1 * 4)))] > -1)
            {
              int num2 = this.AreaMatrixWide[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num1 * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num1 * 4)))]];
              int x = this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num1 * 4)))];
              int y = this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num1 * 4)))];
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), x, y, 0, allowshoredrop: true, SeaBlock: true);
            }
            int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
            for (int index3 = 0; index3 <= mapWidth2; ++index3)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index4 = 0; index4 <= mapHeight; ++index4)
              {
                if (Operators.ConditionalCompareObjectLess((object) this.game.EditObj.TempValue[0].Value[index3, index4], objArray[index3, index4], false))
                  objArray[index3, index4] = (object) this.game.EditObj.TempValue[0].Value[index3, index4];
              }
            }
          }
          ++num1;
        }
        while (num1 <= 3);
      }
      int num3 = 7;
      int num4;
      do
      {
        int unitCounter1 = this.game.Data.UnitCounter;
        for (int index5 = 0; index5 <= unitCounter1; ++index5)
        {
          if (this.game.Data.UnitObj[index5].PreDef == -1 & this.game.Data.UnitObj[index5].IsHQ && this.game.Data.UnitObj[index5].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index5].X > -1 & this.game.Data.UnitObj[index5].PreDef == -1 && this.GroupType[this.game.Data.UnitObj[index5].AIGroup] == num3 && this.game.Data.UnitObj[index5].SupplyInReq > this.game.Data.UnitObj[index5].SupplyIn | this.game.Data.UnitObj[index5].SupplyInReq == 0)
          {
            ++this.game.EditObj.AIProgressNow;
            if (this.game.EditObj.AIProgressNow > 100)
              this.game.EditObj.AIProgressNow = 0;
            int index6 = this.game.Data.UnitObj[index5].HQ;
            if (index6 > -1)
            {
              if ((double) this.game.Data.RuleVar[887] > 0.0)
              {
                index6 = 0;
              }
              else
              {
                this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index5].X, this.game.Data.UnitObj[index5].Y, this.game.Data.UnitObj[index5].Map, allowshoredrop: true, SeaBlock: true);
                if ((double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y] > (double) this.game.Data.RuleVar[3])
                  index6 = -2;
                else if ((double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y] > (double) this.game.Data.RuleVar[52])
                  index6 = -1;
              }
            }
            if (index6 < 0)
            {
              if (alllog)
                this.AddLog("HQ " + this.game.Data.UnitObj[index5].Name + " has trouble receiving supply.");
              num4 = -1;
              int index7 = -1;
              int num5 = 9999;
              int unitCounter2 = this.game.Data.UnitCounter;
              for (int index8 = 0; index8 <= unitCounter2; ++index8)
              {
                if (this.game.Data.UnitObj[index8].PreDef == -1 & this.game.Data.UnitObj[index8].IsHQ && this.game.Data.UnitObj[index8].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index8].X > -1 & this.game.Data.UnitObj[index8].PreDef == -1 && (double) this.game.Data.UnitObj[index8].SupplyIn > (double) this.game.Data.UnitObj[index8].SupplyInReq / 2.0 & this.GroupType[this.game.Data.UnitObj[index8].AIGroup] == num3 + 1 && (double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] <= (double) this.game.Data.RuleVar[51] | index6 == -2 & (double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] <= (double) this.game.Data.RuleVar[3] && this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] < num5)
                {
                  index7 = index8;
                  num5 = this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y];
                }
              }
              if ((double) num5 < (double) this.game.Data.RuleVar[3])
              {
                if (alllog & this.game.Data.UnitObj[index5].HQ > -1)
                  this.AddLog("old HQ was = " + this.game.Data.UnitObj[this.game.Data.UnitObj[index5].HQ].Name);
                this.game.Data.UnitObj[index5].HQ = index7;
                if (alllog & index7 > -1)
                  this.AddLog("new HQ assigned is = " + this.game.Data.UnitObj[index7].Name);
              }
              else if (alllog)
                this.AddLog("no better hq found.");
            }
          }
        }
        num3 += -1;
      }
      while (num3 >= 5);
      int unitCounter3 = this.game.Data.UnitCounter;
      for (int index9 = 0; index9 <= unitCounter3; ++index9)
      {
        if (this.game.Data.Round > 1 & this.game.Data.UnitObj[index9].PreDef == -1 & !this.game.Data.UnitObj[index9].IsHQ && this.game.Data.UnitObj[index9].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index9].X > -1 & this.game.Data.UnitObj[index9].PreDef == -1 & this.game.Data.UnitObj[index9].AIGroup > -1 && this.game.Data.UnitObj[index9].SupplyInReq > this.game.Data.UnitObj[index9].SupplyIn & this.GroupType[this.game.Data.UnitObj[index9].AIGroup] <= 5)
        {
          int index10 = this.game.Data.UnitObj[index9].HQ;
          ++this.game.EditObj.AIProgressNow;
          if (this.game.EditObj.AIProgressNow > 100)
            this.game.EditObj.AIProgressNow = 0;
          if (index10 > -1)
          {
            if ((double) this.game.Data.RuleVar[887] > 0.0)
            {
              index10 = 0;
            }
            else
            {
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index9].X, this.game.Data.UnitObj[index9].Y, this.game.Data.UnitObj[index9].Map, allowshoredrop: true, SeaBlock: true);
              if ((double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index10].X, this.game.Data.UnitObj[index10].Y] > (double) this.game.Data.RuleVar[3])
                index10 = -2;
              else if ((double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index10].X, this.game.Data.UnitObj[index10].Y] > (double) this.game.Data.RuleVar[52])
                index10 = -1;
            }
          }
          if (index10 < 0)
          {
            if (alllog)
              this.AddLog("Unit " + this.game.Data.UnitObj[index9].Name + " has trouble receiving supply.");
            num4 = -1;
            int index11 = -1;
            int num6 = 9999;
            int unitCounter4 = this.game.Data.UnitCounter;
            for (int index12 = 0; index12 <= unitCounter4; ++index12)
            {
              if (this.game.Data.UnitObj[index12].PreDef == -1 & this.game.Data.UnitObj[index12].IsHQ && this.game.Data.UnitObj[index12].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index12].X > -1 & this.game.Data.UnitObj[index12].PreDef == -1 && (double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y] <= (double) this.game.Data.RuleVar[51] | index10 == -2 & (double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y] <= (double) this.game.Data.RuleVar[3] && this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y] < num6)
              {
                index11 = index12;
                num6 = this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y];
              }
            }
            if ((double) num6 < (double) this.game.Data.RuleVar[3])
            {
              if (alllog & this.game.Data.UnitObj[index9].HQ > -1)
                this.AddLog("old HQ was = " + this.game.Data.UnitObj[this.game.Data.UnitObj[index9].HQ].Name);
              this.game.Data.UnitObj[index9].HQ = index11;
              if (alllog & index11 > -1)
                this.AddLog("new HQ assigned is = " + this.game.Data.UnitObj[index11].Name);
            }
            else if (alllog)
              this.AddLog("no better hq found.");
          }
        }
      }
      int unitCounter5 = this.game.Data.UnitCounter;
      for (int index13 = 0; index13 <= unitCounter5; ++index13)
      {
        if (this.game.Data.UnitObj[index13].PreDef == -1 && this.game.Data.UnitObj[index13].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index13].X > -1 & this.game.Data.UnitObj[index13].PreDef == -1)
        {
          if (this.game.Data.UnitObj[index13].HQ == -1)
          {
            ++this.game.EditObj.AIProgressNow;
            if (this.game.EditObj.AIProgressNow > 100)
              this.game.EditObj.AIProgressNow = 0;
            if (this.game.Data.UnitObj[index13].IsHQ)
            {
              int bestCapHq = this.GetBestCapHQ(this.GetGameDataTurn());
              if (bestCapHq != index13)
                this.game.Data.UnitObj[index13].HQ = bestCapHq;
            }
            else
            {
              int index14 = -1;
              int unitCounter6 = this.game.Data.UnitCounter;
              for (int index15 = 0; index15 <= unitCounter6; ++index15)
              {
                if (this.game.Data.UnitObj[index15].AIGroup == this.game.Data.UnitObj[index13].AIGroup & this.game.Data.UnitObj[index15].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index15].IsHQ)
                {
                  index14 = index15;
                  break;
                }
              }
              int[] numArray2 = new int[this.game.Data.UnitCounter + 1];
              int num7 = 0;
              int num8 = -1;
              if (index14 == -1)
              {
                int unitCounter7 = this.game.Data.UnitCounter;
                for (int index16 = 0; index16 <= unitCounter7; ++index16)
                {
                  if (this.game.Data.UnitObj[index16].PreDef == -1 && this.game.Data.UnitObj[index16].AIGroup == this.game.Data.UnitObj[index13].AIGroup & this.game.Data.UnitObj[index16].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index16].HQ > -1)
                  {
                    int[] numArray3 = numArray2;
                    int[] numArray4 = numArray3;
                    int hq = this.game.Data.UnitObj[index16].HQ;
                    int index17 = hq;
                    int num9 = numArray3[hq] + 1;
                    numArray4[index17] = num9;
                    if (numArray2[this.game.Data.UnitObj[index16].HQ] > num7)
                    {
                      num7 = numArray2[this.game.Data.UnitObj[index16].HQ];
                      num8 = this.game.Data.UnitObj[index16].HQ;
                    }
                  }
                }
                if (num8 > -1)
                  index14 = num8;
              }
              if (index14 == -1)
              {
                if ((double) this.game.Data.RuleVar[887] < 1.0)
                  this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index13].X, this.game.Data.UnitObj[index13].Y, this.game.Data.UnitObj[index13].Map, allowshoredrop: true, SeaBlock: true);
                int unitCounter8 = this.game.Data.UnitCounter;
                for (int index18 = 0; index18 <= unitCounter8; ++index18)
                {
                  if (this.game.Data.UnitObj[index18].PreDef == -1 & this.game.Data.UnitObj[index18].X > -1 && ((double) this.game.Data.RuleVar[887] > 0.0 | (double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index18].X, this.game.Data.UnitObj[index18].Y] < (double) this.game.Data.RuleVar[51]) & this.game.Data.UnitObj[index18].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index18].HQ > -1)
                  {
                    int[] numArray5 = numArray2;
                    int[] numArray6 = numArray5;
                    int hq = this.game.Data.UnitObj[index18].HQ;
                    int index19 = hq;
                    int num10 = numArray5[hq] + 1;
                    numArray6[index19] = num10;
                    if (numArray2[this.game.Data.UnitObj[index18].HQ] > num7)
                    {
                      num7 = numArray2[this.game.Data.UnitObj[index18].HQ];
                      num8 = this.game.Data.UnitObj[index18].HQ;
                    }
                  }
                }
                if (num8 > -1)
                  index14 = num8;
              }
              if (index14 > -1)
              {
                this.game.Data.UnitObj[index13].HQ = index14;
                if (alllog)
                  this.AddLog("Unit without HQ " + this.game.Data.UnitObj[index13].Name + " set to HQ: " + this.game.Data.UnitObj[index14].Name);
              }
              else if (alllog)
                this.AddLog("Unit without HQ " + this.game.Data.UnitObj[index13].Name + " not set to any HQ.");
            }
          }
          else if (!this.game.Data.UnitObj[index13].IsHQ && this.game.Data.UnitObj[this.game.Data.UnitObj[index13].HQ].AIGroup != this.game.Data.UnitObj[index13].AIGroup && this.game.Data.UnitObj[index13].TempGroup == -1)
          {
            if ((double) this.game.Data.RuleVar[887] < 1.0)
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index13].X, this.game.Data.UnitObj[index13].Y, this.game.Data.UnitObj[index13].Map, allowshoredrop: true, SeaBlock: true);
            int index20 = -1;
            int unitCounter9 = this.game.Data.UnitCounter;
            for (int index21 = 0; index21 <= unitCounter9; ++index21)
            {
              if (this.game.Data.UnitObj[index21].PreDef == -1 && this.game.Data.UnitObj[index21].AIGroup > 0 & this.game.Data.UnitObj[index21].AIGroup == this.game.Data.UnitObj[index13].AIGroup & this.game.Data.UnitObj[index21].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index21].IsHQ)
              {
                if ((double) this.game.Data.RuleVar[887] < 1.0)
                {
                  if ((double) this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index21].X, this.game.Data.UnitObj[index21].Y] < (double) this.game.Data.RuleVar[51])
                  {
                    index20 = index21;
                    break;
                  }
                }
                else
                  index20 = index21;
              }
            }
            if (index20 > -1 & index13 != index20 & this.game.Data.UnitObj[index13].HQ != index20)
            {
              this.game.Data.UnitObj[index13].HQ = index20;
              if (alllog)
                this.AddLog("Unit with a HQ outside its own group " + this.game.Data.UnitObj[index13].Name + " found a HQ inside its own group: " + this.game.Data.UnitObj[index20].Name);
            }
          }
        }
      }
    }

    public int GetUnitPower(
      int unr,
      bool Attack,
      int AttackX = -1,
      int AttackY = -1,
      int FromDirection = -1,
      int Theater = -1,
      bool IsArtilleryAttack = false,
      float LimitCombatmod = 5f,
      bool WithoutEntrench = false,
      bool EnemyAttack = false,
      bool UseTempCoords = false)
    {
      int unitPower = 0;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      int sfCount = this.game.Data.UnitObj[unr].SFCount;
      int num1;
      float num2;
      int num3;
      for (int index = 0; index <= sfCount; ++index)
      {
        int sf = this.game.Data.UnitObj[unr].SFList[index];
        int type = this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].Theater == Theater | Theater == -1 && !IsArtilleryAttack | this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ArtRange > 0 | this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2)
        {
          int powerPts = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
          int num4 = this.game.Data.SFObj[sf].Qty * powerPts;
          num1 += num4;
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ArtRange > 0 & IsArtilleryAttack & Attack)
            num4 = (int) Math.Round((double) ((float) num4 * this.CONST_ARTMULTI));
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2 & IsArtilleryAttack & Attack)
            num4 = (int) Math.Round((double) ((float) num4 * this.CONST_AIRMULTI));
          int regime = this.game.Data.UnitObj[unr].Regime;
          int num5 = (int) Math.Round((double) ((float) num4 * this.game.Data.PeopleObj[this.game.Data.SFObj[sf].People].BattleForMod[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regime].People].PeopleGroup]));
          if (this.game.Data.Round > 1)
            num5 = (int) Math.Round((double) num5 * 0.2 + (double) num5 * 0.8 * ((double) this.game.Data.UnitObj[unr].SupplyConsume / 100.0));
          int num6 = (int) Math.Round((double) num5 * ((double) this.game.Data.SFObj[sf].Mor / 50.0));
          if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpCombat > 0)
            num6 += (int) Math.Round((double) num6 * ((double) this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpCombat / 100.0));
          int num7 = !Attack ? (int) Math.Round((double) num6 * 0.3 + (double) num6 * 0.7 * ((double) this.game.Data.SFObj[sf].Rdn / 100.0)) : (int) Math.Round((double) (int) Math.Round((double) num6 * ((double) this.game.Data.SFObj[sf].Rdn / 100.0)) * ((double) this.game.Data.SFObj[sf].Rdn / 100.0));
          if (Attack & AttackX > -1)
            num7 = (int) Math.Round((double) ((float) (int) Math.Round((double) ((float) num7 * this.game.Data.SFTypeObj[type].CombatModAtt[this.game.Data.MapObj[0].HexObj[AttackX, AttackY].LandscapeType])) * this.game.Data.SFTypeObj[type].CombatModAtt[this.game.Data.MapObj[0].HexObj[AttackX, AttackY].LandscapeType]));
          else if (!WithoutEntrench & !Attack)
            num7 = !(UseTempCoords & this.game.Data.UnitObj[unr].TempX > -1 & !(this.game.Data.UnitObj[unr].TempX == this.game.Data.UnitObj[unr].X & this.game.Data.UnitObj[unr].TempY == this.game.Data.UnitObj[unr].Y)) ? (int) Math.Round((double) ((float) (int) Math.Round((double) ((float) num7 * (float) (1.0 + ((double) this.game.Data.SFObj[sf].CurrentEntrench + (double) this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType].DefBonus[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup]) / 100.0))) * this.game.Data.SFTypeObj[type].CombatModDef[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType])) : (int) Math.Round((double) ((float) (int) Math.Round((double) ((float) num7 * (float) (1.0 + 1.0 * (double) this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY].LandscapeType].DefBonus[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup] / 100.0))) * this.game.Data.SFTypeObj[type].CombatModDef[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY].LandscapeType]));
          int Number = (int) Math.Round((double) (1 * num7) + (double) this.game.Data.SFObj[sf].Xp / 50.0 * (double) num7);
          if (this.game.Data.UnitObj[unr].HQ > -1 & this.game.Data.SFTypeObj[type].Theater == 0)
            Number = (int) Math.Round((double) ((float) Number * (float) ((double) this.game.HandyFunctionsObj.Gethqpow(unr, true) * (double) this.game.Data.UnitObj[unr].TempCombatImprovePercent / 100.0)));
          if (Attack & AttackX > -1 & !IsArtilleryAttack)
          {
            float num8 = this.GetAverageCombatScore(type, AttackX, AttackY, IsArtilleryAttack, EnemyAttack);
            if ((double) num8 > (double) LimitCombatmod)
              num8 = LimitCombatmod;
            if ((double) num8 < 1.0 / (double) LimitCombatmod)
              num8 = 1f / LimitCombatmod;
            num2 += (float) (int) Math.Round((double) (num8 * (float) (this.game.Data.SFObj[sf].Qty * powerPts)));
            num3 += this.game.Data.SFObj[sf].Qty * powerPts;
          }
          unitPower += Conversion.Int(Number);
        }
      }
      if (Attack & AttackX > -1 & !IsArtilleryAttack & FromDirection > -1)
      {
        if (this.game.Data.MapObj[0].HexObj[AttackX, AttackY].RiverType[FromDirection] > -1)
          unitPower = (int) Math.Round((double) ((float) unitPower * this.GetRiverMod(unr, this.game.Data.MapObj[0].HexObj[AttackX, AttackY].RiverType[FromDirection])));
      }
      else
        unitPower = unitPower;
      if (num3 > 0)
      {
        float num9 = num2 / (float) num3;
        unitPower = (int) Math.Round((double) ((float) unitPower * num9));
      }
      if (unitPower < 1 & num1 > 0)
        unitPower = (int) Math.Round(Math.Max(1.0, (double) num1 / 10.0));
      return unitPower;
    }

    public void MakeTempCategories(bool tlog)
    {
      if (tlog)
        this.AddLog("MAKETEMPCATEGORIES");
      if (tlog)
        this.AddLog("");
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1)
        {
          if (this.GetAIRolePercent(index, 8) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 2;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = ARTILLERY");
          }
          else if (this.GetAIRolePercent(index, 12) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 5;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = FLAK");
          }
          else if (this.GetAIRolePercent(index, 13) + this.GetAIRolePercent(index, 14) + this.GetAIRolePercent(index, 15) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 3;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = AIR");
          }
          else if (this.GetAIRolePercent(index, 5) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 4;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = ENGINEER");
          }
          else if (this.game.HandyFunctionsObj.HasUnitNavySF(index))
          {
            if (this.game.HandyFunctionsObj.GetUnitCarryCap(index, 1) > 0)
            {
              this.game.Data.UnitObj[index].TempCategory = 6;
              if (tlog)
                this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = NAVAL CARGO");
            }
            else
            {
              this.game.Data.UnitObj[index].TempCategory = 7;
              if (tlog)
                this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = NAVAL ATTACK");
            }
          }
          else
          {
            this.game.Data.UnitObj[index].TempCategory = 1;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = NORMAL");
          }
        }
      }
    }

    public void InitAI()
    {
      this.FullLog = true;
      this.ScreenyLog = false;
      if (!this.game.Data.DontShowAIMove)
        this.ScreenyLog = false;
      this.game.EditObj.TempAIString = "Preparing AI Initialization";
      this.game.EditObj.AIProgressNow = 0;
      this.game.EditObj.AIProgressMax = 100;
      this.LogCounter = -1;
      this.LogCounter2 = -1;
      if (this.LastRegime == this.game.Data.Turn)
        this.LastRegime = -1;
      else if (this.LastRegime > -1 & this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime == this.LastRegime)
      {
        this.game.AIRunning = false;
        return;
      }
      if (this.LastRegime > -1 && this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime > -1 & this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime == this.game.Data.RegimeObj[this.LastRegime].UberRegime)
      {
        this.game.AIRunning = false;
      }
      else
      {
        this.LastRegime = this.game.Data.Turn;
        this.InitialCalculations(this.FullLog);
        if (this.FullLog)
          this.WriteLog("01_InitialCalculations");
        this.LogCounter = -1;
        this.MakeCombatMatrix(this.FullLog);
        if (this.FullLog)
          this.WriteLog("02_MakeCombatMatrix");
        this.LogCounter = -1;
        this.MakeTempMovementTypes(this.FullLog);
        if (this.FullLog)
          this.WriteLog("03_MakeTempMovementTypes");
        this.LogCounter = -1;
        this.MakeTempCategories(this.FullLog);
        if (this.FullLog)
          this.WriteLog("04_MakeTempCategories");
        this.LogCounter = -1;
        this.MakeAreaMatrix(this.FullLog);
        if (this.FullLog)
          this.WriteLog("05_MakeAreaMatrix");
        this.LogCounter = -1;
        this.ResetExtraAreaMemory(this.FullLog);
        if (this.FullLog)
          this.WriteLog("06_ResetExtraAreaMemory");
        this.LogCounter = -1;
        this.MakeDistanceEnemyToArea(this.FullLog);
        if (this.FullLog)
          this.WriteLog("07_MakeDistanceEnemyToArea");
        this.LogCounter = -1;
        this.MakeGroups(this.FullLog);
        if (this.FullLog)
          this.WriteLog("08_MakeGroups");
        this.LogCounter = -1;
        if (this.GroupCounter < 0)
        {
          this.game.AIRunning = false;
        }
        else
        {
          this.game.EventRelatedObj.DoCheckEvents(6);
          this.MakeCorpsAndAreaAssesment(this.FullLog);
          if (this.FullLog)
            this.WriteLog("09_MakeCorpsAndAreaAssesment");
          this.LogCounter = -1;
          this.FindBestStrategy(this.FullLog, false);
          this.CurrentAreaGroup = 1;
          this.LogCounter = -1;
          this.GetStrategyScore(ref this.BestStrategy, true, 1f);
          if (this.FullLog)
            this.WriteLog("10_FindBestStrategy_04_the_best_strategy_score");
          this.LogCounter = -1;
          this.StrategyLog();
          if (this.FullLog)
            this.WriteLog("10_FindBestStrategy_05_the_best_strategy_moves");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Make Supply Matrix";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.MakeSupplyMatrix(this.FullLog, false);
          if (this.FullLog)
            this.WriteLog("11_MakeSupplyMatrix");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Implement Best Strategy";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.ImplementBestStrategy(this.FullLog);
          if (this.FullLog)
            this.WriteLog("12_ImplementBestStrategy");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Re-order Groups";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.ReOrderGroups(this.FullLog);
          if (this.FullLog)
            this.WriteLog("13_ReOrderGroups");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Changing HQs";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.ChangingHQs(this.FullLog);
          if (this.FullLog)
            this.WriteLog("14_ChangingHQs");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Init Strategic Transfers";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.InitStrategicTransfers(this.FullLog);
          if (this.FullLog)
            this.WriteLog("15_InitStrategicTransfers");
          this.LogCounter = -1;
          this.InitSetAirIntercept(this.FullLog);
          if (this.FullLog)
            this.WriteLog("16_InitSetAirIntercept");
          this.LogCounter = -1;
          this.MakeSupplyMatrix(false, false);
          int unitCounter = this.game.Data.UnitCounter;
          for (int index = 0; index <= unitCounter; ++index)
          {
            if (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index].AIGroup > -1)
              this.game.Data.UnitObj[index].TempAIString = this.GroupName[this.game.Data.UnitObj[index].AIGroup] + "\r\n... Fallback = " + this.GetAreaName(this.game.Data.UnitObj[index].AIFallback) + "\r\n, Defend = " + this.GetAreaName(this.game.Data.UnitObj[index].AIDefend) + "\r\n, Attack= " + this.GetAreaName(this.game.Data.UnitObj[index].AIAttack) + "\r\n, Followup = " + this.GetAreaName(this.game.Data.UnitObj[index].AIFollowup) + "\r\n, Stance = " + Conversion.Str((object) this.game.Data.UnitObj[index].AIAttackStyle);
          }
          int groupCounter1 = this.GroupCounter;
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupCounter = groupCounter1;
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupType = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupName = new string[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupHis = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastAttack = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastDefend = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFollowUp = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFallBack = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AICorpsTopGroup = new int[groupCounter1 + 1];
          int groupCounter2 = this.GroupCounter;
          for (int index = 0; index <= groupCounter2; ++index)
          {
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupType[index] = this.GroupType[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupName[index] = this.GroupName[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupHis[index] = this.GroupHis[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastAttack[index] = this.GroupAttack[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastDefend[index] = this.GroupDefend[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFollowUp[index] = this.GroupFollowUp[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFallBack[index] = this.GroupFallBack[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AICorpsTopGroup[index] = this.CorpsTopGroup[index];
          }
          this.game.EditObj.TempAIString = "Preparing AI execution";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.WriteLog();
          this.game.AIRunning = false;
        }
      }
    }

    public void StrategyLog()
    {
      this.AddLog("BEST STRATEGY");
      if (Information.IsNothing((object) this.BestStrategy))
        return;
      int counter = this.BestStrategy.Counter;
      for (int index1 = 0; index1 <= counter; ++index1)
      {
        if (this.BestStrategy.Id[index1] < 99000)
          this.AddLog(this.GroupName[this.BestStrategy.Id[index1]] + ", STEP1=" + this.GetAreaName(this.BestStrategy.Data1[index1]) + ", STEP2=" + this.GetAreaName(this.BestStrategy.Data2[index1]) + ", STEP3=" + this.GetAreaName(this.BestStrategy.Data3[index1]) + ", STEP4=" + this.GetAreaName(this.BestStrategy.Data4[index1]) + ", STEP5=" + this.GetAreaName(this.BestStrategy.Data5[index1]));
        else if (this.BestStrategy.Id[index1] < 199000)
        {
          this.AddLog(this.GroupName[this.BestStrategy.Id[index1] - 99000] + ", STANCE=" + Conversion.Str((object) this.BestStrategy.Data1[index1]));
        }
        else
        {
          int index2 = this.BestStrategy.Id[index1] - 199000;
          if (this.BestStrategy.Data1[index1] > -1)
            this.AddLog(this.GroupName[index2] + ", AIRFORCE TOO=" + this.GroupName[this.BestStrategy.Data1[index1]]);
        }
      }
    }

    public void InitialCalculations(bool tlog)
    {
      if (tlog)
        this.AddLog("INITIALCALCULATIONS()");
      GC.Collect();
      this.EnemyMatrix = new int[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.EnemyMatrixCameFrom = new sCoordinate[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.tArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.MoveMatrix = new int[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.MoveMatrixCameFrom = new sCoordinate[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.TempOwner = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.TempCounterOwner = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter1; ++index)
      {
        this.game.Data.UnitObj[index].FinalX = -1;
        this.game.Data.UnitObj[index].FinalY = -1;
        this.game.Data.UnitObj[index].OldX = this.game.Data.UnitObj[index].X;
        this.game.Data.UnitObj[index].OldY = this.game.Data.UnitObj[index].Y;
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SET UNIT VALUES");
      int unitCounter2 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter2; ++index)
      {
        if (this.game.Data.UnitObj[index].X > -1 & this.game.Data.UnitObj[index].PreDef == -1)
        {
          this.game.Data.UnitObj[index].TempUnitPower = this.GetUnitPower(index, false);
          this.game.Data.UnitObj[index].TempCombatImprovePercent = this.game.HandyFunctionsObj.GetCombatImprovePercent(index);
          if (tlog)
            this.AddLog(Strings.Trim(Conversion.Str((object) index)) + ": " + this.game.Data.UnitObj[index].Name + ", TempUnitPower = " + Strings.Trim(Conversion.Str((object) this.game.Data.UnitObj[index].TempUnitPower)) + ", CombatImprovePercent = " + Strings.Trim(Conversion.Str((object) this.game.Data.UnitObj[index].TempCombatImprovePercent)));
        }
      }
      this.AreaMatrixNarrow = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.AreaMatrixWide = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.CombatMatrix = new float[this.game.Data.SFTypeCounter + 1, this.game.Data.SFTypeCounter + 1];
      if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 250)
      {
        this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 6800;
        this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 500;
      }
      else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
      {
        this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 4000;
        this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 350;
      }
      else
      {
        this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 2000;
        this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 200;
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SET DIFFICULTY SETTING");
      if (tlog)
        this.AddLog("Prod Bonus for regime was set to " + Strings.Trim(Conversion.Str((object) this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus)));
      if (tlog)
        this.AddLog("Strategy Moves = " + Strings.Trim(Conversion.Str((object) this.DIFFICULTY_LEVEL_STRATEGY_MOVES)));
      if (tlog)
        this.AddLog("Tactical Moves = " + Strings.Trim(Conversion.Str((object) this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE)));
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SET ATTACK_MINIMUM_ACTUAL_ATTACK");
      this.ATTACK_MINIMUM_ACTUAL_ATTACK = (double) this.game.Data.RuleVar[358] > 0.0 ? (int) Math.Round((double) this.game.Data.RuleVar[358]) : 62;
      if (tlog)
        this.AddLog("set to: " + Strings.Trim(Conversion.Str((object) this.ATTACK_MINIMUM_ACTUAL_ATTACK)));
      if (!((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0))
        return;
      this.ATTACK_MINIMUM_ACTUAL_ATTACK = (int) Math.Round((double) ((float) this.ATTACK_MINIMUM_ACTUAL_ATTACK * this.game.Data.RegimeObj[this.game.Data.Turn].AIConservative));
      if (!tlog)
        return;
      this.AddLog("after modification with AIConservative setting: " + Strings.Trim(Conversion.Str((object) this.ATTACK_MINIMUM_ACTUAL_ATTACK)));
    }

    public void MakeOpHQSupplyMatrix(bool tlog)
    {
      this.SupplyMatrixOpHQPrognosis = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixOpHQReal = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixOpHQPrognosisCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixOpHQRealCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int groupHq = this.GetGroupHQ(this.OpGroup);
      if (groupHq > -1)
      {
        if (tlog)
          this.AddLog("MakeOPHQSupplyMatrix for " + this.game.Data.UnitObj[groupHq].Name);
      }
      else if (tlog)
        this.AddLog("MakeOPHQSupplyMatrix. But not HQ unit found.");
      if (tlog)
        this.AddLog("");
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.SupplyMatrixOpHQReal[index1, index2] = 9999;
          this.SupplyMatrixOpHQPrognosis[index1, index2] = 9999;
        }
      }
      this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y, 0);
      int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
      for (int index3 = 0; index3 <= mapWidth2; ++index3)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index4 = 0; index4 <= mapHeight; ++index4)
        {
          this.SupplyMatrixOpHQReal[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
          this.SupplyMatrixOpHQRealCameFrom[index3, index4] = this.game.EditObj.TempCameFrom[0].Value[index3, index4];
        }
      }
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made of SupplyMatrixOPHQReal");
        this.Screenshot(1, "SUPPLYMATRIXOPHQREAL_" + this.GroupName[this.OpGroup], ref this.SupplyMatrixOpHQReal);
      }
      this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y, 0, dontenterenemy: false, DontCountEnemyRoads: true);
      int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
      for (int index5 = 0; index5 <= mapWidth3; ++index5)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index6 = 0; index6 <= mapHeight; ++index6)
        {
          this.SupplyMatrixOpHQPrognosis[index5, index6] = this.game.EditObj.TempValue[0].Value[index5, index6];
          this.SupplyMatrixOpHQPrognosisCameFrom[index5, index6] = this.game.EditObj.TempCameFrom[0].Value[index5, index6];
        }
      }
      if (!this.ScreenyLog)
        return;
      if (tlog)
        this.AddLog("Screenshot has been made of SupplyMatrixOPHQPrognosis");
      this.Screenshot(1, "SUPPLYMATRIXOPHQPROGNOSIS_" + this.GroupName[this.OpGroup], ref this.SupplyMatrixOpHQReal);
    }

    public void MakeEnemySupplyMatrix(bool tlog)
    {
      int movetype = (int) Math.Round((double) this.game.Data.RuleVar[99]);
      if ((double) this.game.Data.RuleVar[890] > 0.0)
        movetype = (int) Math.Round((double) this.game.Data.RuleVar[890]);
      this.SupplyMatrixEnemyPrognosis = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixEnemyReal = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixEnemyPrognosisCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixEnemyRealCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (tlog)
        this.AddLog(nameof (MakeEnemySupplyMatrix));
      if (tlog)
        this.AddLog("");
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.SupplyMatrixEnemyReal[index1, index2] = 9999;
          this.SupplyMatrixEnemyPrognosis[index1, index2] = 9999;
        }
      }
      int regimeCounter = this.game.Data.RegimeCounter;
      for (int index3 = 0; index3 <= regimeCounter; ++index3)
      {
        int regime = this.GetRegime(index3);
        if (regime != this.GetGameDataTurn())
        {
          if ((double) this.game.Data.RuleVar[335] > 0.0)
          {
            int num = 0;
            do
            {
              if (this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num * 4)))] > 0)
              {
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[index3].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[index3].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))], 0);
                int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
                for (int index4 = 0; index4 <= mapWidth2; ++index4)
                {
                  int mapHeight = this.game.Data.MapObj[0].MapHeight;
                  for (int index5 = 0; index5 <= mapHeight; ++index5)
                  {
                    if (this.SupplyMatrixEnemyReal[index4, index5] > this.game.EditObj.TempValue[0].Value[index4, index5])
                    {
                      this.SupplyMatrixEnemyReal[index4, index5] = this.game.EditObj.TempValue[0].Value[index4, index5];
                      this.SupplyMatrixEnemyRealCameFrom[index4, index5] = this.game.EditObj.TempCameFrom[0].Value[index4, index5];
                    }
                  }
                }
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[index3].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[index3].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))], 0, dontenterenemy: false, DontCountEnemyRoads: true);
                int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
                for (int index6 = 0; index6 <= mapWidth3; ++index6)
                {
                  int mapHeight = this.game.Data.MapObj[0].MapHeight;
                  for (int index7 = 0; index7 <= mapHeight; ++index7)
                  {
                    if (this.SupplyMatrixEnemyPrognosis[index6, index7] > this.game.EditObj.TempValue[0].Value[index6, index7])
                    {
                      this.SupplyMatrixEnemyPrognosis[index6, index7] = this.game.EditObj.TempValue[0].Value[index6, index7];
                      this.SupplyMatrixEnemyPrognosisCameFrom[index6, index7] = this.game.EditObj.TempCameFrom[0].Value[index6, index7];
                    }
                  }
                }
              }
              ++num;
            }
            while (num <= 3);
          }
          else
          {
            int areaCount = this.AreaCount;
            for (int i = 0; i <= areaCount; ++i)
            {
              if (this.IsAreaSupplySource(i, index3))
              {
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0);
                int mapWidth4 = this.game.Data.MapObj[0].MapWidth;
                for (int index8 = 0; index8 <= mapWidth4; ++index8)
                {
                  int mapHeight = this.game.Data.MapObj[0].MapHeight;
                  for (int index9 = 0; index9 <= mapHeight; ++index9)
                  {
                    if (this.SupplyMatrixEnemyReal[index8, index9] > this.game.EditObj.TempValue[0].Value[index8, index9])
                    {
                      this.SupplyMatrixEnemyReal[index8, index9] = this.game.EditObj.TempValue[0].Value[index8, index9];
                      this.SupplyMatrixEnemyRealCameFrom[index8, index9] = this.game.EditObj.TempCameFrom[0].Value[index8, index9];
                    }
                  }
                }
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0, dontenterenemy: false, DontCountEnemyRoads: true);
                int mapWidth5 = this.game.Data.MapObj[0].MapWidth;
                for (int index10 = 0; index10 <= mapWidth5; ++index10)
                {
                  int mapHeight = this.game.Data.MapObj[0].MapHeight;
                  for (int index11 = 0; index11 <= mapHeight; ++index11)
                  {
                    if (this.SupplyMatrixEnemyPrognosis[index10, index11] > this.game.EditObj.TempValue[0].Value[index10, index11])
                    {
                      this.SupplyMatrixEnemyPrognosis[index10, index11] = this.game.EditObj.TempValue[0].Value[index10, index11];
                      this.SupplyMatrixEnemyPrognosisCameFrom[index10, index11] = this.game.EditObj.TempCameFrom[0].Value[index10, index11];
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made of SupplyMatrixEnemyReal");
        this.Screenshot(1, "SUPPLYMATRIXOPHQPROGNOSIS_" + this.GroupName[this.OpGroup], ref this.SupplyMatrixEnemyReal);
      }
      if (!this.ScreenyLog)
        return;
      if (tlog)
        this.AddLog("Screenshot has been made of SupplyMatrixEnemyPrognosis");
      this.Screenshot(1, "SUPPLYMATRIXOPHQPROGNOSIS_" + this.GroupName[this.OpGroup], ref this.SupplyMatrixEnemyPrognosis);
    }

    public void MakeCombatMatrix(bool tlog)
    {
      if (tlog)
        this.AddLog("COMBATMATRIX");
      if (tlog)
        this.AddLog("");
      int sfTypeCounter1 = this.game.Data.SFTypeCounter;
      for (int index1 = 0; index1 <= sfTypeCounter1; ++index1)
      {
        if (tlog)
          this.AddLog("********* " + this.game.Data.SFTypeObj[index1].Name + " VERSUS: ");
        int sfTypeCounter2 = this.game.Data.SFTypeCounter;
        for (int index2 = 0; index2 <= sfTypeCounter2; ++index2)
        {
          int num1 = this.game.Data.SFTypeObj[index1].AttackPower[this.game.Data.SFTypeObj[index2].UnitGroup] * this.game.Data.SFTypeObj[index1].Attacks;
          int num2 = this.game.Data.SFTypeObj[index2].AttackPowerDef[this.game.Data.SFTypeObj[index1].UnitGroup] * this.game.Data.SFTypeObj[index2].Attacks;
          int num3 = this.game.Data.SFTypeObj[index1].HitPoints[this.game.Data.SFTypeObj[index2].UnitGroup];
          int num4 = this.game.Data.SFTypeObj[index2].HitPointsDef[this.game.Data.SFTypeObj[index1].UnitGroup];
          int num5 = this.game.Data.SFTypeObj[index1].PowerPts;
          int num6 = this.game.Data.SFTypeObj[index2].PowerPts;
          if (num6 == 0)
            num6 = 1;
          if (num5 == 0)
            num5 = 1;
          float num7 = 1f;
          float num8 = 1f;
          if (num5 > num6)
          {
            num2 = (int) Math.Round((double) num2 * ((double) num5 / (double) num6));
            num4 = (int) Math.Round((double) num4 * ((double) num5 / (double) num6));
            num8 *= (float) num5 / (float) num6;
          }
          else if (num6 > num5)
          {
            num1 = (int) Math.Round((double) num1 * ((double) num6 / (double) num5));
            num3 = (int) Math.Round((double) num3 * ((double) num6 / (double) num5));
            num7 *= (float) num6 / (float) num5;
          }
          if ((double) num7 * (double) this.game.Data.SFTypeObj[index1].Attacks > (double) num8 * (double) this.game.Data.SFTypeObj[index2].MaxAttacked)
            num1 = (int) Math.Round((double) ((float) num1 * (float) ((double) num8 * (double) this.game.Data.SFTypeObj[index2].MaxAttacked / ((double) num7 * (double) this.game.Data.SFTypeObj[index1].Attacks))));
          if ((double) num8 * (double) this.game.Data.SFTypeObj[index2].Attacks > (double) num7 * (double) this.game.Data.SFTypeObj[index1].MaxAttacked)
            num2 = (int) Math.Round((double) ((float) num2 * (float) ((double) num7 * (double) this.game.Data.SFTypeObj[index1].MaxAttacked / ((double) num8 * (double) this.game.Data.SFTypeObj[index2].Attacks))));
          float num9 = (float) num1 / (float) num4;
          float num10 = (float) num2 / (float) num3;
          float Number = (double) num10 <= 0.0 ? 25f : num9 / num10;
          if ((double) Number > 5.0)
            Number = 5f + (float) Math.Sqrt((double) Number - 4.0);
          if ((double) Number < 0.2)
            Number = 0.2f;
          int theater1 = this.game.Data.SFTypeObj[index1].Theater;
          int theater2 = this.game.Data.SFTypeObj[index2].Theater;
          if (theater1 == 0 & theater2 == 2)
            Number = 10f;
          this.CombatMatrix[index1, index2] = Number;
          if (theater1 == theater2 | (double) num9 > 0.0 && tlog)
            this.AddLog(this.game.Data.SFTypeObj[index2].Name + " = " + Conversion.Str((object) Number));
        }
      }
    }

    public void MakeBottleNeckMatrix()
    {
      this.BottleNeckMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      CoordList coordList1 = new CoordList();
      int regime = this.GetRegime(this.GetLargestEnemy());
      int num1 = 0;
      if (regime == -1)
        return;
      int num2 = 0;
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        this.game.Data.UnitObj[index].TempX = this.game.Data.UnitObj[index].X;
        this.game.Data.UnitObj[index].TempY = this.game.Data.UnitObj[index].Y;
        if (this.game.Data.UnitObj[index].AIGroup == this.OpGroup & this.game.Data.UnitObj[index].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index].X > -1)
        {
          int num3 = 600;
          if ((double) this.game.Data.UnitObj[index].SupplyIn < (double) this.game.Data.UnitObj[index].SupplyInReq * 0.25)
            num3 = (int) Math.Round((double) num3 * 2.5);
          if ((double) this.game.Data.UnitObj[index].Supply < (double) this.game.Data.UnitObj[index].SupplyInReq * 0.1)
            num3 = (int) Math.Round((double) num3 * 1.5);
          if (this.game.Data.UnitObj[index].IsHQ)
            num3 *= 3;
          num2 += num3;
        }
      }
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.TempOwner[index1, index2] = this.game.Data.MapObj[0].HexObj[index1, index2].Regime;
          this.TempCounterOwner[index1, index2] = this.game.Data.MapObj[0].HexObj[index1, index2].Regime;
          this.BottleNeckMatrix[index1, index2] = 0;
        }
      }
      int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
      for (int index3 = 0; index3 <= mapWidth2; ++index3)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index4 = 0; index4 <= mapHeight; ++index4)
        {
          int num4 = 0;
          if (index3 == 47 & index4 == 34)
            index3 = index3;
          if (index3 == 49 & index4 == 33)
            index3 = index3;
          if (this.FrontlineArea[index3, index4] > 0)
            num4 = 1;
          Coordinate coordinate1;
          if (num4 == 0 & (this.tArea[index3, index4] == 2 | this.tArea[index3, index4] == 6 | this.tArea[index3, index4] == 3))
          {
            int tfacing = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index3, index4, 0, tfacing);
              if (coordinate1.onmap && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                num4 = 1;
              ++tfacing;
            }
            while (tfacing <= 6);
          }
          if (num4 > 0)
          {
            CoordList coordList2 = new CoordList();
            coordList2.AddCoord(index3, index4, 0);
            this.TempCounterOwner[index3, index4] = regime;
            SimpleList tempMove = new SimpleList();
            int num5 = this.GetOurSelvesEncircledScore(ref tempMove, false, true);
            if (num5 > 0)
              num5 = num5;
            this.BottleNeckMatrix[index3, index4] = (int) Math.Round((double) (num5 * 100) / (double) num2);
            int tfacing1 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index3, index4, 0, tfacing1);
              if (coordinate1.onmap)
              {
                coordList2.AddCoord(coordinate1.x, coordinate1.y, 0);
                this.TempCounterOwner[coordinate1.x, coordinate1.y] = regime;
              }
              ++tfacing1;
            }
            while (tfacing1 <= 6);
            tempMove = new SimpleList();
            int num6 = this.GetOurSelvesEncircledScore(ref tempMove, false, true);
            if (num6 > 0)
              num6 = num6;
            int[,] bottleNeckMatrix1 = this.BottleNeckMatrix;
            int[,] numArray1 = bottleNeckMatrix1;
            int index5 = index3;
            int index6 = index5;
            int index7 = index4;
            int index8 = index7;
            int num7 = bottleNeckMatrix1[index5, index7] + (int) Math.Round((double) (num6 * 33) / (double) num2);
            numArray1[index6, index8] = num7;
            int tfacing2 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index3, index4, 0, tfacing2);
              if (coordinate1.onmap)
              {
                int num8 = 1;
                do
                {
                  Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                  if (coordinate2.onmap)
                  {
                    coordList2.AddCoord(coordinate2.x, coordinate2.y, 0);
                    this.TempCounterOwner[coordinate2.x, coordinate2.y] = regime;
                  }
                  ++num8;
                }
                while (num8 <= 6);
              }
              ++tfacing2;
            }
            while (tfacing2 <= 6);
            tempMove = new SimpleList();
            int num9 = this.GetOurSelvesEncircledScore(ref tempMove, false, true);
            if ((int) Math.Round((double) (num9 * 12) / (double) num2) > 0)
              num9 = num9;
            int[,] bottleNeckMatrix2 = this.BottleNeckMatrix;
            int[,] numArray2 = bottleNeckMatrix2;
            int index9 = index3;
            int index10 = index9;
            int index11 = index4;
            int index12 = index11;
            int num10 = bottleNeckMatrix2[index9, index11] + (int) Math.Round((double) (num9 * 12) / (double) num2);
            numArray2[index10, index12] = num10;
            if (this.BottleNeckMatrix[index3, index4] > num1)
              num1 = this.BottleNeckMatrix[index3, index4];
            int counter = coordList2.counter;
            for (int index13 = 0; index13 <= counter; ++index13)
              this.TempCounterOwner[coordList2.coord[index13].x, coordList2.coord[index13].y] = this.game.Data.MapObj[0].HexObj[coordList2.coord[index13].x, coordList2.coord[index13].y].Regime;
          }
        }
      }
      if (num1 > 0)
        num1 = num1;
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index = 0; index <= moveMatrixCounter; ++index)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Regime == this.game.Data.Turn & this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempGroup == -1)
          this.game.Data.UnitObj[this.MoveMatrixUnit[index]].AIBottleneck = num1;
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Regime == this.game.Data.Turn & this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempGroup > -1)
          this.game.Data.UnitObj[this.MoveMatrixUnit[index]].AIBottleneck = num1;
      }
    }

    public void MakeSupplyMatrix(bool tlog, bool OnlyReal)
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixPrognosis = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixPrognosisEasyRoads = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixReal = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixPrognosisCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixRealCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.DistanceFromSuppliedHex = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixDistance = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.SupplyMatrix[index1, index2] = -1;
          this.SupplyMatrixReal[index1, index2] = 9999;
          this.SupplyMatrixPrognosis[index1, index2] = 9999;
          this.SupplyMatrixDistance[index1, index2] = -1;
          numArray1[index1, index2] = 0;
        }
      }
      if ((double) this.game.Data.RuleVar[335] > 0.0)
      {
        int num = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num * 4)))] > 0 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))]].Regime, this.GetGameDataTurn()))
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))], 0);
            int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
            for (int index3 = 0; index3 <= mapWidth2; ++index3)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index4 = 0; index4 <= mapHeight; ++index4)
              {
                if (this.SupplyMatrixReal[index3, index4] > this.game.EditObj.TempValue[0].Value[index3, index4])
                {
                  this.SupplyMatrixReal[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
                  this.SupplyMatrixRealCameFrom[index3, index4] = this.game.EditObj.TempCameFrom[0].Value[index3, index4];
                }
              }
            }
            if (OnlyReal)
              return;
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))], 0, dontenterenemy: false);
            int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
            for (int index5 = 0; index5 <= mapWidth3; ++index5)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index6 = 0; index6 <= mapHeight; ++index6)
              {
                if (this.SupplyMatrixPrognosisEasyRoads[index5, index6] > this.game.EditObj.TempValue[0].Value[index5, index6])
                  this.SupplyMatrixPrognosisEasyRoads[index5, index6] = this.game.EditObj.TempValue[0].Value[index5, index6];
              }
            }
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))], 0, dontenterenemy: false, DontCountEnemyRoads: true);
            int mapWidth4 = this.game.Data.MapObj[0].MapWidth;
            for (int index7 = 0; index7 <= mapWidth4; ++index7)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index8 = 0; index8 <= mapHeight; ++index8)
              {
                if (this.SupplyMatrixPrognosis[index7, index8] > this.game.EditObj.TempValue[0].Value[index7, index8])
                {
                  this.SupplyMatrixPrognosis[index7, index8] = this.game.EditObj.TempValue[0].Value[index7, index8];
                  this.SupplyMatrixPrognosisCameFrom[index7, index8] = this.game.EditObj.TempCameFrom[0].Value[index7, index8];
                }
              }
            }
          }
          ++num;
        }
        while (num <= 3);
      }
      else
      {
        int areaCount = this.AreaCount;
        for (int i = 0; i <= areaCount; ++i)
        {
          if (this.IsAreaSupplySource(i, this.game.Data.Turn))
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0);
            int mapWidth5 = this.game.Data.MapObj[0].MapWidth;
            for (int index9 = 0; index9 <= mapWidth5; ++index9)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index10 = 0; index10 <= mapHeight; ++index10)
              {
                if (this.SupplyMatrixReal[index9, index10] > this.game.EditObj.TempValue[0].Value[index9, index10])
                {
                  this.SupplyMatrixReal[index9, index10] = this.game.EditObj.TempValue[0].Value[index9, index10];
                  this.SupplyMatrixRealCameFrom[index9, index10] = this.game.EditObj.TempCameFrom[0].Value[index9, index10];
                }
              }
            }
            if (OnlyReal)
              return;
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0, dontenterenemy: false);
            int mapWidth6 = this.game.Data.MapObj[0].MapWidth;
            for (int index11 = 0; index11 <= mapWidth6; ++index11)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index12 = 0; index12 <= mapHeight; ++index12)
              {
                if (this.SupplyMatrixPrognosisEasyRoads[index11, index12] > this.game.EditObj.TempValue[0].Value[index11, index12])
                  this.SupplyMatrixPrognosisEasyRoads[index11, index12] = this.game.EditObj.TempValue[0].Value[index11, index12];
              }
            }
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0, dontenterenemy: false, DontCountEnemyRoads: true);
            int mapWidth7 = this.game.Data.MapObj[0].MapWidth;
            for (int index13 = 0; index13 <= mapWidth7; ++index13)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index14 = 0; index14 <= mapHeight; ++index14)
              {
                if (this.SupplyMatrixPrognosis[index13, index14] > this.game.EditObj.TempValue[0].Value[index13, index14])
                {
                  this.SupplyMatrixPrognosis[index13, index14] = this.game.EditObj.TempValue[0].Value[index13, index14];
                  this.SupplyMatrixPrognosisCameFrom[index13, index14] = this.game.EditObj.TempCameFrom[0].Value[index13, index14];
                }
              }
            }
          }
        }
      }
      int groupCounter = this.GroupCounter;
      for (int grp = 0; grp <= groupCounter; ++grp)
      {
        int groupHq = this.GetGroupHQ(grp);
        if (groupHq > -1 && this.GroupType[grp] <= 5)
        {
          int x = this.game.Data.UnitObj[groupHq].X;
          int y = this.game.Data.UnitObj[groupHq].Y;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1 && !(this.AreaMatrixWide[x, y] == this.game.Data.UnitObj[groupHq].AIDefend | this.AreaMatrixWide[x, y] == this.game.Data.UnitObj[groupHq].AIAttack) && this.game.Data.UnitObj[groupHq].AIDefend > 0 & this.game.Data.UnitObj[groupHq].AIDefend <= this.AreaCount)
          {
            x = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x;
            y = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y;
          }
          this.SupplyMatrix[x, y] = grp;
          numArray1[x, y] = 1;
          numArray2[x, y] = 1;
        }
      }
      int num1 = 0;
      int num2;
      Coordinate coordinate;
      do
      {
        num2 = 0;
        ++num1;
        int mapWidth8 = this.game.Data.MapObj[0].MapWidth;
        for (int index15 = 0; index15 <= mapWidth8; ++index15)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int index16 = 0; index16 <= mapHeight; ++index16)
          {
            if (numArray1[index15, index16] == num1)
            {
              coordinate = this.game.EditObj.TempCameFrom[0].Value[index15, index16];
              if (coordinate.onmap & numArray1[coordinate.x, coordinate.y] == 0)
              {
                numArray1[coordinate.x, coordinate.y] = num1 + 1;
                num2 = 1;
              }
            }
          }
        }
      }
      while (num2 == 1);
      int num3 = 0;
      int num4;
      do
      {
        num4 = 0;
        ++num3;
        int mapWidth9 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth9; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray2[cx, cy] == num3 & numArray1[cx, cy] > 0)
            {
              int tfacing = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap & numArray1[coordinate.x, coordinate.y] > 0 & numArray2[coordinate.x, coordinate.y] == 0)
                {
                  numArray2[coordinate.x, coordinate.y] = num3 + 1;
                  this.SupplyMatrix[coordinate.x, coordinate.y] = this.SupplyMatrix[cx, cy];
                  num4 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num4 == 1);
      int mapWidth10 = this.game.Data.MapObj[0].MapWidth;
      for (int index17 = 0; index17 <= mapWidth10; ++index17)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index18 = 0; index18 <= mapHeight; ++index18)
        {
          numArray1[index17, index18] = 0;
          if (this.SupplyMatrix[index17, index18] > -1)
          {
            numArray1[index17, index18] = 1;
            this.SupplyMatrixDistance[index17, index18] = 0;
          }
        }
      }
      int num5 = 0;
      int num6;
      do
      {
        num6 = 0;
        ++num5;
        int mapWidth11 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth11; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray1[cx, cy] == num5)
            {
              int tfacing = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[cx, cy].Regime == this.GetGameDataTurn() & numArray1[coordinate.x, coordinate.y] == 0)
                {
                  numArray1[coordinate.x, coordinate.y] = num5 + 1;
                  this.SupplyMatrix[coordinate.x, coordinate.y] = this.SupplyMatrix[cx, cy];
                  this.SupplyMatrixDistance[coordinate.x, coordinate.y] = num5;
                  num6 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num6 == 1 & num5 < 4);
      int mapWidth12 = this.game.Data.MapObj[0].MapWidth;
      for (int index19 = 0; index19 <= mapWidth12; ++index19)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index20 = 0; index20 <= mapHeight; ++index20)
        {
          numArray1[index19, index20] = 0;
          if (index19 == 45 & index20 == 35)
            index19 = index19;
          if ((double) this.SupplyMatrixReal[index19, index20] <= (double) this.game.Data.RuleVar[53] & this.game.Data.MapObj[0].HexObj[index19, index20].Regime == this.GetGameDataTurn())
          {
            numArray1[index19, index20] = 1;
            this.DistanceFromSuppliedHex[index19, index20] = 1;
          }
          else
            this.DistanceFromSuppliedHex[index19, index20] = 9999;
        }
      }
      int num7 = 0;
      int num8;
      do
      {
        num8 = 0;
        ++num7;
        int mapWidth13 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth13; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray1[cx, cy] == num7)
            {
              int tfacing = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime != this.GetGameDataTurn() & numArray1[coordinate.x, coordinate.y] == 0)
                {
                  numArray1[coordinate.x, coordinate.y] = num7 + 1;
                  this.DistanceFromSuppliedHex[coordinate.x, coordinate.y] = num7;
                  num8 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num8 == 1 & num7 < 6);
      if (!(tlog & this.ScreenyLog))
        return;
      this.AddLog("MAKE SUPPLY MATRIX");
      this.AddLog("");
      this.AddLog("Screenshots have been made");
      this.Screenshot(1, "MakeSupplyMatrix_Real", ref this.SupplyMatrixReal);
      this.Screenshot(1, "MakeSupplyMatrix_Prognosis", ref this.SupplyMatrixPrognosis);
      this.Screenshot(1, nameof (MakeSupplyMatrix), ref this.SupplyMatrix);
      this.Screenshot(1, "MakeSupplyMatrix_Distance", ref this.SupplyMatrixDistance);
      this.Screenshot(1, "DistanceFromSuppliedHex", ref this.DistanceFromSuppliedHex);
    }

    public void MoveAndAttackCorps()
    {
      this.MoveAndAttackRound = 0;
      if (this.OpGroup > this.TempGroupHQ.GetUpperBound(0))
        this.TempGroupHQ = (int[]) Utils.CopyArray((Array) this.TempGroupHQ, (Array) new int[this.OpGroup + 1]);
      this.TempGroupHQ[this.OpGroup] = this.GetGroupHQ(this.OpGroup);
      this.LogCounter = -1;
      this.MakeOpHQSupplyMatrix(this.FullLog);
      if (this.FullLog)
        this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_01_MakeOPHQSupplyMatrix");
      this.LogCounter = -1;
      this.MakeEnemySupplyMatrix(this.FullLog);
      if (this.FullLog)
        this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_02_MakeOPHQSupplyMatrix");
      this.LogCounter = -1;
      int num1;
      do
      {
        this.LogCounter = -1;
        this.TempGroupHQ[this.OpGroup] = this.GetGroupHQ(this.OpGroup);
        if (this.TempGroupHQ[this.OpGroup] != -1)
        {
          ++this.MoveAndAttackRound;
          this.game.EditObj.AIProgressMax = 4;
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str((object) this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str((object) (int) Math.Round((double) this.game.EditObj.AIProgressNow / (double) this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
          bool flag = false;
          this.MadeMove = false;
          if (this.FullLog)
            this.AddLog("");
          if (this.FullLog)
            this.AddLog("Move And Attack Round #" + Conversion.Str((object) this.MoveAndAttackRound));
          if (this.SupplyMatrix.GetUpperBound(0) < this.game.Data.MapObj[0].MapWidth)
            this.MakeSupplyMatrix(false, false);
          this.MakeAdvanceAxisMatrix();
          this.SetTArea();
          this.MakeTScoreMatrix();
          this.game.EditObj.AIProgressMax = 4;
          this.game.EditObj.AIProgressNow = 1;
          this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Pre-processing round " + Conversion.Str((object) this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str((object) (int) Math.Round((double) this.game.EditObj.AIProgressNow / (double) this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
          this.MovingIn = false;
          if (this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend > -1 & this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend <= this.AreaCount & this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIAttack <= this.AreaCount)
          {
            if (this.MoveAndAttackRound == 1 & this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIAttackStyle == 1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].y].Regime) == this.GetGameDataTurn())
            {
              if (this.FullLog)
                this.AddLog("ONLY MOVE UNITS OUTSIDE THE CORE DEFENSIVE AREA. DO NOT PUT VIRTUAL UNITS IN.");
              this.MakeMoveMatrix(true, false);
              this.MadeMove = true;
              this.MovingIn = true;
            }
            else if (this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIAttackStyle == 1)
            {
              if (this.FullLog)
                this.AddLog("PUT VIRTUAL UNITS IN.");
              this.MakeMoveMatrix(false, true);
            }
            else
            {
              if (this.FullLog)
                this.AddLog("NO VIRTUAL UNITS / NO LIMITATIONS");
              this.MakeMoveMatrix(false, false);
            }
            this.game.EditObj.AIProgressMax = 4;
            this.game.EditObj.AIProgressNow = 2;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str((object) this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str((object) (int) Math.Round((double) this.game.EditObj.AIProgressNow / (double) this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
            Application.DoEvents();
            this.MarkerList = new SimpleList();
            this.AirMarkerList = new SimpleList();
            this.ArtMarkerList = new SimpleList();
            this.EngineerMarkerList = new SimpleList();
            int power;
            if (this.Meeting | !this.Attacker && !(this.MoveAndAttackRound == 1 & (this.Meeting | !this.Attacker)) && this.GetGroupHQ(this.OpGroup) > -1)
            {
              int aiDefend = this.game.Data.UnitObj[this.GetGroupHQ(this.OpGroup)].AIDefend;
              if (aiDefend > -1 & this.game.Data.UnitObj[this.GetGroupHQ(this.OpGroup)].AIAttack == -1 && this.AreaCounterStep[aiDefend] >= 3 | this.AreaCounterStep[aiDefend] >= 1 & this.AreaCounterDirections[aiDefend, 1] == 0)
              {
                int num2 = 1;
                if (this.FullLog)
                  this.AddLog("AreaCounterPower: " + Conversion.Str((object) this.AreaCounterPower[aiDefend]) + ", AreaCounterStep: " + Conversion.Str((object) this.AreaCounterStep[aiDefend]));
                int Number = 1;
                do
                {
                  if (this.AreaCounterDirections[aiDefend, Number] > 0 && this.AreaCounterRegime[aiDefend, Number] > -1)
                  {
                    if (this.FullLog)
                      this.AddLog("Direction " + Conversion.Str((object) Number) + " = " + this.GetAreaName(this.AreaCounterDirections[aiDefend, Number]) + ", " + this.game.Data.RegimeObj[this.AreaCounterRegime[aiDefend, Number]].Name);
                    if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.AreaCounterDirections[aiDefend, Number]].x, this.AreaCenter[this.AreaCounterDirections[aiDefend, Number]].y].Regime) != this.GetGameDataTurn())
                      num2 = 0;
                  }
                  ++Number;
                }
                while (Number <= 9);
                power = this.AreaCounterPower[aiDefend];
                if (power > 0 & num2 == 1)
                  this.AddVirtualUnits(aiDefend, power, this.FullLog);
              }
            }
            this.MakeEnemyMoveMatrix();
            this.game.EditObj.AIProgressMax = 4;
            this.game.EditObj.AIProgressNow = 4;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str((object) this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str((object) (int) Math.Round((double) this.game.EditObj.AIProgressNow / (double) this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
            if (this.FullLog)
              this.AddLog("Enemy Move Matrix");
            string s = "Units: ";
            int enemyMatrixCounter = this.EnemyMatrixCounter;
            for (int index = 1; index <= enemyMatrixCounter; ++index)
            {
              s = s + this.game.Data.UnitObj[this.EnemyMatrixUnit[index]].Name + ", ";
              power += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(this.EnemyMatrixUnit[index]);
            }
            if (this.FullLog)
              this.AddLog(s);
            this.SetTArea();
            int[,] numArray = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
            int mapWidth = this.game.Data.MapObj[0].MapWidth;
            for (int ix = 0; ix <= mapWidth; ++ix)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int iy = 0; iy <= mapHeight; ++iy)
                numArray[ix, iy] = this.GetTscore(ix, iy);
            }
            this.MakeBottleNeckMatrix();
            this.AddMarkers();
            this.game.EditObj.AIProgressMax = 4;
            this.game.EditObj.AIProgressNow = 3;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str((object) this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str((object) (int) Math.Round((double) this.game.EditObj.AIProgressNow / (double) this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
            Application.DoEvents();
            if (this.FullLog)
            {
              this.AddLog("Normal Markers");
              int counter1 = this.MarkerList.Counter;
              for (int Number = 0; Number <= counter1; ++Number)
              {
                this.AddLog("Marker [[" + Conversion.Str((object) Number) + ") Type=" + Conversion.Str((object) this.MarkerList.Weight[Number]) + "," + Conversion.Str((object) this.MarkerList.Data1[Number]) + "," + Conversion.Str((object) this.MarkerList.Data2[Number]) + "," + Conversion.Str((object) this.MarkerList.Data3[Number]) + "," + Conversion.Str((object) this.MarkerList.Data4[Number]) + ", score= " + Conversion.Str((object) this.MarkerList.Data5[Number]) + " ]] ...  ");
                this.GetTscore(this.MarkerList.Data1[Number], this.MarkerList.Data2[Number], MakeLog: true);
                if (this.MarkerList.Data3[Number] > -1)
                  this.GetTscore(this.MarkerList.Data3[Number], this.MarkerList.Data4[Number], MakeLog: true);
              }
              this.AddLog("Artillery Markers");
              int counter2 = this.ArtMarkerList.Counter;
              for (int Number = 0; Number <= counter2; ++Number)
                this.AddLog("Marker [[" + Conversion.Str((object) Number) + ") Type=" + Conversion.Str((object) this.ArtMarkerList.Weight[Number]) + "," + Conversion.Str((object) this.ArtMarkerList.Data1[Number]) + "," + Conversion.Str((object) this.ArtMarkerList.Data2[Number]) + "," + Conversion.Str((object) this.ArtMarkerList.Data3[Number]) + "," + Conversion.Str((object) this.ArtMarkerList.Data4[Number]) + ", score= " + Conversion.Str((object) this.ArtMarkerList.Data5[Number]) + " ]]");
              this.AddLog("Air Markers");
              int counter3 = this.AirMarkerList.Counter;
              for (int Number = 0; Number <= counter3; ++Number)
                this.AddLog("Marker [[" + Conversion.Str((object) Number) + ") Type=" + Conversion.Str((object) this.AirMarkerList.Weight[Number]) + "," + Conversion.Str((object) this.AirMarkerList.Data1[Number]) + "," + Conversion.Str((object) this.AirMarkerList.Data2[Number]) + "," + Conversion.Str((object) this.AirMarkerList.Data3[Number]) + "," + Conversion.Str((object) this.AirMarkerList.Data4[Number]) + ", score= " + Conversion.Str((object) this.AirMarkerList.Data5[Number]) + " ]]");
              this.AddLog("Engineer Markers");
              int counter4 = this.EngineerMarkerList.Counter;
              for (int Number = 0; Number <= counter4; ++Number)
                this.AddLog("Eng Marker [[" + Conversion.Str((object) Number) + ") Type=" + Conversion.Str((object) this.EngineerMarkerList.Weight[Number]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data1[Number]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data2[Number]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data3[Number]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data4[Number]) + ", score= " + Conversion.Str((object) this.EngineerMarkerList.Data5[Number]) + " ]]");
            }
            if (this.FullLog)
              this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_10_Round_" + this.MoveAndAttackRound.ToString());
            this.LogCounter = -1;
            this.MakeEnemyPowerDispersed();
            this.FindBestMove();
            this.AddLog("BestMove");
            if (!Information.IsNothing((object) this.BestMove))
            {
              if (this.FullLog)
              {
                int counter = this.BestMove.Counter;
                for (int Number1 = 0; Number1 <= counter; ++Number1)
                {
                  int Number2 = this.BestMove.Data2[Number1];
                  if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 1)
                    this.AddLog(Conversion.Str((object) Number1) + ") Type=" + Conversion.Str((object) this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[" + Conversion.Str((object) Number2) + ") Type=" + Conversion.Str((object) this.MarkerList.Weight[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data1[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data2[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data3[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data4[Number2]) + ", score= " + Conversion.Str((object) this.MarkerList.Data5[Number2]) + " ]] , " + Conversion.Str((object) this.BestMove.Data3[Number1]) + "," + Conversion.Str((object) this.BestMove.Data4[Number1]));
                  else if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 2 | this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 5)
                    this.AddLog(Conversion.Str((object) Number1) + ") Type=" + Conversion.Str((object) this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[ART" + Conversion.Str((object) Number2) + ") Type=" + Conversion.Str((object) this.ArtMarkerList.Weight[Number2]) + "," + Conversion.Str((object) this.ArtMarkerList.Data1[Number2]) + "," + Conversion.Str((object) this.ArtMarkerList.Data2[Number2]) + "," + Conversion.Str((object) this.ArtMarkerList.Data3[Number2]) + "," + Conversion.Str((object) this.ArtMarkerList.Data4[Number2]) + ", score= " + Conversion.Str((object) this.ArtMarkerList.Data5[Number2]) + " ]] , " + Conversion.Str((object) this.BestMove.Data3[Number1]) + "," + Conversion.Str((object) this.BestMove.Data4[Number1]));
                  else if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 3)
                    this.AddLog(Conversion.Str((object) Number1) + ") Type=" + Conversion.Str((object) this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[AIR" + Conversion.Str((object) Number2) + ") Type=" + Conversion.Str((object) this.AirMarkerList.Weight[Number2]) + "," + Conversion.Str((object) this.AirMarkerList.Data1[Number2]) + "," + Conversion.Str((object) this.AirMarkerList.Data2[Number2]) + "," + Conversion.Str((object) this.AirMarkerList.Data3[Number2]) + "," + Conversion.Str((object) this.AirMarkerList.Data4[Number2]) + ", score= " + Conversion.Str((object) this.AirMarkerList.Data5[Number2]) + " ]] , " + Conversion.Str((object) this.BestMove.Data3[Number1]) + "," + Conversion.Str((object) this.BestMove.Data4[Number1]));
                  else if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 4)
                  {
                    if (this.EngineerMarkerList.Counter > -1)
                      this.AddLog(Conversion.Str((object) Number1) + ") Type=" + Conversion.Str((object) this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[ENG" + Conversion.Str((object) Number2) + ") Type=" + Conversion.Str((object) this.EngineerMarkerList.Weight[Number2]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data1[Number2]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data2[Number2]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data3[Number2]) + "," + Conversion.Str((object) this.EngineerMarkerList.Data4[Number2]) + ", score= " + Conversion.Str((object) this.EngineerMarkerList.Data5[Number2]) + " ]] , " + Conversion.Str((object) this.BestMove.Data3[Number1]) + "," + Conversion.Str((object) this.BestMove.Data4[Number1]));
                    else
                      this.AddLog(Conversion.Str((object) Number1) + ") Type=" + Conversion.Str((object) this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[" + Conversion.Str((object) Number2) + ") Type=" + Conversion.Str((object) this.MarkerList.Weight[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data1[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data2[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data3[Number2]) + "," + Conversion.Str((object) this.MarkerList.Data4[Number2]) + ", score= " + Conversion.Str((object) this.MarkerList.Data5[Number2]) + " ]] , " + Conversion.Str((object) this.BestMove.Data3[Number1]) + "," + Conversion.Str((object) this.BestMove.Data4[Number1]));
                  }
                }
              }
              this.GetMoveScore(this.BestMove, true);
              this.ExecuteBestMove(ref this.BestMove, false);
              flag = this.MaybeeExecuteAttackMarkers();
              if (this.FullLog)
                this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_20_Round_" + this.MoveAndAttackRound.ToString());
              this.LogCounter = -1;
            }
            this.removevirtualUnits();
            num1 = 0;
            if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100 & this.MoveAndAttackRound <= 4)
            {
              if (flag | this.MadeMove)
                num1 = 1;
            }
            else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 0 & this.MoveAndAttackRound <= 1)
            {
              if (flag | this.MadeMove)
                num1 = 1;
            }
            else if (this.MoveAndAttackRound <= 2 & flag & this.CorpsStance[this.OpGroup] == 3)
              num1 = 1;
            if (this.GroupType[this.OpGroup] >= 5 & this.MoveMatrixCounter <= 1 & !this.MovingIn)
              num1 = 0;
            this.MovingIn = false;
          }
          else
            goto label_99;
        }
        else
          goto label_98;
      }
      while (num1 == 1);
      goto label_100;
label_98:
      return;
label_99:
      return;
label_100:;
    }

    public NewAIClass(GameClass tgame)
    {
      this.ptemp = new int[161, 151];
      this.ptemp2 = new int[161, 151];
      this.ptemp3 = new int[161, 151];
      this.atemp = new int[9000];
      this.atemp2 = new int[9000];
      this.ptempb = new bool[9000];
      this.stemp = new int[9000];
      this.pmatrix = new MapMatrix2Boolean(160, 150);
      this.TscoreMatrix = new int[161, 151];
      this.TscoreCounterMatrix = new int[161, 151];
      this.AreaClosestEnemy = new int[1];
      this.SupplyMatrix = new int[2, 2];
      this.SupplyCounterMatrix = new int[2, 2];
      this.SupplyTempOwnerMatrix = new int[2, 2];
      this.SupplyMatrixReal = new int[2, 2];
      this.SupplyMatrixPrognosis = new int[2, 2];
      this.SupplyMatrixPrognosisEasyRoads = new int[2, 2];
      this.DistanceFromSuppliedHex = new int[2, 2];
      this.BottleNeckMatrix = new int[2, 2];
      this.SupplyMatrixRealCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixPrognosisCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixOpHQReal = new int[2, 2];
      this.SupplyMatrixOpHQPrognosis = new int[2, 2];
      this.SupplyMatrixOpHQRealCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixOpHQPrognosisCameFrom = new Coordinate[2, 2];
      this.DistFromFrontline = new int[2, 2];
      this.FullAdvanceMatrix = new int[161, 151];
      this.SupplyMatrixEnemyReal = new int[2, 2];
      this.SupplyMatrixEnemyPrognosis = new int[2, 2];
      this.SupplyMatrixEnemyRealCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixEnemyPrognosisCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixDistance = new int[2, 2];
      this.AdvanceAxisMatrix = new int[161, 151];
      this.HexOccupyMatrix = new int[2, 2];
      this.FighterMatrix = new int[2, 2];
      this.MoveMatrix = new int[91, 161, 151];
      this.MoveMatrixCameFrom = new sCoordinate[91, 161, 151];
      this.MoveMatrixUnit = new int[91];
      this.MoveMatrixCloseRoad = new Coordinate[91];
      this.AreaSupplyBorderCount = new int[1];
      this.AreaSupplyBorder = new int[1, 1];
      this.AreaSupplyBorderEither = new int[1, 1];
      this.AreasupplyborderSea = new int[1, 1];
      this.RandomAreaNeighbourCount = new int[1];
      this.RandomAreaNeighbour = new int[1, 1];
      this.EnemyMatrix = new int[91, 161, 151];
      this.EnemyMatrixCameFrom = new sCoordinate[91, 161, 151];
      this.EnemyMatrixUnit = new int[91];
      this.EnemyMatrix2CameFrom = new sCoordinate[91, 161, 151];
      this.EnemyMatrix2 = new int[91, 161, 151];
      this.FriendlyPowerDispersed = new int[2, 2];
      this.EnemyPowerDispersed = new int[2, 2];
      this.MoveMatrixUnitMarker = new int[91];
      this.TempMoveMatrixUnitMarker = new int[91];
      this.HistoryMove = new SimpleList[9000];
      this.CombatMatrix = new float[2, 2];
      this.tArea = new int[2, 2];
      this.DistToTArea = new int[2, 2];
      this.DistFromTArea = new int[2, 2];
      this.FrontlineArea = new int[2, 2];
      this.EnemyFrontlineArea = new int[2, 2];
      this.TempOwner = new int[2, 2];
      this.TempCounterOwner = new int[2, 2];
      this.AreaGroup = new int[2];
      this.AreaExtraVP = new int[2];
      this.OldExtraVP = new int[2];
      this.AreaMatrixNarrow = new int[2, 2];
      this.AreaMatrixWide = new int[2, 2];
      this.AreaBorderNoBridge = new int[2, 2];
      this.AreaIsExtra = new bool[2];
      this.AreaBroadBorder = new int[2, 2];
      this.AreaNarrowBorder = new int[2, 2];
      this.AreaBorder = new int[2, 2];
      this.AreaWideBorder = new int[2, 2];
      this.HisAreaDistance = new int[2, 2];
      this.HisAreaDistanceFriendly = new int[2, 2];
      this.AreaCenter = new Coordinate[2];
      this.AreaBridges = new SimpleList[2];
      this.AreaFuzzyVP = new int[2];
      this.AreaDefensive = new int[2];
      this.CorpsStrength = new int[2];
      this.AreaStrength = new int[2];
      this.CounterAttackPossible = new int[2, 2];
      this.CorpsStrategic = new bool[2];
      this.CorpsLoc = new int[2];
      this.CorpsTarget = new int[2];
      this.CorpsSource = new int[2];
      this.CorpsMove = new int[2];
      this.CorpsTopGroup = new int[2];
      this.CorpsEngineer = new bool[2];
      this.AreaOwner = new int[2];
      this.AreaEnemy = new int[2];
      this.AreaStartEnemy = new int[2];
      this.AreaIsHistoricalArea = new int[2];
      this.AreaCounterPower = new int[2];
      this.AreaCounterDirections = new int[2, 10];
      this.AreaCounterRegime = new int[2, 10];
      this.AreaCounterStep = new int[2];
      this.AverageAreaEntrench = new int[2];
      this.CorpsMoveProgress = new int[2];
      this.CorpsStance = new int[2];
      this.CorpsStartLoc = new int[2];
      this.CorpsFirstAreaBattle = new int[2];
      this.CorpsTopRatio = new float[2];
      this.CorpsBottleneck = new int[2];
      this.CorpsOldDefend = new int[2];
      this.TempGroupHQ = new int[2];
      this.CorpsTempStrength = new int[2];
      this.FriendlySupply = new int[2];
      this.StartFriendlySupply = new int[2];
      this.EnemySupply = new int[2];
      this.AreaSteps = new int[2, 2];
      this.CorpsEntrench = new int[2];
      this.EnemySupplyGone = new int[2];
      this.StartEnemySupplyGone = new int[2];
      this.CorpsAirStrength = new int[2];
      this.CorpsTempAirStrength = new int[2];
      this.CorpsAirEffect = new int[2];
      this.corpsstartStrength = new int[2];
      this.CorpsLandStrength = new int[2];
      this.CorpsPowerLeft = new int[2];
      this.CorpsAttack = new int[2];
      this.CorpsDefend = new int[2];
      this.GroupType = new int[2];
      this.GroupHis = new int[2];
      this.GroupName = new string[2];
      this.GroupAttack = new int[2];
      this.GroupDefend = new int[2];
      this.GroupFallBack = new int[2];
      this.GroupFollowUp = new int[2];
      this.TempGroupTarget = new int[2];
      this.GroupHQNeed = new int[2];
      this.SeaBorder = new int[2, 2];
      this.SeaMatrix = new int[2, 2];
      this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 50;
      this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 500;
      this.CONST_ARTMULTI = 2f;
      this.CONST_AIRMULTI = 1.5f;
      this.CONST_LANDDEFMULTI = 2f;
      this.StrTempCorps = new int[1];
      this.StrTempCorpsMod = new float[1];
      this.StrCurSides = new int[1];
      this.StrCounterAttack = new int[1, 1];
      this.StrLandEnemySupply = new int[1];
      this.StartStrLandEnemySupply = new int[1];
      this.StrOrigAreaOwner = new int[1];
      this.StrAreaEntrench = new int[1];
      this.StrAreaNegPow = new int[1];
      this.LogTxt = new string[1];
      this.LogTxt2 = new string[1];
      this.game = tgame;
      this.LastRegime = -1;
    }

    public void PlayCards(int eventgroup, bool alllog)
    {
      if (alllog)
        this.AddLog("PLAY HAND CARDS OF UNITS?");
      if (alllog)
        this.AddLog("");
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index1 = 0; index1 <= unitCounter1; ++index1)
      {
        if (this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].Historical > -1 & this.game.Data.UnitObj[index1].Regime == this.game.Data.Turn)
        {
          int historical = this.game.Data.UnitObj[index1].Historical;
          for (int handCardCounter = this.game.Data.HistoricalUnitObj[historical].HandCardCounter; handCardCounter >= 0; handCardCounter += -1)
          {
            int cardnr = this.game.Data.HistoricalUnitObj[historical].HandCard[handCardCounter];
            int num = 1;
            if (this.game.Data.ActionCardObj[cardnr].HisVarCostType > -1)
            {
              int hisVarCount = this.game.Data.HistoricalUnitObj[historical].HisVarCount;
              for (int index2 = 0; index2 <= hisVarCount; ++index2)
              {
                if (this.game.Data.HistoricalUnitObj[historical].HisVarType[index2] == this.game.Data.ActionCardObj[cardnr].HisVarCostType && this.game.Data.HistoricalUnitObj[historical].HisVarValue[index2] < this.game.Data.ActionCardObj[cardnr].HisVarCostQty)
                  num = 0;
              }
            }
            if (this.game.Data.ActionCardObj[cardnr].PPCost > this.game.Data.RegimeObj[this.game.Data.Turn].ResPts)
              num = 0;
            if (num == 1)
            {
              if (this.game.Data.ActionCardObj[cardnr].PreExecuteEvent > -1)
              {
                if (alllog)
                  this.AddLog("");
                if (alllog)
                  this.AddLog(this.game.Data.UnitObj[index1].Name + " has card with pre-execute event: " + this.game.Data.ActionCardObj[cardnr].Title);
                this.game.EditObj.UnitSelected = index1;
                this.game.ProcessingObj.PlayCardPreEvent(cardnr);
              }
              else if (alllog)
                this.AddLog(this.game.Data.UnitObj[index1].Name + " has card: " + this.game.Data.ActionCardObj[cardnr].Title);
              if (this.game.Data.ActionCardObj[cardnr].AILabel > 0)
              {
                if (alllog)
                  this.AddLog("Calling event for advice on what to play: " + this.game.Data.EventObj[this.game.Data.ActionCardObj[cardnr].AILabel].Name + ". event either sets areax=unit# to play on or areax,areay=hex to play on.");
                this.game.EditObj.AreaX = -1;
                this.game.EditObj.AreaY = -1;
                this.game.EventRelatedObj.DoCheckSpecificEvent(this.game.Data.ActionCardObj[cardnr].AILabel, this.game.Data.ActionCardObj[cardnr].TempVar0, this.game.Data.ActionCardObj[cardnr].TempVar1, index1);
                if (this.game.EditObj.AreaX > -1 & this.game.EditObj.AreaY > -1 & this.game.Data.ActionCardObj[cardnr].AreaSlot > -1 & this.game.Data.ActionCardObj[cardnr].AreaValue > -1)
                {
                  if (alllog)
                    this.AddLog("PLAYED!!! target hex selected = " + this.game.EditObj.AreaX.ToString() + "," + this.game.EditObj.AreaY.ToString());
                  this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                }
                else if (this.game.EditObj.AreaX > -1 & this.game.Data.ActionCardObj[cardnr].UnitSelect)
                {
                  this.game.EditObj.UnitSelected = this.game.EditObj.AreaX;
                  if (alllog)
                    this.AddLog("PLAYED!!! unit target selected = " + this.game.Data.UnitObj[this.game.EditObj.UnitSelected].Name);
                  this.game.EditObj.AreaX = -1;
                  this.game.EditObj.AreaY = -1;
                  this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                }
                else if (alllog)
                  this.AddLog("event has returned AreaX=-1 indicating we should hold playing the card.");
              }
              else
              {
                if (alllog)
                  this.AddLog("card has no AIlabel set for instructions event.");
                if (this.game.Data.ActionCardObj[cardnr].UnitSelect)
                {
                  SimpleList simpleList = new SimpleList();
                  int unitCounter2 = this.game.Data.UnitCounter;
                  for (int index3 = 0; index3 <= unitCounter2; ++index3)
                  {
                    if (this.game.Data.UnitObj[index3].TempUnitSelectable)
                      simpleList.Add(index3, (int) Math.Round((double) (VBMath.Rnd() * (float) this.GetDivisionalPower(index3, -1))));
                  }
                  if (simpleList.Counter > -1)
                  {
                    simpleList.Sort();
                    this.game.EditObj.UnitSelected = simpleList.Id[simpleList.Counter];
                    if (alllog)
                      this.AddLog("PLAYED!!! unit target selected = " + this.game.Data.UnitObj[this.game.EditObj.UnitSelected].Name);
                    this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                  }
                }
                else if (this.game.Data.ActionCardObj[cardnr].AreaSlot > -1 & this.game.Data.ActionCardObj[cardnr].AreaValue > -1)
                {
                  SimpleList simpleList = new SimpleList();
                  int mapWidth = this.game.Data.MapObj[0].MapWidth;
                  for (int tdata1 = 0; tdata1 <= mapWidth; ++tdata1)
                  {
                    int mapHeight = this.game.Data.MapObj[0].MapHeight;
                    for (int tdata2 = 0; tdata2 <= mapHeight; ++tdata2)
                    {
                      if (this.game.Data.MapObj[0].HexObj[tdata1, tdata2].AreaCode[this.game.Data.ActionCardObj[cardnr].AreaSlot] == this.game.Data.ActionCardObj[cardnr].AreaValue)
                        simpleList.Add(tdata1 * 1000 + tdata2, (int) Math.Round((double) (VBMath.Rnd() * 5000f)), tdata1, tdata2);
                    }
                  }
                  if (simpleList.Counter > -1)
                  {
                    simpleList.Sort();
                    this.game.EditObj.AreaX = simpleList.Data1[0];
                    this.game.EditObj.AreaY = simpleList.Data1[0];
                    if (alllog)
                      this.AddLog("PLAYED!!!  target hex selected = " + this.game.EditObj.AreaX.ToString() + "," + this.game.EditObj.AreaY.ToString());
                    this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                  }
                }
                else
                {
                  if (alllog)
                    this.AddLog("PLAYED!!! card played without any settings <not good>");
                  this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                }
              }
            }
          }
        }
      }
    }

    public void ExecuteAI()
    {
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index = 0; index <= moveMatrixCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn)
          this.game.Data.UnitObj[index].AIBottleneck = 0;
      }
      if (this.GroupCounter < 0)
      {
        this.game.AIRunning = false;
      }
      else
      {
        this.game.EditObj.TempAIString = "Setting up Execution";
        this.game.EditObj.AIProgressNow = 0;
        this.game.EditObj.AIProgressMax = 100;
        this.LogCounter = -1;
        this.PlayCards(0, this.FullLog);
        if (this.FullLog)
          this.WriteLog("20_PlayCards");
        this.LogCounter = -1;
        this.MakeTempCategories(this.FullLog);
        if (this.FullLog)
          this.WriteLog("21_MakeTempCategories");
        this.LogCounter = -1;
        this.MakeFighterCoverage(this.FullLog);
        if (this.FullLog)
          this.WriteLog("22_MakeFighterCoverage");
        this.LogCounter = -1;
        this.TempGroupHQ = (int[]) Utils.CopyArray((Array) this.TempGroupHQ, (Array) new int[this.GroupCounter + 1]);
        int groupCounter1 = this.GroupCounter;
        for (int grp = 0; grp <= groupCounter1; ++grp)
          this.TempGroupHQ[grp] = this.GetGroupHQ(grp);
        SimpleList simpleList = new SimpleList();
        this.CorpsLoc = (int[]) Utils.CopyArray((Array) this.CorpsLoc, (Array) new int[this.GroupCounter + 1]);
        int groupCounter2 = this.GroupCounter;
        for (int tid = 0; tid <= groupCounter2; ++tid)
        {
          int tweight = 0;
          int unitCounter = this.game.Data.UnitCounter;
          for (int unr = 0; unr <= unitCounter; ++unr)
          {
            if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].AIGroup == tid)
            {
              tweight = tweight + this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr, true) + this.game.HandyFunctionsObj.GetPowerPtsAbsoluteForAirOnly(unr) * 20;
              if (this.CorpsLoc[tid] != this.game.Data.UnitObj[unr].AIDefend)
                tweight += 26000;
              else if (this.game.Data.UnitObj[unr].AIAttackStyle == 3 && this.game.Data.UnitObj[unr].AIAttack == this.game.Data.UnitObj[unr].AIFollowup | this.game.Data.UnitObj[unr].AIFollowup == -1)
                tweight += 9000;
            }
          }
          simpleList.Add(tid, tweight);
        }
        simpleList.ReverseSort();
        int counter = simpleList.Counter;
        for (int index1 = 0; index1 <= counter; ++index1)
        {
          int num1 = simpleList.Id[index1];
          int num2 = 0;
          int unitCounter = this.game.Data.UnitCounter;
          for (int unr = 0; unr <= unitCounter; ++unr)
          {
            if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].AIGroup == num1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.game.Data.UnitObj[unr].X > -1 && this.game.HandyFunctionsObj.GetLowestAp(unr) > 0)
            {
              ++num2;
              break;
            }
          }
          if (num2 > 0)
          {
            this.OpGroup = num1;
            this.AddLog("");
            this.AddLog("Move And Attack for Corps = " + this.GroupName[this.OpGroup]);
            int index2 = this.GetGroupHQ(this.OpGroup);
            if ((double) this.game.Data.RuleVar[891] > 0.0 | (double) this.game.Data.RuleVar[892] > 0.0 | (double) this.game.Data.RuleVar[893] > 0.0 && index2 > -1)
            {
              int num3 = 0;
              int hq = this.game.Data.UnitObj[index2].HQ;
              if (this.game.Data.UnitObj[index2].Historical > -1)
              {
                if ((double) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].ID == (double) this.game.Data.RuleVar[891])
                  num3 = 1;
                if ((double) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].ID == (double) this.game.Data.RuleVar[892])
                  num3 = 1;
                if ((double) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].ID == (double) this.game.Data.RuleVar[893])
                  num3 = 1;
              }
              if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1)
              {
                if ((double) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].ID == (double) this.game.Data.RuleVar[891])
                  num3 = 1;
                if ((double) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].ID == (double) this.game.Data.RuleVar[892])
                  num3 = 1;
                if ((double) this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].ID == (double) this.game.Data.RuleVar[893])
                  num3 = 1;
              }
              if (num3 == 0)
                index2 = -1;
            }
            if (index2 > -1 & (double) this.game.Data.RuleVar[894] > 0.0 && this.game.Data.UnitObj[index2].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].Type > 7)
              index2 = -1;
            if (index2 > -1)
            {
              this.AddLog("Fallback = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIFallback));
              this.AddLog("Defend = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIDefend));
              this.AddLog("Attack = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIAttack));
              this.AddLog("Followup = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIFollowup));
              this.AddLog("AttackStyle = " + Conversion.Str((object) this.game.Data.UnitObj[index2].AIAttackStyle));
              this.AddLog("--*||*--");
              this.MoveAndAttackCorps();
            }
            else
              this.AddLog("EMPTY CORPS / disabled processing this corps");
          }
        }
        this.LogCounter = -1;
        if (this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime == -1)
          this.ExecuteStrategicTransfers(this.FullLog);
        if (this.FullLog)
          this.WriteLog("51_ExecuteStrategicTransfers");
        this.LogCounter = -1;
        this.SetBackTempGroups(this.FullLog);
        if (this.FullLog)
          this.WriteLog("52_SetBackTempGroups");
        this.LogCounter = -1;
        this.MakeSupplyMatrix(false, false);
        this.game.AIRunning = false;
      }
    }

    public void InitSetAirIntercept(bool alllog)
    {
      if ((double) this.game.Data.RuleVar[842] == 0.0)
        return;
      int unitCounter1 = this.game.Data.UnitCounter;
      int num1;
      int num2;
      for (int unr = 0; unr <= unitCounter1; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1)
        {
          int absoluteForAirOnly = this.game.HandyFunctionsObj.GetPowerPtsAbsoluteForAirOnly(unr);
          if (absoluteForAirOnly > 0)
          {
            if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.game.Data.UnitObj[unr].Regime))
              num1 += absoluteForAirOnly;
            else
              num2 += absoluteForAirOnly;
          }
        }
      }
      int num3 = (int) Math.Round((double) ((float) num1 * this.game.Data.RuleVar[842]));
      bool flag = (num3 < num2 ? (double) (int) Math.Round((double) (100 * num3) / (double) num2) : 100.0) > (double) VBMath.Rnd() * 100.0;
      if (alllog)
        this.AddLog("friendly airpower = " + num3.ToString() + ", enemy airpower = " + num2.ToString() + " intercept = " + flag.ToString());
      int unitCounter2 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter2; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.HandyFunctionsObj.GetPowerPtsAbsoluteForAirOnly(unr) > 0 && this.game.Data.Turn == this.game.Data.UnitObj[unr].Regime)
        {
          this.game.Data.UnitObj[unr].SOInterceptRdnStop = !flag ? 100 : ((double) VBMath.Rnd() <= 0.5 ? 50 : 75);
          if (alllog)
            this.AddLog(this.game.Data.UnitObj[unr].Name + " => intercept stop at rdn <= " + this.game.Data.UnitObj[unr].SOInterceptRdnStop.ToString());
        }
      }
    }

    public int GetEnemyOnArea(int area)
    {
      int areaCount = this.AreaCount;
      int enemyOnArea;
      for (int index = 0; index <= areaCount; ++index)
      {
        if (this.AreaBorder[index, area] > 0 & this.AreaBorder[index, area] < 99 && this.AreaStartEnemy[index] > 0)
          enemyOnArea += this.AreaStartEnemy[index];
      }
      return enemyOnArea;
    }

    public float GetRatioOnArea(int area)
    {
      int index;
      if (this.game.Data.UnitObj[index].AIDefend > this.AreaCount)
        return 1f;
      int groupCounter = this.GroupCounter;
      int num1;
      for (int grp = 0; grp <= groupCounter; ++grp)
      {
        int groupHq = this.GetGroupHQ(grp);
        if (groupHq > -1)
        {
          int num2 = 0;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1 && this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIDefend, area] > 0 & this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIDefend, area] < 99)
          {
            num1 += this.CorpsStrength[grp];
            num2 = 1;
          }
          if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & num2 == 0 && this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIAttack, area] > 0 & this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIAttack, area] < 99)
          {
            num1 += this.CorpsStrength[grp];
            num2 = 1;
          }
          if (this.game.Data.UnitObj[groupHq].AIFallback > -1 & num2 == 0 && this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIFallback, area] > 0 & this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIFallback, area] < 99)
            num1 += this.CorpsStrength[grp];
        }
      }
      int num3 = this.AreaStrength[area];
      if (num1 <= 0)
        return 0.0f;
      if (num3 == 0)
        return 999f;
      this.AddLog("Area = " + this.GetAreaName(area) + ", Ratio = " + Conversion.Str((object) ((float) num1 / (float) num3)));
      return (float) num1 / (float) num3;
    }

    public bool HasThisHQNoSplit(int unr) => unr != -1 && this.game.Data.UnitObj[unr].Historical != -1 && (this.game.Data.UnitObj[unr].AIGroup > -1 && this.GroupType[this.game.Data.UnitObj[unr].AIGroup] == 5 & (double) this.game.Data.RuleVar[888] == 1.0 || this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].NoSplit);

    public void InitFreeRoads()
    {
      if ((double) this.game.Data.RuleVar[32] == -1.0)
        return;
      int locCounter = this.game.Data.LocCounter;
      for (int index1 = 0; index1 <= locCounter; ++index1)
      {
        int x = this.game.Data.LocObj[index1].X;
        int y = this.game.Data.LocObj[index1].Y;
        if (this.game.Data.MapObj[0].HexObj[x, y].Regime == this.game.Data.Turn)
        {
          int index2 = this.AreaMatrixNarrow[x, y];
          if (index2 > -1)
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.AreaCenter[index2].x, this.AreaCenter[index2].y, 0);
            int index3;
            int index4;
            if ((double) this.game.EditObj.TempValue[0].Value[x, y] > (double) this.game.Data.RuleVar[51] && this.game.EditObj.TempValue[0].Value[index3, index4] < 999)
            {
              int num = 1;
              while (num == 1)
              {
                num = 0;
                Coordinate coordinate = this.game.EditObj.TempCameFrom[0].Value[x, y];
                if (coordinate.onmap)
                {
                  int index5 = this.game.HandyFunctionsObj.HexFacing(x, y, 0, coordinate.x, coordinate.y, 0) - 1;
                  this.game.Data.MapObj[0].HexObj[x, y].RoadType[index5] = (int) Math.Round((double) this.game.Data.RuleVar[32]);
                  int index6 = index5 + 3;
                  if (index6 > 5)
                    index6 -= 6;
                  this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].RoadType[index6] = (int) Math.Round((double) this.game.Data.RuleVar[32]);
                  num = 1;
                  x = coordinate.x;
                  y = coordinate.y;
                }
              }
            }
          }
        }
      }
    }

    public void InitDecisions()
    {
      int num1;
      do
      {
        int Number;
        ++Number;
        this.AddLog("INIT DECISION ROUND " + Conversion.Str((object) Number));
        num1 = 0;
        SimpleList simpleList = new SimpleList();
        int locTypeCounter = this.game.Data.LocTypeCounter;
        for (int index1 = 0; index1 <= locTypeCounter; ++index1)
        {
          if (this.game.Data.LocTypeObj[index1].AICanBuild)
          {
            int num2 = 1;
            if (this.game.Data.RegimeObj[this.game.Data.Turn].ResPts < this.game.Data.LocTypeObj[index1].PPCost)
              num2 = 0;
            int index2 = 0;
            do
            {
              if (this.game.Data.LocTypeObj[index1].VarType[index2] > -1 && this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[this.game.Data.LocTypeObj[index1].VarType[index2]] < this.game.Data.LocTypeObj[index1].VarQty[index2])
                num2 = 0;
              if (this.game.Data.LocTypeObj[index1].Research[index2] > -1 && !this.game.Data.RegimeObj[this.game.Data.Turn].ResField[this.game.Data.LocTypeObj[index1].Research[index2]])
                num2 = 0;
              ++index2;
            }
            while (index2 <= 4);
            if (num2 == 1)
            {
              this.game.EditObj.AreaX = -1;
              this.game.EditObj.AreaY = -1;
              Coordinate locationForLocType;
              if (this.game.Data.LocTypeObj[index1].AILocEvent > -1)
              {
                this.game.EventRelatedObj.DoCheckSpecificEvent(this.game.Data.LocTypeObj[index1].AILocEvent, index1);
                locationForLocType.x = this.game.EditObj.AreaX;
                locationForLocType.y = this.game.EditObj.AreaY;
              }
              else
                locationForLocType = this.AutoFindLocationForLocType(index1);
              if (locationForLocType.x > -1 && this.game.EditObj.TempValue[0].Value[locationForLocType.x, locationForLocType.y] == 1)
              {
                int aiPriority = this.game.Data.LocTypeObj[index1].AIPriority;
                if (this.game.Data.LocTypeObj[index1].AIEvent > -1)
                {
                  this.game.EventRelatedObj.DoCheckSpecificEvent(this.game.Data.LocTypeObj[index1].AIEvent, index1);
                  aiPriority += this.game.EditObj.AreaX;
                }
                if (aiPriority > 0)
                {
                  int tid;
                  ++tid;
                  simpleList.Add(tid, aiPriority, 1, index1, locationForLocType.x, locationForLocType.y);
                  num1 = 1;
                }
              }
            }
          }
        }
        simpleList.Sort();
        int counter = simpleList.Counter;
        for (int index = 0; index <= counter; ++index)
          this.AddLog(Conversion.Str((object) simpleList.Id[index]) + ", weight=" + Conversion.Str((object) simpleList.Weight[index]) + " data= " + Conversion.Str((object) simpleList.Data1[index]) + "," + Conversion.Str((object) simpleList.Data2[index]) + "," + Conversion.Str((object) simpleList.Data3[index]) + ",");
        if (simpleList.Counter > -1)
        {
          int num3 = simpleList.Data1[simpleList.Counter];
          int loctype = simpleList.Data2[simpleList.Counter];
          int x = simpleList.Data3[simpleList.Counter];
          int y = simpleList.Data4[simpleList.Counter];
          if (num3 == 1)
            this.game.ProcessingObj.Build(-1, x, y, 0, loctype, this.game.Data.Turn);
        }
      }
      while (num1 == 1);
    }

    public Coordinate AutoFindLocationForLocType(int loctyp)
    {
      int num1 = -1;
      int num2 = -9999;
      int[,] numArray = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.game.HandyFunctionsObj.RedimTempValue(0);
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          if (this.game.Data.MapObj[0].HexObj[index1, index2].Regime > -1)
            numArray[index1, index2] = !this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index1, index2].Regime) ? (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index1, index2].Regime) ? 300 : (this.game.Data.Turn != this.game.Data.MapObj[0].HexObj[index1, index2].Regime ? 100 : 0)) : 1000;
          else if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index1, index2].LandscapeType].IsSea)
            numArray[index1, index2] = 100;
        }
      }
      int num3 = 1;
      int num4 = 0;
      Coordinate locationForLocType;
      while (num3 == 1 & num4 < 999)
      {
        ++num4;
        num3 = 0;
        int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth2; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            int tfacing = 1;
            do
            {
              locationForLocType = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (locationForLocType.onmap && (double) numArray[locationForLocType.x, locationForLocType.y] < Conversion.Int((double) numArray[cx, cy] / 2.0))
              {
                numArray[locationForLocType.x, locationForLocType.y] = (int) Math.Round(Conversion.Int((double) numArray[cx, cy] / 2.0));
                num3 = 1;
              }
              ++tfacing;
            }
            while (tfacing <= 6);
          }
        }
      }
      int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
      int index3;
      int num5;
      for (index3 = 0; index3 <= mapWidth3; ++index3)
      {
        int mapHeight1 = this.game.Data.MapObj[0].MapHeight;
        for (int index4 = 0; index4 <= mapHeight1; ++index4)
        {
          int num6 = 0;
          if (this.game.Data.MapObj[0].HexObj[index3, index4].Regime == this.game.Data.Turn && this.game.Data.MapObj[0].HexObj[index3, index4].Location == -1)
          {
            int buildGround = this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index3, index4].LandscapeType].BuildGround;
            if (this.game.Data.LocTypeObj[loctyp].BuildgroundType[buildGround] && this.game.HandyFunctionsObj.IsHexNextToSea(index3, index4, 0) | !this.game.Data.LocTypeObj[loctyp].IsPort)
            {
              bool flag = true;
              int mapWidth4 = this.game.Data.MapObj[0].MapWidth;
              for (int x2 = 0; x2 <= mapWidth4; ++x2)
              {
                int mapHeight2 = this.game.Data.MapObj[0].MapHeight;
                for (int y2 = 0; y2 <= mapHeight2; ++y2)
                {
                  int location = this.game.Data.MapObj[0].HexObj[x2, y2].Location;
                  if (location > -1)
                  {
                    int locTypeGroup = this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].LocTypeGroup;
                    int num7 = this.game.HandyFunctionsObj.Distance(index3, index4, 0, x2, y2, 0);
                    if (this.game.Data.LocTypeObj[loctyp].MinDistance[locTypeGroup] > -1 && this.game.Data.LocTypeObj[loctyp].MinDistance[locTypeGroup] > num7)
                      flag = false;
                  }
                }
              }
              if (this.game.Data.LocTypeObj[loctyp].SlotType > -1 && this.game.Data.MapObj[0].HexObj[index3, index4].AreaCode[this.game.Data.LocTypeObj[loctyp].SlotType] != this.game.Data.LocTypeObj[loctyp].SlotValue)
                flag = false;
              if (flag)
              {
                num6 = 1;
                if (numArray[index3, index4] > num2)
                {
                  num2 = numArray[index3, index4];
                  num1 = index3;
                  num5 = index4;
                }
              }
            }
          }
          this.game.EditObj.TempValue[0].Value[index3, index4] = num6 != 1 ? 0 : 1;
        }
      }
      locationForLocType.x = num1;
      locationForLocType.y = num5;
      locationForLocType.map = 0;
      locationForLocType.onmap = true;
      if (index3 == -1)
      {
        locationForLocType.onmap = false;
        locationForLocType.y = -1;
      }
      return locationForLocType;
    }

    public void InitUnitHQs()
    {
      bool flag = true;
      if (flag)
        this.AddLog("----------------------");
      if (flag)
        this.AddLog("----------------------");
      if (flag)
        this.AddLog("INITUNITHQ");
      int groupCounter = this.GroupCounter;
      for (int grp = 0; grp <= groupCounter; ++grp)
      {
        int index1 = this.GetGroupHQ(grp);
        int realGroupHq = this.GetRealGroupHQ(grp);
        if (index1 > -1 && !this.game.Data.UnitObj[index1].IsHQ)
          index1 = -1;
        if (index1 > -1)
        {
          if (this.game.Data.UnitObj[index1].IsHQ)
          {
            int unitCounter = this.game.Data.UnitCounter;
            for (int index2 = 0; index2 <= unitCounter; ++index2)
            {
              if (this.game.Data.UnitObj[index2].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index2].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index2].X > -1 & !this.game.Data.UnitObj[index2].IsHQ & this.game.Data.UnitObj[index2].AIGroup == grp && this.game.Data.UnitObj[index2].HQ != index1 | this.game.Data.UnitObj[index2].HQ == -1)
              {
                int num1 = this.game.HandyFunctionsObj.Gethqpow(index2);
                int num2 = this.game.HandyFunctionsObj.Gethqpowifhqis(index2, index1);
                if (num2 >= num1 & num2 > 0 | this.game.Data.UnitObj[index2].HQ == -1)
                {
                  this.game.ProcessingObj.SetUnitHq(index2, index1);
                  if (flag)
                    this.AddLog("Set unit " + this.game.Data.UnitObj[index2].Name + " to HQ " + this.game.Data.UnitObj[index1].Name);
                }
              }
            }
          }
        }
        else
        {
          int unitCounter = this.game.Data.UnitCounter;
          for (int Unr = 0; Unr <= unitCounter; ++Unr)
          {
            if (this.game.Data.UnitObj[Unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[Unr].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[Unr].X > -1 & !this.game.Data.UnitObj[Unr].IsHQ & this.game.Data.UnitObj[Unr].AIGroup == grp && this.game.Data.UnitObj[Unr].HQ != realGroupHq | this.game.Data.UnitObj[Unr].HQ == -1 && realGroupHq != -1)
            {
              this.game.ProcessingObj.SetUnitHq(Unr, realGroupHq);
              if (flag)
                this.AddLog("Set unit " + this.game.Data.UnitObj[Unr].Name + " to HQ " + this.game.Data.UnitObj[realGroupHq].Name);
            }
          }
        }
      }
    }

    public int GetPowerPointsUnderCommand(int hq)
    {
      int pointsUnderCommand = 0;
      bool[] flagArray = new bool[this.GroupCounter + 1];
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter1; ++index)
      {
        if (this.game.Data.UnitObj[index].HQ == hq)
        {
          int aiGroup = this.game.Data.UnitObj[index].AIGroup;
          if (aiGroup <= this.GroupCounter && !flagArray[aiGroup])
          {
            flagArray[aiGroup] = true;
            int unitCounter2 = this.game.Data.UnitCounter;
            for (int unr = 0; unr <= unitCounter2; ++unr)
            {
              if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index].AIGroup == aiGroup)
                pointsUnderCommand += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
            }
          }
        }
      }
      return pointsUnderCommand;
    }

    public int GetGroup(int his)
    {
      int groupCounter = this.GroupCounter;
      for (int group = 0; group <= groupCounter; ++group)
      {
        if (this.GroupHis[group] == his)
          return group;
      }
      return -1;
    }

    public int GetRealGroupHQ(int grp)
    {
      int realGroupHq = this.GetGroupHQ(grp);
      if (realGroupHq > -1 && !this.game.Data.UnitObj[realGroupHq].IsHQ)
        realGroupHq = !(!this.game.Data.UnitObj[realGroupHq].IsHQ & this.game.Data.UnitObj[realGroupHq].HQ > -1) ? -1 : this.game.Data.UnitObj[realGroupHq].HQ;
      return realGroupHq;
    }

    public int GetGroupHQ(int grp)
    {
      int groupHq1 = -1;
      if (grp == -1)
        return -1;
      if (this.GroupHis[grp] > 0)
        groupHq1 = this.game.HandyFunctionsObj.GetUnitByHistorical(this.GroupHis[grp]);
      if (groupHq1 == -1)
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int groupHq2 = 0; groupHq2 <= unitCounter; ++groupHq2)
        {
          if (this.game.Data.UnitObj[groupHq2].PreDef == -1 && this.game.Data.UnitObj[groupHq2].X > -1 & this.GetRegime(this.game.Data.UnitObj[groupHq2].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[groupHq2].IsHQ && this.game.Data.UnitObj[groupHq2].AIGroup == grp)
            return groupHq2;
        }
      }
      if (groupHq1 == -1)
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int groupHq3 = 0; groupHq3 <= unitCounter; ++groupHq3)
        {
          if (this.game.Data.UnitObj[groupHq3].PreDef == -1 && this.game.Data.UnitObj[groupHq3].X > -1 & this.GetRegime(this.game.Data.UnitObj[groupHq3].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[groupHq3].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[groupHq3].Historical].TempAttack > -1 | this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[groupHq3].Historical].TempDefend > -1 && this.game.Data.UnitObj[groupHq3].AIGroup == grp)
            return groupHq3;
        }
      }
      if (groupHq1 == -1)
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int groupHq4 = 0; groupHq4 <= unitCounter; ++groupHq4)
        {
          if (this.game.Data.UnitObj[groupHq4].PreDef == -1 && this.game.Data.UnitObj[groupHq4].X > -1 & this.GetRegime(this.game.Data.UnitObj[groupHq4].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[groupHq4].AIGroup == grp)
            return groupHq4;
        }
      }
      return groupHq1;
    }

    public int GetGroupUnits(int grp)
    {
      int groupUnits = 0;
      if (grp == -1)
        return 0;
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X > -1 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].AIGroup == grp)
          ++groupUnits;
      }
      return groupUnits;
    }

    public int GetLargestArmy()
    {
      int[] numArray1 = new int[this.game.Data.RegimeCounter + 1];
      float num1 = 0.8f + (float) new Random(this.game.Data.MapWidth * this.game.Data.MapHeight * this.GetGameDataTurn() * Strings.Len(this.game.Data.Name)).Next(0, 1000) / 2500f;
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.GetRegime(this.game.Data.UnitObj[unr].Regime) > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.game.Data.UnitObj[unr].X > -1)
        {
          int[] numArray2 = numArray1;
          int[] numArray3 = numArray2;
          int regime1 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          int index1 = regime1;
          int num2 = numArray2[regime1] + (int) Math.Round((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ((double) this.game.HandyFunctionsObj.GetAverageMor(unr) / 50.0) * 0.25);
          numArray3[index1] = num2;
          int[] numArray4 = numArray1;
          int[] numArray5 = numArray4;
          int regime2 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          int index2 = regime2;
          int num3 = numArray4[regime2] + (int) Math.Round((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ((double) this.game.HandyFunctionsObj.GetAverageXp(unr) / 50.0) * 0.75);
          numArray5[index2] = num3;
        }
      }
      int nr = 0;
      int num4 = -1;
      int regimeCounter = this.game.Data.RegimeCounter;
      int num5;
      for (int index = 0; index <= regimeCounter; ++index)
      {
        if (this.GetRegime(index) == this.GetGameDataTurn())
          numArray1[index] = (int) Math.Round((double) ((float) numArray1[index] * num1));
        if (numArray1[index] > num4)
        {
          num4 = numArray1[index];
          nr = index;
        }
        if (this.GetRegime(index) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, index))
          num5 += numArray1[index];
      }
      if (this.GetRegime(nr) == this.GetGameDataTurn())
      {
        this.ATTACKERRATIO = (float) numArray1[this.GetGameDataTurn()] / (float) num5;
        if ((double) this.ATTACKERRATIO < 1.0)
          this.ATTACKERRATIO = 1f;
      }
      return nr;
    }

    public int GetLargestEnemy()
    {
      int[] numArray1 = new int[this.game.Data.RegimeCounter + 1];
      float num1 = 0.8f + (float) new Random(this.game.Data.MapWidth * this.game.Data.MapHeight * this.GetGameDataTurn() * Strings.Len(this.game.Data.Name)).Next(0, 1000) / 2500f;
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.GetRegime(this.game.Data.UnitObj[unr].Regime) > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.game.Data.UnitObj[unr].X > -1 && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.UnitObj[unr].Regime))
        {
          int[] numArray2 = numArray1;
          int[] numArray3 = numArray2;
          int regime1 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          int index1 = regime1;
          int num2 = numArray2[regime1] + (int) Math.Round((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ((double) this.game.HandyFunctionsObj.GetAverageMor(unr) / 50.0) * 0.25);
          numArray3[index1] = num2;
          int[] numArray4 = numArray1;
          int[] numArray5 = numArray4;
          int regime2 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          int index2 = regime2;
          int num3 = numArray4[regime2] + (int) Math.Round((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ((double) this.game.HandyFunctionsObj.GetAverageXp(unr) / 50.0) * 0.75);
          numArray5[index2] = num3;
        }
      }
      int nr = 0;
      int num4 = -1;
      int regimeCounter = this.game.Data.RegimeCounter;
      int num5;
      for (int index = 0; index <= regimeCounter; ++index)
      {
        if (this.GetRegime(index) == this.GetGameDataTurn())
          numArray1[index] = (int) Math.Round((double) ((float) numArray1[index] * num1));
        if (numArray1[index] > num4)
        {
          num4 = numArray1[index];
          nr = index;
        }
        if (this.GetRegime(index) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, index))
          num5 += numArray1[index];
      }
      if (this.GetRegime(nr) == this.GetGameDataTurn())
      {
        this.ATTACKERRATIO = (float) numArray1[this.GetGameDataTurn()] / (float) num5;
        if ((double) this.ATTACKERRATIO < 1.0)
          this.ATTACKERRATIO = 1f;
      }
      return nr;
    }

    public void SetBackTempGroups(bool tlog)
    {
      if (tlog)
        this.AddLog("SET BACK TEMP GROUPS");
      if (tlog)
        this.AddLog("");
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].TempGroup > -1)
        {
          if (tlog)
            this.AddLog(this.game.Data.UnitObj[index].Name + " from tempgroup " + this.GroupName[this.game.Data.UnitObj[index].AIGroup] + " back to group: " + this.GroupName[this.game.Data.UnitObj[index].TempGroup]);
          this.game.Data.UnitObj[index].AIGroup = this.game.Data.UnitObj[index].TempGroup;
          this.game.Data.UnitObj[index].TempGroup = -1;
        }
      }
    }

    public bool CanBeStrategiclyTransferred(int unr) => true;

    public int GetBestCapHQ(int regnr)
    {
      SimpleList simpleList = new SimpleList();
      int unitCounter = this.game.Data.UnitCounter;
      for (int tid = 0; tid <= unitCounter; ++tid)
      {
        if (this.game.Data.UnitObj[tid].Regime == regnr & this.game.Data.UnitObj[tid].SupplyIn > 0 & this.game.Data.UnitObj[tid].AirCap > 0 && this.game.Data.UnitObj[tid].IsHQ)
          simpleList.Add(tid, this.game.Data.UnitObj[tid].AirCap);
      }
      simpleList.Sort();
      return simpleList.Counter >= 0 ? simpleList.Id[simpleList.Counter] : -1;
    }

    public SimpleList GetAreaToAreaPath(int from, int too)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      int num1 = 0;
      numArray1[too] = 1;
      int num2 = 1;
      while (num2 >= 0)
      {
        ++num1;
        --num2;
        int areaCount1 = this.AreaCount;
        for (int index1 = 1; index1 <= areaCount1; ++index1)
        {
          if (numArray1[index1] == num1)
          {
            int areaCount2 = this.AreaCount;
            for (int index2 = 1; index2 <= areaCount2; ++index2)
            {
              if (this.AreaNarrowBorder[index1, index2] > 0)
              {
                int num3 = !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime, this.game.Data.Turn) ? (!this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime, this.game.Data.Turn) ? 99 : 1) : 0;
                if (numArray1[index2] == 0 | numArray1[index2] > num1 + 1 + num3)
                {
                  numArray1[index2] = num1 + 1 + num3;
                  numArray2[index2] = index1;
                  num2 = 1;
                }
              }
            }
          }
        }
      }
      SimpleList areaToAreaPath = new SimpleList();
      if (numArray1[from] > 0)
      {
        int num4 = 0;
        int num5 = 1;
        while (num5 == 1)
        {
          ++num4;
          num5 = 0;
          if (numArray2[from] > 0)
          {
            if (num4 > 1)
              areaToAreaPath.Add(numArray2[from], 1);
            num5 = 1;
            from = numArray2[from];
          }
          if (from == 0)
            num5 = 0;
        }
      }
      return areaToAreaPath;
    }

    public string GetAreaName(int nr, bool withnumber = true)
    {
      if (nr == -1)
        return "-1";
      if (nr > this.AreaCount)
        return "OLD";
      if (!withnumber)
        return this.game.HandyFunctionsObj.GetHexName(this.AreaCenter[nr].x, this.AreaCenter[nr].y, 0);
      return Conversion.Str((object) nr) + ") " + this.game.HandyFunctionsObj.GetHexName(this.AreaCenter[nr].x, this.AreaCenter[nr].y, 0) + "(" + Conversion.Str((object) this.AreaCenter[nr].x) + "," + Conversion.Str((object) this.AreaCenter[nr].y) + ")";
    }

    public Coordinate GetCloseFriendlyRoadHex(
      int x,
      int y,
      int maxdistance,
      int unitslot = -1)
    {
      this.ptemp = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.ptemp2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      SimpleList simpleList = new SimpleList();
      this.ptemp[x, y] = 1;
      int num1 = 0;
      int num2 = 1;
      Coordinate closeFriendlyRoadHex;
      if (unitslot > -1)
      {
        closeFriendlyRoadHex = this.MarkerHasCoord(unitslot);
        if (!closeFriendlyRoadHex.onmap)
          return closeFriendlyRoadHex;
        int index = this.MoveMatrixUnit[unitslot];
        int num3 = 1000;
        while (!(closeFriendlyRoadHex.x == this.game.Data.UnitObj[index].X & closeFriendlyRoadHex.y == this.game.Data.UnitObj[index].Y))
        {
          --num3;
          this.ptemp2[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] = num3;
          sCoordinate sCoordinate = this.MoveMatrixCameFrom[unitslot, closeFriendlyRoadHex.x, closeFriendlyRoadHex.y];
          closeFriendlyRoadHex.x = (int) sCoordinate.x;
          closeFriendlyRoadHex.y = (int) sCoordinate.y;
          closeFriendlyRoadHex.onmap = sCoordinate.onmap;
          if (!closeFriendlyRoadHex.onmap)
            break;
        }
      }
      int index1 = 0;
      int tid;
      do
      {
        if (this.SupplyMatrixReal[x, y] < 9999 && this.game.Data.MapObj[0].HexObj[x, y].RoadType[index1] == 0)
        {
          ++tid;
          if (unitslot == -1)
            simpleList.Add(tid, 50, x, y);
          else
            simpleList.Add(tid, this.ptemp2[x, y], x, y);
        }
        ++index1;
      }
      while (index1 <= 5);
      while (num2 == 1 & num1 <= maxdistance)
      {
        ++num1;
        num2 = 0;
        int mapWidth = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (this.ptemp[cx, cy] == num1)
            {
              int tfacing = 1;
              do
              {
                closeFriendlyRoadHex = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (closeFriendlyRoadHex.onmap & this.ptemp[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] == 0)
                {
                  int num4 = 0;
                  if (unitslot == -1)
                    num4 = 1;
                  else if (this.MoveMatrix[unitslot, closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] <= this.game.HandyFunctionsObj.GetLowestAp(this.MoveMatrixUnit[unitslot]))
                    num4 = 1;
                  if (num4 == 1)
                  {
                    this.ptemp[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] = num1 + 1;
                    num2 = 1;
                    if (this.SupplyMatrixReal[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] < 9999)
                    {
                      int index2 = 0;
                      do
                      {
                        if (this.game.Data.MapObj[0].HexObj[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y].RoadType[index2] == 0)
                        {
                          ++tid;
                          if (unitslot == -1)
                            simpleList.Add(tid, 50 - num1, closeFriendlyRoadHex.x, closeFriendlyRoadHex.y);
                          else
                            simpleList.Add(tid, this.ptemp2[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y], closeFriendlyRoadHex.x, closeFriendlyRoadHex.y);
                        }
                        ++index2;
                      }
                      while (index2 <= 5);
                    }
                  }
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      if (simpleList.Counter == -1)
      {
        closeFriendlyRoadHex.onmap = false;
        return closeFriendlyRoadHex;
      }
      simpleList.Sort();
      closeFriendlyRoadHex.x = simpleList.Data1[simpleList.Counter];
      closeFriendlyRoadHex.y = simpleList.Data2[simpleList.Counter];
      closeFriendlyRoadHex.onmap = true;
      return closeFriendlyRoadHex;
    }

    public int GetGameDataTurn() => this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime > -1 ? this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime : this.game.Data.Turn;

    public int GetRegime(int nr)
    {
      if (nr == -1)
        return -1;
      return this.game.Data.RegimeObj[nr].UberRegime > -1 ? this.game.Data.RegimeObj[nr].UberRegime : nr;
    }

    public void MakeTScoreMatrix()
    {
      this.TscoreMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.TscoreCounterMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int ix = 0; ix <= mapWidth1; ++ix)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int iy = 0; iy <= mapHeight; ++iy)
        {
          this.TscoreMatrix[ix, iy] = this.GetTScore2(ix, iy);
          this.TscoreCounterMatrix[ix, iy] = this.GetTScore2(ix, iy, true);
          this.ptemp[ix, iy] = 0;
        }
      }
      int num1 = 1;
      int num2 = -1;
      Coordinate coordinate;
      while (num1 == 1)
      {
        num1 = 0;
        ++num2;
        int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth2; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (this.ptemp[cx, cy] == num2)
            {
              int num3 = (int) Math.Round((double) this.TscoreCounterMatrix[cx, cy] * 0.5);
              if (num3 > 10)
              {
                int tfacing = 1;
                do
                {
                  coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                  if (coordinate.onmap && num3 > this.TscoreCounterMatrix[coordinate.x, coordinate.y])
                  {
                    this.TscoreCounterMatrix[coordinate.x, coordinate.y] = num3;
                    this.ptemp[coordinate.x, coordinate.y] = num2 + 1;
                    num1 = 1;
                  }
                  ++tfacing;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth3; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
          this.ptemp[index1, index2] = 0;
      }
      int num4 = 1;
      int num5 = -1;
      while (num4 == 1)
      {
        num4 = 0;
        ++num5;
        int mapWidth4 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth4; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (this.ptemp[cx, cy] == num5)
            {
              int num6 = (int) Math.Round((double) this.TscoreMatrix[cx, cy] * 0.5);
              if (num6 > 10)
              {
                int tfacing = 1;
                do
                {
                  coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                  if (coordinate.onmap && num6 > this.TscoreMatrix[coordinate.x, coordinate.y])
                  {
                    this.TscoreMatrix[coordinate.x, coordinate.y] = num6;
                    this.ptemp[coordinate.x, coordinate.y] = num5 + 1;
                    num4 = 1;
                  }
                  ++tfacing;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
    }

    public int GetRandomCorpsGroup()
    {
      int groupCounter1 = this.GroupCounter;
      int num1;
      for (int index = 0; index <= groupCounter1; ++index)
      {
        if (this.GroupType[index] <= 5)
          ++num1;
      }
      int num2 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) num1)) + 1;
      if (num2 > num1)
        num2 = num1;
      int num3 = 0;
      int groupCounter2 = this.GroupCounter;
      for (int randomCorpsGroup = 0; randomCorpsGroup <= groupCounter2; ++randomCorpsGroup)
      {
        if (this.GroupType[randomCorpsGroup] <= 5)
          ++num3;
        if (num3 == num2)
          return randomCorpsGroup;
      }
      return -1;
    }

    public int GetHighestFuzzyVPGroup(int forgroup)
    {
      int highestFuzzyVpGroup = -1;
      int index1 = this.TempGroupHQ[forgroup];
      int hq = index1;
      if (index1 > -1)
      {
        if (this.game.Data.UnitObj[hq].Historical > -1)
        {
          if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type == 8)
            return -1;
          if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type < 7)
          {
            hq = this.game.Data.UnitObj[index1].HQ;
            if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type < 7 && this.game.Data.UnitObj[hq].HQ > -1)
            {
              hq = this.game.Data.UnitObj[hq].HQ;
              if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type < 7 && this.game.Data.UnitObj[hq].HQ > -1)
                hq = this.game.Data.UnitObj[hq].HQ;
            }
          }
        }
      }
      else
        hq = -1;
      int num1 = 0;
      int groupCounter = this.GroupCounter;
      for (int index2 = 0; index2 <= groupCounter; ++index2)
      {
        if (this.GroupType[index2] <= 5)
        {
          int unr = this.TempGroupHQ[index2];
          if (unr > -1 && this.game.HandyFunctionsObj.IsUnitInHQChain(unr, hq) | hq == -1 | hq == this.game.Data.UnitObj[unr].HQ)
          {
            int index3 = !this.Attacker ? this.CorpsLoc[index2] : this.TempGroupTarget[index2];
            if (index3 > -1)
            {
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime) != this.GetGameDataTurn())
              {
                int num2 = (int) Math.Round((double) ((1 + (int) Math.Round(Math.Sqrt((double) this.AreaFuzzyVP[index3]))) * (int) Math.Round((double) this.AreaStrength[index3] / 10.0)) * Math.Sqrt((double) this.CorpsStrength[index2]));
                if (num2 > num1)
                {
                  highestFuzzyVpGroup = index2;
                  num1 = num2;
                }
              }
              else if (!this.Attacker)
              {
                int num3 = (1 + (int) Math.Round(Math.Sqrt((double) this.AreaFuzzyVP[index3]))) * this.CorpsStrength[index2];
                if (num3 > num1)
                {
                  highestFuzzyVpGroup = index2;
                  num1 = num3;
                }
              }
            }
          }
        }
      }
      if (highestFuzzyVpGroup == -1)
        highestFuzzyVpGroup = forgroup;
      return highestFuzzyVpGroup;
    }

    public int GetAverageHexSpeedofCorpsUnit(int grp, bool friendlyter)
    {
      int num1 = 0;
      int num2 = 0;
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup == grp && this.game.Data.UnitObj[index].TempTheater == 0 && !this.game.Data.UnitObj[index].IsHQ)
        {
          int moveType = this.game.Data.SFTypeObj[this.game.Data.UnitObj[index].TempType].MoveType;
          num1 += this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
          if (!friendlyter)
            num1 += 10;
          ++num2;
        }
      }
      return num2 == 0 ? 0 : (int) Math.Round(Conversion.Int(100.0 / (double) (int) Math.Round((double) num1 / (double) num2)));
    }

    public int GetAverageMoveTypeCorpsUnit(int grp)
    {
      int num1 = 0;
      int[] numArray1 = new int[100];
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == grp && this.game.Data.UnitObj[unr].TempTheater == 0 && !this.game.Data.UnitObj[unr].IsHQ)
        {
          int moveType = this.game.Data.SFTypeObj[this.game.Data.UnitObj[unr].TempType].MoveType;
          int[] numArray2 = numArray1;
          int[] numArray3 = numArray2;
          int index1 = moveType;
          int index2 = index1;
          int num2 = numArray2[index1] + this.GetUnitPower(unr, true);
          numArray3[index2] = num2;
        }
      }
      int moveTypeCorpsUnit = -1;
      int index = 0;
      do
      {
        if (numArray1[index] > num1)
        {
          num1 = numArray1[index];
          moveTypeCorpsUnit = index;
        }
        ++index;
      }
      while (index <= 99);
      if (moveTypeCorpsUnit == -1)
        moveTypeCorpsUnit = 3;
      return moveTypeCorpsUnit;
    }

    public int GetHexSpeedofUnit(int i, bool friendlyter)
    {
      int num1 = 0;
      int num2 = 0;
      if (this.game.Data.UnitObj[i].TempTheater == 0)
      {
        int tempType = this.game.Data.UnitObj[i].TempType;
        if (tempType > -1)
        {
          int moveType = this.game.Data.SFTypeObj[tempType].MoveType;
          num1 += this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
          if (!friendlyter)
            num1 += 10;
          ++num2;
        }
      }
      return num2 == 0 ? 0 : (int) Math.Round(Conversion.Int(100.0 / (double) (int) Math.Round((double) num1 / (double) num2)));
    }

    public bool AreaSeaConnect(int nr, int nr2)
    {
      int seaCount = this.SeaCount;
      for (int index = 1; index <= seaCount; ++index)
      {
        if (this.SeaBorder[index, nr] > 0 & this.SeaBorder[index, nr2] > 0)
          return true;
      }
      return false;
    }

    public int AreaSeaConnectSeaNumber(int nr, int nr2)
    {
      int seaCount = this.SeaCount;
      for (int index = 1; index <= seaCount; ++index)
      {
        if (this.SeaBorder[index, nr] > 0 & this.SeaBorder[index, nr2] > 0)
          return index;
      }
      return -1;
    }

    public void GetStrategyScore_EnemySupply()
    {
      if (this.EnemySupply.GetUpperBound(0) <= this.AreaCount)
        this.EnemySupply = (int[]) Utils.CopyArray((Array) this.EnemySupply, (Array) new int[this.AreaCount + 1]);
      int areaCount1 = this.AreaCount;
      for (int index = 0; index <= areaCount1; ++index)
      {
        this.atemp[index] = 0;
        this.atemp2[index] = 0;
        this.StrLandEnemySupply[index] = 0;
        this.EnemySupply[index] = 0;
      }
      int regimeCounter1 = this.game.Data.RegimeCounter;
      int num1;
      for (int index1 = 0; index1 <= regimeCounter1; ++index1)
      {
        if (this.GetRegime(index1) != this.GetGameDataTurn())
        {
          this.OpGroup = -1;
          int regime = this.GetRegime(index1);
          int num2;
          if ((double) this.game.Data.RuleVar[335] > 0.0)
          {
            int num3 = 0;
            do
            {
              if (this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num3 * 4)))] > 0 & this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num3 * 4)))] > -1)
              {
                int index2 = this.AreaMatrixWide[this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num3 * 4)))], this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num3 * 4)))]];
                num1 = 0;
                if (index2 > 0 && this.GetRegime(this.AreaOwner[index2]) == regime)
                {
                  num1 = 1;
                  this.atemp2[index2] = 1;
                  this.StrLandEnemySupply[index2] = 9999;
                }
                num2 = 0;
              }
              ++num3;
            }
            while (num3 <= 3);
          }
          else
          {
            int areaCount2 = this.AreaCount;
            for (int i = 0; i <= areaCount2; ++i)
            {
              if (this.IsAreaSupplySource(i, index1))
              {
                num1 = 1;
                this.atemp2[i] = 1;
                this.StrLandEnemySupply[i] = 9999;
              }
            }
          }
          while (num1 == 1)
          {
            num1 = 0;
            ++num2;
            int areaCount3 = this.AreaCount;
            for (int nr = 1; nr <= areaCount3; ++nr)
            {
              if (this.atemp2[nr] == num2)
              {
                int num4 = this.AreaSupplyBorderCount[nr];
                for (int index3 = 0; index3 <= num4; ++index3)
                {
                  int nr2;
                  if (this.AreaSupplyBorder[nr, index3] > 0 & nr != this.AreaSupplyBorder[nr, index3])
                  {
                    nr2 = this.AreaSupplyBorder[nr, index3];
                    if (this.GetRegime(this.AreaOwner[nr2]) == regime & this.atemp2[nr2] == 0 | this.StrLandEnemySupply[nr2] < 9999 & this.StrLandEnemySupply[nr2] > 0 & this.StrLandEnemySupply[nr2] != this.StrLandEnemySupply[nr])
                    {
                      this.atemp2[nr2] = this.atemp2[nr] + 1;
                      num1 = 1;
                      this.StrLandEnemySupply[nr2] = this.StrLandEnemySupply[nr];
                    }
                  }
                  if (this.AreaSupplyBorder[nr, index3] == 0 & this.AreasupplyborderSea[nr, index3] > 0 & this.StrLandEnemySupply[nr] == 9999 & nr != nr2)
                  {
                    nr2 = this.AreasupplyborderSea[nr, index3];
                    if (this.GetRegime(this.AreaOwner[nr2]) == regime & this.atemp2[nr2] == 0)
                    {
                      this.atemp2[nr2] = this.atemp2[nr] + 1;
                      num1 = 1;
                      this.StrLandEnemySupply[nr2] = this.AreaSeaConnectSeaNumber(nr, nr2);
                    }
                  }
                }
              }
            }
          }
        }
      }
      int areaCount4 = this.AreaCount;
      for (int index = 0; index <= areaCount4; ++index)
      {
        this.atemp[index] = 0;
        this.atemp2[index] = 0;
        this.EnemySupply[index] = 0;
      }
      int regimeCounter2 = this.game.Data.RegimeCounter;
      for (int index4 = 0; index4 <= regimeCounter2; ++index4)
      {
        if (this.game.Data.Turn != index4)
        {
          this.OpGroup = -1;
          int regime = this.GetRegime(index4);
          if ((double) this.game.Data.RuleVar[335] > 0.0)
          {
            int num5 = 0;
            do
            {
              if (this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num5 * 4)))] > 0 & this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num5 * 4)))] > -1)
              {
                int index5 = this.AreaMatrixWide[this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num5 * 4)))], this.game.Data.RegimeObj[regime].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num5 * 4)))]];
                num1 = 0;
                if (index5 > 0 && this.GetRegime(this.AreaOwner[index5]) == regime)
                {
                  num1 = 1;
                  this.atemp2[index5] = 1;
                  this.EnemySupply[index5] = 1;
                }
              }
              ++num5;
            }
            while (num5 <= 3);
          }
          else if (this.game.Data.Turn != index4)
          {
            int areaCount5 = this.AreaCount;
            for (int i = 0; i <= areaCount5; ++i)
            {
              if (this.IsAreaSupplySource(i, index4))
              {
                num1 = 1;
                this.atemp2[i] = 1;
                this.EnemySupply[i] = 1;
              }
            }
          }
          int num6 = 0;
          while (num1 == 1)
          {
            num1 = 0;
            ++num6;
            int areaCount6 = this.AreaCount;
            for (int nr = 1; nr <= areaCount6; ++nr)
            {
              if (this.atemp2[nr] == num6)
              {
                if (nr == 163)
                  nr = nr;
                int num7 = this.AreaSupplyBorderCount[nr];
                for (int index6 = 0; index6 <= num7; ++index6)
                {
                  int nr2 = this.AreaSupplyBorderEither[nr, index6];
                  if ((this.AreaNarrowBorder[nr, nr2] > 0 | this.AreaSeaConnect(nr, nr2)) & nr != nr2 && this.GetRegime(this.AreaOwner[nr2]) == regime & this.atemp2[nr2] == 0)
                  {
                    this.atemp2[nr2] = this.atemp2[nr] + 1;
                    num1 = 1;
                    this.EnemySupply[nr2] = 1;
                  }
                }
              }
            }
          }
        }
      }
      int areaCount7 = this.AreaCount;
      for (int index7 = 0; index7 <= areaCount7; ++index7)
      {
        if (this.AreaEnemy[index7] > 0)
        {
          if (this.EnemySupply[index7] == 0)
          {
            int[] enemySupplyGone = this.EnemySupplyGone;
            int[] numArray = enemySupplyGone;
            int index8 = index7;
            int index9 = index8;
            int num8 = enemySupplyGone[index8] + 1;
            numArray[index9] = num8;
            if (this.EnemySupplyGone[index7] > 1)
              this.AreaEnemy[index7] = (int) Math.Round(0.5 * (double) this.AreaEnemy[index7]);
          }
          else
            this.EnemySupplyGone[index7] = 0;
        }
      }
    }

    public void GetStrategyScore_FriendlySupply(bool tlog, int tround)
    {
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("FRIENDLY SUPPLY");
        this.AddLog("");
      }
      int areaCount1 = this.AreaCount;
      for (int index = 0; index <= areaCount1; ++index)
      {
        this.atemp[index] = 0;
        this.FriendlySupply[index] = 0;
      }
      this.atemp2 = new int[this.AreaCount + 1];
      int num1;
      int num2;
      if ((double) this.game.Data.RuleVar[335] > 0.0)
      {
        int num3 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num3 * 4)))] > 0 && this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num3 * 4)))] > -1)
          {
            int index = this.AreaMatrixWide[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num3 * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num3 * 4)))]];
            num1 = 0;
            if (index > 0 && index > 0 & this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn())
            {
              num1 = 1;
              this.atemp2[index] = 1;
              this.FriendlySupply[index] = 1;
            }
            num2 = 0;
          }
          ++num3;
        }
        while (num3 <= 3);
      }
      else
      {
        int areaCount2 = this.AreaCount;
        for (int i = 0; i <= areaCount2; ++i)
        {
          if (this.IsAreaSupplySource(i, this.game.Data.Turn))
          {
            num1 = 1;
            this.atemp2[i] = 1;
            this.FriendlySupply[i] = 1;
          }
        }
      }
      while (num1 == 1)
      {
        num1 = 0;
        ++num2;
        int areaCount3 = this.AreaCount;
        for (int nr = 1; nr <= areaCount3; ++nr)
        {
          if (this.atemp2[nr] == num2)
          {
            int num4 = this.AreaSupplyBorderCount[nr];
            for (int index = 0; index <= num4; ++index)
            {
              int nr2 = this.AreaSupplyBorderEither[nr, index];
              if (this.atemp2[nr2] == 0 && (this.AreaNarrowBorder[nr, nr2] > 0 | this.AreaSeaConnect(nr, nr2)) & nr != nr2 && this.GetRegime(this.AreaOwner[nr2]) == this.GetGameDataTurn())
              {
                this.atemp2[nr2] = this.atemp2[nr] + 1;
                num1 = 1;
                this.FriendlySupply[nr2] = 1;
              }
            }
          }
        }
      }
      if (tround > 0)
      {
        int groupCounter = this.GroupCounter;
        for (int index = 0; index <= groupCounter; ++index)
        {
          int num5 = 0;
          if (index == 1 & this.CorpsTarget[index] > 0 & tround == 1)
            index = index;
          if (this.FriendlySupply[this.CorpsLoc[index]] == 0 && this.CorpsTarget[index] > 0 && this.FriendlySupply[this.CorpsTarget[index]] == 1)
            num5 = 1;
          if (num5 == 0)
          {
            if (tround >= 2)
            {
              if (tround == 2)
              {
                if (this.FriendlySupply[this.CorpsLoc[index]] == 0)
                  this.CorpsTempStrength[index] = (int) Math.Round((double) this.CorpsTempStrength[index] * 0.66);
              }
              else if (tround == 3)
              {
                if (this.FriendlySupply[this.CorpsLoc[index]] == 0)
                  this.CorpsTempStrength[index] = (int) Math.Round((double) this.CorpsTempStrength[index] * 0.5);
              }
              else if (this.FriendlySupply[this.CorpsLoc[index]] == 0)
                this.CorpsTempStrength[index] = (int) Math.Round((double) this.CorpsTempStrength[index] * 0.33);
            }
          }
          else if (tround >= 3 && tround == 2 && this.FriendlySupply[this.CorpsLoc[index]] == 0)
            this.CorpsTempStrength[index] = (int) Math.Round((double) this.CorpsTempStrength[index] * 0.8);
        }
      }
      if (!tlog)
        return;
      int areaCount4 = this.AreaCount;
      for (int nr = 1; nr <= areaCount4; ++nr)
        this.AddLog(this.GetAreaName(nr) + " = " + this.FriendlySupply[nr].ToString());
    }

    public void GetStrategyScore_TroopsPlace(int round, bool makelog)
    {
      int areaCount = this.AreaCount;
      for (int index1 = 1; index1 <= areaCount; ++index1)
      {
        this.StrAreaNegPow[index1] = 0;
        if (this.AreaEnemy[index1] > 0 & this.Attacker && this.EnemySupply[index1] > 0)
        {
          int[] strAreaEntrench = this.StrAreaEntrench;
          int[] numArray = strAreaEntrench;
          int index2 = index1;
          int index3 = index2;
          int num = strAreaEntrench[index2] + 40;
          numArray[index3] = num;
          if (this.StrAreaEntrench[index1] > 200)
            this.StrAreaEntrench[index1] = 200;
        }
      }
      int counter = this.TempTroops.Counter;
      for (int index4 = 0; index4 <= counter; ++index4)
      {
        int index5 = this.TempTroops.Data1[index4];
        int index6 = this.TempTroops.Data2[index4];
        if (index5 > -1 & index6 > -1)
        {
          int nr = this.AreaMatrixWide[index5, index6];
          if (nr > -1 && this.AreaOwner[nr] > -1)
          {
            if (this.TempTroops.Data3[index4] == 1 & this.AreaOwner[nr] > -1 & this.GetRegime(this.AreaOwner[nr]) != this.GetGameDataTurn())
            {
              int Number = this.TempTroops.Data4[index4];
              if (Number > 0)
              {
                if (makelog)
                  this.AddLog(this.GetAreaName(nr) + " RECEIVES " + Conversion.Str((object) Number) + " REINFORCEMENTS (1PROJECTED)");
                this.StrAreaEntrench[nr] = (int) Math.Round((double) (this.AreaEnemy[nr] * this.StrAreaEntrench[nr] + Number) / (double) (this.AreaEnemy[nr] + Number));
                int[] areaEnemy = this.AreaEnemy;
                int[] numArray1 = areaEnemy;
                int index7 = nr;
                int index8 = index7;
                int num1 = areaEnemy[index7] + Number;
                numArray1[index8] = num1;
                int[] areaStartEnemy = this.AreaStartEnemy;
                int[] numArray2 = areaStartEnemy;
                int index9 = nr;
                int index10 = index9;
                int num2 = areaStartEnemy[index9] + Number;
                numArray2[index10] = num2;
              }
            }
            else if (this.TempTroops.Data3[index4] == 2 & this.AreaOwner[nr] > -1 & this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[nr])].AIPower[0].Value[index5, index6] > 0)
            {
              int num3 = 999;
              int num4 = -1;
              int groupCounter1 = this.GroupCounter;
              for (int index11 = 0; index11 <= groupCounter1; ++index11)
              {
                int num5 = this.CorpsLoc[index11] != nr ? this.AreaSteps[this.CorpsLoc[index11], nr] : 0;
                if (this.GroupType[index11] > 5)
                  num5 += 9;
                if (this.CorpsTarget[index11] > -1 && this.AreaEnemy[this.CorpsTarget[index11]] <= 0)
                  num5 += 3;
                if (num5 < num3)
                {
                  num3 = num5;
                  num4 = index11;
                }
              }
              int num6 = 0;
              int groupCounter2 = this.GroupCounter;
              for (int index12 = 0; index12 <= groupCounter2; ++index12)
              {
                int num7 = this.CorpsLoc[index12] != nr ? this.AreaSteps[this.CorpsLoc[index12], nr] : 0;
                if (this.CorpsTarget[index12] > -1 && this.AreaEnemy[this.CorpsTarget[index12]] <= 0)
                  num7 += 3;
                if (this.GroupType[index12] > 5)
                  num7 += 9;
                if (num7 == num3)
                  ++num6;
              }
              int num8 = num3;
              if (num4 > -1)
              {
                int num9 = this.TempTroops.Data4[index4];
                if (num9 > 0)
                {
                  int groupCounter3 = this.GroupCounter;
                  for (int index13 = 0; index13 <= groupCounter3; ++index13)
                  {
                    if (this.CorpsPowerLeft[index13] > 0)
                    {
                      int num10 = this.CorpsLoc[index13] != nr ? this.AreaSteps[this.CorpsLoc[index13], nr] : 0;
                      if (this.CorpsTarget[index13] > -1 && this.AreaEnemy[this.CorpsTarget[index13]] <= 0)
                        num10 += 3;
                      if (this.GroupType[index13] > 5)
                        num10 += 9;
                      if (num10 == num8)
                      {
                        int index14 = index13;
                        if (makelog)
                          this.AddLog(this.GroupName[index14] + " RECEIVES " + Conversion.Str((object) (int) Math.Round((double) num9 / (double) num6)) + " REINFORCEMENTS (2PROJECTED)");
                        this.CorpsEntrench[index14] = (int) Math.Round((double) (this.CorpsTempStrength[index14] * this.CorpsEntrench[index14]) / (double) (this.CorpsTempStrength[index14] + (int) Math.Round((double) num9 / (double) num6)));
                        int[] corpsTempStrength = this.CorpsTempStrength;
                        int[] numArray3 = corpsTempStrength;
                        int index15 = index14;
                        int index16 = index15;
                        int num11 = corpsTempStrength[index15] + (int) Math.Round((double) num9 / (double) num6);
                        numArray3[index16] = num11;
                        int[] corpsstartStrength = this.corpsstartStrength;
                        int[] numArray4 = corpsstartStrength;
                        int index17 = index14;
                        int index18 = index17;
                        int num12 = corpsstartStrength[index17] + (int) Math.Round((double) num9 / (double) num6);
                        numArray4[index18] = num12;
                        int[] corpsPowerLeft = this.CorpsPowerLeft;
                        int[] numArray5 = corpsPowerLeft;
                        int index19 = index14;
                        int index20 = index19;
                        int num13 = corpsPowerLeft[index19] - (int) Math.Round((double) num9 / (double) num6);
                        numArray5[index20] = num13;
                      }
                    }
                  }
                }
              }
            }
            else if (this.TempTroops.Data3[index4] == 3 & this.AreaOwner[nr] > -1 & this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[nr])].AIPower[0].Value[index5, index6] < 0)
            {
              int num = this.TempTroops.Data4[index4];
              if (round > 1)
                num = num;
              if (makelog)
                this.AddLog(this.GetAreaName(nr) + " GETS" + Conversion.Str((object) Math.Abs(num)) + " NEGATIVE POWER.");
              this.StrAreaNegPow[nr] = Math.Abs(num);
            }
          }
        }
      }
    }

    public void GetStrategyScore_Prepare_TroopsPlace()
    {
      this.TempTroops = new SimpleList();
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int tdata1 = 0; tdata1 <= mapWidth; ++tdata1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int tdata2 = 0; tdata2 <= mapHeight; ++tdata2)
        {
          int index = this.AreaMatrixWide[tdata1, tdata2];
          int tid;
          if (index > -1 && this.AreaOwner[index] > -1)
          {
            if (this.AreaOwner[index] > -1 & this.GetRegime(this.AreaOwner[index]) != this.GetGameDataTurn())
            {
              int tdata4 = this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2];
              if (tdata4 > 0)
              {
                ++tid;
                this.TempTroops.Add(tid, 1, tdata1, tdata2, 1, tdata4);
              }
            }
            else if (this.AreaOwner[index] > -1 & this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2] > 0)
            {
              int tdata4 = this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2];
              if (tdata4 > 0)
              {
                ++tid;
                this.TempTroops.Add(tid, 1, tdata1, tdata2, 2, tdata4);
              }
            }
            else if (this.AreaOwner[index] > -1 & this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2] < 0)
            {
              int num = this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2];
              ++tid;
              this.TempTroops.Add(tid, 1, tdata1, tdata2, 3, Math.Abs(num));
            }
          }
        }
      }
    }

    public void GetStrategyScore_CorpsTarget(ref SimpleList straty, int round, bool makelog)
    {
      int groupCounter = this.GroupCounter;
      for (int index1 = 0; index1 <= groupCounter; ++index1)
      {
        if (this.CurrentAreaGroup == this.AreaGroup[this.CorpsStartLoc[index1]])
        {
          this.CorpsTarget[index1] = 0;
          int nr1 = straty.FindNr(index1);
          if (nr1 > -1)
          {
            int num1 = 0;
            int num2 = 0;
            int num3 = 0;
            if (this.CorpsMove[index1] == 1)
            {
              num1 = straty.Data1[nr1];
              num2 = this.CorpsStartLoc[index1];
              num3 = -1;
            }
            if (this.CorpsMove[index1] == 2)
            {
              num1 = straty.Data2[nr1];
              num2 = straty.Data1[nr1];
              num3 = this.CorpsStartLoc[index1];
            }
            if (this.CorpsMove[index1] == 3)
            {
              num1 = straty.Data3[nr1];
              num2 = straty.Data2[nr1];
              num3 = straty.Data1[nr1];
            }
            if (this.CorpsMove[index1] == 4)
            {
              num1 = straty.Data4[nr1];
              num2 = straty.Data3[nr1];
              num3 = straty.Data2[nr1];
            }
            if (this.CorpsMove[index1] == 5)
            {
              num1 = straty.Data5[nr1];
              num2 = straty.Data4[nr1];
              num3 = straty.Data3[nr1];
            }
            if (num2 == num1)
              num1 = -1;
            if (num3 == num2)
              num1 = -1;
            this.CorpsTarget[index1] = num1;
            int index2 = this.TempGroupHQ[index1];
            if (index2 > -1 & round == 1 && this.game.Data.UnitObj[index2].AIAttack > -1 | this.game.Data.UnitObj[index2].AIDefend > -1 && this.CorpsMove[index1] == 1 & this.game.Data.UnitObj[index2].AIAttack <= this.AreaCount & this.game.Data.UnitObj[index2].AIDefend <= this.AreaCount)
            {
              int num4 = 0;
              if (this.game.Data.UnitObj[index2].AIAttack == this.CorpsTarget[index1])
                num4 = 1;
              else if (this.game.Data.UnitObj[index2].AIAttack == -1)
                num4 = 1;
              else if (this.game.Data.UnitObj[index2].AIFollowup == this.CorpsTarget[index1])
                num4 = 1;
              if (this.game.Data.UnitObj[index2].AIAttack > -1 && this.GetRegime(this.AreaOwner[this.game.Data.UnitObj[index2].AIAttack]) == this.GetGameDataTurn())
                num4 = 1;
              if (num4 == 1)
              {
                if (makelog)
                  this.AddLog(this.GroupName[index1] + " IS SAME");
                ++this.StrConsistSame;
              }
              if (num4 == 0)
              {
                if (makelog)
                  this.AddLog(this.GroupName[index1] + " IS DIFFERENT");
                ++this.StrConsistDifferent;
              }
            }
            if (this.CorpsTarget[index1] <= 0 & !this.Attacker)
            {
              int[] corpsEntrench = this.CorpsEntrench;
              int[] numArray = corpsEntrench;
              int index3 = index1;
              int index4 = index3;
              int num5 = corpsEntrench[index3] + 15;
              numArray[index4] = num5;
              if (this.CorpsEntrench[index1] > 100)
                this.CorpsEntrench[index1] = 100;
            }
            if (this.CorpsMove[index1] > 0 & this.CorpsTarget[index1] > 0)
            {
              if (this.GetRegime(this.AreaOwner[this.CorpsTarget[index1]]) == this.GetGameDataTurn())
              {
                if (this.CorpsStance[index1] == 2)
                {
                  int[] corpsMoveProgress = this.CorpsMoveProgress;
                  int[] numArray = corpsMoveProgress;
                  int index5 = index1;
                  int index6 = index5;
                  int num6 = corpsMoveProgress[index5] + Math.Max(2, (int) Math.Round((double) this.GetAverageHexSpeedofCorpsUnit(index1, true) * 0.33));
                  numArray[index6] = num6;
                }
                else
                {
                  int[] corpsMoveProgress1 = this.CorpsMoveProgress;
                  int[] numArray1 = corpsMoveProgress1;
                  int index7 = index1;
                  int index8 = index7;
                  int num7 = corpsMoveProgress1[index7] + Math.Max(3, this.GetAverageHexSpeedofCorpsUnit(index1, true));
                  numArray1[index8] = num7;
                  int num8 = 0;
                  int areaCount = this.AreaCount;
                  for (int nr2 = 1; nr2 <= areaCount; ++nr2)
                  {
                    if (this.AreaBorder[nr2, this.CorpsTarget[index1]] > 0 && this.GetRegime(this.AreaOwner[nr2]) == this.GetGameDataTurn() && this.GetAreaEnemyNeighbourCount(nr2) > 0)
                      ++num8;
                  }
                  if (num8 == 0)
                  {
                    int[] corpsMoveProgress2 = this.CorpsMoveProgress;
                    int[] numArray2 = corpsMoveProgress2;
                    int index9 = index1;
                    int index10 = index9;
                    int num9 = corpsMoveProgress2[index9] + Math.Min(2, (int) Math.Round((double) this.GetAverageHexSpeedofCorpsUnit(index1, true) / 3.0));
                    numArray2[index10] = num9;
                  }
                  if ((double) this.game.Data.RuleVar[811] > 0.0)
                  {
                    int[] corpsMoveProgress3 = this.CorpsMoveProgress;
                    int[] numArray3 = corpsMoveProgress3;
                    int index11 = index1;
                    int index12 = index11;
                    int num10 = corpsMoveProgress3[index11] + (int) Math.Round((double) (this.game.Data.RuleVar[811] * (float) Math.Max(5, this.GetAverageHexSpeedofCorpsUnit(index1, true))));
                    numArray3[index12] = num10;
                  }
                  this.CorpsEntrench[index1] = 0;
                }
              }
              else
              {
                if (this.GetRegime(this.AreaOwner[this.CorpsTarget[index1]]) == -1)
                {
                  int[] corpsMoveProgress4 = this.CorpsMoveProgress;
                  int[] numArray4 = corpsMoveProgress4;
                  int index13 = index1;
                  int index14 = index13;
                  int num11 = corpsMoveProgress4[index13] + Math.Max(5, this.GetAverageHexSpeedofCorpsUnit(index1, true));
                  numArray4[index14] = num11;
                  int[] corpsMoveProgress5 = this.CorpsMoveProgress;
                  int[] numArray5 = corpsMoveProgress5;
                  int index15 = index1;
                  int index16 = index15;
                  int num12 = corpsMoveProgress5[index15] + (int) Math.Round((double) Math.Max(5, this.GetAverageHexSpeedofCorpsUnit(index1, true)) / 2.0);
                  numArray5[index16] = num12;
                }
                else
                {
                  int[] corpsMoveProgress = this.CorpsMoveProgress;
                  int[] numArray = corpsMoveProgress;
                  int index17 = index1;
                  int index18 = index17;
                  int num13 = corpsMoveProgress[index17] + Math.Max(4, this.GetAverageHexSpeedofCorpsUnit(index1, false));
                  numArray[index18] = num13;
                }
                this.CorpsEntrench[index1] = 0;
              }
            }
            if (makelog)
              this.AddLog(this.GroupName[index1] + " ENTRENCH = " + Conversion.Str((object) this.CorpsEntrench[index1]));
          }
        }
      }
    }

    public void GetStrategyScore_MoveEnemy(int round, bool makelog)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      int areaCount1 = this.AreaCount;
      for (int nr = 1; nr <= areaCount1; ++nr)
      {
        if (this.AreaGroup[nr] == this.CurrentAreaGroup && this.EnemySupply[nr] == 1)
        {
          numArray1[nr] = (int) Math.Round((double) this.AreaEnemy[nr] * 0.33);
          numArray2[nr] = this.GetAreaEnemyNeighbourCountFuzzyVP(nr);
          numArray3[nr] = this.GetAreaFriendlyNeighbourCount2(nr);
        }
      }
      if (!this.Attacker | round > 2)
      {
        int areaCount2 = this.AreaCount;
        for (int nr1 = 1; nr1 <= areaCount2; ++nr1)
        {
          if (this.AreaGroup[nr1] == this.CurrentAreaGroup && this.GetRegime(this.AreaOwner[nr1]) != this.GetGameDataTurn() & this.EnemySupply[nr1] == 1 & this.AreaEnemy[nr1] > 0)
          {
            int num1 = numArray2[nr1];
            if (num1 > 0)
            {
              int areaCount3 = this.AreaCount;
              for (int nr2 = 1; nr2 <= areaCount3; ++nr2)
              {
                if (this.AreaGroup[nr2] == this.CurrentAreaGroup && !this.Attacker | this.Meeting | this.AreaBroadBorder[nr1, nr2] > 0 & this.AreaBroadBorder[nr1, nr2] < 99 && this.GetRegime(this.AreaOwner[nr2]) != this.GetGameDataTurn() & this.AreaOwner[nr2] == this.AreaOwner[nr1] & this.EnemySupply[nr2] == 1 & this.StrLandEnemySupply[nr2] == this.StrLandEnemySupply[nr1] && numArray2[nr2] > numArray2[nr1])
                {
                  float num2 = (float) numArray2[nr2] / (float) num1;
                  if ((double) this.AreaEnemy[nr2] + 300.0 * (1.0 + (double) this.game.Data.RuleVar[828]) < (double) (int) Math.Round((double) ((float) this.AreaEnemy[nr1] * num2)))
                  {
                    int Number = (int) Math.Round((double) numArray1[nr1] * 0.2);
                    if ((double) this.game.Data.RuleVar[828] > 0.0)
                      Number = (int) Math.Round((double) ((float) Number / this.game.Data.RuleVar[828]));
                    this.StrAreaEntrench[nr2] = (int) Math.Round((double) (this.AreaEnemy[nr2] * this.StrAreaEntrench[nr2] + Number) / (double) Math.Max(1, this.AreaEnemy[nr2] + Number));
                    int[] areaEnemy1 = this.AreaEnemy;
                    int[] numArray4 = areaEnemy1;
                    int index1 = nr2;
                    int index2 = index1;
                    int num3 = areaEnemy1[index1] + Number;
                    numArray4[index2] = num3;
                    int[] numArray5 = numArray1;
                    int[] numArray6 = numArray5;
                    int index3 = nr1;
                    int index4 = index3;
                    int num4 = numArray5[index3] - Number;
                    numArray6[index4] = num4;
                    int[] areaEnemy2 = this.AreaEnemy;
                    int[] numArray7 = areaEnemy2;
                    int index5 = nr1;
                    int index6 = index5;
                    int num5 = areaEnemy2[index5] - Number;
                    numArray7[index6] = num5;
                    if (makelog)
                      this.AddLog("ENEMY AREA " + this.GetAreaName(nr1) + " TRANSFER TO " + this.GetAreaName(nr2) + " " + Conversion.Str((object) Number) + " pts");
                  }
                }
              }
            }
          }
        }
      }
      int areaCount4 = this.AreaCount;
      for (int index7 = 1; index7 <= areaCount4; ++index7)
      {
        if (this.AreaGroup[index7] == this.CurrentAreaGroup & this.EnemySupply[index7] == 1 && this.GetRegime(this.AreaOwner[index7]) != this.GetGameDataTurn() && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.AreaOwner[index7], this.GetGameDataTurn()) && numArray3[index7] == 0 & this.AreaEnemy[index7] > 0)
        {
          if (index7 == 19)
            index7 = index7;
          int num6 = 0;
          int areaCount5 = this.AreaCount;
          for (int index8 = 1; index8 <= areaCount5; ++index8)
          {
            if (this.AreaGroup[index8] == this.CurrentAreaGroup & index7 != index8 && this.AreaSteps[index7, index8] > 0 & this.AreaSteps[index7, index8] < 99 & (!this.Attacker | this.Meeting | (double) this.game.Data.RuleVar[830] == 1.0 | this.AreaFuzzyVP[index8] > this.AreaFuzzyVP[index7]) && this.EnemySupply[index8] == 1 & this.StrLandEnemySupply[index8] == this.StrLandEnemySupply[index7] && numArray3[index8] > 0)
              num6 += this.AreaFuzzyVP[index8];
          }
          if (num6 > 0)
          {
            int areaCount6 = this.AreaCount;
            for (int index9 = 1; index9 <= areaCount6; ++index9)
            {
              if (this.AreaGroup[index9] == this.CurrentAreaGroup & index7 != index9 & this.EnemySupply[index9] == 1 && this.AreaSteps[index7, index9] > 0 & this.AreaSteps[index7, index9] < 99 & (!this.Attacker | this.Meeting | (double) this.game.Data.RuleVar[830] == 1.0 | this.AreaFuzzyVP[index9] > this.AreaFuzzyVP[index7]))
              {
                if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.AreaOwner[index9], this.AreaOwner[index7]) & this.StrLandEnemySupply[index9] == this.StrLandEnemySupply[index7] && numArray3[index9] > 0)
                {
                  if (this.Attacker)
                  {
                    if (round > 2)
                    {
                      int num7 = (int) Math.Round(Conversion.Int((double) this.AreaEnemy[index7] * 0.2) * ((double) this.AreaFuzzyVP[index9] / (double) num6));
                      if ((double) this.game.Data.RuleVar[828] > 0.0)
                        num7 = (int) Math.Round((double) ((float) num7 / this.game.Data.RuleVar[828]));
                      if (num7 > 0 & num7 <= this.AreaEnemy[index7])
                      {
                        this.StrAreaEntrench[index9] = (int) Math.Round((double) (this.AreaEnemy[index9] * this.StrAreaEntrench[index9] + num7) / (double) (this.AreaEnemy[index9] + num7));
                        int[] areaEnemy3 = this.AreaEnemy;
                        int[] numArray8 = areaEnemy3;
                        int index10 = index9;
                        int index11 = index10;
                        int num8 = areaEnemy3[index10] + num7;
                        numArray8[index11] = num8;
                        int[] areaEnemy4 = this.AreaEnemy;
                        int[] numArray9 = areaEnemy4;
                        int index12 = index7;
                        int index13 = index12;
                        int num9 = areaEnemy4[index12] - num7;
                        numArray9[index13] = num9;
                      }
                    }
                  }
                  else if (round <= 2)
                  {
                    int num10 = (int) Math.Round(Conversion.Int((double) this.AreaEnemy[index7] * 0.66) * ((double) this.AreaFuzzyVP[index9] / (double) num6));
                    if ((double) this.game.Data.RuleVar[828] > 0.0)
                      num10 = (int) Math.Round((double) ((float) num10 / this.game.Data.RuleVar[828]));
                    if (num10 > 0)
                    {
                      this.StrAreaEntrench[index9] = (int) Math.Round((double) (this.AreaEnemy[index9] * this.StrAreaEntrench[index9] + num10) / (double) (this.AreaEnemy[index9] + num10));
                      int[] areaEnemy5 = this.AreaEnemy;
                      int[] numArray10 = areaEnemy5;
                      int index14 = index9;
                      int index15 = index14;
                      int num11 = areaEnemy5[index14] + num10;
                      numArray10[index15] = num11;
                      int[] areaEnemy6 = this.AreaEnemy;
                      int[] numArray11 = areaEnemy6;
                      int index16 = index7;
                      int index17 = index16;
                      int num12 = areaEnemy6[index16] - num10;
                      numArray11[index17] = num12;
                    }
                  }
                  else
                  {
                    int num13 = (int) Math.Round((double) Conversion.Int(this.AreaEnemy[index7] * 1) * ((double) this.AreaFuzzyVP[index9] / (double) num6));
                    if ((double) this.game.Data.RuleVar[828] > 0.0)
                      num13 = (int) Math.Round((double) ((float) num13 / this.game.Data.RuleVar[828]));
                    if (num13 > 0)
                    {
                      this.StrAreaEntrench[index9] = (int) Math.Round((double) (this.AreaEnemy[index9] * this.StrAreaEntrench[index9] + num13) / (double) (this.AreaEnemy[index9] + num13));
                      int[] areaEnemy7 = this.AreaEnemy;
                      int[] numArray12 = areaEnemy7;
                      int index18 = index9;
                      int index19 = index18;
                      int num14 = areaEnemy7[index18] + num13;
                      numArray12[index19] = num14;
                      int[] areaEnemy8 = this.AreaEnemy;
                      int[] numArray13 = areaEnemy8;
                      int index20 = index7;
                      int index21 = index20;
                      int num15 = areaEnemy8[index20] - num13;
                      numArray13[index21] = num15;
                    }
                  }
                }
                if (0 > this.AreaEnemy[index7])
                  this.AreaEnemy[index7] = 0;
              }
            }
          }
        }
      }
    }

    public void GetStrategyScore_Attacks(ref SimpleList straty, int round, bool makelog)
    {
      bool[] flagArray = new bool[this.AreaCount + 1];
      int num1 = num1;
      int areaCount1 = this.AreaCount;
      for (int nr1 = 1; nr1 <= areaCount1; ++nr1)
      {
        if (this.AreaGroup[nr1] == this.CurrentAreaGroup)
        {
          int num2 = 0;
          int index1 = 0;
          int areaNeighbourCount = this.GetAreaNeighbourCount(nr1);
          int val1 = 0;
          this.StrTempCorpsCounter = -1;
          int groupCounter1 = this.GroupCounter;
          for (int index2 = 0; index2 <= groupCounter1; ++index2)
          {
            if (this.CorpsTarget[index2] == nr1 & this.game.HandyFunctionsObj.IsAlliedOrSelf(this.AreaOwner[this.CorpsLoc[index2]], this.GetGameDataTurn()) & this.CorpsTempStrength[index2] > 0)
            {
              int num3 = 0;
              int Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0 | Number > 99)
                Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0 | Number > 99)
                Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0 | Number > 98)
                Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0)
              {
                Number = Number;
                num3 = 1;
              }
              if (this.CorpsMove[index2] == 1)
              {
                if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.CorpsTarget[index2]].x, this.AreaCenter[this.CorpsTarget[index2]].y].Regime), this.GetGameDataTurn()))
                {
                  if (this.HisAreaDistanceFriendly.GetUpperBound(0) >= index2)
                  {
                    if (this.HisAreaDistanceFriendly[index2, this.CorpsTarget[index2]] < 9999)
                      Number = (int) Math.Round((double) this.HisAreaDistanceFriendly[index2, this.CorpsTarget[index2]] / 20.0);
                    else if (!this.AreaIsExtra[this.CorpsLoc[index2]])
                    {
                      Number = 99;
                    }
                    else
                    {
                      Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                      if (Number == 0 | Number > 99)
                        Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                      if (Number == 0 | Number > 99)
                        Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                      if (Number == 0 | Number > 98)
                        Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    }
                  }
                  else
                  {
                    Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 98)
                      Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  }
                }
                else if (this.HisAreaDistance.GetUpperBound(0) >= index2)
                {
                  if (this.HisAreaDistance[index2, this.CorpsTarget[index2]] < 9999)
                    Number = (int) Math.Round((double) this.HisAreaDistance[index2, this.CorpsTarget[index2]] / 20.0);
                  else if (!this.AreaIsExtra[this.CorpsLoc[index2]])
                  {
                    Number = 99;
                  }
                  else
                  {
                    Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 98)
                      Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  }
                }
                else
                {
                  Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  if (Number == 0 | Number > 99)
                    Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  if (Number == 0 | Number > 99)
                    Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  if (Number == 0 | Number > 98)
                    Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                }
              }
              if (index2 == 7)
                index2 = index2;
              if (round > 1 & this.CorpsStrategic[index2] & this.FriendlySupply[nr1] == 1)
              {
                if (makelog)
                  this.AddLog(this.GroupName[index2] + " HAS STRATEGIC SPEED");
                Number = 1;
              }
              else
              {
                int num4 = this.CorpsStrategic[index2] & this.FriendlySupply[nr1] == 0 ? 1 : 0;
              }
              if (makelog)
                this.AddLog(this.GroupName[index2] + ". FROM: " + this.GetAreaName(this.CorpsLoc[index2]) + ". TOO: " + this.GetAreaName(nr1) + ". Move progress is " + Conversion.Str((object) this.CorpsMoveProgress[index2]) + " of " + Conversion.Str((object) Number));
              if ((double) this.CorpsMoveProgress[index2] >= (double) Number * 0.66 | Number - this.CorpsMoveProgress[index2] < 5 && this.FriendlySupply[this.CorpsLoc[index2]] > 0)
              {
                if (num3 == 1)
                  ;
                int num5 = this.CorpsTempStrength[index2];
                val1 += (int) Math.Round((double) this.CorpsAirEffect[index2] / 100.0 * (double) this.CorpsTempAirStrength[index2]);
                if (this.CorpsStance[index2] == 1)
                  num5 = (int) Math.Round((double) num5 * 0.5);
                if (this.CorpsStance[index2] == 2)
                  num5 = (int) Math.Round((double) num5 * 0.5);
                if (this.CorpsBottleneck[index2] > 0 & this.CorpsOldDefend[index2] == this.CorpsLoc[index2] & round < 4)
                {
                  num5 = (int) Math.Round((double) num5 * ((double) this.CorpsBottleneck[index2] / 100.0));
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK .. PERCENTAGE LEFT = " + this.CorpsBottleneck[index2].ToString());
                }
                ++this.StrTempCorpsCounter;
                this.StrTempCorps = (int[]) Utils.CopyArray((Array) this.StrTempCorps, (Array) new int[this.StrTempCorpsCounter + 1]);
                this.StrTempCorpsMod = (float[]) Utils.CopyArray((Array) this.StrTempCorpsMod, (Array) new float[this.StrTempCorpsCounter + 1]);
                if ((double) this.CorpsMoveProgress[index2] >= (double) Number * 1.33)
                {
                  num5 *= 1;
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 1f;
                }
                else if (this.CorpsMoveProgress[index2] >= Number * 1)
                {
                  num5 = (int) Math.Round((double) num5 * 0.75);
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 0.75f;
                }
                else if ((double) this.CorpsMoveProgress[index2] >= (double) Number * 0.82)
                {
                  num5 = (int) Math.Round((double) num5 * 0.5);
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 0.5f;
                }
                else if ((double) this.CorpsMoveProgress[index2] >= (double) Number * 0.66 | Number - this.CorpsMoveProgress[index2] < 5)
                {
                  num5 = (int) Math.Round((double) num5 * 0.25);
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 0.25f;
                }
                num2 += num5;
                this.StrTempCorps[this.StrTempCorpsCounter] = index2;
                int num6 = 0;
                int num7 = index1;
                for (int index3 = 1; index3 <= num7; ++index3)
                {
                  if (this.StrCurSides[index3] == this.CorpsLoc[index2])
                    num6 = 1;
                }
                if (num6 == 0)
                {
                  ++index1;
                  this.StrCurSides[index1] = this.CorpsLoc[index2];
                }
              }
            }
          }
          int num8;
          if (num2 > 0)
          {
            if (this.GetRegime(this.AreaOwner[nr1]) == this.GetGameDataTurn())
            {
              int num9 = this.AreaOwner[nr1];
            }
            else
            {
              if (makelog)
                this.AddLog("GOT " + Conversion.Str((object) num2) + " : " + Conversion.Str((object) this.AreaEnemy[nr1]) + " ON " + this.GetAreaName(nr1));
              if (makelog)
                this.AddLog("Enemy strength before battle: " + Conversion.Str((object) this.AreaEnemy[nr1]));
              int num10 = num2;
              if (areaNeighbourCount > 4 & index1 > 4)
                num2 = (int) Math.Round((double) num2 * (1.0 + 1.0 * ((double) index1 / (double) areaNeighbourCount)));
              else if (areaNeighbourCount > 3 & index1 > 3)
                num2 = (int) Math.Round((double) num2 * (1.0 + 0.75 * ((double) index1 / (double) areaNeighbourCount)));
              else if (areaNeighbourCount > 2 & index1 > 2)
                num2 = (int) Math.Round((double) num2 * (1.0 + 0.5 * ((double) index1 / (double) areaNeighbourCount)));
              else if (areaNeighbourCount > 1 & index1 > 1)
                num2 = (int) Math.Round((double) num2 * (1.0 + 0.25 * ((double) index1 / (double) areaNeighbourCount)));
              int Number1 = this.AreaEnemy[nr1];
              float num11 = this.AreaEnemy[nr1] != 0 ? (float) num2 / (float) Number1 : 10f;
              int tempCorpsCounter1 = this.StrTempCorpsCounter;
              for (int index4 = 0; index4 <= tempCorpsCounter1; ++index4)
              {
                if ((double) num11 > (double) this.CorpsTopRatio[this.StrTempCorps[index4]] & (round <= 1 & this.Attacker | round <= 2 & !this.Attacker))
                  this.CorpsTopRatio[this.StrTempCorps[index4]] = num11;
              }
              if (this.AreaDefensive[nr1] > 0)
              {
                Number1 = (int) Math.Round((double) Number1 * ((double) (100 + this.AreaDefensive[nr1]) / 100.0));
                if (makelog)
                  this.AddLog("Enemy after AreaDefensive = " + Conversion.Str((object) Number1));
              }
              if (this.StrAreaEntrench[nr1] > 0)
              {
                Number1 = (int) Math.Round((double) Number1 / 2.0) + (int) Math.Round((double) (Number1 + Number1 * (int) Math.Round((double) this.StrAreaEntrench[nr1] / 100.0)) / 2.0);
                if (makelog)
                  this.AddLog("Enemy after Entrench = " + Conversion.Str((object) Number1));
              }
              if (this.EnemySupply[nr1] < 1)
              {
                Number1 = (int) Math.Round((double) Number1 * 0.2);
                if (makelog)
                  this.AddLog("Enemy after No-supply = " + Conversion.Str((object) Number1));
              }
              num8 = 0;
              float num12 = this.AreaEnemy[nr1] != 0 ? (float) num2 / (float) Number1 : 10f;
              if ((double) num12 > 10.0)
                num12 = 10f;
              if (val1 > 0 & round <= 2)
              {
                num12 += (float) (val1 * 2) / (float) Math.Max(val1, num2);
                if (makelog)
                  this.AddLog("Ratio after Air = " + Conversion.Str((object) num12));
              }
              int Number2;
              int Number3;
              if ((double) num12 > 1.0)
              {
                float Number4 = (float) (6.0 / Math.Sqrt((double) Math.Min(9f, num12)));
                if (makelog)
                  this.AddLog("TSng For defender casualties = " + Conversion.Str((object) Number4));
                if (this.StrAreaEntrench[nr1] > 150)
                {
                  Number4 *= 1.66f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after entrench= " + Conversion.Str((object) Number4));
                }
                else if (this.StrAreaEntrench[nr1] > 100)
                {
                  Number4 *= 1.44f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after entrench= " + Conversion.Str((object) Number4));
                }
                else if (this.StrAreaEntrench[nr1] > 50)
                {
                  Number4 *= 1.22f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after entrench= " + Conversion.Str((object) Number4));
                }
                if (this.AreaDefensive[nr1] > 150)
                {
                  Number4 *= 1.66f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after areadef= " + Conversion.Str((object) Number4));
                }
                else if (this.AreaDefensive[nr1] > 100)
                {
                  Number4 *= 1.44f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after areadef= " + Conversion.Str((object) Number4));
                }
                else if (this.AreaDefensive[nr1] > 50)
                {
                  Number4 *= 1.22f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after areadef= " + Conversion.Str((object) Number4));
                }
                if ((double) this.game.Data.RuleVar[394] > 0.0)
                {
                  Number4 *= this.game.Data.RuleVar[394];
                  if (makelog)
                    this.AddLog("TSng For defender casualties after rulevar394= " + Conversion.Str((object) Number4));
                }
                float Number5 = Number4 * 0.66f;
                if (makelog)
                  this.AddLog("TSng For defender casualties after *0.66 = " + Conversion.Str((object) Number5));
                Number2 = (int) Math.Round((double) ((float) num10 / Number5));
                float num13 = (float) (6.0 / Math.Sqrt((double) Math.Min(9f, num12)));
                if (this.StrAreaEntrench[nr1] > 150)
                  num13 *= 1.66f;
                else if (this.StrAreaEntrench[nr1] > 100)
                  num13 *= 1.44f;
                else if (this.StrAreaEntrench[nr1] > 50)
                  num13 *= 1.22f;
                if (this.AreaDefensive[nr1] > 150)
                  num13 *= 1.66f;
                else if (this.AreaDefensive[nr1] > 100)
                  num13 *= 1.44f;
                else if (this.AreaDefensive[nr1] > 50)
                  num13 *= 1.22f;
                if ((double) this.game.Data.RuleVar[394] > 0.0)
                  num13 *= this.game.Data.RuleVar[394];
                float Number6 = num13 * 0.66f;
                if (makelog)
                  this.AddLog("TSng For defender casualties after *0.66 = " + Conversion.Str((object) Number6));
                Number3 = (int) Math.Round((double) ((float) num10 / Number6));
              }
              else
              {
                Number2 = 0;
                Number3 = 0;
              }
              if (Number2 > this.AreaEnemy[nr1])
              {
                Number3 = (int) Math.Round((double) ((float) Number3 * ((float) this.AreaEnemy[nr1] / (float) Number2)));
                Number2 = this.AreaEnemy[nr1];
              }
              int[] areaEnemy = this.AreaEnemy;
              int[] numArray1 = areaEnemy;
              int index5 = nr1;
              int index6 = index5;
              int num14 = areaEnemy[index5] - Number2;
              numArray1[index6] = num14;
              if (Number3 > num10)
                Number3 = num10;
              if (makelog)
                this.AddLog("ratio: " + Conversion.Str((object) num12) + " totdam = " + Conversion.Str((object) Number3) + ", totdam2 = " + Conversion.Str((object) Number2));
              if (makelog)
                this.AddLog("Enemy strength after: " + Conversion.Str((object) this.AreaEnemy[nr1]));
              if (makelog)
                this.AddLog("Friendly strength after: " + Conversion.Str((object) (num10 - Number3)));
              int tempCorpsCounter2 = this.StrTempCorpsCounter;
              for (int index7 = 0; index7 <= tempCorpsCounter2; ++index7)
              {
                int index8 = this.StrTempCorps[index7];
                if (makelog)
                  this.AddLog(this.GroupName[index8] + " LOSES " + Conversion.Str((object) (int) Math.Round((double) ((float) Number3 * ((float) this.CorpsTempStrength[index8] * this.StrTempCorpsMod[index7] / (float) num2)))));
                int num15 = 0;
                if (num2 > 0)
                  num15 = (int) Math.Round((double) ((float) Number3 * ((float) this.CorpsTempStrength[index8] * this.StrTempCorpsMod[index7] / (float) num2)));
                if (num15 > this.CorpsTempStrength[index8])
                  num15 = this.CorpsTempStrength[index8];
                if (num2 > 0)
                {
                  int[] corpsTempStrength = this.CorpsTempStrength;
                  int[] numArray2 = corpsTempStrength;
                  int index9 = index8;
                  int index10 = index9;
                  int num16 = corpsTempStrength[index9] - (int) Math.Round((double) ((float) Number3 * ((float) this.CorpsTempStrength[index8] * this.StrTempCorpsMod[index7] / (float) num2)));
                  numArray2[index10] = num16;
                }
                if (num2 > 0)
                {
                  int[] corpsPowerLeft = this.CorpsPowerLeft;
                  int[] numArray3 = corpsPowerLeft;
                  int index11 = index8;
                  int index12 = index11;
                  int num17 = corpsPowerLeft[index11] + num15;
                  numArray3[index12] = num17;
                }
                if (this.CorpsFirstAreaBattle[index8] == 0)
                  this.CorpsFirstAreaBattle[index8] = nr1;
                if (0 > this.CorpsTempStrength[index8])
                  this.CorpsTempStrength[index8] = 0;
              }
              if (0 >= this.AreaEnemy[nr1])
                this.AreaEnemy[nr1] = 0;
            }
            int groupCounter2 = this.GroupCounter;
            for (int tid = 0; tid <= groupCounter2; ++tid)
            {
              if (this.CorpsTarget[tid] == nr1 & this.AreaEnemy[nr1] <= 0)
              {
                int num18 = this.AreaNarrowBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0 | num18 > 99)
                  num18 = this.AreaBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0 | num18 > 99)
                  num18 = this.AreaWideBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0 | num18 > 98)
                  num18 = this.AreaBroadBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0)
                  num18 = num18;
                if (this.CorpsMove[tid] == 1)
                {
                  if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr1].x, this.AreaCenter[nr1].y].Regime), this.GetGameDataTurn()))
                  {
                    if (this.HisAreaDistanceFriendly.GetUpperBound(0) >= tid)
                    {
                      if (this.HisAreaDistanceFriendly[tid, nr1] < 9999)
                        num18 = (int) Math.Round((double) this.HisAreaDistanceFriendly[tid, nr1] / 20.0);
                      else if (!this.AreaIsExtra[this.CorpsLoc[tid]])
                      {
                        num18 = 99;
                      }
                      else
                      {
                        num18 = this.AreaNarrowBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                        if (num18 == 0 | num18 > 99)
                          num18 = this.AreaBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                        if (num18 == 0 | num18 > 99)
                          num18 = this.AreaWideBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                        if (num18 == 0 | num18 > 98)
                          num18 = this.AreaBroadBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      }
                    }
                    else
                    {
                      num18 = this.AreaBorder[this.CorpsLoc[tid], nr1];
                      if (num18 == 0)
                        num18 = this.AreaWideBorder[this.CorpsLoc[tid], nr1];
                      if (num18 == 0 | num18 > 98)
                        num18 = this.AreaBroadBorder[this.CorpsLoc[tid], nr1];
                    }
                  }
                  else if (this.HisAreaDistance.GetUpperBound(0) >= tid)
                  {
                    if (this.HisAreaDistance[tid, nr1] < 9999)
                      num18 = (int) Math.Round((double) this.HisAreaDistance[tid, nr1] / 20.0);
                    else if (!this.AreaIsExtra[this.CorpsLoc[tid]])
                    {
                      num18 = 99;
                    }
                    else
                    {
                      num18 = this.AreaNarrowBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      if (num18 == 0 | num18 > 99)
                        num18 = this.AreaBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      if (num18 == 0 | num18 > 99)
                        num18 = this.AreaWideBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      if (num18 == 0 | num18 > 98)
                        num18 = this.AreaBroadBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                    }
                  }
                  else
                  {
                    num18 = this.AreaBorder[this.CorpsLoc[tid], nr1];
                    if (num18 == 0)
                      num18 = this.AreaWideBorder[this.CorpsLoc[tid], nr1];
                    if (num18 == 0 | num18 > 98)
                      num18 = this.AreaBroadBorder[this.CorpsLoc[tid], nr1];
                  }
                }
                if (round > 1 & this.CorpsStrategic[tid] & this.FriendlySupply[nr1] == 1)
                {
                  if (makelog)
                    this.AddLog(this.GroupName[tid] + " HAS STRATEGIC SPEED");
                  num18 = 1;
                }
                else
                {
                  int num19 = this.CorpsStrategic[tid] & this.FriendlySupply[nr1] == 0 ? 1 : 0;
                }
                if (this.CorpsMoveProgress[tid] >= num18)
                {
                  this.CorpsLoc[tid] = nr1;
                  int[] corpsMoveProgress = this.CorpsMoveProgress;
                  int[] numArray4 = corpsMoveProgress;
                  int index13 = tid;
                  int index14 = index13;
                  int num20 = corpsMoveProgress[index13] - num18;
                  numArray4[index14] = num20;
                  int nr2 = this.AreaOwner[nr1];
                  if (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.AreaOwner[nr1]), this.GetGameDataTurn()))
                  {
                    this.AreaOwner[nr1] = this.GetRegime(this.game.Data.Turn);
                    if (makelog)
                      this.AddLog("CONQUERED AREA!!");
                  }
                  if (this.GetRegime(nr2) != this.GetGameDataTurn())
                  {
                    int[] corpsMove = this.CorpsMove;
                    int[] numArray5 = corpsMove;
                    int index15 = tid;
                    int index16 = index15;
                    int num21 = corpsMove[index15] + 1;
                    numArray5[index16] = num21;
                    if (this.CorpsMoveProgress[tid] > 4)
                      this.CorpsMoveProgress[tid] = 4;
                  }
                  else
                  {
                    int index17;
                    do
                    {
                      index17 = -1;
                      int[] corpsMove = this.CorpsMove;
                      int[] numArray6 = corpsMove;
                      int index18 = tid;
                      int index19 = index18;
                      int num22 = corpsMove[index18] + 1;
                      numArray6[index19] = num22;
                      int nr3 = straty.FindNr(tid);
                      if (this.CorpsMove[tid] == 1)
                        index17 = straty.Data1[nr3];
                      if (this.CorpsMove[tid] == 2)
                        index17 = straty.Data2[nr3];
                      if (this.CorpsMove[tid] == 3)
                        index17 = straty.Data3[nr3];
                      if (this.CorpsMove[tid] == 4)
                        index17 = straty.Data4[nr3];
                      if (this.CorpsMove[tid] == 5)
                        index17 = straty.Data5[nr3];
                      if (index17 > 0 & index17 != this.CorpsLoc[tid])
                      {
                        if (this.GetRegime(this.AreaOwner[index17]) == this.GetGameDataTurn())
                        {
                          int num23 = this.AreaBorder[this.CorpsLoc[tid], index17];
                          if (num23 == 0)
                            num23 = this.AreaWideBorder[this.CorpsLoc[tid], index17];
                          if (num23 == 0)
                            num23 = this.AreaBroadBorder[this.CorpsLoc[tid], index17];
                          if (round > 1 & this.CorpsStrategic[tid] & this.FriendlySupply[index17] == 1)
                          {
                            num23 = 0;
                          }
                          else
                          {
                            int num24 = this.CorpsStrategic[tid] & this.FriendlySupply[index17] == 0 ? 1 : 0;
                          }
                          if (this.CorpsMoveProgress[tid] >= num23)
                          {
                            this.CorpsLoc[tid] = index17;
                            this.CorpsMoveProgress[tid] = 0;
                            if (0 > this.CorpsMoveProgress[tid])
                              this.CorpsMoveProgress[tid] = 0;
                          }
                          else
                            index17 = -1;
                        }
                        else
                          index17 = -1;
                      }
                      else
                      {
                        index17 = -1;
                        this.CorpsMoveProgress[tid] = 0;
                      }
                    }
                    while (index17 > 0);
                  }
                }
              }
            }
          }
          if ((round < 5 | this.Meeting | !this.Attacker | (double) this.game.Data.RuleVar[386] == 1.0 | round == 1 | round % 2 == 0) & this.GetGameDataTurn() == this.GetRegime(this.AreaOwner[nr1]))
          {
            int Number7 = 0;
            int Number8 = 0;
            int Number9 = 0;
            int Number10 = 0;
            int num25 = 0;
            int index20 = 0;
            int num26 = 9999;
            int areaCount2 = this.AreaCount;
            for (int nr4 = 1; nr4 <= areaCount2; ++nr4)
            {
              if (this.AreaGroup[nr4] == this.CurrentAreaGroup && nr4 != nr1 & this.AreaNarrowBorder[nr1, nr4] > 0 && this.GetRegime(this.AreaOwner[nr4]) != this.GetGameDataTurn() & this.EnemySupplyGone[nr4] < 2 && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[nr4])) && this.AreaEnemy[nr4] > 0)
              {
                int[,] strCounterAttack = this.StrCounterAttack;
                int[,] numArray = strCounterAttack;
                int index21 = nr4;
                int index22 = index21;
                int index23 = nr1;
                int index24 = index23;
                int num27 = strCounterAttack[index21, index23] + 4;
                numArray[index22, index24] = num27;
                if (this.GetAreaEnemyNeighbourCountFuzzyVP(nr4) > 0)
                {
                  ++index20;
                  if (!(this.AreaCounterStep[nr1] > 0 & this.AreaCounterDirections[nr1, 1] == 0))
                  {
                    if (index20 < 9)
                      this.AreaCounterDirections[nr1, index20] = nr4;
                    if (index20 < 9)
                      this.AreaCounterRegime[nr1, index20] = this.AreaOwner[nr4];
                  }
                  if (this.AreaNarrowBorder[nr1, nr4] > 0 & this.AreaBorderNoBridge[nr1, nr4] < 1)
                  {
                    if ((double) this.StrCounterAttack[nr4, nr1] - (double) this.game.Data.RuleVar[831] >= (double) (10 + this.AreaBorder[nr1, nr4]))
                      Number7 += (int) Math.Round((double) (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) / (double) this.GetAreaEnemyNeighbourCountFuzzyVP(nr4));
                    else if ((double) this.StrCounterAttack[nr4, nr1] - (double) this.game.Data.RuleVar[831] >= (double) (0 + this.AreaBorder[nr1, nr4]))
                      Number7 += (int) Math.Round(0.2 * (double) (int) Math.Round((double) (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) / (double) this.GetAreaEnemyNeighbourCountFuzzyVP(nr4)));
                    else if ((double) this.game.Data.RuleVar[826] == 0.0 & (double) this.StrCounterAttack[nr4, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr4] / 2.0)
                      Number7 += (int) Math.Round(0.1 * (double) (int) Math.Round((double) (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) / (double) this.GetAreaEnemyNeighbourCountFuzzyVP(nr4)));
                    else
                      Number7 = 0;
                  }
                  else if ((double) this.StrCounterAttack[nr4, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr4])
                    Number7 += (int) Math.Round((double) (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) / (double) this.GetAreaEnemyNeighbourCountFuzzyVP(nr4));
                  else if ((double) this.game.Data.RuleVar[826] == 0.0 & !this.Attacker & (double) this.StrCounterAttack[nr4, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr4] / 2.0)
                    Number7 += (int) Math.Round(0.1 * (double) (int) Math.Round((double) (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) / (double) this.GetAreaEnemyNeighbourCountFuzzyVP(nr4)));
                }
              }
            }
            if (!this.Attacker)
              Number7 = (int) Math.Round((double) Number7 * 1.4);
            if (this.StrAreaNegPow[nr1] != 0)
            {
              Number7 += Math.Abs(this.StrAreaNegPow[nr1]);
              if (index20 == 0)
                index20 = 1;
            }
            if (Number7 > this.AreaCounterPower[nr1] & round + 1 > this.AreaCounterStep[nr1])
            {
              this.AreaCounterPower[nr1] = Number7;
              if (this.AreaCounterStep[nr1] == 0)
                this.AreaCounterStep[nr1] = round;
            }
            int groupCounter3 = this.GroupCounter;
            int num28;
            for (int index25 = 0; index25 <= groupCounter3; ++index25)
            {
              if (this.CorpsLoc[index25] == nr1)
              {
                int num29 = this.CorpsTempStrength[index25];
                if (this.CorpsLoc[index25] > -1 & this.CorpsTarget[index25] > -1 && this.CorpsTarget[index25] != this.CorpsLoc[index25] & this.GetRegime(this.AreaOwner[this.CorpsTarget[index25]]) == this.GetGameDataTurn())
                {
                  if (this.GroupType[index25] == 5 & Number7 > 0)
                    num29 = num29;
                  int num30 = 0;
                  int areaCount3 = this.AreaCount;
                  for (int index26 = 1; index26 <= areaCount3; ++index26)
                  {
                    if (this.AreaNarrowBorder[index26, this.CorpsTarget[index25]] > 0 && this.GetRegime(this.AreaOwner[index26]) != this.GetGameDataTurn())
                      ++num30;
                  }
                  if (this.CorpsStance[index25] != 2)
                  {
                    if (makelog)
                      this.AddLog("NO POWER FOR GROUP MOVING THROUGH AREA..: " + this.GroupName[index25]);
                    num29 = 0;
                  }
                  else if (this.CorpsMove[index25] == 1 & num30 == 0)
                  {
                    if (makelog)
                      this.AddLog("3 * POWER FOR RETREAT MODE DEFENDER IF TARGET OF RETREAT IS NOT BORDERING ENEMY..: " + this.GroupName[index25]);
                    num29 *= 4;
                  }
                  else if (this.CorpsMove[index25] == 1)
                  {
                    if (makelog)
                      this.AddLog("3 * POWER FOR RETREAT MODE DEFENDER IF TARGET OF RETREAT IS NOT BORDERING ENEMY..: " + this.GroupName[index25]);
                    num29 *= 2;
                  }
                  else if (this.CorpsMove[index25] <= 2)
                  {
                    if (makelog)
                      this.AddLog("SECOND RETREAT OR RETREAT TO COMBATED AREA IS JUST NORMAL SCORE.: " + this.GroupName[index25]);
                    num29 *= 1;
                  }
                  else
                  {
                    if (makelog)
                      this.AddLog("OTHER.: " + this.GroupName[index25]);
                    num29 *= 1;
                  }
                }
                num28 = 0;
                Number9 += num29;
                if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] && this.CorpsBottleneck[index25] < num26)
                  num26 = this.CorpsBottleneck[index25];
                if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] & round >= 3)
                {
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK FOR OUR DEFENDERS.." + this.CorpsBottleneck[index25].ToString());
                  num28 = 1;
                }
                else if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] & round >= 2)
                {
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK FOR OUR DEFENDERS.." + this.CorpsBottleneck[index25].ToString());
                  num28 = 1;
                }
                else if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] & round >= 1)
                {
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK FOR OUR DEFENDERS.." + this.CorpsBottleneck[index25].ToString());
                  num28 = 1;
                }
                else
                  num29 = (int) Math.Round((double) ((float) num29 * ((float) (100 + this.CorpsEntrench[index25]) / 100f)));
                if (this.CorpsStance[index25] == 3)
                  num29 = (int) Math.Round((double) num29 * 0.66);
                if (this.FriendlySupply[nr1] < 1)
                  num29 = (int) Math.Round((double) num29 * 0.2);
                Number8 += num29;
              }
              else if (this.AreaBorder[nr1, this.CorpsLoc[index25]] <= 0)
                ;
            }
            if (this.AreaDefensive[nr1] > 0)
              Number8 = (int) Math.Round((double) Number8 * ((double) (100 + this.AreaDefensive[nr1]) / 100.0));
            if (Number7 > 0 & makelog)
              this.AddLog("ENEMY POWER on " + this.GetAreaName(nr1) + ". powon= " + Conversion.Str((object) Number7) + ", powdef=" + Conversion.Str((object) Number8) + " (core=" + Conversion.Str((object) Number9) + ", neighbours=" + Conversion.Str((object) Number10));
            float num31 = !(Number8 == 0 & Number7 > 0) ? (!(Number7 > 0 & Number8 > 0) ? 0.0f : (float) Number7 / (float) Number8) : 10f;
            num8 = 0;
            if ((double) num31 > 9.0)
              num31 = 9f;
            if ((double) num31 > 5.0 & (double) num31 < 8.0)
              num31 = num31;
            int Number11;
            int Number12;
            if ((double) num31 > 1.0)
            {
              if (this.Attacker)
              {
                float num32 = (float) (6.0 / Math.Sqrt((double) Math.Min(9f, num31)));
                if ((double) this.game.Data.RuleVar[395] > 0.0)
                  num32 *= this.game.Data.RuleVar[395];
                Number11 = (int) Math.Round((double) ((float) Number7 / num32));
                float num33 = (float) (6.0 / Math.Sqrt((double) Math.Min(2f, num31)));
                if ((double) this.game.Data.RuleVar[395] > 0.0)
                  num33 *= this.game.Data.RuleVar[395];
                Number12 = (int) Math.Round((double) ((float) Number7 / num33));
              }
              else
              {
                float num34 = (float) (13.0 / Math.Sqrt(Math.Pow((double) Math.Min(9f, num31), 1.8)));
                if ((double) this.game.Data.RuleVar[395] > 0.0)
                  num34 *= this.game.Data.RuleVar[395];
                Number11 = (int) Math.Round((double) ((float) Number7 / num34));
                float num35 = (float) (13.0 / Math.Sqrt(Math.Pow((double) Math.Min(2f, num31), 1.8)));
                if ((double) this.game.Data.RuleVar[395] > 0.0)
                  num35 *= this.game.Data.RuleVar[395];
                Number12 = (int) Math.Round((double) ((float) Number7 / num35));
              }
            }
            else if ((double) num31 > 0.5 | this.StrAreaNegPow[nr1] > 0)
            {
              float num36 = 6f;
              if ((double) this.game.Data.RuleVar[395] > 0.0)
                num36 *= this.game.Data.RuleVar[395];
              Number11 = (int) Math.Round((double) ((float) Number7 / num36));
              float num37 = 6f * num31;
              if ((double) this.game.Data.RuleVar[395] > 0.0)
                num37 *= this.game.Data.RuleVar[395];
              Number12 = (int) Math.Round((double) ((float) Number7 / num37));
            }
            else
            {
              Number11 = 0;
              Number12 = 0;
            }
            if ((double) this.game.Data.RuleVar[829] > 0.0)
            {
              Number11 = (int) Math.Round((double) ((float) Number11 / this.game.Data.RuleVar[829]));
              Number12 = (int) Math.Round((double) ((float) Number12 / this.game.Data.RuleVar[829]));
            }
            if (num26 > 0 & num26 < 100)
              Number12 = (int) Math.Round((double) Number12 * ((double) num26 / 100.0));
            if (Number8 == 0)
              Number12 = 0;
            if (Number11 > 0 & makelog)
              this.AddLog("COUNTERATTACK on " + this.GetAreaName(nr1) + ". powon= " + Conversion.Str((object) Number7) + ", powdef=" + Conversion.Str((object) Number8) + " (core=" + Conversion.Str((object) Number9) + ", neighbours=" + Conversion.Str((object) Number10) + ". CAUSES " + Conversion.Str((object) Number11) + " dammage on defender.  And " + Conversion.Str((object) Number12) + " dammage on attacker. (ratio is " + Conversion.Str((object) num31) + ")");
            if (nr1 == 31 & this.AreaGroupCount == 1 & Number7 > 0 & Number8 == 0)
              nr1 = nr1;
            if (Number11 > 0)
            {
              int num38 = 0;
              int num39 = -1;
              int num40 = 0;
              num25 = 0;
              int num41 = 0;
              int num42 = Number7;
              int num43 = 0;
              int groupCounter4 = this.GroupCounter;
              for (int index27 = 0; index27 <= groupCounter4; ++index27)
              {
                if (this.CorpsLoc[index27] == nr1 & Number9 > 0)
                {
                  int num44 = 1;
                  if (this.CorpsLoc[index27] > -1 & this.CorpsTarget[index27] > -1 && this.CorpsTarget[index27] != this.CorpsLoc[index27] & this.GetRegime(this.AreaOwner[this.CorpsTarget[index27]]) == this.GetGameDataTurn())
                    num44 = 0;
                  if (num44 == 1)
                  {
                    int num45 = (int) Math.Round((double) Number11 * ((double) this.CorpsTempStrength[index27] / (double) (Number9 + Number10)));
                    num41 += num45;
                    int num46 = num45;
                    if (num46 > this.CorpsTempStrength[index27])
                      num46 = this.CorpsTempStrength[index27];
                    int[] corpsTempStrength = this.CorpsTempStrength;
                    int[] numArray7 = corpsTempStrength;
                    int index28 = index27;
                    int index29 = index28;
                    int num47 = corpsTempStrength[index28] - num45;
                    numArray7[index29] = num47;
                    int[] corpsPowerLeft = this.CorpsPowerLeft;
                    int[] numArray8 = corpsPowerLeft;
                    int index30 = index27;
                    int index31 = index30;
                    int num48 = corpsPowerLeft[index30] + num46;
                    numArray8[index31] = num48;
                    if (this.CorpsFirstAreaBattle[index27] == 0)
                      this.CorpsFirstAreaBattle[index27] = nr1;
                    if (this.CorpsTempStrength[index27] < 0)
                      num41 += this.CorpsTempStrength[index27];
                    if (0 > this.CorpsTempStrength[index27])
                      this.CorpsTempStrength[index27] = 0;
                    num38 += this.CorpsTempStrength[index27];
                  }
                }
                else
                {
                  int num49 = this.AreaBorder[nr1, this.CorpsLoc[index27]] > 0 & Number9 + Number10 > 0 ? 1 : 0;
                }
              }
              if (Number12 > 0 & index20 == 1)
                Number12 = Number12;
              int num50 = 0;
              int areaCount4 = this.AreaCount;
              for (int nr5 = 1; nr5 <= areaCount4; ++nr5)
              {
                if (nr5 != nr1 & this.AreaBorder[nr1, nr5] > 0 & num42 > 0 && this.GetRegime(this.AreaOwner[nr5]) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[nr5])))
                {
                  if (this.AreaOwner[nr5] > -1)
                    num39 = this.AreaOwner[nr5];
                  int Number13 = 0;
                  if (this.AreaNarrowBorder[nr1, nr5] > 0 & this.AreaBorderNoBridge[nr1, nr5] < 1)
                  {
                    if ((double) this.StrCounterAttack[nr5, nr1] - (double) this.game.Data.RuleVar[831] >= (double) (this.AreaBorder[nr1, nr5] + 10))
                      Number13 = (int) Math.Round((double) Number12 * ((double) (this.AreaEnemy[nr5] * this.AreaFuzzyVP[nr1]) / (double) Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) / (double) num42));
                    else if ((double) this.StrCounterAttack[nr5, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr5])
                      Number13 = (int) Math.Round((double) Number12 * ((double) this.AreaEnemy[nr5] * 0.2 * (double) this.AreaFuzzyVP[nr1] / (double) Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) / (double) num42));
                    else if ((double) this.game.Data.RuleVar[826] == 0.0 & (double) this.StrCounterAttack[nr5, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr5] / 2.0)
                      Number13 = (int) Math.Round((double) Number12 * ((double) this.AreaEnemy[nr5] * 0.1 * (double) this.AreaFuzzyVP[nr1] / (double) Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) / (double) num42));
                  }
                  else if ((double) this.StrCounterAttack[nr5, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr5])
                    Number13 = (int) Math.Round((double) Number12 * ((double) (this.AreaEnemy[nr5] * this.AreaFuzzyVP[nr1]) / (double) Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) / (double) num42));
                  else if ((double) this.game.Data.RuleVar[826] == 0.0 & (double) this.StrCounterAttack[nr5, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr5] / 2.0)
                    Number13 = (int) Math.Round((double) Number12 * ((double) this.AreaEnemy[nr5] * 0.1 * (double) this.AreaFuzzyVP[nr1] / (double) Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) / (double) num42));
                  if ((double) this.StrCounterAttack[nr5, nr1] - (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr5] / 2.0 | (double) this.StrCounterAttack[nr5, nr1] + (double) this.game.Data.RuleVar[831] >= (double) this.AreaBorder[nr1, nr5])
                  {
                    int[] areaEnemy = this.AreaEnemy;
                    int[] numArray = areaEnemy;
                    int index32 = nr5;
                    int index33 = index32;
                    int num51 = areaEnemy[index32] - Number13;
                    numArray[index33] = num51;
                    if (makelog)
                      this.AddLog(this.GetAreaName(nr5) + " LOSES " + Conversion.Str((object) Number13));
                    if (this.AreaEnemy[nr5] < 0)
                      this.AreaEnemy[nr5] = 0;
                    num43 += (int) Math.Round((double) (this.AreaEnemy[nr5] * this.AreaFuzzyVP[nr1]) / (double) Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)));
                    ++num50;
                  }
                }
              }
              if (num39 == -1)
              {
                int regimeCounter = this.game.Data.RegimeCounter;
                for (int reg1 = 0; reg1 <= regimeCounter; ++reg1)
                {
                  if (!this.game.Data.RegimeObj[reg1].Sleep && !this.game.HandyFunctionsObj.IsAlliedOrSelf(reg1, this.GetGameDataTurn()))
                  {
                    num39 = reg1;
                    num40 = num42;
                    num43 = num42;
                    if (num40 > 0)
                      num50 = 1;
                  }
                }
              }
              if (num38 == 0 & num39 > -1 & num43 > 0 & num50 > 0)
              {
                if (makelog)
                  this.AddLog("COUNTERATTACK ON " + this.GetAreaName(nr1) + " SUCCEEDS!!! ENEMY TROOPS MOVE IN. " + Conversion.Str((object) ((double) num43 / (double) num50)) + " points move in.");
                int groupCounter5 = this.GroupCounter;
                for (int tid = 0; tid <= groupCounter5; ++tid)
                {
                  if (this.CorpsLoc[tid] == nr1 & Number9 > 0)
                  {
                    int num52 = 1;
                    if (this.CorpsLoc[tid] > -1 & this.CorpsTarget[tid] > -1 && this.CorpsTarget[tid] != this.CorpsLoc[tid] & this.GetRegime(this.AreaOwner[this.CorpsTarget[tid]]) == this.GetGameDataTurn())
                      num52 = 0;
                    if (num52 == 0)
                    {
                      if (tid == 7)
                        tid = tid;
                      int nr6 = straty.FindNr(tid);
                      this.CorpsLoc[tid] = this.CorpsTarget[tid];
                      int[] corpsMove = this.CorpsMove;
                      int[] numArray = corpsMove;
                      int index34 = tid;
                      int index35 = index34;
                      int num53 = corpsMove[index34] + 1;
                      numArray[index35] = num53;
                      if (this.CorpsMove[tid] == 1)
                        num28 = straty.Data1[nr6];
                      if (this.CorpsMove[tid] == 2)
                        num28 = straty.Data2[nr6];
                      if (this.CorpsMove[tid] == 3)
                        num28 = straty.Data3[nr6];
                      if (this.CorpsMove[tid] == 4)
                        num28 = straty.Data4[nr6];
                      if (this.CorpsMove[tid] == 5)
                        num28 = straty.Data5[nr6];
                      this.CorpsTarget[tid] = num28;
                      this.CorpsMoveProgress[tid] = 0;
                      if (makelog)
                        this.AddLog("MOVED FRIENDLY " + this.GroupName[tid] + " TO " + this.GetAreaName(this.CorpsLoc[tid]) + ", NEW TARGET: " + this.GetAreaName(this.CorpsTarget[tid]));
                    }
                  }
                }
                int areaCount5 = this.AreaCount;
                for (int nr7 = 1; nr7 <= areaCount5; ++nr7)
                {
                  if (nr7 != nr1 & this.AreaBorder[nr1, nr7] > 0 && this.GetRegime(this.AreaOwner[nr7]) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[nr7])))
                  {
                    int Number14 = (int) Math.Round((double) num43 / 2.0 / (double) num50 * ((double) (int) Math.Round((double) (this.AreaEnemy[nr7] * this.AreaFuzzyVP[nr1]) / (double) Math.Max(this.GetAreaEnemyNeighbourCountFuzzyVP(nr7), 1)) / (double) num43));
                    if (Number14 > this.AreaEnemy[nr7])
                      Number14 = this.AreaEnemy[nr7];
                    int[] areaEnemy = this.AreaEnemy;
                    int[] numArray = areaEnemy;
                    int index36 = nr7;
                    int index37 = index36;
                    int num54 = areaEnemy[index36] - Number14;
                    numArray[index37] = num54;
                    if (makelog & Number14 > 0)
                      this.AddLog("FROM " + this.GetAreaName(nr7) + " : " + Conversion.Str((object) Number14));
                    num40 += Number14;
                    if (this.AreaEnemy[nr7] < 0)
                      this.AreaEnemy[nr7] = 0;
                    if (this.GetAreaEnemyNeighbourCount(nr7) == 0)
                    {
                      if (!this.Attacker)
                      {
                        num40 += this.AreaEnemy[nr7];
                        this.AreaEnemy[nr7] = 0;
                      }
                      if (this.Attacker)
                      {
                        num40 += (int) Math.Round((double) this.AreaEnemy[nr7] / 2.0);
                        this.AreaEnemy[nr7] = (int) Math.Round((double) this.AreaEnemy[nr7] / 2.0);
                      }
                      if (makelog & Number14 > 0)
                        this.AddLog("ALL FROM " + this.GetAreaName(nr7) + " : " + Conversion.Str((object) this.AreaEnemy[nr7]));
                      this.AreaEnemy[nr7] = 0;
                    }
                  }
                }
                this.AreaOwner[nr1] = num39;
                this.AreaEnemy[nr1] = num40;
                int areaCount6 = this.AreaCount;
                for (int index38 = 1; index38 <= areaCount6; ++index38)
                {
                  if (index38 != nr1 & this.AreaBorder[nr1, index38] > 0 && this.GetRegime(this.AreaOwner[index38]) == this.GetGameDataTurn())
                    this.StrCounterAttack[nr1, index38] = -8;
                }
                int num55 = 0;
                int areaCount7 = this.AreaCount;
                for (int nr8 = 1; nr8 <= areaCount7; ++nr8)
                {
                  if (nr8 != nr1 & this.AreaBorder[nr1, nr8] > 0 && this.GetRegime(this.AreaOwner[nr8]) != this.GetGameDataTurn() && this.GetAreaEnemyNeighbourCount(nr8) == 0)
                  {
                    num55 += this.AreaEnemy[nr8];
                    this.AreaEnemy[nr8] = 0;
                  }
                }
                if (num55 > 0)
                {
                  int[] areaEnemy = this.AreaEnemy;
                  int[] numArray = areaEnemy;
                  int index39 = nr1;
                  int index40 = index39;
                  int num56 = areaEnemy[index39] + num55;
                  numArray[index40] = num56;
                }
              }
            }
          }
        }
      }
    }

    public int GetStrategyScore(ref SimpleList Straty, bool makelog, float Progress)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      if (makelog)
      {
        int num1 = num1;
      }
      this.EnemySupplyGone = new int[this.AreaCount + 1];
      int areaCount1 = this.AreaCount;
      for (int index = 0; index <= areaCount1; ++index)
        this.EnemySupplyGone[index] = this.StartEnemySupplyGone[index];
      if (this.StrCurSides.GetUpperBound(0) < this.AreaCount)
      {
        this.StrCurSides = new int[this.AreaCount + 1];
        this.StrCounterAttack = new int[this.AreaCount + 1, this.AreaCount + 1];
        this.StrLandEnemySupply = new int[this.AreaCount + 1];
        this.StrOrigAreaOwner = new int[this.AreaCount + 1];
        this.StrAreaEntrench = new int[this.AreaCount + 1];
        this.StrAreaNegPow = new int[this.AreaCount + 1];
      }
      else
      {
        int areaCount2 = this.AreaCount;
        for (int index1 = 0; index1 <= areaCount2; ++index1)
        {
          this.StrCurSides[index1] = 0;
          int areaCount3 = this.AreaCount;
          for (int index2 = 0; index2 <= areaCount3; ++index2)
            this.StrCounterAttack[index1, index2] = 0;
          this.StrLandEnemySupply[index1] = 0;
          this.StrOrigAreaOwner[index1] = 0;
          this.StrAreaEntrench[index1] = 0;
          this.StrAreaNegPow[index1] = 0;
        }
      }
      this.StrTempCorpsCounter = 0;
      if (this.FriendlySupply.GetUpperBound(0) < this.AreaCount | this.AreaCounterPower.GetUpperBound(0) < this.AreaCount)
      {
        this.AreaOwner = new int[this.AreaCount + 1];
        this.AreaCounterPower = new int[this.AreaCount + 1];
        this.AreaCounterDirections = new int[this.AreaCount + 1, 10];
        this.AreaCounterRegime = new int[this.AreaCount + 1, 10];
        this.AreaCounterStep = new int[this.AreaCount + 1];
        this.AreaEnemy = new int[this.AreaCount + 1];
        this.FriendlySupply = new int[this.AreaCount + 1];
        this.EnemySupply = new int[this.AreaCount + 1];
        this.AreaStartEnemy = new int[this.AreaCount + 1];
      }
      else
      {
        int areaCount4 = this.AreaCount;
        for (int index3 = 0; index3 <= areaCount4; ++index3)
        {
          this.AreaCounterPower[index3] = 0;
          int index4 = 0;
          do
          {
            this.AreaCounterDirections[index3, index4] = 0;
            this.AreaCounterRegime[index3, index4] = 0;
            ++index4;
          }
          while (index4 <= 9);
          this.AreaCounterStep[index3] = 0;
          this.AreaEnemy[index3] = 0;
          this.AreaStartEnemy[index3] = 0;
        }
      }
      if (this.CorpsTempAirStrength.GetUpperBound(0) < this.GroupCounter | this.CorpsTopRatio.GetUpperBound(0) < this.GroupCounter | this.CorpsLoc.GetUpperBound(0) < this.GroupCounter | this.CorpsTarget.GetUpperBound(0) < this.GroupCounter | this.CorpsAirEffect.GetUpperBound(0) < this.GroupCounter)
      {
        this.CorpsAirEffect = new int[this.GroupCounter + 1];
        this.CorpsEntrench = new int[this.GroupCounter + 1];
        this.CorpsLoc = new int[this.GroupCounter + 1];
        this.CorpsTarget = new int[this.GroupCounter + 1];
        this.CorpsMove = new int[this.GroupCounter + 1];
        this.CorpsMoveProgress = new int[this.GroupCounter + 1];
        this.CorpsStance = new int[this.GroupCounter + 1];
        this.CorpsTempStrength = new int[this.GroupCounter + 1];
        this.corpsstartStrength = new int[this.GroupCounter + 1];
        this.CorpsTempAirStrength = new int[this.GroupCounter + 1];
        this.CorpsFirstAreaBattle = new int[this.GroupCounter + 1];
        this.CorpsTopRatio = new float[this.GroupCounter + 1];
      }
      else
      {
        int groupCounter = this.GroupCounter;
        for (int index = 0; index <= groupCounter; ++index)
        {
          this.CorpsAirEffect[index] = 0;
          this.CorpsTarget[index] = 0;
          this.CorpsMoveProgress[index] = 0;
          this.CorpsTempAirStrength[index] = 0;
          this.CorpsFirstAreaBattle[index] = 0;
          this.CorpsTopRatio[index] = 0.0f;
        }
      }
      if (this.CorpsStance.GetUpperBound(0) < this.GroupCounter)
        this.CorpsStance = new int[this.GroupCounter + 1];
      if (this.CorpsAirStrength.GetUpperBound(0) < this.GroupCounter)
        this.CorpsAirStrength = (int[]) Utils.CopyArray((Array) this.CorpsAirStrength, (Array) new int[this.GroupCounter + 1]);
      if (Information.IsNothing((object) Straty))
        return -99999;
      int num2 = !(this.AreaGroupRound == 1 & this.AreaGroupCount > 1) ? (this.AreaGroupCount > 1 ? (this.AreaGroupCount > 3 ? 7 : 7) : 10) : 4;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].ProdBonus >= 100 & (double) Progress > 0.4)
        Progress = 1f;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].ProdBonus >= 250)
        Progress = 1f;
      int areaCount5 = this.AreaCount;
      for (int index = 1; index <= areaCount5; ++index)
      {
        this.AreaOwner[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime;
        this.StrOrigAreaOwner[index] = this.AreaOwner[index];
        this.AreaEnemy[index] = this.AreaStrength[index];
        this.AreaStartEnemy[index] = this.AreaStrength[index];
        this.StrAreaEntrench[index] = this.AverageAreaEntrench[index];
      }
      int groupCounter1 = this.GroupCounter;
      for (int grp = 0; grp <= groupCounter1; ++grp)
      {
        this.CorpsLoc[grp] = this.CorpsStartLoc[grp];
        this.CorpsMove[grp] = 1;
        this.CorpsMoveProgress[grp] = 0;
        this.CorpsAirEffect[grp] = 100;
        this.CorpsEntrench[grp] = this.GetAverageCorpsEntrench(grp, 1);
        int nr = Straty.FindNr(grp + 99000);
        this.CorpsStance[grp] = nr <= -1 ? 2 : Straty.Data1[nr];
        this.CorpsTempStrength[grp] = this.CorpsStrength[grp];
        this.corpsstartStrength[grp] = this.CorpsStrength[grp];
      }
      int groupCounter2 = this.GroupCounter;
      for (int index5 = 0; index5 <= groupCounter2; ++index5)
      {
        int nr = Straty.FindNr(index5 + 199000);
        if (nr > -1 && Straty.Data1[nr] > -1)
        {
          int num3 = 100 - this.game.HandyFunctionsObj.Distance(this.AreaCenter[this.CorpsLoc[index5]].x, this.AreaCenter[this.CorpsLoc[index5]].y, 0, this.AreaCenter[this.CorpsLoc[Straty.Data1[nr]]].x, this.AreaCenter[this.CorpsLoc[Straty.Data1[nr]]].y, 0) * 5;
          if (0 > num3)
            num3 = 0;
          if (this.CorpsAirStrength[index5] > 0)
          {
            this.CorpsAirEffect[Straty.Data1[nr]] = (int) Math.Round((double) (this.CorpsAirEffect[Straty.Data1[nr]] * this.CorpsTempAirStrength[Straty.Data1[nr]] + num3 * this.CorpsAirStrength[index5]) / (double) (this.CorpsTempAirStrength[Straty.Data1[nr]] + this.CorpsAirStrength[index5]));
            int[] corpsTempAirStrength = this.CorpsTempAirStrength;
            int[] numArray3 = corpsTempAirStrength;
            int[] data1 = Straty.Data1;
            int[] numArray4 = data1;
            int index6 = nr;
            int index7 = index6;
            int index8 = numArray4[index7];
            int num4 = corpsTempAirStrength[data1[index6]] + this.CorpsAirStrength[index5];
            numArray3[index8] = num4;
          }
        }
      }
      int Number1 = 0;
      if (makelog)
        this.AddLog("STRATEGY SCORE");
      if (makelog)
        this.AddLog("Is attacker = " + Conversion.Str((object) this.Attacker));
      this.StrConsistSame = 0;
      this.StrConsistDifferent = 0;
      if (makelog)
      {
        if (makelog)
        {
          int Number2;
          this.AddLog("INITIAL SETUP****" + Conversion.Str((object) Number2) + "****");
        }
        int Number3 = 0;
        int areaCount6 = this.AreaCount;
        for (int nr = 1; nr <= areaCount6; ++nr)
        {
          if (makelog & this.AreaEnemy[nr] > 0)
          {
            this.AddLog(this.GetAreaName(nr) + ", Owner = " + Conversion.Str((object) this.AreaOwner[nr]) + ", AreaEnemy = " + Conversion.Str((object) this.AreaEnemy[nr]) + ", AreaSupply = " + Conversion.Str((object) this.EnemySupply[nr]));
            Number3 += this.AreaEnemy[nr];
          }
        }
        if (makelog)
          this.AddLog("TOTAL AreaEnemy = " + Conversion.Str((object) Number3));
        if (makelog)
          this.AddLog("***");
      }
      int num5;
      while (num5 < num2)
      {
        ++num5;
        if (makelog)
          this.AddLog("ROUND " + Conversion.Str((object) num5));
        this.GetStrategyScore_CorpsTarget(ref Straty, num5, makelog);
        this.GetStrategyScore_FriendlySupply(false, num5);
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].ProdBonus < 100)
        {
          if (num5 == 1 | num5 % 3 == 0 | !this.Attacker)
            this.GetStrategyScore_EnemySupply();
          this.GetStrategyScore_TroopsPlace(num5, makelog);
          if (num5 <= 2 | num5 % 3 == 0 | this.Meeting | !this.Attacker)
            this.GetStrategyScore_MoveEnemy(num5, makelog);
        }
        else
        {
          this.GetStrategyScore_EnemySupply();
          this.GetStrategyScore_TroopsPlace(num5, makelog);
          this.GetStrategyScore_MoveEnemy(num5, makelog);
        }
        if (makelog)
        {
          if (makelog)
            this.AddLog("****" + Conversion.Str((object) num5) + "****");
          int Number4 = 0;
          int areaCount7 = this.AreaCount;
          for (int nr = 1; nr <= areaCount7; ++nr)
          {
            if (makelog & this.AreaEnemy[nr] > 0)
            {
              this.AddLog(this.GetAreaName(nr) + ", Owner = " + Conversion.Str((object) this.AreaOwner[nr]) + ", AreaEnemy = " + Conversion.Str((object) this.AreaEnemy[nr]) + ", AreaSupply = " + Conversion.Str((object) this.EnemySupply[nr]));
              Number4 += this.AreaEnemy[nr];
            }
          }
          if (makelog)
            this.AddLog("TOTAL AreaEnemy = " + Conversion.Str((object) Number4));
          if (makelog)
            this.AddLog("***");
          int Number5 = 0;
          int groupCounter3 = this.GroupCounter;
          for (int index = 0; index <= groupCounter3; ++index)
          {
            if (makelog & this.CorpsTempStrength[index] > 0)
              this.AddLog(this.GroupName[index] + ", TempStr = " + Conversion.Str((object) this.CorpsTempStrength[index]) + ", Str = " + Conversion.Str((object) this.CorpsStrength[index]) + ", Area = " + this.GetAreaName(this.CorpsLoc[index]) + ", Target = " + this.GetAreaName(this.CorpsTarget[index]) + " Stance = " + Conversion.Str((object) this.CorpsStance[index]) + ", Supply=" + Conversion.Str((object) this.FriendlySupply[this.CorpsLoc[index]]));
            Number5 += this.CorpsTempStrength[index];
          }
          if (makelog)
            this.AddLog("TOTAL TempStr = " + Conversion.Str((object) Number5));
        }
        this.GetStrategyScore_Attacks(ref Straty, num5, makelog);
        int Number6 = this.GetStrategyScoreForVP(makelog, num5);
        if (makelog)
          this.AddLog(Conversion.Str((object) num5) + ") SCORE FOR VP= " + Conversion.Str((object) Number6));
        if (this.Attacker)
        {
          if (num5 == 1)
            Number6 *= 5;
          if (num5 == 2)
            Number6 *= 3;
          if (num5 == 3)
            Number6 *= 2;
          if (num5 == 4)
            Number6 *= 1;
          if (num5 == 5)
            Number6 *= 1;
          if (num5 == 6)
            Number6 *= 1;
        }
        if (makelog)
          this.AddLog(Conversion.Str((object) num5) + ") SCORE AFTER ADJUSTMENT ROUND NR = " + Conversion.Str((object) Number6));
        if (this.Attacker)
          Number6 = (int) Math.Round((double) Number6 * 0.5 + (double) Number6 * 0.5 * (double) this.GetStrategyScoreForEnemyLeft());
        if (makelog & this.Attacker)
          this.AddLog(Conversion.Str((object) num5) + ") SCORE AFTER ADJUSTMENT ENEMY RATIO (" + Conversion.Str((object) this.GetStrategyScoreForEnemyLeft()) + ") = " + Conversion.Str((object) Number6));
        if (Number6 > 0)
          Number6 = (int) Math.Round((double) Number6 * 0.9 + (double) Number6 * 0.1 * (double) this.GetStrategyScoreForKillRatio());
        else if (Number6 > -1000)
          Number6 = (int) Math.Round((double) Number6 * 0.9 + (double) Number6 * 0.1 * (1.0 / (double) this.GetStrategyScoreForKillRatio()));
        if (makelog)
          this.AddLog(Conversion.Str((object) num5) + ") SCORE AFTER ADJUSTMENT 0.1 (" + Conversion.Str((object) this.GetStrategyScoreForKillRatio()) + ") KILL RATIO = " + Conversion.Str((object) Number6));
        Number1 += Number6;
        if (this.Attacker)
        {
          int Number7 = Number6 <= 0 ? (int) Math.Round((double) Number6 * 0.2 + (double) Number6 * 0.8 * (1.0 / (double) this.GetStrategyScoreForUnusedCorps(makelog))) : (int) Math.Round((double) Number6 * 0.2 + (double) Number6 * 0.8 * (double) this.GetStrategyScoreForUnusedCorps(makelog));
          if (makelog)
            this.AddLog(Conversion.Str((object) num5) + ") SCORE AFTER ADJUSTMENT (" + Conversion.Str((object) this.GetStrategyScoreForUnusedCorps(false)) + ") UNUSED RATIO = " + Conversion.Str((object) Number7));
          Number1 += Number7;
        }
        int counter = this.TempPowerAbove.Counter;
        for (int index9 = 0; index9 <= counter; ++index9)
        {
          int num6 = 0;
          int groupCounter4 = this.GroupCounter;
          for (int index10 = 0; index10 <= groupCounter4; ++index10)
          {
            if (this.CorpsLoc[index10] == this.TempPowerAbove.Id[index9])
              num6 += this.CorpsTempStrength[index10];
          }
          if (num6 > this.TempPowerAbove.Data1[index9])
          {
            int Number8 = (int) Math.Round((double) ((num6 - this.TempPowerAbove.Data1[index9]) * this.TempPowerAbove.Data2[index9]) / (double) (1 + (num2 - num5)));
            Number1 += Number8;
            if (makelog)
              this.AddLog(Conversion.Str((object) Number8) + " points for PowerAbove Points in area " + this.GetAreaName(this.TempPowerAbove.Id[index9]));
          }
        }
        if (makelog)
          this.AddLog("***=> END OF ROUND SCORE = " + Conversion.Str((object) Number1));
      }
      if (this.StrConsistSame + this.StrConsistDifferent > 0 & this.game.Data.Round > 1)
      {
        float Number9 = (float) this.StrConsistSame / (float) (this.StrConsistSame + this.StrConsistDifferent);
        if (makelog)
          this.AddLog("CONSISTENCY MODIFIER (FOR 1/2 OF SCORE) = " + Conversion.Str((object) Number9));
        Number1 = Number1 <= 0 ? ((double) Number9 != 0.0 ? (int) Math.Round((double) Number1 * 0.5 + (double) Number1 * 0.5 * (1.0 / (double) Number9)) : (int) Math.Round((double) Number1 * 0.5)) : (int) Math.Round((double) Number1 * 0.5 + (double) Number1 * 0.5 * (double) Number9);
      }
      int Number10 = Number1 - this.ClosenessToFrontScore(makelog);
      if (makelog)
        this.AddLog("***=> SCORE AFTER ADDING CLOSENESS TO PROGNOSED ENEMY POSITION = " + Conversion.Str((object) Number10));
      int Number11 = Number10 - this.ClosenessToCurrentFrontScore(makelog);
      if (makelog)
        this.AddLog("***=> SCORE AFTER ADDING CLOSENESS TO CURRENT ENEMY POSITION= " + Conversion.Str((object) Number11));
      int groupCounter5 = this.GroupCounter;
      for (int index = 0; index <= groupCounter5; ++index)
      {
        if (this.StartFriendlySupply[this.CorpsStartLoc[index]] == 0 && this.FriendlySupply[this.CorpsLoc[index]] == 1)
        {
          int Number12 = this.CorpsTempStrength[index];
          Number11 += Number12;
          if (makelog)
            this.AddLog(Conversion.Str((object) Number12) + " points for surving power points from encirclement ");
        }
      }
      int groupCounter6 = this.GroupCounter;
      for (int tid1 = 0; tid1 <= groupCounter6; ++tid1)
      {
        int nr1 = Straty.FindNr(tid1);
        if (nr1 > -1 & this.GroupType[tid1] <= 5 && Straty.Data1[nr1] > 0)
        {
          int groupCounter7 = this.GroupCounter;
          for (int tid2 = 0; tid2 <= groupCounter7; ++tid2)
          {
            if (this.CorpsStartLoc[tid2] == this.CorpsStartLoc[tid1])
            {
              int nr2 = Straty.FindNr(tid2);
              if (nr2 > -1 & this.GroupType[tid2] <= 5 && Straty.Data1[nr2] != Straty.Data1[nr1] && this.HisAreaDistance[tid1, Straty.Data1[nr1]] > this.HisAreaDistance[tid2, Straty.Data1[nr1]])
              {
                int Number13 = (int) Math.Round(Math.Sqrt((double) (int) Math.Round((double) Math.Min(this.corpsstartStrength[tid2], this.corpsstartStrength[tid1]) * ((double) (this.HisAreaDistance[tid1, Straty.Data1[nr1]] - this.HisAreaDistance[tid2, Straty.Data1[nr1]]) / 500.0))));
                Number11 -= Number13;
                if (makelog)
                  this.AddLog(Conversion.Str((object) Number13) + " points for having group " + this.GroupName[tid1] + " moving while " + this.GroupName[tid2] + " would have been quicker. = " + Conversion.Str((object) Number13) + " penalty.");
              }
            }
          }
        }
      }
      if (makelog)
        this.AddLog("***=> FINAL SCORE AFTER ALL ROUNDS = " + Conversion.Str((object) Number11));
      int d = 0;
      int groupCounter8 = this.GroupCounter;
      for (int index = 0; index <= groupCounter8; ++index)
        d += this.CorpsTempStrength[index];
      int Number14 = Number11 + (int) Math.Round(Math.Sqrt((double) d));
      if (makelog)
        this.AddLog("***=> FINAL SCORE AFTER SQRT(TOTALTROOPS) added = " + Conversion.Str((object) Number14));
      return Number14;
    }

    public int ClosenessToFrontScore(bool makelog)
    {
      int groupCounter = this.GroupCounter;
      int frontScore;
      for (int index1 = 0; index1 <= groupCounter; ++index1)
      {
        int Number1 = 999999;
        int Number2 = 0;
        if (this.GroupType[index1] <= 5 & this.CorpsLoc[index1] > 0 && this.AreaGroup[this.CorpsLoc[index1]] == this.CurrentAreaGroup)
        {
          if (this.CorpsStrength[index1] <= this.CorpsTempStrength[index1])
          {
            int areaCount = this.AreaCount;
            for (int index2 = 1; index2 <= areaCount; ++index2)
            {
              if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.AreaOwner[index2]) && this.game.Data.RegimeObj[this.game.Data.Turn].AIVP[0].Value[this.AreaCenter[index2].x, this.AreaCenter[index2].y] > 0 | this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].VP > 0)
              {
                int areaStep = this.AreaSteps[index2, this.CorpsLoc[index1]];
                int num = this.AreaSteps[index2, this.CorpsLoc[index1]] > 1 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 2 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 3 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 4 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 5 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 6 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 7 ? 14 : 12) : 10) : 8) : 6) : 4) : 2) : 0;
                if (areaStep > 0 && areaStep < Number1)
                {
                  Number1 = areaStep;
                  Number2 = num;
                }
              }
            }
          }
          if (Number1 <= 99999)
          {
            if (makelog)
              this.AddLog(Conversion.Str((object) Number2) + " point multiplier for " + this.GroupName[index1] + ". Closest enemy dist =" + Conversion.Str((object) Number1));
            int Number3 = (int) Math.Round(Math.Sqrt(Math.Sqrt((double) this.corpsstartStrength[index1]))) * Number2;
            frontScore += Number3;
            if (makelog)
              this.AddLog("Removes -" + Conversion.Str((object) Number3));
          }
        }
      }
      return frontScore;
    }

    public int ClosenessToCurrentFrontScore(bool makelog)
    {
      int groupCounter = this.GroupCounter;
      int currentFrontScore;
      for (int index1 = 0; index1 <= groupCounter; ++index1)
      {
        int Number1 = 999999;
        int Number2 = 0;
        if (this.GroupType[index1] <= 5 & this.CorpsLoc[index1] > 0 && this.AreaGroup[this.CorpsLoc[index1]] == this.CurrentAreaGroup)
        {
          if (this.CorpsStrength[index1] <= this.CorpsTempStrength[index1])
          {
            int areaCount = this.AreaCount;
            for (int index2 = 1; index2 <= areaCount; ++index2)
            {
              if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime) && this.game.Data.RegimeObj[this.game.Data.Turn].AIVP[0].Value[this.AreaCenter[index2].x, this.AreaCenter[index2].y] > 0 | this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].VP > 0)
              {
                int areaStep = this.AreaSteps[index2, this.CorpsLoc[index1]];
                int num = this.AreaSteps[index2, this.CorpsLoc[index1]] > 1 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 2 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 3 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 4 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 5 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 6 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 7 ? 14 : 12) : 10) : 8) : 6) : 4) : 2) : 0;
                if (areaStep > 0 && areaStep < Number1)
                {
                  Number1 = areaStep;
                  Number2 = num;
                }
              }
            }
          }
          if (Number1 <= 99999)
          {
            if (makelog)
              this.AddLog(Conversion.Str((object) Number2) + " point multiplier for " + this.GroupName[index1] + ". Closest CURRENT FRONT enemy dist =" + Conversion.Str((object) Number1));
            int Number3 = (int) Math.Round((double) ((int) Math.Round(Math.Sqrt(Math.Sqrt((double) this.corpsstartStrength[index1]))) * Number2) / 2.0);
            currentFrontScore += Number3;
            if (makelog)
              this.AddLog("Removes -" + Conversion.Str((object) Number3));
          }
        }
      }
      return currentFrontScore;
    }

    public int GetAreaBorderSteps(int from, int too, int maxstep)
    {
      int[] numArray = new int[this.AreaCount + 1];
      numArray[from] = 1;
      int num1 = 1;
      int areaBorderSteps = 0;
      while (num1 == 1)
      {
        num1 = 0;
        ++areaBorderSteps;
        if (areaBorderSteps > maxstep)
          return 9999;
        int areaCount = this.AreaCount;
        for (int index1 = 1; index1 <= areaCount; ++index1)
        {
          if (numArray[index1] == areaBorderSteps)
          {
            int num2 = this.AreaSupplyBorderCount[index1];
            for (int index2 = 1; index2 <= num2; ++index2)
            {
              int index3 = this.AreaSupplyBorder[index1, index2];
              if (numArray[index3] == 0)
              {
                numArray[index3] = areaBorderSteps + 1;
                if (too == index3)
                  return areaBorderSteps;
                num1 = 1;
              }
            }
          }
        }
      }
      return 9999;
    }

    public int GetAreaNarrowBorderSteps(int from, int too, int maxstep)
    {
      int areaCount1 = this.AreaCount;
      for (int index = 0; index <= areaCount1; ++index)
        this.stemp[index] = 0;
      this.stemp[from] = 1;
      int num = 1;
      int narrowBorderSteps = 0;
      while (num == 1)
      {
        num = 0;
        ++narrowBorderSteps;
        if (narrowBorderSteps > maxstep)
          return 9999;
        int areaCount2 = this.AreaCount;
        for (int index1 = 1; index1 <= areaCount2; ++index1)
        {
          if (this.stemp[index1] == narrowBorderSteps)
          {
            int areaCount3 = this.AreaCount;
            for (int index2 = 1; index2 <= areaCount3; ++index2)
            {
              if (this.AreaNarrowBorder[index1, index2] > 0 & this.AreaNarrowBorder[index1, index2] < 99 & index1 != index2 && this.stemp[index2] == 0)
              {
                this.stemp[index2] = narrowBorderSteps + 1;
                if (too == index2)
                  return narrowBorderSteps;
                num = 1;
              }
            }
          }
        }
      }
      return 9999;
    }

    public int GetAverageCorpsEntrench(int grp, int CatOnly = -1)
    {
      int unitCounter = this.game.Data.UnitCounter;
      int num1;
      int num2;
      for (int index1 = 0; index1 <= unitCounter; ++index1)
      {
        if (this.game.Data.UnitObj[index1].PreDef == -1 && this.game.Data.UnitObj[index1].AIGroup == grp & this.game.Data.UnitObj[index1].X > -1 && this.game.Data.UnitObj[index1].TempCategory == CatOnly | CatOnly == -1)
        {
          int sfCount = this.game.Data.UnitObj[index1].SFCount;
          for (int index2 = 0; index2 <= sfCount; ++index2)
          {
            int sf = this.game.Data.UnitObj[index1].SFList[index2];
            int num3 = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Qty;
            num1 += num3 * this.game.Data.SFObj[sf].CurrentEntrench;
            num2 += num3;
          }
        }
      }
      return num2 == 0 ? 0 : (int) Math.Round((double) num1 / (double) num2);
    }

    public int GetAverageAreaEntrench(int Area, int CatOnly = -1)
    {
      int unitCounter = this.game.Data.UnitCounter;
      int num1;
      int num2;
      for (int index1 = 0; index1 <= unitCounter; ++index1)
      {
        if (this.game.Data.UnitObj[index1].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index1].Regime) != this.GetGameDataTurn() & this.game.Data.UnitObj[index1].X > -1 && this.AreaMatrixNarrow[this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y] == Area && this.game.Data.UnitObj[index1].TempCategory == CatOnly | CatOnly == -1)
        {
          int sfCount = this.game.Data.UnitObj[index1].SFCount;
          for (int index2 = 0; index2 <= sfCount; ++index2)
          {
            int sf = this.game.Data.UnitObj[index1].SFList[index2];
            int num3 = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Qty;
            num1 += num3 * this.game.Data.SFObj[sf].CurrentEntrench;
            num2 += num3;
          }
        }
      }
      return num2 == 0 ? 0 : (int) Math.Round((double) num1 / (double) num2);
    }

    public Coordinate GetAverageCorpsUnitCoord(int grp, int CatOnly = -1, bool ReturnRoadHex = false)
    {
      SimpleList simpleList1 = new SimpleList();
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter1; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup == grp & this.game.Data.UnitObj[unr].X > -1 && this.game.Data.UnitObj[unr].TempCategory == CatOnly | CatOnly == -1)
        {
          int num4 = this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          if (this.game.Data.UnitObj[unr].IsHQ)
            num4 = (int) Math.Round((double) num4 / 5.0);
          num2 += this.game.Data.UnitObj[unr].X * num4;
          num3 += this.game.Data.UnitObj[unr].Y * num4;
          int tid;
          ++tid;
          simpleList1.Add(tid, 0, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y);
          num1 += num4;
        }
      }
      Coordinate averageCorpsUnitCoord;
      averageCorpsUnitCoord.onmap = false;
      if (num1 == 0 || simpleList1.Counter == -1)
        return averageCorpsUnitCoord;
      averageCorpsUnitCoord.x = (int) Math.Round((double) num2 / (double) num1);
      averageCorpsUnitCoord.y = (int) Math.Round((double) num3 / (double) num1);
      int counter = simpleList1.Counter;
      for (int index = 0; index <= counter; ++index)
        simpleList1.Weight[index] = this.game.HandyFunctionsObj.Distance(simpleList1.Data1[index], simpleList1.Data2[index], 0, averageCorpsUnitCoord.x, averageCorpsUnitCoord.y, 0);
      simpleList1.Sort();
      averageCorpsUnitCoord.x = simpleList1.Data1[0];
      averageCorpsUnitCoord.y = simpleList1.Data2[0];
      if (ReturnRoadHex)
      {
        SimpleList simpleList2 = new SimpleList();
        int tid = 0;
        int unitCounter2 = this.game.Data.UnitCounter;
        for (int index1 = 0; index1 <= unitCounter2; ++index1)
        {
          if (this.game.Data.UnitObj[index1].PreDef == -1 && this.game.Data.UnitObj[index1].AIGroup == grp & this.game.Data.UnitObj[index1].X > -1 && this.GetRegime(this.game.Data.UnitObj[index1].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index1].TempCategory == CatOnly | CatOnly == -1)
          {
            int num5 = 0;
            ++tid;
            int index2 = 0;
            do
            {
              if (this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y].RoadType[index2] > -1)
                num5 = 1;
              ++index2;
            }
            while (index2 <= 5);
            if (num5 == 1)
              simpleList2.Add(tid, this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0, averageCorpsUnitCoord.x, averageCorpsUnitCoord.y, 0), this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y);
          }
        }
        if (simpleList2.Counter > -1)
        {
          simpleList2.Sort();
          averageCorpsUnitCoord.x = simpleList2.Data1[0];
          averageCorpsUnitCoord.y = simpleList2.Data2[0];
          averageCorpsUnitCoord.onmap = true;
          return averageCorpsUnitCoord;
        }
      }
      return averageCorpsUnitCoord;
    }

    public float GetStrategyScoreForKillRatio()
    {
      int num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int num4 = 0;
      int areaCount = this.AreaCount;
      for (int index = 1; index <= areaCount; ++index)
      {
        num1 += this.AreaStartEnemy[index];
        num2 += this.AreaEnemy[index];
      }
      int groupCounter = this.GroupCounter;
      for (int index = 0; index <= groupCounter; ++index)
      {
        if (this.GroupType[index] <= 5)
          ;
        num3 += this.corpsstartStrength[index];
        num4 += this.CorpsTempStrength[index];
      }
      if (num4 > num3)
        num4 = num3;
      if (num2 > num1)
        num2 = num1;
      float scoreForKillRatio = (float) (num1 - num2) / (float) Math.Max(1, num3 - num4);
      if ((double) scoreForKillRatio == 0.0)
        scoreForKillRatio = 1f;
      if ((double) scoreForKillRatio < 0.25)
        scoreForKillRatio = scoreForKillRatio;
      if ((double) scoreForKillRatio > 4.0)
        scoreForKillRatio = 4f;
      return scoreForKillRatio;
    }

    public float GetStrategyScoreForEnemyLeft()
    {
      int num1 = 0;
      int num2 = 0;
      int areaCount = this.AreaCount;
      for (int index = 1; index <= areaCount; ++index)
      {
        num1 += this.AreaStartEnemy[index];
        num2 += this.AreaEnemy[index];
      }
      if (num1 == 0)
        return 1f;
      return num2 > num1 ? 0.0f : 1f - (float) num2 / (float) num1;
    }

    public float GetStrategyScoreForUnusedCorps(bool makelog)
    {
      int groupCounter = this.GroupCounter;
      int num1;
      int num2;
      for (int index = 0; index <= groupCounter; ++index)
      {
        if (this.AreaGroup[this.CorpsLoc[index]] == this.CurrentAreaGroup)
        {
          int num3 = 0;
          int num4 = this.CorpsStrength[index] > this.CorpsTempStrength[index] | this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.CorpsLoc[index]].x, this.AreaCenter[this.CorpsLoc[index]].y].Regime) != this.GetGameDataTurn() ? 1 : 0;
          if (this.CorpsLoc[index] <= 0 || this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.CorpsLoc[index]].x, this.AreaCenter[this.CorpsLoc[index]].y].Regime) == this.GetGameDataTurn())
            ;
          if (this.CorpsTarget[index] <= 0 || this.GetRegime(this.AreaOwner[this.CorpsTarget[index]]) == this.GetGameDataTurn())
            ;
          if (this.GroupType[index] > 5 & this.CorpsTempAirStrength[index] <= 0)
            num3 = 1;
          if (this.CorpsStrength[index] > this.CorpsTempStrength[index])
            num3 = 1;
          if (this.StartFriendlySupply[this.CorpsStartLoc[index]] == 0)
            num3 = 1;
          if (num3 == 1)
          {
            num1 += this.CorpsStrength[index];
          }
          else
          {
            num2 += 1 * this.CorpsStrength[index] + this.CorpsTempAirStrength[index] * 10;
            if (makelog)
              this.AddLog(this.GroupName[index] + " IS NOT USED");
          }
        }
      }
      float scoreForUnusedCorps = (float) num1 / (float) Math.Max(1, num1 + num2);
      if ((double) scoreForUnusedCorps == 0.0)
        scoreForUnusedCorps = 1f;
      return scoreForUnusedCorps;
    }

    public int GetStrategyScoreForVP(bool makelog, int round)
    {
      int tempTotVp = this.TempTotVP;
      int tempCurVp = this.TempCurVP;
      int num1 = 0;
      int strategyScoreForVp = 0;
      int num2 = 0;
      if (tempTotVp <= 0)
        return 0;
      int areaCount1 = this.AreaCount;
      for (int nr = 1; nr <= areaCount1; ++nr)
      {
        if (this.AreaGroup[nr] == this.CurrentAreaGroup)
        {
          int x = this.AreaCenter[nr].x;
          int y = this.AreaCenter[nr].y;
          if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
            num2 = num2 + this.game.Data.RegimeObj[this.game.Data.Turn].AIVP[0].Value[x, y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].VP + this.AreaExtraVP[nr];
          if (this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn())
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
            {
              int Number = (int) Math.Round(1000.0 * ((double) (this.AreaExtraVP[nr] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].VP) / (double) tempTotVp));
              strategyScoreForVp += Number;
              if (makelog)
                this.AddLog(this.GetAreaName(nr) + " = + " + Conversion.Str((object) Number) + " pts. (VP) ( Extra VP= " + Conversion.Str((object) this.AreaExtraVP[nr]) + ")");
            }
          }
          else if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) == this.GetGameDataTurn() && this.GetRegime(this.AreaOwner[nr]) != this.GetGameDataTurn())
          {
            int Number = (int) Math.Round(1000.0 * ((double) (this.AreaExtraVP[nr] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].VP) / (double) tempTotVp));
            strategyScoreForVp -= Number;
            if (makelog)
              this.AddLog(this.GetAreaName(nr) + " = - " + Conversion.Str((object) Number) + " pts. (VP) ( Extra VP= " + Conversion.Str((object) this.AreaExtraVP[nr]) + ")");
          }
        }
      }
      int areaCount2 = this.AreaCount;
      int num3;
      int num4;
      for (int index = 1; index <= areaCount2; ++index)
      {
        if (this.AreaGroup[index] == this.CurrentAreaGroup)
        {
          num3 += this.AreaStrength[index];
          num4 += this.AreaEnemy[index];
        }
      }
      float num5 = num3 <= 0 ? 0.0f : 1f - (float) num4 / (float) num3;
      if ((double) num5 > 1.0)
        num5 = 1f;
      if ((double) num5 < 0.0)
        num5 = 0.0f;
      num1 = (int) Math.Round((double) (350f * ((float) num2 / (float) Math.Max(1, tempTotVp - tempCurVp)) * num5));
      int Number1 = 0;
      int areaCount3 = this.AreaCount;
      for (int index = 1; index <= areaCount3; ++index)
      {
        if (this.AreaGroup[index] == this.CurrentAreaGroup)
        {
          int x = this.AreaCenter[index].x;
          int y = this.AreaCenter[index].y;
          if (this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn())
            Number1 += this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].VP;
        }
      }
      if (makelog)
        this.AddLog("Our AI has " + Conversion.Str((object) Number1) + " VP prognosed.");
      bool flag;
      if (this.Attacker && (double) this.game.Data.RuleVar[266] > 0.0 & (double) Number1 >= (double) this.game.Data.RuleVar[266])
      {
        strategyScoreForVp *= 20;
        flag = true;
        if (makelog)
          this.AddLog("CONSIDERED VICTORY *20");
      }
      if (!this.Attacker && (double) this.game.Data.RuleVar[265] > 0.0 & (double) Number1 <= (double) this.game.Data.RuleVar[265] & this.AreaGroupCount == 1)
      {
        strategyScoreForVp -= 2000;
        flag = true;
        if (makelog)
          this.AddLog("CONSIDER LOST. subtracted -2000. ");
      }
      if ((double) (this.game.Data.Round + round) > (double) this.game.Data.RuleVar[844] & (double) this.game.Data.RuleVar[844] > 0.0)
      {
        if (this.Attacker & !flag)
        {
          strategyScoreForVp -= 2000;
          if (makelog)
            this.AddLog("CONSIDER LOST DUE TO PAST END OF SCENARIO DURATION. subtracted -2000. ");
        }
        else if (!this.Attacker & !flag)
          return 2000;
      }
      int num6 = 0;
      int num7 = 0;
      int areaCount4 = this.AreaCount;
      for (int index = 1; index <= areaCount4; ++index)
      {
        if (!this.AreaIsExtra[index])
        {
          if (this.AreaOwner[index] == this.GetGameDataTurn() & this.StrOrigAreaOwner[index] != this.GetGameDataTurn())
            ++num6;
          if (this.AreaOwner[index] != this.GetGameDataTurn() & this.StrOrigAreaOwner[index] == this.GetGameDataTurn())
            ++num7;
        }
      }
      if (num6 > 0 | num7 > 0)
      {
        int Number2 = num6 + (int) Math.Round((double) num6 * ((double) this.AverageVP / 2.0));
        int Number3 = num7 + (int) Math.Round((double) num7 * ((double) this.AverageVP / 2.0));
        strategyScoreForVp = strategyScoreForVp + Number2 - Number3;
        if (makelog)
          this.AddLog("Score for Areas Added " + Conversion.Str((object) Number2) + " Score for Areas Lost -" + Conversion.Str((object) Number3));
      }
      return strategyScoreForVp;
    }

    public int GetClosestAreaThroughSupply(int grp)
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      int areaThroughSupply = -1;
      int index1 = -1;
      if (this.SupplyMatrix.GetUpperBound(0) < 2)
        return 0;
      if (this.GroupHis[grp] > -1)
      {
        index1 = this.game.HandyFunctionsObj.GetUnitByHistorical(this.GroupHis[grp]);
      }
      else
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int index2 = 0; index2 <= unitCounter; ++index2)
        {
          if (this.game.Data.UnitObj[index2].PreDef == -1 && this.game.Data.UnitObj[index2].AIGroup == grp)
          {
            index1 = index2;
            break;
          }
        }
      }
      if (index1 == -1)
        return 0;
      int hq = this.game.Data.UnitObj[index1].HQ;
      if (hq == -1)
        return 0;
      if (hq > -1)
      {
        areaThroughSupply = -1;
        Coordinate coordinate;
        coordinate.onmap = true;
        coordinate.x = this.game.Data.UnitObj[index1].X;
        coordinate.y = this.game.Data.UnitObj[index1].Y;
        for (; areaThroughSupply == -1 & coordinate.onmap; coordinate = this.SupplyMatrixRealCameFrom[coordinate.x, coordinate.y])
        {
          int index3 = this.AreaMatrixWide[coordinate.x, coordinate.y];
          if (index3 > 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime) == this.GetGameDataTurn())
            areaThroughSupply = index3;
        }
        if (areaThroughSupply == -1)
        {
          coordinate.onmap = true;
          coordinate.x = this.game.Data.UnitObj[index1].X;
          coordinate.y = this.game.Data.UnitObj[index1].Y;
          for (; areaThroughSupply == -1 & coordinate.onmap; coordinate = this.SupplyMatrixPrognosisCameFrom[coordinate.x, coordinate.y])
          {
            int index4 = this.AreaMatrixWide[coordinate.x, coordinate.y];
            if (index4 > 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index4].x, this.AreaCenter[index4].y].Regime) == this.GetGameDataTurn())
              areaThroughSupply = index4;
          }
        }
      }
      if (areaThroughSupply == -1)
        areaThroughSupply = 0;
      return areaThroughSupply;
    }

    public int GetStartArea(int grp)
    {
      Coordinate averageCorpsUnitCoord = this.GetAverageCorpsUnitCoord(grp, ReturnRoadHex: true);
      if (this.game.Data.Round == 1)
      {
        int groupHq = this.GetGroupHQ(grp);
        if (groupHq > -1)
        {
          int num = this.AreaMatrixNarrow[this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y];
        }
      }
      int startArea = 0;
      if (startArea == 0 & this.AreaMatrixNarrow[averageCorpsUnitCoord.x, averageCorpsUnitCoord.y] > 0)
        startArea = this.AreaMatrixNarrow[averageCorpsUnitCoord.x, averageCorpsUnitCoord.y];
      if (startArea == 0)
        startArea = this.GetClosestAreaThroughSupply(grp);
      if (startArea == 0)
        startArea = this.AreaMatrixWide[averageCorpsUnitCoord.x, averageCorpsUnitCoord.y];
      return startArea;
    }

    public int GetHisAreaAsAIArea(int hisarea)
    {
      int areaCount = this.AreaCount;
      for (int hisAreaAsAiArea = 1; hisAreaAsAiArea <= areaCount; ++hisAreaAsAiArea)
      {
        if (this.AreaIsHistoricalArea[hisAreaAsAiArea] == hisarea)
          return hisAreaAsAiArea;
      }
      return -1;
    }

    public int GetTotalVPonMap(bool OnlyVP = false)
    {
      int totalVponMap;
      if (this.Attacker | OnlyVP)
      {
        int mapWidth = this.game.Data.MapObj[0].MapWidth;
        for (int index1 = 0; index1 <= mapWidth; ++index1)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int index2 = 0; index2 <= mapHeight; ++index2)
          {
            if (this.CurrentAreaGroup > 0)
            {
              if (this.AreaMatrixWide[index1, index2] > 0 && this.AreaGroup[this.AreaMatrixWide[index1, index2]] == this.CurrentAreaGroup)
              {
                totalVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
                if (!OnlyVP)
                  totalVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
              }
            }
            else
            {
              totalVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
              if (!OnlyVP)
                totalVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
            }
          }
        }
      }
      else if (this.CurrentAreaGroup > 0)
      {
        int areaCount = this.AreaCount;
        for (int index = 0; index <= areaCount; ++index)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup)
            totalVponMap += this.AreaFuzzyVP[index];
        }
      }
      else
      {
        int areaCount = this.AreaCount;
        for (int index = 0; index <= areaCount; ++index)
          totalVponMap += this.AreaFuzzyVP[index];
      }
      if (this.AreaExtraVP.GetUpperBound(0) < this.AreaCount)
        this.AreaExtraVP = new int[this.AreaCount + 1];
      if (!OnlyVP)
      {
        int areaCount = this.AreaCount;
        for (int index = 0; index <= areaCount; ++index)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup)
            totalVponMap += this.AreaExtraVP[index];
        }
      }
      return totalVponMap;
    }

    public int GetStartVPonMap(bool OnlyVP = false)
    {
      int startVponMap;
      if (this.Attacker | OnlyVP)
      {
        int mapWidth = this.game.Data.MapObj[0].MapWidth;
        for (int index1 = 0; index1 <= mapWidth; ++index1)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int index2 = 0; index2 <= mapHeight; ++index2)
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index1, index2].Regime) == this.GetGameDataTurn())
            {
              if (this.CurrentAreaGroup > 0)
              {
                if (this.AreaMatrixWide[index1, index2] > 0 && this.AreaGroup[this.AreaMatrixWide[index1, index2]] == this.CurrentAreaGroup)
                {
                  startVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
                  if (!OnlyVP)
                    startVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
                }
              }
              else
              {
                startVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
                if (!OnlyVP)
                  startVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
              }
            }
          }
        }
      }
      else if (this.CurrentAreaGroup > 0)
      {
        int areaCount = this.AreaCount;
        for (int index = 0; index <= areaCount; ++index)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn())
            startVponMap += this.AreaFuzzyVP[index];
        }
      }
      else
      {
        int areaCount = this.AreaCount;
        for (int index = 0; index <= areaCount; ++index)
        {
          if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn())
            startVponMap += this.AreaFuzzyVP[index];
        }
      }
      if (!OnlyVP)
      {
        int areaCount = this.AreaCount;
        for (int index = 0; index <= areaCount; ++index)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn())
            startVponMap += this.AreaExtraVP[index];
        }
      }
      return startVponMap;
    }

    public int GetRandomFriendlyArea(
      int nr,
      int not1 = -1,
      int not2 = -1,
      int not3 = -1,
      int not4 = -1,
      int not5 = -1,
      int grp = -1,
      bool allowsame = false,
      int tAreaGroup = -1)
    {
      int num1 = 0;
      int upperBound1 = this.AreaCenter.GetUpperBound(0);
      for (int index = 1; index <= upperBound1; ++index)
      {
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn() && tAreaGroup == -1 | tAreaGroup == this.AreaGroup[index] && this.AreaSteps[nr, index] < 4 | nr == index & allowsame && !(!allowsame & nr == index))
        {
          int num2 = 1;
          if (not1 == index | not2 == index | not3 == index | not4 == index | not5 == index)
            num2 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance[grp, index] >= 999)
              num2 = 0;
            if (nr == index)
              num2 = 1;
          }
          if (num2 == 1)
            ++num1;
        }
      }
      if (num1 <= 0)
        return 0;
      int num3 = (int) Math.Round((double) (Conversion.Int((float) num1 * VBMath.Rnd()) + 1f));
      int num4 = 0;
      int upperBound2 = this.AreaCenter.GetUpperBound(0);
      for (int randomFriendlyArea = 1; randomFriendlyArea <= upperBound2; ++randomFriendlyArea)
      {
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomFriendlyArea].x, this.AreaCenter[randomFriendlyArea].y].Regime) == this.GetGameDataTurn() && tAreaGroup == -1 | tAreaGroup == this.AreaGroup[randomFriendlyArea] && this.AreaSteps[nr, randomFriendlyArea] < 4 | nr == randomFriendlyArea & allowsame && !(!allowsame & nr == randomFriendlyArea))
        {
          int num5 = 1;
          if (not1 == randomFriendlyArea | not2 == randomFriendlyArea | not3 == randomFriendlyArea | not4 == randomFriendlyArea | not5 == randomFriendlyArea)
            num5 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance[grp, randomFriendlyArea] >= 999)
              num5 = 0;
            if (nr == randomFriendlyArea)
              num5 = 1;
          }
          if (num5 == 1)
          {
            ++num4;
            if (num4 == num3)
              return randomFriendlyArea;
          }
        }
      }
      return 0;
    }

    public void SetRandomAreaNeighbour_new(int tareagroup)
    {
      this.RandomAreaNeighbourCount = new int[this.AreaCount + 1];
      this.RandomAreaNeighbour = new int[this.AreaCount + 1, this.AreaCount + 1];
      int areaCount = this.AreaCount;
      for (int index1 = 1; index1 <= areaCount; ++index1)
      {
        this.RandomAreaNeighbourCount[index1] = -1;
        int num1 = this.AreaSupplyBorderCount[index1];
        for (int index2 = 0; index2 <= num1; ++index2)
        {
          int index3 = index2 != -1 ? this.AreaSupplyBorder[index1, index2] : index1;
          if (index3 > 0 && tareagroup == -1 | tareagroup == this.AreaGroup[index3] && !(this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime].Sleep & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index1].x, this.AreaCenter[index1].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime)))
          {
            int[] areaNeighbourCount = this.RandomAreaNeighbourCount;
            int[] numArray = areaNeighbourCount;
            int index4 = index1;
            int index5 = index4;
            int num2 = areaNeighbourCount[index4] + 1;
            numArray[index5] = num2;
            this.RandomAreaNeighbour[index1, this.RandomAreaNeighbourCount[index1]] = index3;
          }
        }
      }
    }

    public int GetRandomAreaNeighbourFromPreSet_new(
      int nr,
      int not1 = -1,
      int not2 = -1,
      int not3 = -1,
      int not4 = -1,
      int not5 = -1,
      int grp = -1,
      bool allowsame = false,
      int tAreaGroup = -1)
    {
      if (this.RandomAreaNeighbourCount[nr] <= -1)
        return 0;
      int num1 = (int) Math.Round((double) Conversion.Int((float) (this.RandomAreaNeighbourCount[nr] + 1) * VBMath.Rnd()));
      int num2 = 0;
      int num3 = this.RandomAreaNeighbourCount[nr];
      for (int index = 0; index <= num3; ++index)
      {
        int neighbourFromPreSetNew = this.RandomAreaNeighbour[nr, index];
        if (neighbourFromPreSetNew > 0)
        {
          int num4 = 1;
          if (not1 == neighbourFromPreSetNew | not2 == neighbourFromPreSetNew | not3 == neighbourFromPreSetNew | not4 == neighbourFromPreSetNew | not5 == neighbourFromPreSetNew)
            num4 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance[grp, neighbourFromPreSetNew] >= 999)
              num4 = 0;
            if (!this.CorpsEngineer[grp] && this.AreaBorderNoBridge[nr, neighbourFromPreSetNew] == 0)
              num4 = 0;
            if (nr == neighbourFromPreSetNew)
              num4 = 1;
          }
          if (num4 == 1)
          {
            ++num2;
            if (num2 == num1)
              return neighbourFromPreSetNew;
          }
        }
      }
      return 0;
    }

    public int GetRandomAreaNeighbour_broad(
      int nr,
      int not1 = -1,
      int not2 = -1,
      int not3 = -1,
      int not4 = -1,
      int not5 = -1,
      int grp = -1,
      bool allowsame = false,
      int tAreaGroup = -1)
    {
      int num1 = 0;
      int upperBound1 = this.AreaCenter.GetUpperBound(0);
      for (int index = 1; index <= upperBound1; ++index)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[index] && this.AreaBroadBorder[nr, index] > 0 & this.AreaBroadBorder[nr, index] < 99 | nr == index & allowsame && !(!allowsame & nr == index) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime)))
        {
          int num2 = 1;
          if (not1 == index | not2 == index | not3 == index | not4 == index | not5 == index)
            num2 = 0;
          if (num2 == 1)
            ++num1;
        }
      }
      if (num1 <= 0)
        return 0;
      int num3 = (int) Math.Round((double) (Conversion.Int((float) num1 * VBMath.Rnd()) + 1f));
      int num4 = 0;
      int upperBound2 = this.AreaCenter.GetUpperBound(0);
      for (int areaNeighbourBroad = 1; areaNeighbourBroad <= upperBound2; ++areaNeighbourBroad)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[areaNeighbourBroad] && this.AreaBroadBorder[nr, areaNeighbourBroad] > 0 & this.AreaBroadBorder[nr, areaNeighbourBroad] < 99 | nr == areaNeighbourBroad & allowsame && !(!allowsame & nr == areaNeighbourBroad) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[areaNeighbourBroad].x, this.AreaCenter[areaNeighbourBroad].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[areaNeighbourBroad].x, this.AreaCenter[areaNeighbourBroad].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[areaNeighbourBroad].x, this.AreaCenter[areaNeighbourBroad].y].Regime)))
        {
          int num5 = 1;
          if (not1 == areaNeighbourBroad | not2 == areaNeighbourBroad | not3 == areaNeighbourBroad | not4 == areaNeighbourBroad | not5 == areaNeighbourBroad)
            num5 = 0;
          if (num5 == 1)
          {
            ++num4;
            if (num4 == num3)
              return areaNeighbourBroad;
          }
        }
      }
      return 0;
    }

    public int GetRandomAreaNeighbour(
      int nr,
      int not1 = -1,
      int not2 = -1,
      int not3 = -1,
      int not4 = -1,
      int not5 = -1,
      int grp = -1,
      bool allowsame = false,
      int tAreaGroup = -1)
    {
      int num1 = 0;
      if (grp > -1 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.AreaOwner[nr]) && this.FriendlySupply[nr] == 0)
        return this.GetRandomAreaNeighbour_broad(nr, not1, not2, not3, not4, not5, grp, true, tAreaGroup);
      int upperBound1 = this.AreaCenter.GetUpperBound(0);
      for (int index = 1; index <= upperBound1; ++index)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[index] && this.AreaBorder[nr, index] > 0 & this.AreaBorder[nr, index] < 99 | nr == index & allowsame && !(!allowsame & nr == index) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime)))
        {
          int num2 = 1;
          if (not1 == index | not2 == index | not3 == index | not4 == index | not5 == index)
            num2 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance.GetUpperBound(0) >= grp && this.HisAreaDistance[grp, index] >= 999)
              num2 = 0;
            if (!this.CorpsEngineer[grp] && this.AreaBorderNoBridge[nr, index] == 0)
              num2 = 0;
            if (nr == index)
              num2 = 1;
          }
          if (num2 == 1)
            ++num1;
        }
      }
      if (num1 <= 0)
        return 0;
      int num3 = (int) Math.Round((double) (Conversion.Int((float) num1 * VBMath.Rnd()) + 1f));
      int num4 = 0;
      int upperBound2 = this.AreaCenter.GetUpperBound(0);
      for (int randomAreaNeighbour = 1; randomAreaNeighbour <= upperBound2; ++randomAreaNeighbour)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[randomAreaNeighbour] && this.AreaBorder[nr, randomAreaNeighbour] > 0 & this.AreaBorder[nr, randomAreaNeighbour] < 99 | nr == randomAreaNeighbour & allowsame && !(!allowsame & nr == randomAreaNeighbour) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomAreaNeighbour].x, this.AreaCenter[randomAreaNeighbour].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomAreaNeighbour].x, this.AreaCenter[randomAreaNeighbour].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomAreaNeighbour].x, this.AreaCenter[randomAreaNeighbour].y].Regime)))
        {
          int num5 = 1;
          if (not1 == randomAreaNeighbour | not2 == randomAreaNeighbour | not3 == randomAreaNeighbour | not4 == randomAreaNeighbour | not5 == randomAreaNeighbour)
            num5 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance.GetUpperBound(0) >= grp && this.HisAreaDistance[grp, randomAreaNeighbour] >= 999)
              num5 = 0;
            if (!this.CorpsEngineer[grp] && this.AreaBorderNoBridge[nr, randomAreaNeighbour] == 0)
              num5 = 0;
            if (nr == randomAreaNeighbour)
              num5 = 1;
          }
          if (num5 == 1)
          {
            ++num4;
            if (num4 == num3)
              return randomAreaNeighbour;
          }
        }
      }
      return 0;
    }

    public int GetAreaNeighbourCount(int nr)
    {
      int areaNeighbourCount = 0;
      int upperBound = this.AreaCenter.GetUpperBound(0);
      for (int index = 1; index <= upperBound; ++index)
      {
        if (this.AreaBorder[nr, index] > 0)
          ++areaNeighbourCount;
      }
      return areaNeighbourCount;
    }

    public int GetAreaEnemyNeighbourCount(int nr)
    {
      int enemyNeighbourCount = 0;
      int num = this.AreaSupplyBorderCount[nr];
      for (int index1 = 0; index1 <= num; ++index1)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index1]] > 0)
        {
          int index2 = this.AreaSupplyBorder[nr, index1];
          if (this.AreaOwner[nr] != this.AreaOwner[index2] & this.game.HandyFunctionsObj.IsHostileNotSelf2(this.AreaOwner[nr], this.AreaOwner[index2]))
          {
            if (!(this.GetGameDataTurn() != this.AreaOwner[nr] & this.GetGameDataTurn() != this.AreaOwner[index2]))
              ++enemyNeighbourCount;
            else
              enemyNeighbourCount = enemyNeighbourCount;
          }
        }
      }
      return enemyNeighbourCount;
    }

    public int GetAreaEnemyNeighbourCountFuzzyVP(int nr)
    {
      int neighbourCountFuzzyVp = 0;
      int num = this.AreaSupplyBorderCount[nr];
      for (int index1 = 0; index1 <= num; ++index1)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index1]] > 0)
        {
          int index2 = this.AreaSupplyBorder[nr, index1];
          if (this.game.HandyFunctionsObj.IsHostileNotSelf2(this.AreaOwner[nr], this.AreaOwner[index2]))
            neighbourCountFuzzyVp += this.AreaFuzzyVP[index2];
        }
      }
      return neighbourCountFuzzyVp;
    }

    public int GetAreaFriendlyNeighbourCount(int nr)
    {
      int friendlyNeighbourCount = 0;
      int num = this.AreaSupplyBorderCount[nr];
      for (int index = 0; index <= num; ++index)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index]] > 0 & this.GetGameDataTurn() == this.GetRegime(this.AreaOwner[this.AreaSupplyBorder[nr, index]]))
          ++friendlyNeighbourCount;
      }
      return friendlyNeighbourCount;
    }

    public int GetAreaFriendlyNeighbourCount2(int nr)
    {
      int friendlyNeighbourCount2 = 0;
      int num = this.AreaSupplyBorderCount[nr];
      for (int index = 0; index <= num; ++index)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index]] > 0 & this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[this.AreaSupplyBorder[nr, index]])))
          ++friendlyNeighbourCount2;
      }
      return friendlyNeighbourCount2;
    }

    public int GetAreaFriendlyNeighbourFuzzyVPCount(int nr)
    {
      int neighbourFuzzyVpCount = 0;
      int num = this.AreaSupplyBorderCount[nr];
      for (int index = 0; index <= num; ++index)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index]] > 0 & this.GetGameDataTurn() == this.GetRegime(this.AreaOwner[this.AreaSupplyBorder[nr, index]]))
          neighbourFuzzyVpCount += this.AreaFuzzyVP[index];
      }
      return neighbourFuzzyVpCount;
    }

    public bool IsAreaSupplySource(int i, int regnr)
    {
      int location = this.game.Data.MapObj[0].HexObj[this.AreaCenter[i].x, this.AreaCenter[i].y].Location;
      return this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[i].x, this.AreaCenter[i].y].Regime) == this.GetRegime(regnr) && location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].MaxProd > 0;
    }

    public int GetScoreForReconquestOfImportance()
    {
      int reconquestOfImportance = 0;
      if ((double) this.game.Data.RuleVar[335] > 0.0)
      {
        int num = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num * 4)))] > 0)
          {
            int regime = this.game.Data.MapObj[0].HexObj[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))]].Regime;
            int nr = this.TempCounterOwner[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))]];
            if (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(regime), this.GetGameDataTurn()) && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(nr), this.GetGameDataTurn()))
              reconquestOfImportance += 2000;
            if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(regime), this.GetGameDataTurn()) && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(nr), this.GetGameDataTurn()))
              reconquestOfImportance -= 2000;
          }
          ++num;
        }
        while (num <= 3);
      }
      return reconquestOfImportance;
    }

    public void MakeSupplyCounterOwnerMatrix()
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyCounterMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.SupplyCounterMatrix[index1, index2] = 9999;
          numArray1[index1, index2] = 0;
        }
      }
      if ((double) this.game.Data.RuleVar[335] <= 0.0)
        return;
      int num = 0;
      do
      {
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num * 4)))] > 0)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))], 0, DontCountEnemyRoads: true, UseCounterOwner: true);
          int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
          for (int index3 = 0; index3 <= mapWidth2; ++index3)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int index4 = 0; index4 <= mapHeight; ++index4)
            {
              if (this.SupplyCounterMatrix[index3, index4] > this.game.EditObj.TempValue[0].Value[index3, index4])
                this.SupplyCounterMatrix[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
            }
          }
        }
        ++num;
      }
      while (num <= 3);
    }

    public void MakeSupplyTempOwnerMatrix()
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyTempOwnerMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.SupplyCounterMatrix[index1, index2] = 9999;
          numArray1[index1, index2] = 0;
        }
      }
      if ((double) this.game.Data.RuleVar[335] <= 0.0)
        return;
      int num = 0;
      do
      {
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 3f + (float) (num * 4)))] > 0)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(), (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 0.0f + (float) (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[(int) Math.Round((double) (this.game.Data.RuleVar[335] + 1f + (float) (num * 4)))], 0, DontCountEnemyRoads: true, UseCounterOwner: true, UseTempOwner: true);
          int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
          for (int index3 = 0; index3 <= mapWidth2; ++index3)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int index4 = 0; index4 <= mapHeight; ++index4)
            {
              if (this.SupplyTempOwnerMatrix[index3, index4] > this.game.EditObj.TempValue[0].Value[index3, index4])
                this.SupplyTempOwnerMatrix[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
            }
          }
        }
        ++num;
      }
      while (num <= 3);
    }

    public Coordinate GetDefindedAreaCapitol(int areanr)
    {
      SimpleList simpleList = new SimpleList();
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int tdata1 = 0; tdata1 <= mapWidth; ++tdata1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int tdata2 = 0; tdata2 <= mapHeight; ++tdata2)
        {
          if (this.game.Data.AreaObj[areanr].Code == this.game.Data.MapObj[0].HexObj[tdata1, tdata2].AreaCode[this.game.Data.AreaObj[areanr].Slot])
          {
            int tweight = 0;
            int tid;
            ++tid;
            if (this.game.Data.MapObj[0].HexObj[tdata1, tdata2].Location > -1)
              tweight = 10;
            if (this.game.Data.MapObj[0].HexObj[tdata1, tdata2].VP > 0)
              tweight += this.game.Data.MapObj[0].HexObj[tdata1, tdata2].VP * 10;
            simpleList.Add(tid, tweight, tdata1, tdata2);
          }
        }
      }
      simpleList.Sort();
      Coordinate defindedAreaCapitol;
      defindedAreaCapitol.onmap = false;
      if (simpleList.Counter > -1)
      {
        defindedAreaCapitol.onmap = true;
        defindedAreaCapitol.x = simpleList.Data1[0];
        defindedAreaCapitol.y = simpleList.Data2[0];
      }
      return defindedAreaCapitol;
    }

    public void MakeAdvanceAxisMatrix()
    {
      this.AdvanceAxisMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.FullAdvanceMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.ptemp = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.ptemp2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      Coordinate coordinate1;
      coordinate1.x = -1;
      Coordinate coordinate2;
      coordinate2.x = -1;
      int groupHq = this.GetGroupHQ(this.OpGroup);
      Coordinate coordinate3;
      coordinate3.onmap = false;
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.AdvanceAxisMatrix[index1, index2] = -1;
          this.FullAdvanceMatrix[index1, index2] = 0;
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIDefend > this.AreaCount || this.game.Data.UnitObj[groupHq].AIFallback > this.AreaCount || this.game.Data.UnitObj[groupHq].AIAttack > this.AreaCount || this.game.Data.UnitObj[groupHq].AIFollowup > this.AreaCount)
        return;
      Coordinate coordinate4;
      if (this.game.Data.UnitObj[groupHq].AIFallback > -1 & this.game.Data.UnitObj[groupHq].AIDefend > -1)
      {
        coordinate1 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback];
        coordinate2 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
        if (coordinate1.onmap & coordinate2.onmap)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
          coordinate4 = coordinate2;
          coordinate3 = coordinate2;
          this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
          for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIDefend > -1 & this.game.Data.UnitObj[groupHq].AIAttack > -1)
      {
        coordinate1 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
        coordinate2 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack];
        if (coordinate1.onmap & coordinate2.onmap)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
          coordinate4 = coordinate2;
          coordinate3 = coordinate2;
          this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
          for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & this.game.Data.UnitObj[groupHq].AIFollowup > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].y].Regime != -1)
      {
        coordinate1 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack];
        coordinate2 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFollowup];
        if (coordinate1.onmap & coordinate2.onmap)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
          coordinate4 = coordinate2;
          coordinate3 = coordinate2;
          this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
          for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
        }
      }
      int num1;
      if (coordinate1.x > -1 & coordinate2.x > -1)
      {
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), coordinate2.x, coordinate2.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate1.x, TarY: coordinate1.y, TarMap: 0);
        coordinate4 = coordinate1;
        this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
        int num2;
        num1 = num2 + 1;
        for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate2.x & coordinate4.y == coordinate2.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
        {
          this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
          ++num1;
        }
        if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & this.game.Data.UnitObj[groupHq].AIFollowup > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].y].Regime != -1)
        {
          coordinate4.x = -1;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
            coordinate4 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
          else if (this.CorpsLoc[this.OpGroup] > -1)
            coordinate4 = this.AreaCenter[this.CorpsLoc[this.OpGroup]];
          if (coordinate4.x > -1)
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate4.x, TarY: coordinate4.y, TarMap: 0);
            this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
            ++num1;
            for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            {
              this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
              ++num1;
            }
          }
        }
      }
      if (coordinate1.x > -1 & coordinate2.x > -1)
      {
        int num3 = num1 + 3;
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
        coordinate4 = coordinate2;
        this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num3;
        int num4 = num3 - 1;
        for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
        {
          this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num4;
          --num4;
        }
        if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & this.game.Data.UnitObj[groupHq].AIFollowup > -1)
        {
          coordinate4.x = -1;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
            coordinate4 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
          else if (this.CorpsLoc[this.OpGroup] > -1)
            coordinate4 = this.AreaCenter[this.CorpsLoc[this.OpGroup]];
          if (coordinate4.x > -1)
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[99]), 99, (int) Math.Round((double) this.game.Data.RuleVar[3]), coordinate4.x, coordinate4.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate1.x, TarY: coordinate1.y, TarMap: 0);
            Coordinate coordinate5 = coordinate4;
            coordinate4 = coordinate1;
            this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num4;
            int num5 = num4 - 1;
            for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate5.x == coordinate4.x & coordinate5.y == coordinate4.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            {
              this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num5;
              --num5;
            }
          }
        }
      }
      int num6 = 1;
      int[,] numArray = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      while (num6 == 1)
      {
        num6 = 0;
        int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth2; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray[cx, cy] == 0 && this.FullAdvanceMatrix[cx, cy] > 0)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray[coordinate1.x, coordinate1.y] == 0 & this.FullAdvanceMatrix[coordinate1.x, coordinate1.y] <= 0 && (int) Math.Round((double) this.FullAdvanceMatrix[cx, cy] * 0.75) > this.FullAdvanceMatrix[coordinate1.x, coordinate1.y])
                {
                  this.FullAdvanceMatrix[coordinate1.x, coordinate1.y] = (int) Math.Round((double) this.FullAdvanceMatrix[cx, cy] * 0.75);
                  num6 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
              numArray[cx, cy] = 1;
            }
          }
        }
      }
      int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
      for (int index3 = 0; index3 <= mapWidth3; ++index3)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index4 = 0; index4 <= mapHeight; ++index4)
        {
          this.ptemp[index3, index4] = 0;
          if (this.AdvanceAxisMatrix[index3, index4] > -1)
          {
            if ((double) this.SupplyMatrixReal[index3, index4] < (double) this.game.Data.RuleVar[53])
            {
              this.ptemp[index3, index4] = 1;
              this.ptemp2[index3, index4] = 1;
            }
            else
            {
              this.AdvanceAxisMatrix[index3, index4] = -1;
              this.ptemp2[index3, index4] = 1;
            }
          }
        }
      }
      int num7 = 0;
      int num8;
      do
      {
        num8 = 0;
        ++num7;
        int mapWidth4 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth4; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (this.ptemp[cx, cy] == num7)
            {
              int tfacing = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap & this.ptemp[coordinate1.x, coordinate1.y] == 0 & this.ptemp2[coordinate1.x, coordinate1.y] == 1)
                {
                  this.ptemp[coordinate1.x, coordinate1.y] = num7 + 1;
                  this.AdvanceAxisMatrix[cx, cy] = num7;
                  num8 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num8 == 1 & num7 < 4);
    }

    public void AddVirtualUnits(int area, int power, bool tlog)
    {
      int[,] numArray = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
          numArray[index1, index2] = -1;
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("VIRTUAL UNITS:");
      Coordinate coordinate;
      if (this.AreaCounterDirections[area, 1] == 0)
      {
        int num1 = -1;
        int regimeCounter = this.game.Data.RegimeCounter;
        for (int reg2 = 0; reg2 <= regimeCounter; ++reg2)
        {
          if (!this.game.Data.RegimeObj[reg2].Sleep & !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetGameDataTurn(), reg2))
          {
            int num2;
            num1 = num2;
            break;
          }
        }
        if (num1 > -1)
        {
          int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
          for (int cx = 0; cx <= mapWidth2; ++cx)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int cy = 0; cy <= mapHeight; ++cy)
            {
              if (this.AreaMatrixNarrow[cx, cy] == area & this.game.Data.MapObj[0].HexObj[cx, cy].Location > -1)
              {
                int tfacing = 1;
                do
                {
                  coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                  if (coordinate.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                  {
                    numArray[coordinate.x, coordinate.y] = num1;
                    break;
                  }
                  ++tfacing;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      else
      {
        int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth3; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (this.AreaMatrixNarrow[cx, cy] == area)
            {
              int tfacing = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap)
                {
                  int num3 = 0;
                  int num4 = this.AreaMatrixNarrow[coordinate.x, coordinate.y];
                  int index = 1;
                  while (this.AreaCounterDirections[area, index] != num4)
                  {
                    ++index;
                    if (index > 9)
                      goto label_38;
                  }
                  num3 = 1;
                  int num5 = this.AreaCounterRegime[area, index];
label_38:
                  if (num3 == 1)
                    numArray[coordinate.x, coordinate.y] = num5;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      CoordList coordList = new CoordList();
      int mapWidth4 = this.game.Data.MapObj[0].MapWidth;
      for (int x = 0; x <= mapWidth4; ++x)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int y = 0; y <= mapHeight; ++y)
        {
          if (numArray[x, y] > -1)
            coordList.AddCoord(x, y, 0);
        }
      }
      int num = 0;
      if (coordList.counter <= -1)
        return;
      while (num < 50 & power > 0 & num <= this.MoveMatrixCounter * 3)
      {
        ++num;
        int index3 = (int) Math.Round((double) ((float) coordList.counter * VBMath.Rnd()));
        coordinate = coordList.coord[index3];
        if (coordinate.onmap)
        {
          int randomUnit = this.GetRandomUnit(numArray[coordinate.x, coordinate.y]);
          if (randomUnit > -1)
          {
            this.game.Data.AddUnit(coordinate.x, coordinate.y, 0);
            this.game.HandyFunctionsObj.CopyUnit(this.game.Data.UnitCounter, randomUnit);
            this.game.Data.UnitObj[this.game.Data.UnitCounter].IsVirtual = true;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Regime = numArray[coordinate.x, coordinate.y];
            this.game.Data.UnitObj[this.game.Data.UnitCounter].X = coordinate.x;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Y = coordinate.y;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].TempType = this.game.Data.UnitObj[this.game.Data.UnitCounter].TempType;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].TempCategory = this.game.Data.UnitObj[this.game.Data.UnitCounter].TempCategory;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].TempTypeRoad = this.game.Data.UnitObj[this.game.Data.UnitCounter].TempTypeRoad;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Map = 0;
            power -= this.game.HandyFunctionsObj.GetPowerPtsAbsolute(randomUnit);
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Name = "VIRTUAL " + this.game.Data.UnitObj[this.game.Data.UnitCounter].Name;
            if (tlog)
              this.AddLog("Copy of " + this.game.Data.UnitObj[randomUnit].Name + " added on " + coordinate.x.ToString() + "," + coordinate.y.ToString());
            this.MakeTempMovementType(this.game.Data.UnitCounter);
            int sfCount = this.game.Data.UnitObj[this.game.Data.UnitCounter].SFCount;
            for (int index4 = 0; index4 <= sfCount; ++index4)
            {
              int sf = this.game.Data.UnitObj[this.game.Data.UnitCounter].SFList[index4];
              this.game.Data.SFObj[sf].Rdn = 100;
              this.game.Data.SFObj[sf].Ap = 100;
            }
          }
        }
      }
    }

    public void removevirtualUnits()
    {
      for (int unitCounter = this.game.Data.UnitCounter; unitCounter >= 0; unitCounter += -1)
      {
        if (this.game.Data.UnitObj[unitCounter].IsVirtual)
        {
          DataClass data = this.game.Data;
          int nr = unitCounter;
          GameClass gameClass = (GameClass) null;
          ref GameClass local = ref gameClass;
          data.RemoveUnit(nr, ref local);
        }
      }
    }

    public int GetRandomUnit(int regnr)
    {
      int num;
      for (; num < 100; ++num)
      {
        int unr = (int) Math.Round((double) (VBMath.Rnd() * (float) this.game.Data.UnitCounter));
        if (this.game.Data.UnitObj[unr].Regime == regnr & !this.game.Data.UnitObj[unr].IsHQ & this.game.Data.UnitObj[unr].PreDef == -1 & !this.game.Data.UnitObj[unr].IsVirtual && !this.game.HandyFunctionsObj.HasUnitAirSF(unr) & !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
          return unr;
      }
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].Regime == regnr & !this.game.Data.UnitObj[unr].IsHQ && !this.game.HandyFunctionsObj.HasUnitAirSF(unr) & !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.Data.UnitObj[unr].PreDef > -1 & this.game.Data.UnitObj[unr].Regime == regnr)
          return unr;
      }
      return -1;
    }

    public bool MaybeeExecuteAttackMarkers()
    {
      bool flag = false;
      int counter1 = this.AirMarkerList.Counter;
      Coordinate Target;
      for (int index1 = 0; index1 <= counter1; ++index1)
      {
        if (this.AirMarkerList.Weight[index1] == 1 & this.AirMarkerList.Data3[index1] > -1)
        {
          int scoreForAirAttack = this.GetScoreForAirAttack(this.AirMarkerList.Data3[index1], this.AirMarkerList.Data4[index1], false, true);
          if (scoreForAirAttack > 0)
          {
            this.game.TempCombat = new CombatClass(this.game);
            Target.x = this.AirMarkerList.Data3[index1];
            Target.y = this.AirMarkerList.Data4[index1];
            this.game.EditObj.TempUnitList = new UnitList();
            this.JoinUnitsAirAttack(Target.x, Target.y, ref this.game.EditObj.TempUnitList);
            this.AddLog("AIR ATTACK ON " + Conversion.Str((object) Target.x) + "," + Conversion.Str((object) Target.y) + " with points score = " + Conversion.Str((object) scoreForAirAttack));
            string s = "PARTICIPANTS: ";
            int counter2 = this.game.EditObj.TempUnitList.counter;
            for (int index2 = 0; index2 <= counter2; ++index2)
            {
              if (index2 > 0)
                s += ", ";
              s += this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index2]].Name;
            }
            this.AddLog(s);
            this.game.TempCombat.Init(Target, 1, this.game.EditObj.TempUnitList, 14);
            this.game.TempCombat.DoBattle();
            this.game.TempCombat.EndBattle();
            flag = true;
            this.game.TempCombat = (CombatClass) null;
            this.MakeTempMovementTypes(false);
            int num = index1;
            int counter3 = this.AirMarkerList.Counter;
            for (int index3 = num; index3 <= counter3; ++index3)
            {
              if (this.AirMarkerList.Data3[index3] == this.AirMarkerList.Data3[index1] & this.AirMarkerList.Data4[index3] == this.AirMarkerList.Data4[index1])
                this.AirMarkerList.Weight[index3] = 0;
            }
          }
        }
      }
      int counter4 = this.ArtMarkerList.Counter;
      for (int index4 = 0; index4 <= counter4; ++index4)
      {
        if (this.ArtMarkerList.Weight[index4] == 1)
        {
          int scoreForArtAttack = this.GetScoreForArtAttack(this.ArtMarkerList.Data3[index4], this.ArtMarkerList.Data4[index4], false, true);
          if (scoreForArtAttack > 0)
          {
            this.game.TempCombat = new CombatClass(this.game);
            Target.x = this.ArtMarkerList.Data3[index4];
            Target.y = this.ArtMarkerList.Data4[index4];
            this.game.EditObj.TempUnitList = new UnitList();
            this.JoinUnitsArtilleryAttack(Target.x, Target.y, ref this.game.EditObj.TempUnitList);
            this.AddLog("ARTILLERY ATTACK ON " + Conversion.Str((object) Target.x) + "," + Conversion.Str((object) Target.y) + " with points score = " + Conversion.Str((object) scoreForArtAttack));
            string s = "PARTICIPANTS: ";
            int counter5 = this.game.EditObj.TempUnitList.counter;
            for (int index5 = 0; index5 <= counter5; ++index5)
            {
              if (index5 > 0)
                s += ", ";
              s += this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index5]].Name;
            }
            this.AddLog(s);
            this.game.TempCombat.Init(Target, 1, this.game.EditObj.TempUnitList, 11);
            this.game.TempCombat.DoBattle();
            this.game.TempCombat.EndBattle();
            flag = true;
            this.game.TempCombat = (CombatClass) null;
            this.MakeTempMovementTypes(false);
            int num = index4;
            int counter6 = this.ArtMarkerList.Counter;
            for (int index6 = num; index6 <= counter6; ++index6)
            {
              if (this.ArtMarkerList.Data3[index6] == this.ArtMarkerList.Data3[index4] & this.ArtMarkerList.Data4[index6] == this.ArtMarkerList.Data4[index4])
                this.ArtMarkerList.Weight[index6] = 0;
            }
          }
        }
      }
      int counter7 = this.MarkerList.Counter;
      for (int index7 = 0; index7 <= counter7; ++index7)
      {
        if (this.MarkerList.Weight[index7] == 1)
        {
          this.AddLog("CHECK");
          int scoreForAttack = this.GetScoreForAttack(this.MarkerList.Data3[index7], this.MarkerList.Data4[index7], false, true);
          if (scoreForAttack > 0)
          {
            this.AddLog("REAL TRY");
            int num1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
            int groupHq = this.GetGroupHQ(this.OpGroup);
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
              num1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
              num1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
            if (Operators.CompareString(this.game.Data.UnitObj[groupHq].Name, "X Corps", false) == 0)
              ;
            if (this.Attacker)
            {
              if ((double) this.CorpsTopRatio[this.OpGroup] > 1.0)
                num1 = (int) Math.Round((double) num1 / Math.Sqrt((double) Math.Min(9f, this.CorpsTopRatio[this.OpGroup])));
              num1 = (int) Math.Round((double) num1 * 0.9);
            }
            if (scoreForAttack >= num1)
            {
              this.game.TempCombat = new CombatClass(this.game);
              Target.x = this.MarkerList.Data3[index7];
              Target.y = this.MarkerList.Data4[index7];
              this.game.EditObj.OrderType = 2;
              this.game.EditObj.TempUnitList = new UnitList();
              this.JoinUnitsInLandAttack(Target.x, Target.y, ref this.game.EditObj.TempUnitList);
              if (this.game.EditObj.TempUnitList.counter > -1)
              {
                this.AddLog("ATTACK ON " + Conversion.Str((object) Target.x) + "," + Conversion.Str((object) Target.y) + " with points score = " + Conversion.Str((object) scoreForAttack));
                string s = "PARTICIPANTS: ";
                int counter8 = this.game.EditObj.TempUnitList.counter;
                for (int index8 = 0; index8 <= counter8; ++index8)
                {
                  if (index8 > 0)
                    s += ", ";
                  s += this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index8]].Name;
                }
                this.AddLog(s);
                this.game.TempCombat.Init(Target, 1, this.game.EditObj.TempUnitList, 2);
                this.game.TempCombat.DoBattle();
                this.game.TempCombat.EndBattle();
                flag = true;
                this.game.TempCombat = (CombatClass) null;
                this.MakeTempMovementTypes(false);
                int num2 = index7;
                int counter9 = this.MarkerList.Counter;
                for (int index9 = num2; index9 <= counter9; ++index9)
                {
                  if (this.MarkerList.Data3[index9] == this.MarkerList.Data3[index7] & this.MarkerList.Data4[index9] == this.MarkerList.Data4[index7])
                    this.MarkerList.Weight[index9] = 0;
                }
              }
            }
          }
        }
      }
      return flag;
    }

    public void ExecuteBestMove(ref SimpleList TempMove, bool IsSimulation)
    {
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter1; ++index)
      {
        this.game.Data.UnitObj[index].TempX = -1;
        this.game.Data.UnitObj[index].TempY = -1;
      }
      int counter1 = TempMove.Counter;
      for (int index1 = 0; index1 <= counter1; ++index1)
      {
        if (TempMove.Weight[index1] >= 1)
        {
          int unitslot = TempMove.Data1[index1];
          if (unitslot > -1)
          {
            int unr = this.MoveMatrixUnit[unitslot];
            int num1 = 0;
            do
            {
              int num2 = 0;
              if (num1 == 0 & this.game.Data.UnitObj[unr].IsHQ)
                num2 = 1;
              if (num1 == 1 & this.game.Data.UnitObj[unr].TempCategory == 3)
                num2 = 1;
              if (num1 == 1 & this.game.Data.UnitObj[unr].TempCategory == 2)
                num2 = 1;
              if (num1 == 1 & this.game.Data.UnitObj[unr].TempCategory == 5)
                num2 = 1;
              if (num1 == 2 & this.game.Data.UnitObj[unr].TempCategory == 1)
                num2 = 1;
              if (num1 == 2 & this.game.Data.UnitObj[unr].TempCategory == 4)
                num2 = 1;
              if (num1 == 2 & this.game.Data.UnitObj[unr].TempCategory <= 0)
                num2 = 1;
              if (num1 > 0 & this.game.Data.UnitObj[unr].IsHQ)
                num2 = 0;
              if (num2 == 1)
              {
                int x1 = this.game.Data.UnitObj[unr].X;
                int y1 = this.game.Data.UnitObj[unr].Y;
                int x2 = TempMove.Data3[index1];
                int y2 = TempMove.Data4[index1];
                if (this.game.Data.UnitObj[unr].TempStrategic && this.game.Data.UnitObj[unr].TempCategory != 3 && !this.game.Data.UnitObj[unr].IsHQ && this.CanBeStrategiclyTransferred(unr))
                {
                  Coordinate closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 4, unitslot);
                  if (closeFriendlyRoadHex.onmap)
                  {
                    x2 = closeFriendlyRoadHex.x;
                    y2 = closeFriendlyRoadHex.y;
                  }
                }
                if (this.game.Data.UnitObj[unr].IsHQ)
                  unr = unr;
                if (this.game.Data.UnitObj[unr].TempCategory == 3)
                {
                  int index2 = this.AirMarkerList.Data1[TempMove.Data2[index1]];
                  int index3 = this.AirMarkerList.Data2[TempMove.Data2[index1]];
                  if (!(x1 == index2 & y1 == index3))
                  {
                    this.game.HandyFunctionsObj.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, ismove: true);
                    if (this.game.EditObj.TempValue[0].Value[index2, index3] < 9999)
                    {
                      this.AddLog("AIR MOVING " + this.game.Data.UnitObj[unr].Name + " TO <" + Conversion.Str((object) index2) + "," + Conversion.Str((object) index3) + ">");
                      this.game.ProcessingObj.ExecuteMovement(unr, x1, y1, 0, index2, index3, 0);
                    }
                  }
                }
                else
                {
                  int num3 = 0;
                  if (this.MoveMatrix[unitslot, x2, y2] < 9999)
                  {
                    this.game.HandyFunctionsObj.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, ismove: true);
                    if (!(x1 == x2 & y1 == y2))
                    {
                      while (!this.game.EditObj.TempCameFrom[0].Value[x2, y2].onmap & !(x1 == x2 & y1 == y2))
                      {
                        ++num3;
                        sCoordinate sCoordinate = this.MoveMatrixCameFrom[unitslot, x2, y2];
                        Coordinate coordinate;
                        coordinate.x = (int) sCoordinate.x;
                        coordinate.y = (int) sCoordinate.y;
                        coordinate.onmap = sCoordinate.onmap;
                        if (!(x2 == 0 & y2 == 0 & coordinate.x == 0 & coordinate.y == 0))
                        {
                          x2 = coordinate.x;
                          y2 = coordinate.y;
                          if (num3 > 199)
                            break;
                        }
                        else
                          break;
                      }
                      if (!(x1 == x2 & y1 == y2))
                      {
                        if (this.game.EditObj.TempValue[0].Value[x2, y2] < 9999)
                        {
                          this.AddLog("MOVING " + this.game.Data.UnitObj[unr].Name + " TO <" + Conversion.Str((object) x2) + "," + Conversion.Str((object) y2) + ">");
                          this.game.ProcessingObj.ExecuteMovement(unr, x1, y1, 0, x2, y2, 0);
                          if (this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter <= 15)
                            ;
                        }
                        if (this.game.Data.UnitObj[unr].X == x2 & this.game.Data.UnitObj[unr].Y == y2 && this.game.Data.UnitObj[unr].TempCategory == 4 & this.EngineerMarkerList.Counter > -1)
                        {
                          this.game.HandyFunctionsObj.InfraHexHighlight(x2, y2, 0, unr);
                          int index4 = this.EngineerMarkerList.Data3[TempMove.Data2[index1]];
                          int index5 = this.EngineerMarkerList.Data4[TempMove.Data2[index1]];
                          if (index4 > -1)
                          {
                            int facing = this.game.HandyFunctionsObj.HexFacing(x2, y2, 0, index4, index5, 0) - 1;
                            if (this.game.EditObj.TempValue[0].Value[index4, index5] == 0 & facing >= 0)
                            {
                              this.game.ProcessingObj.BuildInfra(unr, x2, y2, 0, facing);
                              this.AddLog("ENGINEER " + this.game.Data.UnitObj[unr].Name + " BUILD BRIDGE FROM <" + Conversion.Str((object) x2) + "," + Conversion.Str((object) y2) + "> to <" + Conversion.Str((object) index4) + "," + Conversion.Str((object) index5));
                            }
                          }
                        }
                      }
                    }
                  }
                  else
                    this.AddLog(this.game.Data.UnitObj[unr].Name + " DID NOT MOVE. Because move prognosis thinks it can never reach that point. ");
                }
              }
              ++num1;
            }
            while (num1 <= 2);
          }
        }
      }
      if (this.Attacker)
        return;
      int unitCounter2 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter2; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].AIGroup == this.OpGroup && this.game.Data.UnitObj[unr].AIAttackStyle == 1 & (this.game.Data.UnitObj[unr].TempCategory == 1 | this.game.Data.UnitObj[unr].TempCategory == 4))
        {
          int index6 = this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
          if (index6 > 0 & this.game.Data.UnitObj[unr].AIAttack == -1 && this.AreaBridges[index6].Counter > -1)
          {
            int counter2 = this.AreaBridges[index6].Counter;
            for (int index7 = 0; index7 <= counter2; ++index7)
            {
              int index8 = this.AreaBridges[index6].Id[index7];
              if (index8 > 0 && this.AreaBridges[index6].Data1[index7] == this.game.Data.UnitObj[unr].X & this.AreaBridges[index6].Data2[index7] == this.game.Data.UnitObj[unr].Y | this.AreaBridges[index6].Data3[index7] == this.game.Data.UnitObj[unr].X & this.AreaBridges[index6].Data4[index7] == this.game.Data.UnitObj[unr].Y && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index8].x, this.AreaCenter[index8].y].Regime)))
              {
                this.game.EditObj.OrderX = this.game.Data.UnitObj[unr].X;
                this.game.EditObj.OrderY = this.game.Data.UnitObj[unr].Y;
                int num4;
                int num5;
                if (this.AreaBridges[index6].Data1[index7] == this.game.Data.UnitObj[unr].X & this.AreaBridges[index6].Data2[index7] == this.game.Data.UnitObj[unr].Y)
                {
                  num4 = this.AreaBridges[index6].Data3[index7];
                  num5 = this.AreaBridges[index6].Data4[index7];
                }
                else
                {
                  num4 = this.AreaBridges[index6].Data1[index7];
                  num5 = this.AreaBridges[index6].Data2[index7];
                }
                int facing = this.game.HandyFunctionsObj.HexFacing(this.game.EditObj.OrderX, this.game.EditObj.OrderY, 0, num4, num5, 0) - 1;
                if (facing >= 0 && this.game.Data.MapObj[0].HexObj[this.game.EditObj.OrderX, this.game.EditObj.OrderY].Bridge[facing] && (double) this.game.Data.RuleVar[505] == 0.0 & (double) this.game.Data.RuleVar[809] == 0.0)
                {
                  this.AddLog("BLOW BRIDGE ATTEMPT TOWARDS " + Conversion.Str((object) num4) + "," + Conversion.Str((object) num5));
                  this.game.ProcessingObj.BlowBridge(unr, this.game.EditObj.OrderX, this.game.EditObj.OrderY, 0, facing);
                }
                this.game.EditObj.OrderX = -1;
                this.game.EditObj.OrderY = -1;
              }
            }
          }
        }
      }
    }

    public int GetSameCoordinateMarker(int unr, SimpleList tlist)
    {
      int counter = tlist.Counter;
      for (int coordinateMarker = 0; coordinateMarker <= counter; ++coordinateMarker)
      {
        if ((tlist.Weight[coordinateMarker] == 5 | tlist.Data3[coordinateMarker] == -1) & tlist.Data1[coordinateMarker] == this.game.Data.UnitObj[unr].X & tlist.Data2[coordinateMarker] == this.game.Data.UnitObj[unr].Y || tlist.Data1[coordinateMarker] == this.game.Data.UnitObj[unr].X & tlist.Data2[coordinateMarker] == this.game.Data.UnitObj[unr].Y)
          return coordinateMarker;
      }
      return -1;
    }

    public SimpleList GetRandomAttackMarkers(
      int movematrixnr,
      SimpleList tlist,
      int AverageSupplyPercentage)
    {
      int num1 = this.MoveMatrixUnit[movematrixnr];
      SimpleList randomAttackMarkers1 = new SimpleList();
      SimpleList randomAttackMarkers2 = new SimpleList();
      if (num1 == -1)
        return randomAttackMarkers1;
      int counter = tlist.Counter;
      for (int tid = 0; tid <= counter; ++tid)
      {
        if (tlist.Weight[tid] == 1 & tlist.Data3[tid] > -1)
        {
          if (AverageSupplyPercentage < 20 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 1)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 20 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 2)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 20 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 3)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 35 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 1)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 35 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 2)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 50 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 1)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 35)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 20)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 5)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
        }
      }
      if (randomAttackMarkers1.Counter > -1)
      {
        randomAttackMarkers1.Sort();
        int index1 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (Math.Min(10, randomAttackMarkers1.Counter) + 1)));
        int num2 = Math.Min(10, randomAttackMarkers1.Counter);
        for (int index2 = 0; index2 <= num2; ++index2)
        {
          if (randomAttackMarkers1.Data3[index2] == randomAttackMarkers1.Data3[index1] & randomAttackMarkers1.Data4[index2] == randomAttackMarkers1.Data4[index1])
            randomAttackMarkers2.Add(randomAttackMarkers1.Id[index2], 1);
        }
      }
      return randomAttackMarkers2;
    }

    public SimpleList GetRandomBottleneckMarkers(int movematrixnr, SimpleList tlist)
    {
      int num = this.MoveMatrixUnit[movematrixnr];
      SimpleList bottleneckMarkers = new SimpleList();
      SimpleList simpleList = new SimpleList();
      if (num == -1)
        return bottleneckMarkers;
      int counter = tlist.Counter;
      for (int tid = 0; tid <= counter; ++tid)
      {
        if ((double) this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 5.0 + (double) VBMath.Rnd() * 20.0)
          bottleneckMarkers.Add(tid, (int) Math.Round((double) this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]] / (double) this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]]), tlist.Data1[tid], tlist.Data2[tid], tlist.Data1[tid], tlist.Data2[tid]);
      }
      bottleneckMarkers.Sort();
      return bottleneckMarkers;
    }

    public int ReturnShockAndAweMarker(SimpleList tMarkerlist, float trnd, int UnitSlot, int unr)
    {
      int num1 = 0;
      int counter1 = this.MarkerList.Counter;
      for (int index1 = 0; index1 <= counter1; ++index1)
      {
        if (this.MarkerList.Weight[index1] == 1)
        {
          int num2 = 0;
          int num3 = 0;
          int counter2 = this.ArtMarkerList.Counter;
          for (int index2 = 0; index2 <= counter2; ++index2)
          {
            if (this.ArtMarkerList.Weight[index2] == 1 & this.ArtMarkerList.Data3[index2] == this.MarkerList.Data3[index1] & this.ArtMarkerList.Data4[index2] == this.MarkerList.Data4[index1])
              num2 = 1;
          }
          if (this.ArtMarkerList.Counter < 1)
            num2 = 1;
          int counter3 = this.AirMarkerList.Counter;
          for (int index3 = 0; index3 <= counter3; ++index3)
          {
            if (this.AirMarkerList.Weight[index3] == 1 & this.AirMarkerList.Data3[index3] == this.MarkerList.Data3[index1] & this.AirMarkerList.Data4[index3] == this.MarkerList.Data4[index1])
              num3 = 1;
          }
          if (this.AirMarkerList.Counter < 1)
            num3 = 1;
          if (num2 == 1 & num3 == 1)
            ++num1;
        }
      }
      if (num1 == 0)
        return -1;
      int counter4 = this.MarkerList.Counter;
      for (int index4 = 0; index4 <= counter4; ++index4)
      {
        if (this.MarkerList.Weight[index4] == 1)
        {
          int num4 = 0;
          int num5 = 0;
          int counter5 = this.ArtMarkerList.Counter;
          for (int index5 = 0; index5 <= counter5; ++index5)
          {
            if (this.ArtMarkerList.Weight[index5] == 1 & this.ArtMarkerList.Data3[index5] == this.MarkerList.Data3[index4] & this.ArtMarkerList.Data4[index5] == this.MarkerList.Data4[index4])
              num4 = 1;
          }
          if (this.ArtMarkerList.Counter < 1)
            num4 = 1;
          int counter6 = this.AirMarkerList.Counter;
          for (int index6 = 0; index6 <= counter6; ++index6)
          {
            if (this.AirMarkerList.Weight[index6] == 1 & this.AirMarkerList.Data3[index6] == this.MarkerList.Data3[index4] & this.AirMarkerList.Data4[index6] == this.MarkerList.Data4[index4])
              num5 = 1;
          }
          if (this.AirMarkerList.Counter < 1)
            num5 = 1;
          if (num4 == 1 & num5 == 1)
          {
            int num6;
            ++num6;
            if (num6 == (int) Math.Round((double) Conversion.Int(trnd * (float) num1)) + 1)
            {
              int counter7 = tMarkerlist.Counter;
              int num7;
              for (int index7 = 0; index7 <= counter7; ++index7)
              {
                if (this.MoveMatrix[UnitSlot, tMarkerlist.Data1[index7], tMarkerlist.Data2[index7]] < 9999 | this.game.Data.UnitObj[unr].X == tMarkerlist.Data1[index7] & this.game.Data.UnitObj[unr].Y == tMarkerlist.Data2[index7] && tMarkerlist.Data3[index7] == this.MarkerList.Data3[index4] & tMarkerlist.Data4[index7] == this.MarkerList.Data4[index4])
                  ++num7;
              }
              int num8 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) num7)) + 1;
              if (num7 > 0)
              {
                int counter8 = tMarkerlist.Counter;
                for (int index8 = 0; index8 <= counter8; ++index8)
                {
                  int num9;
                  if (this.MoveMatrix[UnitSlot, tMarkerlist.Data1[index8], tMarkerlist.Data2[index8]] < 9999 | this.game.Data.UnitObj[unr].X == tMarkerlist.Data1[index8] & this.game.Data.UnitObj[unr].Y == tMarkerlist.Data2[index8] && tMarkerlist.Data3[index8] == this.MarkerList.Data3[index4] & tMarkerlist.Data4[index8] == this.MarkerList.Data4[index4])
                    ++num9;
                  if (num9 == num8)
                    return index8;
                }
              }
              return -1;
            }
          }
        }
      }
      return -1;
    }

    public void FindBestMove()
    {
      this.LogCounter2 = -1;
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1)
        {
          this.game.Data.UnitObj[unr].TempUnitPower = this.GetUnitPower(unr, false);
          this.game.Data.UnitObj[unr].TempCombatImprovePercent = this.game.HandyFunctionsObj.GetCombatImprovePercent(unr);
          if (this.OpGroup == 1)
            this.AddLog2(this.game.Data.UnitObj[unr].Name + " TEMPUNITPOWER = " + Conversion.Str((object) this.game.Data.UnitObj[unr].TempUnitPower) + " , COMBATIMPRPERCENT=" + Conversion.Str((object) this.game.Data.UnitObj[unr].TempCombatImprovePercent));
        }
      }
      this.AAM1.x = this.game.Data.MapObj[0].MapWidth;
      this.AAM1.y = this.game.Data.MapObj[0].MapHeight;
      this.AAM2.x = -1;
      this.AAM2.y = -1;
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      int index1;
      for (index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          if (this.FullAdvanceMatrix[index1, index2] > 0)
          {
            if (index1 < this.AAM1.x)
              this.AAM1.x = index1;
            if (index2 < this.AAM1.y)
              this.AAM1.y = index2;
            if (index1 > this.AAM2.x)
              this.AAM2.x = index1;
            if (index2 > this.AAM2.y)
              this.AAM2.y = index2;
          }
        }
      }
      this.CMS1.x = this.game.Data.MapObj[0].MapWidth;
      this.CMS2.y = this.game.Data.MapObj[0].MapHeight;
      this.CMS2.x = -1;
      this.CMS2.y = -1;
      int enemyMatrixCounter = this.EnemyMatrixCounter;
      for (int index3 = 1; index3 <= enemyMatrixCounter; ++index3)
      {
        int index4 = this.EnemyMatrixUnit[index3];
        index1 = this.game.Data.UnitObj[index4].X;
        int y = this.game.Data.UnitObj[index4].Y;
        if (Math.Max(0, index1 - 10) < this.CMS1.x)
          this.CMS1.x = Math.Max(0, index1 - 10);
        if (Math.Max(0, y - 10) < this.CMS1.y)
          this.CMS1.y = Math.Max(0, y - 10);
        if (Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10) > this.CMS2.x)
          this.CMS2.x = Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10);
        if (Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10) > this.CMS2.y)
          this.CMS2.y = Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10);
      }
      int num1 = 0;
      int num2 = 0;
      int moveMatrixCounter1 = this.MoveMatrixCounter;
      for (int index5 = 0; index5 <= moveMatrixCounter1; ++index5)
      {
        int index6 = this.MoveMatrixUnit[index5];
        num1 += this.game.Data.UnitObj[index6].SupplyIn;
        num2 += this.game.Data.UnitObj[index6].SupplyInReq;
        index1 = this.game.Data.UnitObj[index6].X;
        int y = this.game.Data.UnitObj[index6].Y;
        if (Math.Max(0, index1 - 10) < this.CMS1.x)
          this.CMS1.x = Math.Max(0, index1 - 10);
        if (Math.Max(0, y - 10) < this.CMS1.y)
          this.CMS1.y = Math.Max(0, y - 10);
        if (Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10) > this.CMS2.x)
          this.CMS2.x = Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10);
        if (Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10) > this.CMS2.y)
          this.CMS2.y = Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10);
      }
      int num3 = num2 + 1;
      this.AverageSupplyPercentage = (int) Math.Round(100.0 * ((double) num1 / (double) num3));
      int num4 = 0;
      SimpleList simpleList1 = new SimpleList();
      int moveMatrixCounter2 = this.MoveMatrixCounter;
      SimpleList simpleList2;
      for (int tdata1 = 0; tdata1 <= moveMatrixCounter2; ++tdata1)
      {
        int index7 = this.MoveMatrixUnit[tdata1];
        if (this.game.Data.UnitObj[index7].Historical > -1)
        {
          int historical = this.game.Data.UnitObj[index7].Historical;
          if (this.game.Data.HistoricalUnitObj[historical].TempTargetX > -1)
          {
            if (this.game.Data.UnitObj[index7].TempCategory == 1)
              simpleList2 = this.MarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 2)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 5)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 3)
              simpleList2 = this.AirMarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 4)
              simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
            int counter = simpleList2.Counter;
            int tid;
            for (int tdata2 = 0; tdata2 <= counter; ++tdata2)
            {
              if (this.game.Data.HistoricalUnitObj[historical].TempTargetAttackX > -1)
              {
                if (simpleList2.Data1[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetX & simpleList2.Data2[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetY & simpleList2.Data3[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetAttackX & simpleList2.Data4[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetAttackY)
                {
                  ++tid;
                  simpleList1.Add(tid, 1, tdata1, tdata2, simpleList2.Data1[tdata2], simpleList2.Data2[tdata2], CheckExistence: false);
                  this.MoveMatrixUnitMarker[tdata1] = tdata2;
                  num4 = 1;
                }
              }
              else if (simpleList2.Data1[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetX & simpleList2.Data2[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetY)
              {
                ++tid;
                simpleList1.Add(tid, 1, tdata1, tdata2, simpleList2.Data1[tdata2], simpleList2.Data2[tdata2], CheckExistence: false);
                this.MoveMatrixUnitMarker[tdata1] = tdata2;
                num4 = 1;
              }
            }
          }
        }
      }
      if (num4 == 1)
      {
        this.BestMove = simpleList1;
      }
      else
      {
        bool flag1 = true;
        GC.Collect();
        VBMath.Randomize((double) (this.game.Data.Turn + this.game.Data.Round + this.game.Data.MapObj[0].MapWidth));
        int Number1 = -9999;
        int Number2 = 0;
        this.Meeting = false;
        bool flag2 = this.GetLargestArmy() == this.GetGameDataTurn();
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 1)
          this.Attacker = true;
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 2)
          this.Attacker = false;
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 3)
          this.Meeting = true;
        this.HistoryScoreList = new SimpleList();
        this.HistoryMoveCounter = 0;
        this.BestMove = (SimpleList) null;
        if (this.MarkerList.Counter == -1)
          return;
        int tid = 0;
        int Number3 = this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE;
        if (this.MoveMatrixCounter > 15)
          Number3 = (int) Math.Round((double) Number3 * Math.Sqrt((double) this.MoveMatrixCounter / 15.0));
        if (this.MoveAndAttackRound > 1)
          Number3 = (int) Math.Round((double) Number3 / (double) this.MoveAndAttackRound);
        if (this.MoveMatrixCounter <= 1)
        {
          Number3 = (int) Math.Round((double) Number3 / 4.0);
          if (this.GroupType[this.OpGroup] >= 5)
            Number3 = (int) Math.Round((double) Number3 / 4.0);
        }
        else if (this.MoveMatrixCounter <= 2)
          Number3 = (int) Math.Round((double) Number3 / 3.0);
        else if (this.MoveMatrixCounter <= 3)
          Number3 = (int) Math.Round((double) Number3 / 2.5);
        else if (this.MoveMatrixCounter <= 4)
          Number3 = (int) Math.Round((double) Number3 / 2.0);
        else if (this.MoveMatrixCounter <= 5)
          Number3 = (int) Math.Round((double) Number3 / 1.5);
        if (Number3 < 10)
          Number3 = 10;
        int num5 = 99999;
        int num6 = 9999;
        int num7 = 9999;
        int num8 = 9999;
        int index8 = 1;
        do
        {
          this.MoveMatrixUnitMarker[index8] = -1;
          this.TempMoveMatrixUnitMarker[index8] = -1;
          ++index8;
        }
        while (index8 <= 90);
        if (flag1)
          this.AddLog2("MAXMOVE = " + Conversion.Str((object) Number3));
        bool quicktest = false;
        int num9 = this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus <= 100 & this.CorpsStance[this.OpGroup] == 3 ? 1 : 0;
        int num10;
        while (Number2 < Number3)
        {
          SimpleList TempMove = new SimpleList();
          ++Number2;
          if (flag1)
          {
            this.AddLog2("");
            this.AddLog2("******** " + Number2.ToString());
          }
          int num11;
          if (Number2 > num11)
            quicktest = false;
          if (Number2 == 1 | Number2 % 20 == 0)
          {
            this.game.EditObj.AIProgressMax = Number3;
            this.game.EditObj.AIProgressNow = Number2;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str((object) this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str((object) (int) Math.Round((double) Number2 / (double) Number3 * 100.0))) + "% completed.";
          }
          bool flag3 = false;
          if (Number2 + 10 < Number3)
          {
            if ((double) VBMath.Rnd() < 0.02)
            {
              num6 = 9999;
              flag3 = true;
            }
            else if ((double) VBMath.Rnd() < 0.02)
            {
              num7 = 9999;
              flag3 = true;
            }
          }
          int index9 = 1;
          do
          {
            this.MoveMatrixUnitMarker[index9] = -1;
            ++index9;
          }
          while (index9 <= 90);
          SimpleList simpleList3 = new SimpleList();
          float num12 = VBMath.Rnd();
          float trnd = VBMath.Rnd();
          VBMath.Rnd();
          VBMath.Rnd();
          int moveMatrixCounter3 = this.MoveMatrixCounter;
          int num13;
          int num14;
          int num15;
          int num16;
          for (int index10 = 1; index10 <= moveMatrixCounter3; ++index10)
          {
            int index11 = this.MoveMatrixUnit[index10];
            if (index11 > -1)
            {
              if (this.game.Data.UnitObj[index11].TempCategory == 1)
                simpleList2 = this.MarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 2)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 5)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 3)
                simpleList2 = this.AirMarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 4)
                simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
              int tdata2_1;
              int num17;
              if (this.game.Data.UnitObj[index11].TempStrategic)
              {
                if (flag1)
                  this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Strategic Move");
                int index12 = this.game.Data.UnitObj[index11].AIAttackStyle != 3 ? this.game.Data.UnitObj[index11].AIDefend : this.game.Data.UnitObj[index11].AIAttack;
                if (index12 > -1)
                {
                  int x = this.AreaCenter[index12].x;
                  int y = this.AreaCenter[index12].y;
                  int num18 = -1;
                  if (this.game.Data.MapObj[0].HexObj[x, y].UnitCounter > -1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
                  {
                    int counter = simpleList2.Counter;
                    for (int index13 = 0; index13 <= counter; ++index13)
                    {
                      if (this.GetTscore(simpleList2.Data1[index13], simpleList2.Data2[index13]) > num18)
                      {
                        x = simpleList2.Data1[index13];
                        y = simpleList2.Data2[index13];
                        num18 = this.GetTscore(x, y);
                      }
                    }
                  }
                  tdata2_1 = -1;
                  int counter1 = simpleList2.Counter;
                  for (int index14 = 0; index14 <= counter1; ++index14)
                  {
                    if (simpleList2.Data1[index14] == x & simpleList2.Data2[index14] == y)
                      tdata2_1 = index14;
                  }
                  if (tdata2_1 == -1)
                  {
                    simpleList2.Add(50000 + tid, 2, x, y, -1, -1);
                    tdata2_1 = simpleList2.Counter;
                  }
                  TempMove.Add(tid, 1, index10, tdata2_1, x, y, CheckExistence: false, CheckData1Existence: true);
                  num17 = 0;
                  this.MoveMatrixUnitMarker[index10] = tdata2_1;
                }
              }
              else if (!Information.IsNothing((object) simpleList2))
              {
                if (flag3 | (double) Number2 <= (double) Number3 / 8.0)
                {
                  if (flag1)
                    this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Random OR Doctrines");
                  ++tid;
                  int num19 = 1;
                  int num20 = 0;
                  if ((this.Attacker & (double) num12 < 0.1 | !this.Attacker & (double) num12 < 0.05) & !this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => ShockAwe Doctrine");
                    tdata2_1 = this.ReturnShockAndAweMarker(simpleList2, trnd, index10, index11);
                    if (tdata2_1 > -1)
                    {
                      int tdata3 = simpleList2.Data1[tdata2_1];
                      int tdata4 = simpleList2.Data2[tdata2_1];
                      if (tdata3 == 13)
                        tdata3 = tdata3;
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if ((this.Attacker & (double) num12 < 0.1 | !this.Attacker & (double) num12 < 0.05) & this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => HQ in focus Doctrine");
                    tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                    if (tdata2_1 > -1)
                    {
                      int tdata3 = simpleList2.Data1[tdata2_1];
                      int tdata4 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num5 >= Number2)
                  {
                    ++num13;
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Do not move doctrine");
                    tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                    num5 = Number2;
                    if (tdata2_1 > -1)
                    {
                      int tdata3 = simpleList2.Data1[tdata2_1];
                      int tdata4 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num6 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & !this.game.Data.UnitObj[index11].IsHQ)
                  {
                    ++num14;
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Center Target Doctrine");
                    tdata2_1 = this.game.Data.UnitObj[index11].AIAttack <= -1 ? this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y) : this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].y);
                    num6 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      int tdata3 = simpleList2.Data1[tdata2_1];
                      int tdata4 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num6 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Central Target Doctrine (HQ behind)");
                    if (this.game.Data.UnitObj[index11].AIFallback > -1)
                      tdata2_1 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].y);
                    else if (this.game.Data.UnitObj[index11].AIDefend > -1)
                      tdata2_1 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y);
                    num6 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      int tdata3 = simpleList2.Data1[tdata2_1];
                      int tdata4 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num7 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & !this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Closest Target");
                    ++num15;
                    tdata2_1 = this.GetMarkerForClosestEnemy(index11, this.AverageSupplyPercentage);
                    num7 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      int tdata3 = simpleList2.Data1[tdata2_1];
                      int tdata4 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num7 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Closest Target (HQ)");
                    int tdata2_2 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                    int tdata3 = simpleList2.Data1[tdata2_2];
                    int tdata4 = simpleList2.Data2[tdata2_2];
                    TempMove.Add(tid, 1, index10, tdata2_2, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                    num19 = 0;
                    this.MoveMatrixUnitMarker[index10] = tdata2_2;
                  }
                  else if (num8 >= Number2 & this.game.Data.UnitObj[index11].AIDefend > -1)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => To Defend Area!");
                    ++num16;
                    tdata2_1 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y);
                    num8 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      int tdata3 = simpleList2.Data1[tdata2_1];
                      int tdata4 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  while (num19 == 1 & num20 < 100)
                  {
                    ++num20;
                    int tdata2_3 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                    if (this.MoveMatrix[index10, simpleList2.Data1[tdata2_3], simpleList2.Data2[tdata2_3]] < 9999 | this.game.Data.UnitObj[index11].X == simpleList2.Data1[tdata2_3] & this.game.Data.UnitObj[index11].Y == simpleList2.Data2[tdata2_3])
                    {
                      int tdata3;
                      int tdata4;
                      if ((double) VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index11].TempCategory == 1)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM : MUTATED MARKER");
                        tdata3 = (int) Math.Round((double) ((float) simpleList2.Data1[tdata2_3] + Conversion.Int((float) ((double) VBMath.Rnd() * 4.0 - 2.0))));
                        tdata4 = (int) Math.Round((double) ((float) simpleList2.Data2[tdata2_3] + Conversion.Int((float) ((double) VBMath.Rnd() * 4.0 - 2.0))));
                        if (tdata3 < 0 | tdata4 < 0 | tdata3 > this.game.Data.MapObj[0].MapWidth | tdata4 > this.game.Data.MapObj[0].MapHeight)
                        {
                          tdata3 = simpleList2.Data1[tdata2_3];
                          tdata4 = simpleList2.Data2[tdata2_3];
                        }
                        if (this.MoveMatrix[index10, tdata3, tdata4] >= 9999)
                        {
                          tdata3 = simpleList2.Data1[tdata2_3];
                          tdata4 = simpleList2.Data2[tdata2_3];
                        }
                      }
                      else if ((double) VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index11].TempCategory != 3 & this.CorpsStance[this.OpGroup] == 1)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM AIR : Own Coordinate");
                        tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                        if (tdata2_1 > -1)
                          tdata2_3 = tdata2_1;
                        tdata3 = simpleList2.Data1[tdata2_3];
                        tdata4 = simpleList2.Data2[tdata2_3];
                      }
                      else if ((double) VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index11].IsHQ)
                      {
                        tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM HQ : Different Coordinate");
                        if (tdata2_1 > -1)
                          tdata2_3 = tdata2_1;
                        tdata3 = simpleList2.Data1[tdata2_3];
                        tdata4 = simpleList2.Data2[tdata2_3];
                      }
                      else
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM : RANDOM MARKER");
                        tdata3 = simpleList2.Data1[tdata2_3];
                        tdata4 = simpleList2.Data2[tdata2_3];
                      }
                      ++tid;
                      TempMove.Add(tid, 1, index10, tdata2_3, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_3;
                    }
                  }
                }
                else
                {
                  Random random = new Random(Number2 + this.game.Data.Round * 4002);
                  float num21 = (float) Math.Sqrt(Math.Sqrt((double) ((float) random.Next(0, 100000) / 100000f)));
                  int num22 = 0;
                  if (Number2 >= Number3 - 2)
                  {
                    num21 = 1f;
                    num22 = 1;
                    if (flag1)
                      this.AddLog2("MODE: Mutate top record. Special for HQ positioning");
                  }
                  else if (random.Next(0, 100) > 30)
                  {
                    num21 = 1f;
                    num22 = 1;
                    if (flag1)
                      this.AddLog2("MODE: Mutate top record");
                  }
                  else if (random.Next(0, 100) < 50)
                  {
                    if ((double) VBMath.Rnd() > 0.5)
                      num21 = 1f;
                    if (flag1)
                      this.AddLog2("MODE: Mix old record with top record OR Doctrine");
                  }
                  else
                  {
                    if ((double) VBMath.Rnd() > 0.5)
                      num21 = (float) Math.Sqrt(Math.Sqrt((double) VBMath.Rnd()));
                    if (flag1)
                      this.AddLog2("MODE: Mix old record with other old record OR Doctrine");
                  }
                  float num23 = (double) VBMath.Rnd() >= 0.33 ? ((double) VBMath.Rnd() >= 0.5 ? (float) Math.Min(0.6, (double) (8f / (float) (1 + this.MoveMatrixCounter))) : (float) Math.Min(0.45, (double) (4f / (float) (1 + this.MoveMatrixCounter)))) : (float) Math.Min(0.3, (double) (2f / (float) (1 + this.MoveMatrixCounter)));
                  for (int tdata2_4 = this.HistoryScoreList.Counter; tdata2_4 >= 0; tdata2_4 += -1)
                  {
                    int num24 = this.HistoryScoreList.Weight[this.HistoryScoreList.Counter] - this.HistoryScoreList.Weight[0];
                    if ((double) ((float) (this.HistoryScoreList.Weight[tdata2_4] - this.HistoryScoreList.Weight[0]) / (float) num24) <= (double) num21)
                    {
                      int index15 = this.HistoryScoreList.Id[tdata2_4];
                      ++tid;
                      if (Number2 == Number3 - 2)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM SELF + GIVE DEFENSIVE LOC TO HQ");
                        int nr = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          int unr = this.MoveMatrixUnit[this.HistoryMove[index15].Data1[nr]];
                          tdata2_1 = -1;
                          if (this.game.Data.UnitObj[unr].IsHQ)
                          {
                            tdata2_1 = this.GetNormalDefensiveCenterMarker(unr, this.HistoryMove[index15].Data1[nr]);
                            if (tdata2_1 > -1)
                            {
                              TempMove.Add(tid, 1, index10, tdata2_1, this.MarkerList.Data1[tdata2_1], this.MarkerList.Data2[tdata2_1], CheckExistence: false, CheckData1Existence: true);
                              this.MoveMatrixUnitMarker[index10] = tdata2_1;
                            }
                          }
                          if (tdata2_1 == -1)
                          {
                            TempMove.Add(tid, 1, index10, this.HistoryMove[index15].Data2[nr], this.HistoryMove[index15].Data3[nr], this.HistoryMove[index15].Data4[nr], this.HistoryMove[index15].Data5[nr], false, true);
                            this.MoveMatrixUnitMarker[index10] = this.HistoryMove[index15].Data2[nr];
                            break;
                          }
                          break;
                        }
                        break;
                      }
                      if (Number2 == Number3 - 1)
                      {
                        if (flag1)
                          this.AddLog(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM SELF + GIVE FALLBACK LOC TO HQ");
                        int nr = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          int unr = this.MoveMatrixUnit[this.HistoryMove[index15].Data1[nr]];
                          tdata2_1 = -1;
                          if (this.game.Data.UnitObj[unr].IsHQ)
                          {
                            tdata2_1 = this.GetNormalFallbackCenterMarker(unr, this.HistoryMove[index15].Data1[nr]);
                            if (tdata2_1 > -1)
                            {
                              TempMove.Add(tid, 1, index10, tdata2_1, this.MarkerList.Data1[tdata2_1], this.MarkerList.Data2[tdata2_1], CheckExistence: false, CheckData1Existence: true);
                              this.MoveMatrixUnitMarker[index10] = tdata2_1;
                            }
                          }
                          if (tdata2_1 == -1)
                          {
                            TempMove.Add(tid, 1, index10, this.HistoryMove[index15].Data2[nr], this.HistoryMove[index15].Data3[nr], this.HistoryMove[index15].Data4[nr], this.HistoryMove[index15].Data5[nr], false, true);
                            this.MoveMatrixUnitMarker[index10] = this.HistoryMove[index15].Data2[nr];
                            break;
                          }
                          break;
                        }
                        break;
                      }
                      if ((double) VBMath.Rnd() > (double) num23)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM SELF");
                        int nr = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          TempMove.Add(tid, 1, index10, this.HistoryMove[index15].Data2[nr], this.HistoryMove[index15].Data3[nr], this.HistoryMove[index15].Data4[nr], this.HistoryMove[index15].Data5[nr], false, true);
                          this.MoveMatrixUnitMarker[index10] = this.HistoryMove[index15].Data2[nr];
                          break;
                        }
                        break;
                      }
                      int num25;
                      if ((double) VBMath.Rnd() < 0.25 & num22 == 0)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM OTHER STRAT.");
                        int nr = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          ++tid;
                          tdata2_4 = this.HistoryMove[index15].Data2[nr];
                          int tdata3 = this.HistoryMove[index15].Data3[nr];
                          int tdata4 = this.HistoryMove[index15].Data4[nr];
                          TempMove.Add(tid, 1, index10, tdata2_4, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                          break;
                        }
                        tdata2_4 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                        int tdata3_1 = simpleList2.Data1[tdata2_4];
                        int tdata4_1 = simpleList2.Data2[tdata2_4];
                        ++tid;
                        TempMove.Add(tid, 1, index10, tdata2_4, tdata3_1, tdata4_1, CheckExistence: false, CheckData1Existence: true);
                        num17 = 0;
                        this.MoveMatrixUnitMarker[index10] = tdata2_4;
                        num25 = -1;
                        break;
                      }
                      if (num22 == 0)
                      {
                        int num26 = (int) Math.Round((double) (VBMath.Rnd() * 100f));
                        int num27;
                        int num28;
                        int num29;
                        if ((int) Math.Round((double) (VBMath.Rnd() * 100f)) < 50)
                        {
                          num27 = index10;
                          num28 = index10;
                          num29 = 0;
                          if (flag1)
                            this.AddLog2(this.game.Data.UnitObj[index11].Name + " => DOCTRINE. JUST THIS UNIT.");
                        }
                        else
                        {
                          num27 = 1;
                          num28 = this.MoveMatrixCounter;
                          num29 = 1;
                          if (flag1)
                            this.AddLog2(this.game.Data.UnitObj[index11].Name + " => DOCTRINE. FULL HISTORICAL.");
                        }
                        int num30 = num27;
                        int num31 = num28;
                        for (int tdata1 = num30; tdata1 <= num31; ++tdata1)
                        {
                          int num32 = 0;
                          if ((double) this.game.Data.RuleVar[356] == 0.0)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical == this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Historical & this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Historical > -1 | num29 == 0 && this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].TempCategory)
                              num32 = 1;
                          }
                          else if (index10 == tdata1 | (double) VBMath.Rnd() > 2.0 / (double) this.MoveMatrixCounter && this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].TempCategory)
                            num32 = 1;
                          if (num32 == 1)
                          {
                            num10 = -1;
                            if (num26 < 25)
                            {
                              tdata2_1 = this.ReturnShockAndAweMarker(simpleList2, trnd, index10, index11);
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => SHOCK&AWE");
                            }
                            else if (num26 < 50)
                            {
                              tdata2_1 = this.GetSameCoordinateMarker(this.MoveMatrixUnit[tdata1], simpleList2);
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => STAY PUT");
                            }
                            else if (num26 < 75)
                            {
                              if (this.game.Data.UnitObj[index11].AIAttack > -1)
                              {
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => ATTACK CENTER");
                                tdata2_1 = this.GetMarkerForCoordinate(this.MoveMatrixUnit[tdata1], this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].y);
                              }
                              else
                              {
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => Random MArker");
                                tdata2_1 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                              }
                            }
                            else
                            {
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => CLOSEST ENEMY");
                              tdata2_1 = (double) VBMath.Rnd() <= 0.5 ? this.GetMarkerForClosestEnemy(index11, this.AverageSupplyPercentage) : this.GetMarkerForClosestEnemy(this.MoveMatrixUnit[tdata1], this.AverageSupplyPercentage);
                            }
                            if (tdata2_1 > -1 && this.MoveMatrix[tdata1, simpleList2.Data1[tdata2_1], simpleList2.Data2[tdata2_1]] < 9999 | this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].X == simpleList2.Data1[tdata2_1] & this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Y == simpleList2.Data2[tdata2_1])
                            {
                              int tdata3 = simpleList2.Data1[tdata2_1];
                              int tdata4 = simpleList2.Data2[tdata2_1];
                              ++tid;
                              TempMove.Add(tid, 1, tdata1, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                              this.MoveMatrixUnitMarker[tdata1] = tdata2_1;
                            }
                          }
                        }
                        break;
                      }
                      int num33 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * 7f));
                      if (num33 == 0 | num33 == 3 & this.CorpsStance[this.OpGroup] == 1)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : TAKE RANDOM MARKER");
                      }
                      else if (num33 == 1 | (num33 == 2 | num33 == 3) & this.CorpsStance[this.OpGroup] == 3)
                      {
                        num33 = 1;
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : RANDOM SIDES OF ATTACK ON SAME ATTACK MARKER (div only)");
                      }
                      else if (num33 == 4 | num33 == 2 & this.CorpsStance[this.OpGroup] == 1)
                      {
                        num33 = 2;
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : MOVE ON DEFEND / FALLBACK / SELF");
                      }
                      else if (num33 == 5 | num33 == 6)
                      {
                        num33 = 3;
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : RANDOM BOTTLENECK");
                      }
                      SimpleList simpleList4 = new SimpleList();
                      int num34;
                      int num35;
                      if ((double) VBMath.Rnd() > 0.5 & (num33 == 0 | num33 == 2))
                      {
                        num34 = index10;
                        num35 = index10;
                      }
                      else
                      {
                        num34 = 0;
                        num35 = this.MoveMatrixCounter;
                      }
                      int num36;
                      int num37;
                      switch (num33)
                      {
                        case 1:
                          simpleList4 = this.GetRandomAttackMarkers(index10, simpleList2, this.AverageSupplyPercentage);
                          num34 = 0;
                          num35 = this.MoveMatrixCounter;
                          num36 = (int) Math.Round((double) (VBMath.Rnd() * 100f));
                          num37 = (int) Math.Round((double) (VBMath.Rnd() * 100f));
                          if (simpleList4.Counter < 0)
                          {
                            if (flag1)
                              this.AddLog2(this.game.Data.UnitObj[index11].Name + "!*could not find randomattackmarkers*");
                            num33 = 0;
                            break;
                          }
                          break;
                        case 3:
                          simpleList4 = this.GetRandomBottleneckMarkers(index10, simpleList2);
                          if (simpleList4.Counter < 0)
                          {
                            if (flag1)
                              this.AddLog2(this.game.Data.UnitObj[index11].Name + "!*could not find random bottlenecks*");
                            num33 = 0;
                            break;
                          }
                          break;
                      }
                      int num38 = num34;
                      int num39 = num35;
                      for (int index16 = num38; index16 <= num39; ++index16)
                      {
                        int num40 = 0;
                        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical == this.game.Data.UnitObj[this.MoveMatrixUnit[index16]].Historical & this.game.Data.UnitObj[this.MoveMatrixUnit[index16]].Historical > -1 && this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == this.game.Data.UnitObj[this.MoveMatrixUnit[index16]].TempCategory)
                          ++num40;
                        if (num40 > 0)
                        {
                          switch (num33)
                          {
                            case 0:
                              tdata2_4 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                              int num41 = simpleList2.Data1[tdata2_4];
                              int num42 = simpleList2.Data2[tdata2_4];
                              if ((double) VBMath.Rnd() < 0.2 / (double) num40 & this.game.Data.UnitObj[index11].TempCategory == 1)
                              {
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! MUTATED MARKER(type0)");
                                int index17 = (int) Math.Round((double) ((float) simpleList2.Data1[tdata2_4] + Conversion.Int((float) ((double) VBMath.Rnd() * 4.0 - 2.0))));
                                int index18 = (int) Math.Round((double) ((float) simpleList2.Data2[tdata2_4] + Conversion.Int((float) ((double) VBMath.Rnd() * 4.0 - 2.0))));
                                if (index17 < 0 | index18 < 0 | index17 > this.game.Data.MapObj[0].MapWidth | index18 > this.game.Data.MapObj[0].MapHeight)
                                {
                                  index17 = simpleList2.Data1[tdata2_4];
                                  index18 = simpleList2.Data2[tdata2_4];
                                }
                                if (this.MoveMatrix[index10, index17, index18] >= 9999)
                                {
                                  num41 = simpleList2.Data1[tdata2_4];
                                  num42 = simpleList2.Data2[tdata2_4];
                                  continue;
                                }
                                continue;
                              }
                              if (flag1)
                              {
                                this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! RANDOM MARKER(type0)");
                                continue;
                              }
                              continue;
                            case 1:
                              int index19 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList4.Counter + 1)));
                              tdata2_4 = simpleList4.Id[index19];
                              int tdata3_2 = simpleList2.Data1[tdata2_4];
                              int tdata4_2 = simpleList2.Data2[tdata2_4];
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! SAME TARGET RANDOM DIRECTON MARKER (type1) : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                              ++tid;
                              TempMove.Add(tid, 1, index10, tdata2_4, tdata3_2, tdata4_2, CheckExistence: false, CheckData1Existence: true);
                              num17 = 0;
                              this.MoveMatrixUnitMarker[index10] = tdata2_4;
                              num25 = -1;
                              continue;
                            case 2:
                              int num43 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * 3f));
                              if (num43 == 0 & this.game.Data.UnitObj[index11].AIDefend > -1)
                              {
                                int markerForCoordinate = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y);
                                if (markerForCoordinate > -1)
                                {
                                  tdata2_4 = markerForCoordinate;
                                  int tdata3_3 = simpleList2.Data1[tdata2_4];
                                  int tdata4_3 = simpleList2.Data2[tdata2_4];
                                  if (flag1)
                                    this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! TO DEFEND AREA : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                                  ++tid;
                                  TempMove.Add(tid, 1, index10, tdata2_4, tdata3_3, tdata4_3, CheckExistence: false, CheckData1Existence: true);
                                  num17 = 0;
                                  this.MoveMatrixUnitMarker[index10] = tdata2_4;
                                  num25 = -1;
                                  continue;
                                }
                                continue;
                              }
                              if (num43 == 1 & this.game.Data.UnitObj[index11].AIFallback > -1)
                              {
                                int markerForCoordinate = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].y);
                                if (markerForCoordinate > -1)
                                {
                                  tdata2_4 = markerForCoordinate;
                                  int tdata3_4 = simpleList2.Data1[tdata2_4];
                                  int tdata4_4 = simpleList2.Data2[tdata2_4];
                                  if (flag1)
                                    this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! TO FALLBACK AREA : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                                  ++tid;
                                  TempMove.Add(tid, 1, index10, tdata2_4, tdata3_4, tdata4_4, CheckExistence: false, CheckData1Existence: true);
                                  num17 = 0;
                                  this.MoveMatrixUnitMarker[index10] = tdata2_4;
                                  num25 = -1;
                                  continue;
                                }
                                continue;
                              }
                              int markerForCoordinate1 = this.GetMarkerForCoordinate(index11, this.game.Data.UnitObj[index11].X, this.game.Data.UnitObj[index11].Y);
                              if (markerForCoordinate1 > -1)
                              {
                                tdata2_4 = markerForCoordinate1;
                                int tdata3_5 = simpleList2.Data1[tdata2_4];
                                int tdata4_5 = simpleList2.Data2[tdata2_4];
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! TO DO-NOT-MOVE : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                                ++tid;
                                TempMove.Add(tid, 1, index10, tdata2_4, tdata3_5, tdata4_5, CheckExistence: false, CheckData1Existence: true);
                                num17 = 0;
                                this.MoveMatrixUnitMarker[index10] = tdata2_4;
                                num25 = -1;
                                continue;
                              }
                              continue;
                            case 3:
                              int index20 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList4.Counter + 1)));
                              tdata2_4 = simpleList4.Id[index20];
                              int tdata3_6 = simpleList2.Data1[tdata2_4];
                              int tdata4_6 = simpleList2.Data2[tdata2_4];
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! RANDOM Bottlenec(type1) : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                              ++tid;
                              TempMove.Add(tid, 1, index10, tdata2_4, tdata3_6, tdata4_6, CheckExistence: false, CheckData1Existence: true);
                              num17 = 0;
                              this.MoveMatrixUnitMarker[index10] = tdata2_4;
                              num25 = -1;
                              continue;
                            default:
                              continue;
                          }
                        }
                      }
                      if (num33 == 1)
                      {
                        if (num36 > 0)
                        {
                          int moveMatrixCounter4 = this.MoveMatrixCounter;
                          for (int index21 = 0; index21 <= moveMatrixCounter4; ++index21)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index21]].TempCategory == 2 && (int) Math.Round((double) (VBMath.Rnd() * 100f)) < num36)
                            {
                              int coordinateTarget = this.GetClosestMarkerForCoordinateTarget(index21, simpleList2.Data3[tdata2_4], simpleList2.Data4[tdata2_4]);
                              if (coordinateTarget > -1)
                              {
                                int tdata3 = this.ArtMarkerList.Data1[coordinateTarget];
                                int tdata4 = this.ArtMarkerList.Data2[coordinateTarget];
                                ++tid;
                                TempMove.Add(tid, 1, index21, coordinateTarget, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                                num17 = 0;
                                this.MoveMatrixUnitMarker[index21] = coordinateTarget;
                                num25 = -1;
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! ARTILLERY SUPPORT ASSIGNED (type1) : " + this.ArtMarkerList.Data1[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data2[coordinateTarget].ToString() + "=>" + this.ArtMarkerList.Data3[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data4[coordinateTarget].ToString());
                              }
                            }
                          }
                        }
                        if (num37 > 0)
                        {
                          int moveMatrixCounter5 = this.MoveMatrixCounter;
                          for (int index22 = 0; index22 <= moveMatrixCounter5; ++index22)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index22]].TempCategory == 3 && (int) Math.Round((double) (VBMath.Rnd() * 100f)) < num37)
                            {
                              int coordinateTarget = this.GetClosestMarkerForCoordinateTarget(index22, simpleList2.Data3[tdata2_4], simpleList2.Data4[tdata2_4]);
                              if (coordinateTarget > -1)
                              {
                                int tdata3 = this.ArtMarkerList.Data1[coordinateTarget];
                                int tdata4 = this.ArtMarkerList.Data2[coordinateTarget];
                                ++tid;
                                TempMove.Add(tid, 1, index22, coordinateTarget, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                                num17 = 0;
                                this.MoveMatrixUnitMarker[index22] = coordinateTarget;
                                num25 = -1;
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! AIR SUPPORT ASSIGNED (type1) : " + this.ArtMarkerList.Data1[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data2[coordinateTarget].ToString() + "=>" + this.ArtMarkerList.Data3[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data4[coordinateTarget].ToString());
                              }
                            }
                          }
                          break;
                        }
                        break;
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
          int moveScore;
          if (this.FullLog)
          {
            if (num13 > 0 & num13 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("DO NOT MOVE DOCTRINE I");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineI_" + this.MoveAndAttackRound.ToString());
              num13 += 1000;
            }
            else if (num14 > 0 & num14 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("CENTER TARGET DOCTRINE II");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineII_" + this.MoveAndAttackRound.ToString());
              num14 += 1000;
            }
            else if (num15 > 0 & num15 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("CLOSEST TARGET DOCTRINE III");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineIII_" + this.MoveAndAttackRound.ToString());
              num15 += 1000;
            }
            else if (num16 > 0 & num16 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("DEFEND_AREA_DOCTRINE IV");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineIV_" + this.MoveAndAttackRound.ToString());
              num15 += 1000;
            }
            else
              moveScore = this.GetMoveScore(TempMove, false, quicktest);
          }
          else
            moveScore = this.GetMoveScore(TempMove, false, quicktest);
          if (flag1)
            this.AddLog2(Conversion.Str((object) Number2) + ") CurrentScore = " + Conversion.Str((object) moveScore) + ", BestScore=" + Conversion.Str((object) Number1));
          if (moveScore != Number1)
          {
            this.HistoryMove[this.HistoryMoveCounter] = TempMove;
            this.HistoryScoreList.Add(this.HistoryMoveCounter, moveScore, CheckExistence: false);
            this.HistoryScoreList.Sort();
            ++this.HistoryMoveCounter;
            Number2 = Number2;
            if (this.HistoryScoreList.Counter > 450)
              this.HistoryScoreList.Remove(this.HistoryScoreList.Id[(int) Math.Round((double) VBMath.Rnd() * (double) this.HistoryScoreList.Counter * 0.5)]);
            if (moveScore > Number1 | Information.IsNothing((object) this.BestMove))
            {
              int moveMatrixCounter6 = this.MoveMatrixCounter;
              for (int index23 = 1; index23 <= moveMatrixCounter6; ++index23)
                this.TempMoveMatrixUnitMarker[index23] = this.MoveMatrixUnitMarker[index23];
              this.BestMove = TempMove;
              Number1 = moveScore;
              if (flag1)
                this.AddLog2("NEW BEST SCORE = " + Conversion.Str((object) moveScore));
            }
            else if (flag1)
              this.AddLog2("OLD BEST SCORE = " + Conversion.Str((object) Number1));
          }
        }
        if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100 & this.MoveMatrixCounter > 3)
        {
          bool[] flagArray1 = new bool[2];
          float num44 = 1.1f;
          if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
            num44 = 0.9f;
          if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 250)
            num44 = 0.0f;
          this.AddLog2("START SYSTEMATICAL CORTEX");
          this.AddExtraMarkers();
          int moveMatrixCounter7 = this.MoveMatrixCounter;
          int index24;
          for (int index25 = 1; index25 <= moveMatrixCounter7; ++index25)
          {
            num10 = this.BestMove.FindNr(-1, index25);
            int unr = this.MoveMatrixUnit[index25];
            if (unr > -1 & (double) num44 < 1.0 && !this.game.Data.UnitObj[unr].TempStrategic)
            {
              if (this.game.Data.UnitObj[unr].TempCategory == 1)
                simpleList2 = this.MarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 2)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 5)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 3)
                simpleList2 = this.AirMarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 4)
                simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
              bool[] flagArray2 = new bool[simpleList2.Counter + 1];
              for (int counter = simpleList2.Counter; counter >= 0; counter += -1)
              {
                flagArray2[counter] = true;
                if ((double) VBMath.Rnd() > (double) num44 | simpleList2.Id[counter] < 9999)
                {
                  if (simpleList2.Data3[counter] > -1)
                  {
                    if (this.game.HandyFunctionsObj.MoveApCostPreview(unr, simpleList2.Data1[counter], simpleList2.Data2[counter], simpleList2.Data1[counter], simpleList2.Data2[counter], 0, simpleList2.Data3[counter], simpleList2.Data4[counter], 0, true).x + this.MoveMatrix[index25, simpleList2.Data1[counter], simpleList2.Data2[counter]] > this.game.HandyFunctionsObj.GetLowestAp(unr))
                      flagArray2[counter] = false;
                  }
                  else if (this.MoveMatrix[index25, simpleList2.Data1[counter], simpleList2.Data2[counter]] > this.game.HandyFunctionsObj.GetLowestAp(unr))
                    flagArray2[counter] = false;
                }
                else
                  flagArray2[counter] = false;
              }
              int counter2 = simpleList2.Counter;
              for (index24 = 0; index24 <= counter2; ++index24)
              {
                if (flagArray2[index24])
                {
                  SimpleList TempMove = new SimpleList();
                  int counter3 = this.BestMove.Counter;
                  for (int index26 = 0; index26 <= counter3; ++index26)
                    TempMove.Add(this.BestMove.Id[index26], this.BestMove.Weight[index26], this.BestMove.Data1[index26], this.BestMove.Data2[index26], this.BestMove.Data3[index26], this.BestMove.Data4[index26], this.BestMove.Data5[index26], false, true);
                  int moveMatrixCounter8 = this.MoveMatrixCounter;
                  for (int index27 = 1; index27 <= moveMatrixCounter8; ++index27)
                    this.MoveMatrixUnitMarker[index27] = this.TempMoveMatrixUnitMarker[index27];
                  this.MoveMatrixUnitMarker[index25] = index24;
                  int nr = TempMove.FindNr(-1, index25);
                  if (nr > -1)
                  {
                    TempMove.Weight[nr] = 1;
                    TempMove.Data1[nr] = index25;
                    TempMove.Data2[nr] = index24;
                    TempMove.Data3[nr] = simpleList2.Data1[index24];
                    TempMove.Data4[nr] = simpleList2.Data2[index24];
                  }
                  else
                  {
                    ++tid;
                    TempMove.Add(tid, 1, index25, index24, simpleList2.Data1[index24], simpleList2.Data2[index24], CheckExistence: false, CheckData1Existence: true);
                  }
                  int moveScore = this.GetMoveScore(TempMove, false, quicktest);
                  if (moveScore > Number1)
                  {
                    int moveMatrixCounter9 = this.MoveMatrixCounter;
                    for (int index28 = 1; index28 <= moveMatrixCounter9; ++index28)
                      this.TempMoveMatrixUnitMarker[index28] = this.MoveMatrixUnitMarker[index28];
                    this.AddLog2(Conversion.Str((object) index24) + ") New sys Bestscore=" + Conversion.Str((object) Number1) + ", CurrentScore = " + Conversion.Str((object) moveScore));
                    this.BestMove = TempMove;
                    Number1 = moveScore;
                  }
                  if (index24 % 20 == 0)
                  {
                    this.game.EditObj.AIProgressMax = this.MoveMatrixCounter;
                    this.game.EditObj.AIProgressNow = index25;
                    this.game.EditObj.TempAIString = "Systematical finetuning. Round " + Conversion.Str((object) index25) + "/" + Conversion.Str((object) this.MoveMatrixCounter);
                  }
                }
              }
            }
          }
          this.AddLog2("START SYSTEMATICAL ATTACK PERMUTATIONS");
          bool[] flagArray3 = new bool[this.MarkerList.Counter + 1];
          bool[] flagArray4 = new bool[this.MoveMatrixCounter + 1];
          int counter4 = this.MarkerList.Counter;
          for (int index29 = 0; index29 <= counter4; ++index29)
          {
            int num45 = 0;
            if (!flagArray3[index29])
            {
              SimpleList TempMove = new SimpleList();
              int counter5 = this.BestMove.Counter;
              for (int index30 = 0; index30 <= counter5; ++index30)
                TempMove.Add(this.BestMove.Id[index30], this.BestMove.Weight[index30], this.BestMove.Data1[index30], this.BestMove.Data2[index30], this.BestMove.Data3[index30], this.BestMove.Data4[index30], this.BestMove.Data5[index30], false, true);
              int moveMatrixCounter10 = this.MoveMatrixCounter;
              for (int index31 = 1; index31 <= moveMatrixCounter10; ++index31)
                this.MoveMatrixUnitMarker[index31] = this.TempMoveMatrixUnitMarker[index31];
              bool[] flagArray5 = new bool[this.MoveMatrixCounter + 1];
              if (this.MarkerList.Weight[index29] == 1 & !flagArray3[index29])
              {
                int moveMatrixCounter11 = this.MoveMatrixCounter;
                for (int tdata1 = 1; tdata1 <= moveMatrixCounter11; ++tdata1)
                {
                  if (!flagArray5[tdata1])
                  {
                    int unr = this.MoveMatrixUnit[tdata1];
                    if (this.game.Data.UnitObj[unr].TempCategory == 1)
                    {
                      int num46 = 9999;
                      int num47 = -1;
                      int counter6 = this.MarkerList.Counter;
                      for (int index32 = 0; index32 <= counter6; ++index32)
                      {
                        if (this.MarkerList.Data3[index29] == this.MarkerList.Data3[index32] && this.MarkerList.Data4[index29] == this.MarkerList.Data4[index32])
                        {
                          flagArray3[index32] = true;
                          if (this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] <= this.game.HandyFunctionsObj.GetLowestAp(unr))
                          {
                            int x = this.game.HandyFunctionsObj.MoveApCostPreview(unr, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32], this.MarkerList.Data1[index32], this.MarkerList.Data2[index32], 0, this.MarkerList.Data3[index32], this.MarkerList.Data4[index32], 0, true).x;
                            if (this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] + x <= this.game.HandyFunctionsObj.GetLowestAp(unr) && x + this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] < num46)
                            {
                              num46 = this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] + x;
                              num47 = index32;
                            }
                          }
                        }
                      }
                      if (num47 > -1)
                      {
                        int tdata2 = num47;
                        int nr = this.BestMove.FindNr(-1, tdata1);
                        flagArray5[tdata1] = true;
                        int num48 = this.MoveMatrixUnit[tdata1];
                        ++num45;
                        if (nr > -1)
                        {
                          TempMove.Weight[nr] = 1;
                          TempMove.Data1[nr] = tdata1;
                          TempMove.Data2[nr] = tdata2;
                          TempMove.Data3[nr] = this.MarkerList.Data1[tdata2];
                          TempMove.Data4[nr] = this.MarkerList.Data2[tdata2];
                        }
                        else
                        {
                          ++tid;
                          TempMove.Add(tid, 1, tdata1, tdata2, this.MarkerList.Data1[tdata2], this.MarkerList.Data2[tdata2], CheckExistence: false, CheckData1Existence: true);
                        }
                        this.MoveMatrixUnitMarker[tdata1] = tdata2;
                      }
                    }
                  }
                }
              }
              if (num45 > 0)
              {
                int moveScore = this.GetMoveScore(TempMove, false, quicktest);
                if (moveScore > Number1)
                {
                  int moveMatrixCounter12 = this.MoveMatrixCounter;
                  for (int index33 = 1; index33 <= moveMatrixCounter12; ++index33)
                    this.TempMoveMatrixUnitMarker[index33] = this.MoveMatrixUnitMarker[index33];
                  this.AddLog2(Conversion.Str((object) index24) + ") Attack permutations Bestscore=" + Conversion.Str((object) Number1) + ", CurrentScore = " + Conversion.Str((object) moveScore));
                  this.BestMove = TempMove;
                  Number1 = moveScore;
                }
                this.game.EditObj.AIProgressMax = simpleList2.Counter;
                this.game.EditObj.AIProgressNow = index29;
                this.game.EditObj.TempAIString = "Systematical attack permutations.";
              }
            }
          }
          if (!Information.IsNothing((object) this.BestMove))
          {
            int moveMatrixCounter13 = this.MoveMatrixCounter;
            for (int index34 = 1; index34 <= moveMatrixCounter13; ++index34)
              this.MoveMatrixUnitMarker[index34] = this.TempMoveMatrixUnitMarker[index34];
          }
        }
        if (this.LogCounter2 <= -1)
          return;
        this.LogTxt = new string[this.LogCounter2 + 1];
        this.LogCounter = this.LogCounter2;
        int logCounter2 = this.LogCounter2;
        for (int index35 = 0; index35 <= logCounter2; ++index35)
          this.LogTxt[index35] = this.LogTxt2[index35];
        this.WriteLog("FullAILog_1_30_" + this.GroupName[this.OpGroup] + "_40_scoring_round" + this.MoveAndAttackRound.ToString());
        this.LogCounter = -1;
        this.LogCounter2 = -1;
      }
    }

    public int GetSameTargetAsOtherUnit(int unitslot, int unr)
    {
      int moveMatrixCounter1 = this.MoveMatrixCounter;
      int num1;
      for (int index = 1; index <= moveMatrixCounter1; ++index)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == this.game.Data.UnitObj[unr].TempCategory && this.MoveMatrixUnit[index] != unr)
          ++num1;
      }
      if (num1 == 0)
        return -1;
      int num2 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) num1)) + 1;
      int num3 = 0;
      int moveMatrixCounter2 = this.MoveMatrixCounter;
      for (int index = 1; index <= moveMatrixCounter2; ++index)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == this.game.Data.UnitObj[unr].TempCategory && this.MoveMatrixUnit[index] != unr)
        {
          ++num3;
          if (num2 == num3)
            return this.MoveMatrixUnitMarker[index];
        }
      }
      return -1;
    }

    public int GetNormalDefensiveCenterMarker(int unr, int unitslot)
    {
      SimpleList markerList = this.MarkerList;
      int aiDefend = this.game.Data.UnitObj[unr].AIDefend;
      if (aiDefend > -1)
      {
        int counter = markerList.Counter;
        for (int defensiveCenterMarker = 0; defensiveCenterMarker <= counter; ++defensiveCenterMarker)
        {
          if (markerList.Data1[defensiveCenterMarker] == this.AreaCenter[aiDefend].x & markerList.Data2[defensiveCenterMarker] == this.AreaCenter[aiDefend].y && this.MoveMatrix[unitslot, markerList.Data1[defensiveCenterMarker], markerList.Data2[defensiveCenterMarker]] < 9999)
            return defensiveCenterMarker;
        }
      }
      return -1;
    }

    public int GetNormalFallbackCenterMarker(int unr, int unitslot)
    {
      SimpleList markerList = this.MarkerList;
      int aiFallback = this.game.Data.UnitObj[unr].AIFallback;
      if (aiFallback > -1)
      {
        int counter = markerList.Counter;
        for (int fallbackCenterMarker = 0; fallbackCenterMarker <= counter; ++fallbackCenterMarker)
        {
          if (markerList.Data1[fallbackCenterMarker] == this.AreaCenter[aiFallback].x & markerList.Data2[fallbackCenterMarker] == this.AreaCenter[aiFallback].y && this.MoveMatrix[unitslot, markerList.Data1[fallbackCenterMarker], markerList.Data2[fallbackCenterMarker]] < 9999)
            return fallbackCenterMarker;
        }
      }
      return -1;
    }

    public int GetRandomSameTarget(SimpleList TempMove, int TempMarker, int UnitSlot, int Unr)
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList.Counter != -1 ? this.EngineerMarkerList : this.MarkerList;
      if (Information.IsNothing((object) Expression) || Expression.Weight[TempMarker] != 1)
        return TempMarker;
      int num1 = -1;
      int counter1 = Expression.Counter;
      for (int index = 0; index <= counter1; ++index)
      {
        if (TempMarker != index && Expression.Data3[index] == Expression.Data3[TempMarker] & Expression.Data4[index] == Expression.Data4[TempMarker] && this.MoveMatrix[UnitSlot, Expression.Data1[index], Expression.Data2[index]] < 9999 | this.game.Data.UnitObj[Unr].X == Expression.Data1[index] & this.game.Data.UnitObj[Unr].Y == Expression.Data2[index])
          ++num1;
      }
      if (num1 > -1)
      {
        int num2 = (int) Math.Round((double) (VBMath.Rnd() * (float) (num1 + 1)));
        int num3 = -1;
        int counter2 = Expression.Counter;
        for (int randomSameTarget = 0; randomSameTarget <= counter2; ++randomSameTarget)
        {
          if (TempMarker != randomSameTarget && Expression.Data3[randomSameTarget] == Expression.Data3[TempMarker] & Expression.Data4[randomSameTarget] == Expression.Data4[TempMarker] && this.MoveMatrix[UnitSlot, Expression.Data1[randomSameTarget], Expression.Data2[randomSameTarget]] < 9999 | this.game.Data.UnitObj[Unr].X == Expression.Data1[randomSameTarget] & this.game.Data.UnitObj[Unr].Y == Expression.Data2[randomSameTarget])
          {
            ++num3;
            if (num2 == num3)
              return randomSameTarget;
          }
        }
      }
      return TempMarker;
    }

    public void Backup_FindBestMove()
    {
      int Number = -9999;
      int num1 = 0;
      bool flag1 = this.GetLargestArmy() == this.GetGameDataTurn();
      this.HistoryScoreList = new SimpleList();
      this.HistoryMoveCounter = 0;
      this.BestMove = (SimpleList) null;
      if (this.MarkerList.Counter == -1)
        return;
      int tid = 0;
      int num2 = this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE;
      if (this.MoveMatrixCounter > 12)
        num2 = (int) Math.Round((double) num2 * Math.Sqrt((double) this.MoveMatrixCounter / 12.0));
      if (this.MoveMatrixCounter < 8)
        num2 = (int) Math.Round((double) num2 * ((double) this.MoveMatrixCounter / 8.0));
      int num3 = 99999;
      int num4 = 9999;
      int num5 = 9999;
      int index1 = 1;
      do
      {
        this.MoveMatrixUnitMarker[index1] = -1;
        this.TempMoveMatrixUnitMarker[index1] = -1;
        ++index1;
      }
      while (index1 <= 90);
      while (num1 < num2)
      {
        SimpleList TempMove = new SimpleList();
        ++num1;
        if (num1 == 1)
          this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + " is moving. Round = " + Conversion.Str((object) this.MoveAndAttackRound);
        bool flag2 = false;
        if ((double) VBMath.Rnd() < 0.05)
        {
          num4 = 9999;
          flag2 = true;
        }
        else if ((double) VBMath.Rnd() < 0.05)
        {
          num5 = 9999;
          flag2 = true;
        }
        int index2 = 1;
        do
        {
          this.MoveMatrixUnitMarker[index2] = -1;
          ++index2;
        }
        while (index2 <= 90);
        SimpleList simpleList1 = new SimpleList();
        float num6 = VBMath.Rnd();
        float trnd = VBMath.Rnd();
        VBMath.Rnd();
        VBMath.Rnd();
        int moveMatrixCounter1 = this.MoveMatrixCounter;
        SimpleList simpleList2;
        int tdata2_1;
        for (int index3 = 1; index3 <= moveMatrixCounter1; ++index3)
        {
          int index4 = this.MoveMatrixUnit[index3];
          if (index4 > -1)
          {
            if (this.game.Data.UnitObj[index4].TempCategory == 1)
              simpleList2 = this.MarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 2)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 5)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 3)
              simpleList2 = this.AirMarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 4)
              simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
            int num7;
            if (this.game.Data.UnitObj[index4].TempStrategic)
            {
              int index5 = this.game.Data.UnitObj[index4].AIAttackStyle != 3 ? this.game.Data.UnitObj[index4].AIDefend : this.game.Data.UnitObj[index4].AIAttack;
              if (index5 > -1)
              {
                int x = this.AreaCenter[index5].x;
                int y = this.AreaCenter[index5].y;
                int num8 = -1;
                if (this.game.Data.MapObj[0].HexObj[x, y].UnitCounter > -1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
                {
                  int counter = simpleList2.Counter;
                  for (int index6 = 0; index6 <= counter; ++index6)
                  {
                    if (this.GetTscore(simpleList2.Data1[index6], simpleList2.Data2[index6]) > num8)
                    {
                      x = simpleList2.Data1[index6];
                      y = simpleList2.Data2[index6];
                      num8 = this.GetTscore(x, y);
                    }
                  }
                }
                tdata2_1 = -1;
                int counter1 = simpleList2.Counter;
                for (int index7 = 0; index7 <= counter1; ++index7)
                {
                  if (simpleList2.Data1[index7] == x & simpleList2.Data2[index7] == y)
                    tdata2_1 = index7;
                }
                if (tdata2_1 == -1)
                {
                  simpleList2.Add(50000 + tid, 2, x, y, -1, -1);
                  tdata2_1 = simpleList2.Counter;
                }
                TempMove.Add(tid, 1, index3, tdata2_1, x, y, CheckExistence: false);
                num7 = 0;
                this.MoveMatrixUnitMarker[index3] = tdata2_1;
              }
            }
            else if (!Information.IsNothing((object) simpleList2))
            {
              if (flag2 | num1 <= 10 | (double) VBMath.Rnd() <= 1.0 / (double) Math.Min(10, this.MoveMatrixCounter))
              {
                ++tid;
                int num9 = 1;
                int num10 = 0;
                if ((this.Attacker & (double) num6 < 0.1 | !this.Attacker & (double) num6 < 0.05) & !this.game.Data.UnitObj[index4].IsHQ)
                {
                  this.AddLog("SHOCKAWE DOCTRINE");
                  tdata2_1 = this.ReturnShockAndAweMarker(simpleList2, trnd, index3, index4);
                  if (tdata2_1 > -1)
                  {
                    int tdata3 = simpleList2.Data1[tdata2_1];
                    int tdata4 = simpleList2.Data2[tdata2_1];
                    if (tdata3 == 13)
                      tdata3 = tdata3;
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if ((this.Attacker & (double) num6 < 0.1 | !this.Attacker & (double) num6 < 0.05) & this.game.Data.UnitObj[index4].IsHQ)
                {
                  tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                  if (tdata2_1 > -1)
                  {
                    int tdata3 = simpleList2.Data1[tdata2_1];
                    int tdata4 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num3 >= num1)
                {
                  this.AddLog("DONT MOVE DOCTRINE 1");
                  tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                  num3 = num1;
                  if (tdata2_1 > -1)
                  {
                    int tdata3 = simpleList2.Data1[tdata2_1];
                    int tdata4 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num4 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & !this.game.Data.UnitObj[index4].IsHQ)
                {
                  this.AddLog("DOCTRINE2");
                  tdata2_1 = this.game.Data.UnitObj[index4].AIAttack <= -1 ? this.GetMarkerForCoordinate(index4, this.AreaCenter[this.game.Data.UnitObj[index4].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index4].AIDefend].y) : this.GetMarkerForCoordinate(index4, this.AreaCenter[this.game.Data.UnitObj[index4].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index4].AIAttack].y);
                  num4 = num1;
                  if (tdata2_1 > -1 && tdata2_1 > -1)
                  {
                    int tdata3 = simpleList2.Data1[tdata2_1];
                    int tdata4 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num4 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & this.game.Data.UnitObj[index4].IsHQ)
                {
                  int tdata2_2 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                  int tdata3 = simpleList2.Data1[tdata2_2];
                  int tdata4 = simpleList2.Data2[tdata2_2];
                  TempMove.Add(tid, 1, index3, tdata2_2, tdata3, tdata4, CheckExistence: false);
                  num9 = 0;
                  this.MoveMatrixUnitMarker[index3] = tdata2_2;
                }
                else if (num5 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & !this.game.Data.UnitObj[index4].IsHQ)
                {
                  this.AddLog("DOCTRINE3");
                  num5 = num1;
                  if (tdata2_1 > -1 && tdata2_1 > -1)
                  {
                    int tdata3 = simpleList2.Data1[tdata2_1];
                    int tdata4 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num5 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & this.game.Data.UnitObj[index4].IsHQ)
                {
                  int tdata2_3 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                  int tdata3 = simpleList2.Data1[tdata2_3];
                  int tdata4 = simpleList2.Data2[tdata2_3];
                  TempMove.Add(tid, 1, index3, tdata2_3, tdata3, tdata4, CheckExistence: false);
                  num9 = 0;
                  this.MoveMatrixUnitMarker[index3] = tdata2_3;
                }
                while (num9 == 1 & num10 < 100)
                {
                  ++num10;
                  int tdata2_4 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                  if (this.MoveMatrix[index3, simpleList2.Data1[tdata2_4], simpleList2.Data2[tdata2_4]] < 9999 | this.game.Data.UnitObj[index4].X == simpleList2.Data1[tdata2_4] & this.game.Data.UnitObj[index4].Y == simpleList2.Data2[tdata2_4])
                  {
                    int tdata3;
                    int tdata4;
                    if ((double) VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index4].TempCategory == 1)
                    {
                      tdata3 = (int) Math.Round((double) ((float) simpleList2.Data1[tdata2_4] + Conversion.Int((float) ((double) VBMath.Rnd() * 4.0 - 2.0))));
                      tdata4 = (int) Math.Round((double) ((float) simpleList2.Data2[tdata2_4] + Conversion.Int((float) ((double) VBMath.Rnd() * 4.0 - 2.0))));
                      if (tdata3 < 0 | tdata4 < 0 | tdata3 > this.game.Data.MapObj[0].MapWidth | tdata4 > this.game.Data.MapObj[0].MapHeight)
                      {
                        tdata3 = simpleList2.Data1[tdata2_4];
                        tdata4 = simpleList2.Data2[tdata2_4];
                      }
                      if (this.MoveMatrix[index3, tdata3, tdata4] >= 9999)
                      {
                        tdata3 = simpleList2.Data1[tdata2_4];
                        tdata4 = simpleList2.Data2[tdata2_4];
                      }
                    }
                    else if ((double) VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index4].TempCategory != 3 & this.CorpsStance[this.OpGroup] == 1)
                    {
                      tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                      if (tdata2_1 > -1)
                        tdata2_4 = tdata2_1;
                      tdata3 = simpleList2.Data1[tdata2_4];
                      tdata4 = simpleList2.Data2[tdata2_4];
                    }
                    else if ((double) VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index4].IsHQ)
                    {
                      tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                      if (tdata2_1 > -1)
                        tdata2_4 = tdata2_1;
                      tdata3 = simpleList2.Data1[tdata2_4];
                      tdata4 = simpleList2.Data2[tdata2_4];
                    }
                    else
                    {
                      tdata3 = simpleList2.Data1[tdata2_4];
                      tdata4 = simpleList2.Data2[tdata2_4];
                    }
                    ++tid;
                    TempMove.Add(tid, 1, index3, tdata2_4, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_4;
                  }
                }
              }
              else
              {
                if (this.game.Data.UnitObj[index4].IsHQ)
                  index4 = index4;
                float num11 = (float) Math.Sqrt(Math.Sqrt((double) ((float) new Random(num1 + this.game.Data.Round * 4002).Next(0, 100000) / 100000f)));
                if ((double) VBMath.Rnd() > 0.5)
                  num11 = 1f;
                float num12 = 1f / (float) (1 + this.MoveMatrixCounter);
                if ((double) VBMath.Rnd() < 0.5)
                  num12 = (float) (((double) num12 + 1.0) / 2.0);
                else if ((double) VBMath.Rnd() < 0.5)
                  num12 = VBMath.Rnd();
                for (int tdata2_5 = this.HistoryScoreList.Counter; tdata2_5 >= 0; tdata2_5 += -1)
                {
                  int num13 = this.HistoryScoreList.Weight[this.HistoryScoreList.Counter] - this.HistoryScoreList.Weight[0];
                  if ((double) ((float) (this.HistoryScoreList.Weight[tdata2_5] - this.HistoryScoreList.Weight[0]) / (float) num13) <= (double) num11)
                  {
                    int index8 = this.HistoryScoreList.Id[tdata2_5];
                    ++tid;
                    int index9;
                    if ((double) VBMath.Rnd() < (double) num12)
                    {
                      index9 = this.HistoryMove[index8].FindNr(-1, index3);
                      this.AddLog("COPY SELF EXISTING");
                    }
                    else if ((double) VBMath.Rnd() < 0.7)
                    {
                      index9 = (int) Math.Round((double) Conversion.Int((float) (this.HistoryMove[index8].Counter + 1) * VBMath.Rnd()));
                      if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.HistoryMove[index8].Data1[index9]]].TempCategory == this.game.Data.UnitObj[index4].TempCategory)
                      {
                        if ((double) VBMath.Rnd() < 0.5 & this.game.Data.UnitObj[index4].TempCategory == 1)
                        {
                          int moveMatrixCounter2 = this.MoveMatrixCounter;
                          for (int index10 = 1; index10 <= moveMatrixCounter2; ++index10)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == 1 && this.game.Data.UnitObj[this.MoveMatrixUnit[index3]].Historical == this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical & this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical > -1)
                            {
                              tdata2_1 = this.GetRandomSameTarget(this.HistoryMove[index8], this.HistoryMove[index8].Data2[index9], index10, this.MoveMatrixUnit[index10]);
                              if (tdata2_1 > -1 && this.MoveMatrix[index10, simpleList2.Data1[tdata2_1], simpleList2.Data2[tdata2_1]] < 9999 | this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].X == simpleList2.Data1[tdata2_1] & this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Y == simpleList2.Data2[tdata2_1])
                              {
                                int tdata3 = simpleList2.Data1[tdata2_1];
                                int tdata4 = simpleList2.Data2[tdata2_1];
                                TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false);
                                this.MoveMatrixUnitMarker[index10] = tdata2_1;
                                this.AddLog("WHOLE HIS UNIT TAKE MARKER FROM OTHER");
                              }
                            }
                          }
                        }
                        else
                        {
                          int index11 = index3;
                          tdata2_1 = this.GetRandomSameTarget(this.HistoryMove[index8], this.HistoryMove[index8].Data2[index9], index11, this.MoveMatrixUnit[index11]);
                          if (tdata2_1 > -1)
                          {
                            if (this.MoveMatrix[index11, simpleList2.Data1[tdata2_1], simpleList2.Data2[tdata2_1]] < 9999 | this.game.Data.UnitObj[this.MoveMatrixUnit[index11]].X == simpleList2.Data1[tdata2_1] & this.game.Data.UnitObj[this.MoveMatrixUnit[index11]].Y == simpleList2.Data2[tdata2_1])
                            {
                              int tdata3 = simpleList2.Data1[tdata2_1];
                              int tdata4 = simpleList2.Data2[tdata2_1];
                              TempMove.Add(tid, 1, index11, tdata2_1, tdata3, tdata4, CheckExistence: false);
                              this.MoveMatrixUnitMarker[index11] = tdata2_1;
                              this.AddLog("SINGLE UNIT COPY MARKER");
                              break;
                            }
                            index9 = this.HistoryMove[index8].FindNr(-1, index3);
                          }
                        }
                      }
                      else
                        index9 = this.HistoryMove[index8].FindNr(-1, index3);
                    }
                    else
                    {
                      tdata2_5 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (simpleList2.Counter + 1)));
                      int tdata3 = simpleList2.Data1[tdata2_5];
                      int tdata4 = simpleList2.Data2[tdata2_5];
                      ++tid;
                      TempMove.Add(tid, 1, index3, tdata2_5, tdata3, tdata4, CheckExistence: false);
                      num7 = 0;
                      this.MoveMatrixUnitMarker[index3] = tdata2_5;
                      index9 = -1;
                    }
                    if (index9 > -1)
                    {
                      TempMove.Add(tid, 1, index3, this.HistoryMove[index8].Data2[index9], this.HistoryMove[index8].Data3[index9], this.HistoryMove[index8].Data4[index9], this.HistoryMove[index8].Data5[index9], false);
                      this.MoveMatrixUnitMarker[index3] = this.HistoryMove[index8].Data2[index9];
                      break;
                    }
                    break;
                  }
                }
              }
            }
          }
        }
        int moveMatrixCounter3 = this.MoveMatrixCounter;
        for (int unitslot = 1; unitslot <= moveMatrixCounter3; ++unitslot)
        {
          int unr = this.MoveMatrixUnit[unitslot];
          if (unr > -1 & (double) VBMath.Rnd() > 0.9)
          {
            if (this.game.Data.UnitObj[unr].TempCategory == 3)
              ;
            tdata2_1 = this.GetSameTargetAsOtherUnit(unitslot, unr);
            if (tdata2_1 > -1)
              this.MoveMatrixUnitMarker[unitslot] = tdata2_1;
          }
          if (unr > -1)
          {
            simpleList2 = (SimpleList) null;
            if (this.game.Data.UnitObj[unr].TempCategory == 1)
              simpleList2 = this.MarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 2)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 5)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 3)
              simpleList2 = this.AirMarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 4)
              simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
            if (!Information.IsNothing((object) simpleList2) && (double) VBMath.Rnd() < 0.15 & this.game.Data.UnitObj[unr].TempCategory != 3 & this.CorpsStance[this.OpGroup] == 1)
            {
              tdata2_1 = this.GetSameCoordinateMarker(unr, simpleList2);
              if (tdata2_1 > -1)
                this.MoveMatrixUnitMarker[unitslot] = tdata2_1;
            }
          }
        }
        int moveScore = this.GetMoveScore(TempMove, false);
        this.AddLog("CurrentScore = " + Conversion.Str((object) moveScore) + ", BestScore = " + Conversion.Str((object) Number));
        if (moveScore != Number)
        {
          this.HistoryMove[this.HistoryMoveCounter] = TempMove;
          this.HistoryScoreList.Add(this.HistoryMoveCounter, moveScore, CheckExistence: false);
          this.HistoryScoreList.Sort();
          ++this.HistoryMoveCounter;
          num1 = num1;
          if (this.HistoryScoreList.Counter > 50)
            this.HistoryScoreList.Remove(this.HistoryScoreList.Id[(int) Math.Round((double) VBMath.Rnd() * (double) this.HistoryScoreList.Counter * 0.5)]);
          if (moveScore > Number)
          {
            int moveMatrixCounter4 = this.MoveMatrixCounter;
            for (int index12 = 1; index12 <= moveMatrixCounter4; ++index12)
              this.TempMoveMatrixUnitMarker[index12] = this.MoveMatrixUnitMarker[index12];
            this.BestMove = TempMove;
            Number = moveScore;
          }
        }
      }
      if (Information.IsNothing((object) this.BestMove))
        return;
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index13 = 1; index13 <= moveMatrixCounter; ++index13)
        this.MoveMatrixUnitMarker[index13] = this.TempMoveMatrixUnitMarker[index13];
    }

    public int GetMarkerForSelfTarget(SimpleList TempMove, int TempMarker, int UnitSlot, int Unr)
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing((object) Expression))
        return TempMarker;
      int counter = Expression.Counter;
      for (int markerForSelfTarget = 0; markerForSelfTarget <= counter; ++markerForSelfTarget)
      {
        if (Expression.Data1[markerForSelfTarget] == this.game.Data.UnitObj[Unr].X & Expression.Data2[markerForSelfTarget] == this.game.Data.UnitObj[Unr].Y)
          return markerForSelfTarget;
      }
      return TempMarker;
    }

    public int GetMarkerForCoordinate(int Unr, int X, int y)
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing((object) Expression))
        return -1;
      SimpleList simpleList = new SimpleList();
      int counter = Expression.Counter;
      for (int tid = 0; tid <= counter; ++tid)
      {
        if (Expression.Data1[tid] == X & Expression.Data2[tid] == y)
          simpleList.Add(tid, (int) Math.Round((double) (VBMath.Rnd() * 1000f)));
      }
      simpleList.Sort();
      return simpleList.Counter > -1 ? simpleList.Id[0] : -1;
    }

    public int GetClosestMarkerForCoordinateTarget(int movematrixnr, int X, int y)
    {
      int unr = this.MoveMatrixUnit[movematrixnr];
      SimpleList Expression;
      if (this.game.Data.UnitObj[unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing((object) Expression))
        return -1;
      SimpleList simpleList = new SimpleList();
      int counter = Expression.Counter;
      for (int tid = 0; tid <= counter; ++tid)
      {
        if (Expression.Data3[tid] == X & Expression.Data4[tid] == y & (double) this.MoveMatrix[movematrixnr, Expression.Data1[tid], Expression.Data2[tid]] < (double) this.game.HandyFunctionsObj.GetLowestAp(unr) * 0.66)
        {
          int num = this.MoveMatrix[movematrixnr, Expression.Data1[tid], Expression.Data2[tid]];
          int tweight = (int) Math.Round((double) num * 0.8 + (double) num * (double) VBMath.Rnd() * 0.2);
          simpleList.Add(tid, tweight);
        }
      }
      simpleList.Sort();
      return simpleList.Counter > -1 ? simpleList.Id[0] : -1;
    }

    public int GetMarkerForClosestEnemy(int Unr, int AverageSupplyPercentage)
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing((object) Expression))
        return -1;
      SimpleList simpleList = new SimpleList();
      int counter = Expression.Counter;
      for (int tid = 0; tid <= counter; ++tid)
      {
        if (Expression.Weight[tid] == 1)
        {
          int num = this.game.HandyFunctionsObj.Distance(Expression.Data1[tid], Expression.Data2[tid], 0, this.game.Data.UnitObj[Unr].X, this.game.Data.UnitObj[Unr].Y, 0, 99);
          if (AverageSupplyPercentage < 40 & Expression.Data3[tid] > -1)
          {
            if (this.DistanceFromSuppliedHex[Expression.Data3[tid], Expression.Data4[tid]] <= 1)
              simpleList.Add(tid, num * 10 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
            else if (this.DistanceFromSuppliedHex[Expression.Data3[tid], Expression.Data4[tid]] <= 2)
              simpleList.Add(tid, num * 20 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
            else
              simpleList.Add(tid, num * 50 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
          }
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 35)
            simpleList.Add(tid, num * 10 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 20)
            simpleList.Add(tid, num * 15 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 10)
            simpleList.Add(tid, num * 20 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 5)
            simpleList.Add(tid, num * 25 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
          else
            simpleList.Add(tid, num * 50 + (int) Math.Round((double) (VBMath.Rnd() * 10f)));
        }
      }
      simpleList.Sort();
      return simpleList.Counter > -1 ? simpleList.Id[0] : -1;
    }

    public int GetMoveScore(SimpleList TempMove, bool MakeLog, bool quicktest = false)
    {
      if (this.OpGroup <= this.CorpsTopRatio.GetUpperBound(0))
      {
        if (quicktest)
        {
          if (MakeLog)
          {
            this.AddLog("***QUICK TEST SCORING MOVE***");
            this.AddLog("CORPSRATIO = " + Conversion.Str((object) this.CorpsTopRatio[this.OpGroup]));
          }
        }
        else if (MakeLog)
        {
          this.AddLog("***SCORING MOVE***");
          this.AddLog("CORPSRATIO = " + Conversion.Str((object) this.CorpsTopRatio[this.OpGroup]));
        }
      }
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        this.game.Data.UnitObj[index].TempX = -1;
        this.game.Data.UnitObj[index].TempY = -1;
        this.game.Data.UnitObj[index].FinalX = -1;
        this.game.Data.UnitObj[index].FinalY = -1;
      }
      int moveMatrixCounter1 = this.MoveMatrixCounter;
      for (int index = 1; index <= moveMatrixCounter1; ++index)
        this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempSlot = index;
      int moveMatrixCounter2 = this.MoveMatrixCounter;
      for (int tdata1 = 1; tdata1 <= moveMatrixCounter2; ++tdata1)
      {
        int num = -1;
        int counter = TempMove.Counter;
        for (int index = 0; index <= counter; ++index)
        {
          if (TempMove.Weight[index] >= 1 && tdata1 == TempMove.Data1[index])
          {
            num = index;
            break;
          }
        }
        int index1 = num;
        int unr = this.MoveMatrixUnit[tdata1];
        this.game.Data.UnitObj[unr].TempSlot = tdata1;
        int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(unr);
        int x = this.game.Data.UnitObj[unr].X;
        int y = this.game.Data.UnitObj[unr].Y;
        int index2;
        int index3;
        if (index1 == -1)
        {
          index2 = x;
          index3 = y;
        }
        else
        {
          index2 = TempMove.Data3[index1];
          index3 = TempMove.Data4[index1];
        }
        if (this.game.Data.UnitObj[unr].FinalX == -1)
        {
          this.game.Data.UnitObj[unr].FinalX = index2;
          this.game.Data.UnitObj[unr].FinalY = index3;
        }
        Coordinate coordinate1;
        if (this.game.Data.UnitObj[unr].TempCategory == 3)
        {
          if (lowestAp < this.MoveMatrix[tdata1, index2, index3])
          {
            index2 = x;
            index3 = y;
          }
        }
        else if (this.MoveMatrix[tdata1, index2, index3] == 9999)
        {
          index2 = x;
          index3 = y;
        }
        else
        {
          for (; lowestAp < this.MoveMatrix[tdata1, index2, index3] & !(x == index2 & y == index3); index3 = coordinate1.y)
          {
            sCoordinate sCoordinate = this.MoveMatrixCameFrom[tdata1, index2, index3];
            coordinate1.x = (int) sCoordinate.x;
            coordinate1.y = (int) sCoordinate.y;
            coordinate1.onmap = sCoordinate.onmap;
            if (!coordinate1.onmap)
            {
              index2 = x;
              index3 = y;
              break;
            }
            index2 = coordinate1.x;
          }
        }
        if (!this.game.HandyFunctionsObj.HasHexRoad(index2, index3, 0) && this.game.Data.UnitObj[unr].TempStrategic && !this.game.Data.UnitObj[unr].IsHQ && this.CanBeStrategiclyTransferred(unr))
        {
          Coordinate coordinate2 = this.MoveMatrixCloseRoad[tdata1];
          if (coordinate2.onmap)
          {
            index2 = coordinate2.x;
            index3 = coordinate2.y;
            if (MakeLog)
              this.AddLog("OVERRULE TO " + Conversion.Str((object) coordinate2.x) + "," + Conversion.Str((object) coordinate2.y));
          }
          else if (MakeLog)
            this.AddLog("CANT FIND OVERRULE");
        }
        this.game.Data.UnitObj[unr].TempX = index2;
        this.game.Data.UnitObj[unr].TempY = index3;
        if (MakeLog)
          this.AddLog(this.game.Data.UnitObj[unr].Name + " PROJECTED TO REACH " + Conversion.Str((object) index2) + "," + Conversion.Str((object) index3));
        if (!(this.game.Data.UnitObj[unr].TempX == this.game.Data.UnitObj[unr].X & this.game.Data.UnitObj[unr].TempY == this.game.Data.UnitObj[unr].Y))
        {
          if (TempMove.FindNr(-1, tdata1) == -1)
            ;
        }
      }
      int Number1 = 5000 + this.GetScoreForHexOccupationAndHQ2(ref TempMove, MakeLog);
      if (MakeLog)
        this.AddLog("***Score after Hex Occupation scores added = " + Conversion.Str((object) Number1));
      int scoreForAttacks = this.GetScoreForAttacks(true, MakeLog);
      int groupHq = this.GetGroupHQ(this.OpGroup);
      int Number2;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
      {
        float num = 1.25f;
        if ((double) this.game.Data.RuleVar[367] > 0.0)
          num *= this.game.Data.RuleVar[367] / 100f;
        Number2 = (int) Math.Round((double) ((float) scoreForAttacks * num));
      }
      else
      {
        float num = 1.25f;
        if ((double) this.game.Data.RuleVar[368] > 0.0)
          num *= this.game.Data.RuleVar[368] / 100f;
        Number2 = (int) Math.Round((double) ((float) scoreForAttacks * num));
      }
      if (Number2 > 0)
      {
        if (MakeLog)
          this.AddLog("Attack score = " + Conversion.Str((object) Number2));
        Number2 = this.MoveAndAttackRound != 1 ? (this.MoveAndAttackRound != 2 ? Number2 : (int) Math.Round((double) Number2 * 0.75 + 0.25 * (double) Number2 * ((double) Math.Min(100, this.GetFreeAP(true)) / 100.0))) : (int) Math.Round((double) Number2 * 0.5 + 0.5 * (double) Number2 * ((double) Math.Min(100, this.GetFreeAP(true)) / 100.0));
        if (MakeLog)
          this.AddLog("***AttackScore Modified for free Ap = " + Conversion.Str((object) Number2));
      }
      int Number3 = Number1 + Number2;
      if (MakeLog)
        this.AddLog("***Score after Attack scores added = " + Conversion.Str((object) Number3));
      int scoreForMovingIn = this.GetScoreForMovingIn(ref TempMove, MakeLog);
      int num1;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle != 3)
      {
        float num2 = 0.1f;
        if ((double) this.game.Data.RuleVar[369] > 0.0)
          num2 = (float) ((double) num2 * (double) this.game.Data.RuleVar[369] / 100.0);
        num1 = (int) Math.Round((double) ((float) scoreForMovingIn * num2));
      }
      else
      {
        float num3 = 0.2f;
        if ((double) this.game.Data.RuleVar[370] > 0.0)
          num3 = (float) ((double) num3 * (double) this.game.Data.RuleVar[370] / 100.0);
        num1 = (int) Math.Round((double) ((float) scoreForMovingIn * num3));
      }
      int Number4 = Number3 + num1;
      if (MakeLog)
        this.AddLog("***Score after for [moving in] scores added = " + Conversion.Str((object) Number4));
      this.CounterAttackPossible = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (!quicktest)
      {
        int counterAttackScore = this.GetCounterAttackScore(ref TempMove, MakeLog);
        int num4 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ((double) this.game.Data.RuleVar[372] != 0.0 ? (int) Math.Round((double) counterAttackScore * (double) this.game.Data.RuleVar[372] / 100.0) : counterAttackScore) : ((double) this.game.Data.RuleVar[371] != 0.0 ? (int) Math.Round((double) counterAttackScore * (double) this.game.Data.RuleVar[371] / 100.0) : (int) Math.Round((double) counterAttackScore * 1.25));
        if (this.GroupCounter > this.CorpsTopRatio.GetUpperBound(0))
          this.CorpsTopRatio = (float[]) Utils.CopyArray((Array) this.CorpsTopRatio, (Array) new float[this.GroupCounter + 1]);
        if ((double) this.CorpsTopRatio[this.OpGroup] > 1.0)
          num4 = (int) Math.Round((double) num4 / Math.Sqrt((double) this.CorpsTopRatio[this.OpGroup]));
        Number4 -= num4;
        if (MakeLog)
          this.AddLog("***Score after [counter attack score] subtracted = " + Conversion.Str((object) Number4));
      }
      if (!quicktest)
      {
        int num5 = (int) Math.Round((double) this.GetCounterMoveScore(ref TempMove, MakeLog) / Math.Max(1.0, Math.Sqrt(2.0 * (double) this.CorpsTopRatio[this.OpGroup])));
        int num6 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ((double) this.game.Data.RuleVar[374] != 0.0 ? (int) Math.Round((double) num5 * (double) this.game.Data.RuleVar[374] / 100.0) : num5) : ((double) this.game.Data.RuleVar[373] != 0.0 ? (int) Math.Round((double) num5 * (double) this.game.Data.RuleVar[373] / 100.0) : (int) Math.Round((double) num5 / 2.0));
        Number4 -= num6;
        if (MakeLog)
          this.AddLog("***Score after [counter move score] subtracted = " + Conversion.Str((object) Number4));
      }
      if (!quicktest)
      {
        int num7 = this.GetOurSelvesEncircledScore(ref TempMove, MakeLog);
        if (num7 > 0)
          num7 = num7;
        int num8 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ((double) this.game.Data.RuleVar[376] != 0.0 ? (int) Math.Round((double) num7 * (double) this.game.Data.RuleVar[376] / 100.0) : num7) : ((double) this.game.Data.RuleVar[375] != 0.0 ? (int) Math.Round((double) num7 * (double) this.game.Data.RuleVar[375] / 100.0) : num7);
        Number4 -= num8;
        if (MakeLog)
          this.AddLog("***Score after [GetOurselvesEncircled] subtracted = " + Conversion.Str((object) Number4));
      }
      if (!this.MovingIn)
      {
        int scoreForEntrench = this.GetScoreForEntrench(ref TempMove, MakeLog);
        Number4 += scoreForEntrench;
        if (MakeLog)
          this.AddLog("***Score after Entrench added = " + Conversion.Str((object) Number4));
      }
      if (!quicktest)
      {
        int enemyEncircledScore = this.GetEnemyEncircledScore(ref TempMove, MakeLog);
        int Number5 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ((double) this.game.Data.RuleVar[381] != 0.0 ? (int) Math.Round((double) enemyEncircledScore * (double) this.game.Data.RuleVar[381] / 100.0) : (int) Math.Round((double) enemyEncircledScore / 4.0)) : ((double) this.game.Data.RuleVar[380] != 0.0 ? (int) Math.Round((double) enemyEncircledScore * (double) this.game.Data.RuleVar[380] / 100.0) : (int) Math.Round((double) enemyEncircledScore / 4.0));
        if (MakeLog)
          this.AddLog(" encircle enemy /4 = " + Conversion.Str((object) Number5));
        Number4 += Number5;
        if (MakeLog)
          this.AddLog("***Score after [GetEnemyEncircled] added = " + Conversion.Str((object) Number4));
      }
      int Number6 = 0;
      int Number7 = 0;
      int Number8 = 0;
      int num9 = 0;
      int num10 = 0;
      if (!quicktest && this.game.Data.UnitObj[groupHq].AIAttackStyle == 3 & this.game.Data.RegimeObj[this.GetRegime(this.game.Data.Turn)].ProdBonus >= 100)
      {
        if (this.AAM1.x == 0 & this.AAM2.x == 0)
        {
          this.AAM2.x = this.game.Data.MapObj[0].MapWidth;
          this.AAM2.y = this.game.Data.MapObj[0].MapHeight;
        }
        int x1 = this.AAM1.x;
        int x2 = this.AAM2.x;
        for (int index4 = x1; index4 <= x2; ++index4)
        {
          int y1 = this.AAM1.y;
          int y2 = this.AAM2.y;
          for (int index5 = y1; index5 <= y2; ++index5)
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index4, index5].Regime) == this.GetGameDataTurn())
              Number6 += this.FullAdvanceMatrix[index4, index5];
            if (this.GetRegime(this.TempOwner[index4, index5]) == this.GetGameDataTurn() & this.TempCounterOwner[index4, index5] == this.GetGameDataTurn())
              Number7 += this.FullAdvanceMatrix[index4, index5];
            Number8 += this.FullAdvanceMatrix[index4, index5];
            if (this.FullAdvanceMatrix[index4, index5] > num9)
              num9 = this.FullAdvanceMatrix[index4, index5];
          }
        }
        int num11 = this.game.HandyFunctionsObj.GetGroupPowerPoints(groupHq) * 13;
        if (num11 > Number4)
          num11 = Number4;
        if (MakeLog)
          this.AddLog("Full Matrix score. Hexes. Started with " + Conversion.Str((object) Number6) + ", Ended with " + Conversion.Str((object) Number7) + " of total " + Conversion.Str((object) Number8));
        if ((double) this.game.Data.RuleVar[383] == 0.0 & Number8 > 0)
        {
          if (Number6 > Number7)
            Number4 += (int) Math.Round(0.0 - (double) num11 * 0.15 * ((double) (Number6 - Number7) / (double) Number8));
          else if (Number7 > Number6)
            Number4 += (int) Math.Round(0.0 + (double) num11 * 0.15 * ((double) (Number7 - Number6) / (double) Number8));
        }
        else if (Number8 > 0)
        {
          if (Number6 > Number7)
            Number4 += (int) Math.Round(0.0 - (double) num11 * ((double) this.game.Data.RuleVar[383] / 100.0) * ((double) (Number6 - Number7) / (double) Number8));
          else if (Number7 > Number6)
            Number4 += (int) Math.Round(0.0 + (double) num11 * ((double) this.game.Data.RuleVar[383] / 100.0) * ((double) (Number7 - Number6) / (double) Number8));
        }
        if (MakeLog)
          this.AddLog("***Score after [FullAdvanceMatrix Pts for Hexes] added = " + Conversion.Str((object) Number4));
        if ((double) this.CorpsTopRatio[this.OpGroup] > 2.0)
        {
          int Number9 = 0;
          int Number10 = 0;
          int moveMatrixCounter3 = this.MoveMatrixCounter;
          for (int index6 = 1; index6 <= moveMatrixCounter3; ++index6)
          {
            int index7 = this.MoveMatrixUnit[index6];
            if (this.game.Data.UnitObj[index7].TempCategory == 1)
            {
              int x3 = this.game.Data.UnitObj[index7].X;
              int y = this.game.Data.UnitObj[index7].Y;
              Number9 += this.FullAdvanceMatrix[x3, y];
              int index8 = this.game.Data.UnitObj[index7].TempX;
              int index9 = this.game.Data.UnitObj[index7].TempY;
              if (index8 == -1)
              {
                index8 = this.game.Data.UnitObj[index7].X;
                index9 = this.game.Data.UnitObj[index7].Y;
              }
              if (this.GetRegime(this.TempOwner[index8, index9]) == this.GetGameDataTurn() & this.TempCounterOwner[index8, index9] == this.GetGameDataTurn())
                Number10 += this.FullAdvanceMatrix[index8, index9];
              ++num10;
            }
          }
          int Number11 = num9 * num10;
          if (MakeLog)
            this.AddLog("Full Matrix score. Units Hex Values. Started with " + Conversion.Str((object) Number9) + ", Ended with " + Conversion.Str((object) Number10) + " of a total " + Conversion.Str((object) Number11));
          if ((double) this.game.Data.RuleVar[382] == 0.0 & Number11 > 0)
          {
            if (Number9 > Number10)
              Number4 += (int) Math.Round(0.0 - (double) num11 * 0.4 * ((double) (Number9 - Number10) / (double) Number11));
            else if (Number10 > Number9 & Number11 > 0)
              Number4 += (int) Math.Round(0.0 + (double) num11 * 0.4 * ((double) (Number10 - Number9) / (double) Number11));
          }
          else if (Number11 > 0)
          {
            if (Number9 > Number10)
              Number4 += (int) Math.Round(0.0 - (double) num11 * ((double) this.game.Data.RuleVar[382] / 100.0) * ((double) (Number9 - Number10) / (double) Number11));
            else if (Number10 > Number9 & Number11 > 0)
              Number4 += (int) Math.Round(0.0 + (double) num11 * ((double) this.game.Data.RuleVar[382] / 100.0) * ((double) (Number10 - Number9) / (double) Number11));
          }
          if (MakeLog)
            this.AddLog("***Score after [FullAdvanceMatrix Pts for Units] added = " + Conversion.Str((object) Number4));
        }
        else if (MakeLog)
          this.AddLog("No Full Matrix score calculated because group not strong enough to warrant it.");
      }
      int reconquestOfImportance = this.GetScoreForReconquestOfImportance();
      if (reconquestOfImportance != 0)
      {
        Number4 += reconquestOfImportance;
        if (MakeLog)
          this.AddLog("GOT " + Conversion.Str((object) reconquestOfImportance) + " FOR RECONQUESTS OR LOSSES OF IMPORTANCE! (such as supply bases)");
      }
      return Number4;
    }

    public int GetPercentTempUnits()
    {
      int unitCounter = this.game.Data.UnitCounter;
      int num1;
      int num2;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
        {
          ++num1;
          if (this.game.Data.UnitObj[index].TempGroup > -1)
            ++num2;
        }
      }
      return num1 == 0 ? 0 : (int) Math.Round(100.0 * ((double) num2 / (double) num1));
    }

    public int GetAbsoluteTempUnits(int grp)
    {
      int unitCounter = this.game.Data.UnitCounter;
      int absoluteTempUnits;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1)
        {
          if (this.game.Data.UnitObj[index].AIGroup == grp)
          {
            if (this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
            {
              int num;
              ++num;
              if (this.game.Data.UnitObj[index].TempGroup > -1)
                ++absoluteTempUnits;
            }
          }
          else if (this.game.Data.UnitObj[index].TempGroup == grp)
            ++absoluteTempUnits;
        }
      }
      return absoluteTempUnits;
    }

    public int GetAverageUnitPowerPointsAbsolute()
    {
      int unitCounter = this.game.Data.UnitCounter;
      int num1;
      int num2;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn())
        {
          num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          ++num2;
        }
      }
      if (num2 == 0)
        num2 = 1;
      return (int) Math.Round(Conversion.Int((double) num1 / (double) num2));
    }

    public int GetAverageEnemyUnitPowerPointsAbsolute()
    {
      int num1;
      int num2;
      if (this.EnemyMatrixCounter <= 1)
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int index = 1; index <= unitCounter; ++index)
        {
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.UnitObj[index].Regime))
          {
            int unr = index;
            if (unr > -1 & unr <= this.game.Data.UnitCounter)
              num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
            ++num2;
          }
        }
      }
      else
      {
        int enemyMatrixCounter = this.EnemyMatrixCounter;
        for (int index = 1; index <= enemyMatrixCounter; ++index)
        {
          int unr = this.EnemyMatrixUnit[index];
          if (unr > -1 & unr <= this.game.Data.UnitCounter)
            num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          ++num2;
        }
      }
      if (num2 == 0)
        num2 = 1;
      return (int) Math.Round(Conversion.Int((double) num1 / (double) num2));
    }

    public int GetEnemyEncircledScore(ref SimpleList tempMove, bool makelog)
    {
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
        }
      }
      if (makelog)
        this.AddLog("Get Enemy Encircled Score");
      int powerPointsAbsolute = this.GetAverageEnemyUnitPowerPointsAbsolute();
      int enemyMatrixCounter1 = this.EnemyMatrixCounter;
      Coordinate coordinate1;
      Coordinate coordinate2;
      int enemyEncircledScore;
      for (int index = 1; index <= enemyMatrixCounter1; ++index)
      {
        int unr = this.EnemyMatrixUnit[index];
        if (!this.game.Data.UnitObj[unr].IsVirtual)
        {
          int regime = this.game.Data.UnitObj[unr].Regime;
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.GetGameDataTurn(), this.GetRegime(regime)))
          {
            int num1 = 1;
            coordinate1.x = this.game.Data.UnitObj[unr].X;
            coordinate1.y = this.game.Data.UnitObj[unr].Y;
            coordinate1.onmap = false;
            if (coordinate1.x > -1 & coordinate1.y > -1)
              coordinate1.onmap = true;
            while (coordinate1.onmap & num1 == 1 & this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] != 0)
            {
              num1 = 0;
              if (regime == this.TempOwner[coordinate1.x, coordinate1.y] | this.game.Data.UnitObj[unr].X == coordinate1.x & this.game.Data.UnitObj[unr].Y == coordinate1.y)
              {
                int num2;
                if ((double) this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
                {
                  num2 = 1;
                  break;
                }
                if ((double) this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixEnemyRealCameFrom[coordinate1.x, coordinate1.y];
                  if (regime == this.TempOwner[coordinate2.x, coordinate2.y])
                  {
                    coordinate1 = coordinate2;
                    num2 = 1;
                    break;
                  }
                }
                if (num1 == 0 & (double) this.SupplyMatrixEnemyPrognosis[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixEnemyPrognosisCameFrom[coordinate1.x, coordinate1.y];
                  if (regime == this.TempOwner[coordinate2.x, coordinate2.y])
                  {
                    coordinate1 = coordinate2;
                    num1 = 1;
                  }
                }
              }
              if (num1 == 0)
              {
                int Number = (int) Math.Round(100.0 * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) Math.Max(1, powerPointsAbsolute)) * 0.15 * ((double) this.GetTscore(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y) / 100.0));
                if (makelog)
                  this.AddLog("ENEMY SOFT encircled: " + this.game.Data.UnitObj[unr].Name + ". Bonus pts =" + Conversion.Str((object) Number));
                enemyEncircledScore += Number;
              }
            }
          }
        }
      }
      int enemyMatrixCounter2 = this.EnemyMatrixCounter;
      for (int index3 = 1; index3 <= enemyMatrixCounter2; ++index3)
      {
        int unr = this.EnemyMatrixUnit[index3];
        if (!this.game.Data.UnitObj[unr].IsVirtual)
        {
          int regime = this.game.Data.UnitObj[unr].Regime;
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.GetGameDataTurn(), this.GetRegime(regime)))
          {
            int num3 = 1;
            coordinate1.x = this.game.Data.UnitObj[unr].X;
            coordinate1.y = this.game.Data.UnitObj[unr].Y;
            coordinate1.onmap = false;
            int num4 = 0;
            int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
            for (int index4 = 0; index4 <= mapWidth2; ++index4)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index5 = 0; index5 <= mapHeight; ++index5)
                this.ptemp3[index4, index5] = 0;
            }
            if (coordinate1.x > -1 & coordinate1.y > -1)
              coordinate1.onmap = true;
            while (coordinate1.onmap & num3 == 1 & this.SupplyMatrixEnemyPrognosis[coordinate1.x, coordinate1.y] != 0)
            {
              num3 = 0;
              if ((double) this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
              {
                coordinate2 = this.SupplyMatrixEnemyRealCameFrom[coordinate1.x, coordinate1.y];
                if (regime == this.TempCounterOwner[coordinate2.x, coordinate2.y] | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && this.ptemp3[coordinate2.x, coordinate2.y] == 0)
                {
                  coordinate1 = coordinate2;
                  num3 = 1;
                  ++num4;
                  if (num4 == 10)
                    break;
                }
              }
              if (num3 == 0 & (double) this.SupplyMatrixEnemyPrognosis[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
              {
                coordinate2 = this.SupplyMatrixEnemyPrognosisCameFrom[coordinate1.x, coordinate1.y];
                if (regime == this.TempCounterOwner[coordinate2.x, coordinate2.y] | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && this.ptemp3[coordinate2.x, coordinate2.y] == 0)
                {
                  coordinate1 = coordinate2;
                  num3 = 1;
                }
              }
              if (num3 == 0)
              {
                coordinate2.onmap = false;
                int tfacing = 1;
                do
                {
                  Coordinate coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing);
                  if (coordinate3.onmap && regime == this.TempCounterOwner[coordinate3.x, coordinate3.y] | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && (double) this.SupplyMatrixEnemyPrognosis[coordinate3.x, coordinate3.y] < (double) this.game.Data.RuleVar[53] && this.ptemp3[coordinate3.x, coordinate3.y] == 0)
                  {
                    if (!coordinate2.onmap)
                      coordinate2 = coordinate3;
                    else if (this.SupplyMatrixEnemyPrognosis[coordinate3.x, coordinate3.y] < this.SupplyMatrixEnemyPrognosis[coordinate2.x, coordinate2.y])
                      coordinate2 = coordinate3;
                  }
                  ++tfacing;
                }
                while (tfacing <= 6);
                if (coordinate2.onmap)
                {
                  coordinate1 = coordinate2;
                  num3 = 1;
                  this.ptemp3[coordinate1.x, coordinate1.y] = 1;
                }
              }
              if (num3 == 0)
              {
                int Number = (int) Math.Round(45.0 * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) Math.Max(1, powerPointsAbsolute)) * ((double) this.GetTscore(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y) / 100.0));
                if (makelog)
                  this.AddLog("ENEMY HARD encircled: " + this.game.Data.UnitObj[unr].Name + ". Bonus pts =" + Conversion.Str((object) Number));
                enemyEncircledScore += Number;
              }
            }
          }
        }
      }
      return enemyEncircledScore;
    }

    public int GetOurSelvesEncircledScore(ref SimpleList tempMove, bool makelog, bool IsTest = false)
    {
      if (makelog)
        this.AddLog("Get Ourselves Encircled Score");
      this.GetGroupHQ(this.OpGroup);
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
          this.ptemp3[index1, index2] = 0;
        }
      }
      int powerPointsAbsolute = this.GetAverageUnitPowerPointsAbsolute();
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
        this.game.Data.UnitObj[index].TempEncircled = 0;
      int groupHq = this.GetGroupHQ(this.OpGroup);
      bool flag = true;
      int num1 = 0;
      int num2;
      do
      {
        if (num1 == 0 & !this.game.Data.UnitObj[groupHq].IsHQ)
        {
          flag = true;
          num1 = 2;
        }
        Coordinate coordinate1;
        Coordinate coordinate2;
        Coordinate coordinate3;
        if (num1 == 0 | num1 == 2)
        {
          int moveMatrixCounter1 = this.MoveMatrixCounter;
          for (int index = 1; index <= moveMatrixCounter1; ++index)
          {
            int unr = this.MoveMatrixUnit[index];
            if (unr == groupHq | num1 == 2)
            {
              int num3 = 1;
              int num4 = (int) Math.Round((double) this.game.Data.RuleVar[52]);
              int num5 = Math.Max(0, (int) Math.Round((double) ((float) this.SupplyMatrixReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] - this.game.Data.RuleVar[51])));
              if (num4 > num5)
                num4 = num5;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              coordinate1.onmap = false;
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num3 == 1)
              {
                num3 = 0;
                if (this.SupplyMatrixReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] <= num4)
                {
                  num3 = 1;
                  break;
                }
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn() | this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate1.x, coordinate1.y]))
                {
                  if ((double) this.SupplyMatrixReal[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[52])
                  {
                    coordinate2 = this.SupplyMatrixRealCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate1.x, coordinate1.y]) | this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == -1)
                    {
                      coordinate1 = coordinate2;
                      num3 = 1;
                    }
                  }
                  if (num3 == 0 & (double) this.SupplyMatrixPrognosis[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[52])
                  {
                    coordinate2 = this.SupplyMatrixPrognosisCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == -1)
                    {
                      coordinate1 = coordinate2;
                      num3 = 1;
                    }
                  }
                }
                if (this.SupplyMatrixReal[coordinate1.x, coordinate1.y] > num4)
                {
                  if (num3 == 0)
                  {
                    int Number = !(this.game.Data.UnitObj[unr].IsHQ & powerPointsAbsolute > 0) ? 150 : (int) Math.Round(100.0 * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) powerPointsAbsolute) * 0.75);
                    if ((double) this.game.Data.UnitObj[unr].SupplyIn < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                      Number = (int) Math.Round((double) Number * 2.5);
                    if ((double) this.game.Data.UnitObj[unr].Supply < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                      Number = (int) Math.Round((double) Number * 1.5);
                    if (this.game.Data.UnitObj[unr].IsHQ)
                      Number *= 3;
                    if (!IsTest)
                      this.game.Data.UnitObj[unr].TempEncircled = 1;
                    if (makelog)
                      this.AddLog("NO EASY SUPPLY ROUTE TO HIGH HQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str((object) Number));
                    if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                      ;
                    num2 += Number;
                  }
                }
                else
                  break;
              }
              if (num3 == 0 & num1 == 0)
                flag = false;
            }
          }
          int moveMatrixCounter2 = this.MoveMatrixCounter;
          for (int index3 = 1; index3 <= moveMatrixCounter2; ++index3)
          {
            int unr = this.MoveMatrixUnit[index3];
            if (groupHq == unr)
            {
              int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
              for (int index4 = 0; index4 <= mapWidth2; ++index4)
              {
                int mapHeight = this.game.Data.MapObj[0].MapHeight;
                for (int index5 = 0; index5 <= mapHeight; ++index5)
                  this.ptemp3[index4, index5] = 0;
              }
              int num6 = 1;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              coordinate1.onmap = false;
              int num7 = 0;
              int num8 = (int) Math.Round((double) this.game.Data.RuleVar[52]);
              int num9 = Math.Max(0, (int) Math.Round((double) ((float) this.SupplyMatrixReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] - this.game.Data.RuleVar[51])));
              if (num8 > num9)
                num8 = num9;
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num6 == 1 & this.SupplyMatrixReal[coordinate1.x, coordinate1.y] != 0)
              {
                num6 = 0;
                if ((double) this.SupplyMatrixReal[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[52])
                {
                  coordinate2 = this.SupplyMatrixRealCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num6 = 1;
                    ++num7;
                    if (num7 >= 25)
                      break;
                  }
                }
                if (num6 == 0 & (double) this.SupplyMatrixPrognosis[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[52])
                {
                  coordinate2 = this.SupplyMatrixPrognosisCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num6 = 1;
                  }
                }
                if (num6 == 0)
                {
                  coordinate2.onmap = false;
                  int tfacing = 1;
                  do
                  {
                    coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing);
                    if (coordinate3.onmap && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate3.x, coordinate3.y]) && this.ptemp3[coordinate3.x, coordinate3.y] == 0 && this.SupplyMatrixPrognosis[coordinate3.x, coordinate3.y] < num8)
                    {
                      if (!coordinate2.onmap)
                        coordinate2 = coordinate3;
                      else if (this.SupplyMatrixPrognosis[coordinate3.x, coordinate3.y] < this.SupplyMatrixPrognosis[coordinate2.x, coordinate2.y])
                        coordinate2 = coordinate3;
                    }
                    ++tfacing;
                  }
                  while (tfacing <= 6);
                  if (coordinate2.onmap)
                  {
                    coordinate1 = coordinate2;
                    num6 = 1;
                    this.ptemp3[coordinate2.x, coordinate2.y] = 1;
                  }
                }
                if (this.SupplyMatrixReal[coordinate1.x, coordinate1.y] > num8)
                {
                  if (num6 == 0)
                  {
                    int Number = !(this.game.Data.UnitObj[unr].IsHQ & powerPointsAbsolute > 0) ? 50 : (int) Math.Round(100.0 * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) powerPointsAbsolute) * 0.25);
                    if ((double) this.game.Data.UnitObj[unr].SupplyIn < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                      Number = (int) Math.Round((double) Number * 2.5);
                    if ((double) this.game.Data.UnitObj[unr].Supply < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                      Number *= 3;
                    if (this.game.Data.UnitObj[unr].IsHQ)
                      Number *= 3;
                    if (!IsTest)
                      this.game.Data.UnitObj[unr].TempEncircled = 2;
                    if (makelog)
                      this.AddLog("NO HARD SUPPLY ROUTE TO HIGH HQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str((object) Number));
                    if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                      ;
                    num2 += Number;
                  }
                }
                else
                  break;
              }
              if (num6 == 0 & num1 == 0)
                flag = false;
            }
          }
        }
        if (num1 == 1)
        {
          int moveMatrixCounter3 = this.MoveMatrixCounter;
          for (int index = 1; index <= moveMatrixCounter3; ++index)
          {
            int unr = this.MoveMatrixUnit[index];
            if (unr != groupHq)
            {
              int num10 = 1;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              if (coordinate1.x == -1)
              {
                coordinate1.x = this.game.Data.UnitObj[unr].X;
                coordinate1.y = this.game.Data.UnitObj[unr].Y;
              }
              coordinate1.onmap = false;
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num10 == 1 & this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] != 0)
              {
                num10 = 0;
                int num11;
                if ((double) this.SupplyMatrixOpHQReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] <= (double) this.game.Data.RuleVar[52])
                {
                  num11 = 1;
                  break;
                }
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn() | this.game.Data.Turn == this.TempOwner[coordinate1.x, coordinate1.y] | this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == -1)
                {
                  if ((double) this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
                  {
                    coordinate2 = this.SupplyMatrixOpHQRealCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate1.x, coordinate1.y]))
                    {
                      coordinate1 = coordinate2;
                      num11 = 1;
                      break;
                    }
                  }
                  if (num10 == 0 & (double) this.SupplyMatrixOpHQPrognosis[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
                  {
                    coordinate2 = this.SupplyMatrixOpHQPrognosisCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate2.x, coordinate2.y]))
                    {
                      coordinate1 = coordinate2;
                      num10 = 1;
                    }
                  }
                }
                if (!flag)
                  num10 = 0;
                if (num10 == 0)
                {
                  int Number = !this.game.Data.UnitObj[unr].IsHQ ? 150 : (int) Math.Round(100.0 * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) powerPointsAbsolute) * 0.75);
                  if (!flag)
                    Number = (int) Math.Round((double) Number / 2.0);
                  if ((double) this.game.Data.UnitObj[unr].SupplyIn < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                    Number = (int) Math.Round((double) Number * 2.5);
                  if ((double) this.game.Data.UnitObj[unr].Supply < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                    Number = (int) Math.Round((double) Number * 1.5);
                  if (this.game.Data.UnitObj[unr].IsHQ)
                    Number *= 3;
                  if (!IsTest)
                    this.game.Data.UnitObj[unr].TempEncircled = 1;
                  if (makelog)
                    this.AddLog("NO EASY SUPPLY ROUTE TO OPHQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str((object) Number));
                  if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                    ;
                  num2 += Number;
                }
              }
            }
          }
          int moveMatrixCounter4 = this.MoveMatrixCounter;
          for (int index6 = 1; index6 <= moveMatrixCounter4; ++index6)
          {
            int unr = this.MoveMatrixUnit[index6];
            if (unr != groupHq)
            {
              int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
              for (int index7 = 0; index7 <= mapWidth3; ++index7)
              {
                int mapHeight = this.game.Data.MapObj[0].MapHeight;
                for (int index8 = 0; index8 <= mapHeight; ++index8)
                  this.ptemp3[index7, index8] = 0;
              }
              int num12 = 1;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              coordinate1.onmap = false;
              int num13 = 0;
              if (coordinate1.x == -1)
              {
                coordinate1.x = this.game.Data.UnitObj[unr].X;
                coordinate1.y = this.game.Data.UnitObj[unr].Y;
              }
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num12 == 1 & this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] != 0)
              {
                num12 = 0;
                if ((double) this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixOpHQRealCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num12 = 1;
                    ++num13;
                    if (num13 >= 10)
                      break;
                  }
                }
                if (num12 == 0 & (double) this.SupplyMatrixOpHQPrognosis[coordinate1.x, coordinate1.y] <= (double) this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixOpHQPrognosisCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num12 = 1;
                  }
                }
                if (num12 == 0)
                {
                  coordinate2.onmap = false;
                  int tfacing = 1;
                  do
                  {
                    coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing);
                    if (coordinate3.onmap && this.GetRegime(this.game.Data.Turn) == this.GetRegime(this.TempCounterOwner[coordinate3.x, coordinate3.y]) && this.ptemp3[coordinate3.x, coordinate3.y] == 0 && (double) this.SupplyMatrixOpHQPrognosis[coordinate3.x, coordinate3.y] < (double) this.game.Data.RuleVar[53])
                    {
                      if (!coordinate2.onmap)
                        coordinate2 = coordinate3;
                      else if (this.SupplyMatrixOpHQPrognosis[coordinate3.x, coordinate3.y] < this.SupplyMatrixOpHQPrognosis[coordinate2.x, coordinate2.y])
                        coordinate2 = coordinate3;
                    }
                    ++tfacing;
                  }
                  while (tfacing <= 6);
                  if (coordinate2.onmap)
                  {
                    coordinate1 = coordinate2;
                    num12 = 1;
                    this.ptemp3[coordinate2.x, coordinate2.y] = 1;
                  }
                }
                if (!flag)
                  num12 = 0;
                if (num12 == 0)
                {
                  int Number = !this.game.Data.UnitObj[unr].IsHQ ? 50 : (int) Math.Round(100.0 * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) powerPointsAbsolute) * 0.25);
                  if (!flag)
                    Number = (int) Math.Round((double) Number / 2.0);
                  if ((double) this.game.Data.UnitObj[unr].SupplyIn < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                    Number = (int) Math.Round((double) Number * 2.5);
                  if ((double) this.game.Data.UnitObj[unr].Supply < (double) this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                    Number *= 3;
                  if (this.game.Data.UnitObj[unr].IsHQ)
                    Number *= 3;
                  if (!IsTest)
                    this.game.Data.UnitObj[unr].TempEncircled = 2;
                  if (makelog)
                    this.AddLog("NO HARD SUPPLY ROUTE TO OPHQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str((object) Number));
                  if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                    ;
                  num2 += Number;
                }
              }
            }
          }
        }
        ++num1;
      }
      while (num1 <= 1);
      return num2 * 8;
    }

    public void MakeEnemyPowerDispersed()
    {
      this.EnemyPowerDispersed = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int x1 = 0; x1 <= mapWidth; ++x1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int y1 = 0; y1 <= mapHeight; ++y1)
        {
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[x1, y1].Regime, this.game.Data.Turn) && this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter > -1)
          {
            int num1 = 0;
            int unitCounter = this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter;
            for (int index = 0; index <= unitCounter; ++index)
            {
              int unit = this.game.Data.MapObj[0].HexObj[x1, y1].UnitList[index];
              num1 += this.game.Data.UnitObj[unit].TempUnitPower;
            }
            if (num1 > 0)
            {
              int num2 = Math.Max(0, x1 - 5);
              int num3 = Math.Min(x1 + 5, this.game.Data.MapObj[0].MapWidth);
              for (int x2 = num2; x2 <= num3; ++x2)
              {
                int num4 = Math.Max(0, y1 - 5);
                int num5 = Math.Min(y1 + 5, this.game.Data.MapObj[0].MapHeight);
                for (int y2 = num4; y2 <= num5; ++y2)
                {
                  int num6 = this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0, 6) + 1;
                  int num7 = num6 * num6;
                  int num8 = 0;
                  if (num7 <= 36)
                    num8 = (int) Math.Round((double) num1 / (double) num7);
                  int[,] enemyPowerDispersed = this.EnemyPowerDispersed;
                  int[,] numArray = enemyPowerDispersed;
                  int index1 = x2;
                  int index2 = index1;
                  int index3 = y2;
                  int index4 = index3;
                  int num9 = enemyPowerDispersed[index1, index3] + num8;
                  numArray[index2, index4] = num9;
                }
              }
            }
          }
        }
      }
    }

    public void MakeFriendlyPowerDispersed()
    {
      this.FriendlyPowerDispersed = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int x1 = 0; x1 <= mapWidth; ++x1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int y1 = 0; y1 <= mapHeight; ++y1)
        {
          if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[x1, y1].Regime, this.game.Data.Turn) && this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter > -1)
          {
            int num1 = 0;
            int unitCounter = this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter;
            for (int index = 0; index <= unitCounter; ++index)
            {
              int unit = this.game.Data.MapObj[0].HexObj[x1, y1].UnitList[index];
              if (this.game.Data.UnitObj[unit].AIGroup != this.OpGroup)
                num1 += this.game.Data.UnitObj[unit].TempUnitPower;
            }
            if (num1 > 0)
            {
              int num2 = Math.Max(0, x1 - 5);
              int num3 = Math.Min(x1 + 5, this.game.Data.MapObj[0].MapWidth);
              for (int x2 = num2; x2 <= num3; ++x2)
              {
                int num4 = Math.Max(0, y1 - 5);
                int num5 = Math.Min(y1 + 5, this.game.Data.MapObj[0].MapHeight);
                for (int y2 = num4; y2 <= num5; ++y2)
                {
                  int num6 = this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0, 6) + 1;
                  int num7 = num6 * num6;
                  int num8 = 0;
                  if (num7 <= 36)
                    num8 = (int) Math.Round((double) num1 / (double) num7);
                  int[,] friendlyPowerDispersed = this.FriendlyPowerDispersed;
                  int[,] numArray = friendlyPowerDispersed;
                  int index1 = x2;
                  int index2 = index1;
                  int index3 = y2;
                  int index4 = index3;
                  int num9 = friendlyPowerDispersed[index1, index3] + num8;
                  numArray[index2, index4] = num9;
                }
              }
            }
          }
        }
      }
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index5 = 0; index5 <= moveMatrixCounter; ++index5)
      {
        int index6 = this.MoveMatrixUnit[index5];
        int tempX = this.game.Data.UnitObj[index6].TempX;
        int tempY = this.game.Data.UnitObj[index6].TempY;
        if (tempX > -1 & tempY > -1)
        {
          int tempUnitPower = this.game.Data.UnitObj[index6].TempUnitPower;
          int num10 = Math.Max(0, tempX - 5);
          int num11 = Math.Min(tempX + 5, this.game.Data.MapObj[0].MapWidth);
          for (int x2 = num10; x2 <= num11; ++x2)
          {
            int num12 = Math.Max(0, tempY - 5);
            int num13 = Math.Min(tempY + 5, this.game.Data.MapObj[0].MapHeight);
            for (int y2 = num12; y2 <= num13; ++y2)
            {
              int num14 = this.game.HandyFunctionsObj.Distance(tempX, tempY, 0, x2, y2, 0, 6) + 1;
              int num15 = num14 * num14;
              int num16 = 0;
              if (num15 <= 36)
                num16 = (int) Math.Round((double) tempUnitPower / (double) num15);
              int[,] friendlyPowerDispersed = this.FriendlyPowerDispersed;
              int[,] numArray = friendlyPowerDispersed;
              int index7 = x2;
              int index8 = index7;
              int index9 = y2;
              int index10 = index9;
              int num17 = friendlyPowerDispersed[index7, index9] + num16;
              numArray[index8, index10] = num17;
            }
          }
        }
      }
    }

    public int GetCounterMoveScore(ref SimpleList tempMove, bool makelog)
    {
      int groupHq = this.GetGroupHQ(this.OpGroup);
      if (Operators.CompareString(this.GroupName[this.OpGroup], "IL Corps", false) == 0)
      {
        int num1 = num1;
      }
      int num2 = 6;
      this.MakeFriendlyPowerDispersed();
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
          this.pmatrix.Value[index1, index2] = false;
        }
      }
      if (makelog)
        this.AddLog("Enemy Counter Moves");
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[unr].AIGroup == this.OpGroup)
          {
            if (this.game.Data.UnitObj[unr].TempX > -1 && this.GetRegime(this.TempCounterOwner[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY]) == this.GetGameDataTurn() && this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr, true, false) > 10)
            {
              int[,] ptemp2 = this.ptemp2;
              int[,] numArray = ptemp2;
              int tempX = this.game.Data.UnitObj[unr].TempX;
              int index3 = tempX;
              int tempY = this.game.Data.UnitObj[unr].TempY;
              int index4 = tempY;
              int num3 = ptemp2[tempX, tempY] + 1;
              numArray[index3, index4] = num3;
              this.pmatrix.Value[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY] = true;
            }
          }
          else if (this.game.Data.UnitObj[unr].X > -1 && this.GetRegime(this.TempCounterOwner[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y]) == this.GetGameDataTurn() && this.game.Data.UnitObj[unr].AIDefend == this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] | this.game.Data.UnitObj[unr].AIFallback == this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] && this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr, true, false) > 10)
          {
            int[,] ptemp2 = this.ptemp2;
            int[,] numArray = ptemp2;
            int x = this.game.Data.UnitObj[unr].X;
            int index5 = x;
            int y = this.game.Data.UnitObj[unr].Y;
            int index6 = y;
            int num4 = ptemp2[x, y] + 1;
            numArray[index5, index6] = num4;
            this.pmatrix.Value[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] = true;
          }
        }
      }
      int enemyMatrixCounter1 = this.EnemyMatrixCounter;
      int unr1;
      Coordinate coordinate1;
      int counterMoveScore;
      for (int index7 = 1; index7 <= enemyMatrixCounter1; ++index7)
      {
        unr1 = this.EnemyMatrixUnit[index7];
        int num5 = Math.Max(this.game.Data.UnitObj[unr1].X - num2, this.CMS1.x);
        int num6 = Math.Min(this.game.Data.UnitObj[unr1].X + num2, this.CMS2.x);
        int num7 = Math.Max(this.game.Data.UnitObj[unr1].Y - num2, this.CMS1.y);
        int num8 = Math.Min(this.game.Data.UnitObj[unr1].Y + num2, this.CMS2.y);
        int num9 = num5;
        int num10 = num6;
        for (int index8 = num9; index8 <= num10; ++index8)
        {
          int num11 = num7;
          int num12 = num8;
          for (int index9 = num11; index9 <= num12; ++index9)
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index8, index9].Regime) == this.GetGameDataTurn() & this.ptemp2[index8, index9] <= 0 && this.ptemp[index8, index9] == 0)
            {
              int num13 = 0;
              if (this.AdvanceAxisMatrix[index8, index9] == 0)
                num13 = 1;
              if (this.game.Data.MapObj[0].HexObj[index8, index9].Location > -1 | this.game.HandyFunctionsObj.HasHexBridge(index8, index9, 0))
                num13 = 1;
              if (this.SupplyMatrix[index8, index9] > -1 & this.SupplyMatrixDistance[index8, index9] == 0)
                num13 = 1;
              if (this.FrontlineArea[index8, index9] == 1)
                num13 = 1;
              int num14 = 1;
              coordinate1.x = index8;
              coordinate1.y = index9;
              coordinate1.onmap = true;
              int val1 = this.EnemyPowerDispersed[index8, index9] <= this.FriendlyPowerDispersed[index8, index9] * 1 ? (this.EnemyPowerDispersed[index8, index9] <= (int) Math.Round((double) this.FriendlyPowerDispersed[index8, index9] * 0.75) ? (this.EnemyPowerDispersed[index8, index9] <= (int) Math.Round((double) this.FriendlyPowerDispersed[index8, index9] * 0.5) ? (this.EnemyPowerDispersed[index8, index9] <= (int) Math.Round((double) this.FriendlyPowerDispersed[index8, index9] * 0.4) ? (this.EnemyPowerDispersed[index8, index9] <= (int) Math.Round((double) this.FriendlyPowerDispersed[index8, index9] * 0.3) ? (this.EnemyPowerDispersed[index8, index9] <= (int) Math.Round((double) this.FriendlyPowerDispersed[index8, index9] * 0.2) ? (this.EnemyPowerDispersed[index8, index9] <= (int) Math.Round((double) this.FriendlyPowerDispersed[index8, index9] * 0.1) ? 75 : 100) : 125) : 150) : 175) : 200) : 250) : 300;
              int num15 = (this.game.Data.UnitObj[unr1].SupplyConsume <= 80 ? (this.game.Data.UnitObj[unr1].SupplyConsume <= 50 ? Math.Max(10, this.game.HandyFunctionsObj.GetAverageRdn(unr1) - 50) : Math.Max(10, this.game.HandyFunctionsObj.GetAverageRdn(unr1) - 25)) : (!this.game.Data.UnitObj[unr1].DidAttack ? Math.Min(val1, this.game.HandyFunctionsObj.GetAverageRdn(unr1) + 25) : Math.Min(75, this.game.HandyFunctionsObj.GetAverageRdn(unr1) - 25))) + 15;
              if (this.EnemyMatrix[index7, index8, index9] > num15)
                num14 = 0;
              if (this.game.HandyFunctionsObj.HasUnitAirSF(unr1))
                num14 = 0;
              if (this.GetRegime(this.TempOwner[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y]) != this.GetGameDataTurn() | this.game.Data.MapObj[0].HexObj[index8, index9].Location > -1)
              {
                while (num14 == 1 & !(coordinate1.x == this.game.Data.UnitObj[unr1].X & coordinate1.y == this.game.Data.UnitObj[unr1].Y))
                {
                  num14 = 0;
                  if (this.EnemyMatrixCameFrom[index7, coordinate1.x, coordinate1.y].onmap)
                  {
                    sCoordinate sCoordinate = this.EnemyMatrixCameFrom[index7, coordinate1.x, coordinate1.y];
                    coordinate1.x = (int) sCoordinate.x;
                    coordinate1.y = (int) sCoordinate.y;
                    coordinate1.onmap = sCoordinate.onmap;
                    coordinate1.onmap = true;
                    num14 = 1;
                  }
                  else
                  {
                    coordinate1.onmap = false;
                    coordinate1.x = -1;
                  }
                  if (coordinate1.onmap && this.ptemp2[coordinate1.x, coordinate1.y] > 0)
                    num14 = 0;
                }
              }
              if (num14 == 1)
              {
                if (this.tArea[index8, index9] > 0)
                {
                  int d = (int) Math.Round(Math.Sqrt(num13 != 1 ? 10.0 : (double) this.GetTscore(index8, index9, IsCounterAttack: true)) * 4.0);
                  if (this.GetRegime(this.TempOwner[index8, index9]) != this.GetGameDataTurn())
                    d = (int) Math.Round((double) d / 2.0);
                  if (this.BottleNeckMatrix[index8, index9] > 0)
                    d *= (int) Math.Round(3.0 * Math.Sqrt(Math.Min(100.0, (double) this.BottleNeckMatrix[index8, index9] / 3.0)));
                  if ((double) this.game.Data.RuleVar[265] > 0.0 && (double) (this.game.HandyFunctionsObj.GetRegimeVP(this.GetGameDataTurn()) - this.game.Data.MapObj[0].HexObj[index8, index9].VP) < (double) this.game.Data.RuleVar[265])
                    d = (d + 200) * 10;
                  int Number = (int) Math.Round(Math.Sqrt((double) d) * 10.0);
                  if (makelog)
                    this.AddLog("Enemy counter move on <" + Conversion.Str((object) index8) + "," + Conversion.Str((object) index9) + "> give " + Conversion.Str((object) Number) + "pts. with unit: " + this.game.Data.UnitObj[unr1].Name);
                  counterMoveScore += Number;
                }
                this.ptemp[index8, index9] = 1;
                this.TempCounterOwner[index8, index9] = this.game.Data.UnitObj[unr1].Regime;
              }
            }
          }
        }
      }
      if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
      {
        int enemyMatrixCounter2 = this.EnemyMatrixCounter;
        for (int index10 = 1; index10 <= enemyMatrixCounter2; ++index10)
        {
          unr1 = this.EnemyMatrixUnit[index10];
          int num16 = this.game.HandyFunctionsObj.GetAverageRdn(unr1);
          if (this.game.Data.UnitObj[unr1].SupplyIn > 0)
            num16 += 30;
          if (num16 > 100)
            num16 = 100;
          HandyFunctionsclass handyFunctionsObj = this.game.HandyFunctionsObj;
          int unr2 = unr1;
          int x1 = this.game.Data.UnitObj[unr1].X;
          int y1 = this.game.Data.UnitObj[unr1].Y;
          MapMatrix2Boolean pmatrix = this.pmatrix;
          CustomDC2AICalls customDc2AiCalls = (CustomDC2AICalls) null;
          ref CustomDC2AICalls local = ref customDc2AiCalls;
          handyFunctionsObj.MakeMovePrediction3(unr2, x1, y1, 0, TempUnitsMatrix: pmatrix, tcustomAi: (ref local));
          int x2 = this.CMS1.x;
          int x3 = this.CMS2.x;
          for (int index11 = x2; index11 <= x3; ++index11)
          {
            int y2 = this.CMS1.y;
            int y3 = this.CMS2.y;
            for (int index12 = y2; index12 <= y3; ++index12)
            {
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index11, index12].Regime) == this.GetGameDataTurn() && this.ptemp[index11, index12] == 0 && this.game.EditObj.TempValue[0].Value[index11, index12] <= num16)
              {
                this.ptemp[index11, index12] = 1;
                this.TempCounterOwner[index11, index12] = this.game.Data.UnitObj[unr1].Regime;
                int Number = (int) Math.Round((double) this.GetTscore(index11, index12, IsCounterAttack: true) / 2.0);
                if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
                  Number = (int) Math.Round((double) Number * 1.5);
                if (makelog)
                  this.AddLog("Enemy counter move on (AI slow calc mode) <" + Conversion.Str((object) index11) + "," + Conversion.Str((object) index12) + "> give " + Conversion.Str((object) Number) + "pts. with unit: " + this.game.Data.UnitObj[unr1].Name);
                counterMoveScore += Number;
              }
            }
          }
        }
      }
      int x4 = this.CMS1.x;
      int x5 = this.CMS2.x;
      for (int cx = x4; cx <= x5; ++cx)
      {
        int y4 = this.CMS1.y;
        int y5 = this.CMS2.y;
        for (int cy = y4; cy <= y5; ++cy)
        {
          if (this.ptemp[cx, cy] == 1)
          {
            int tfacing1 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing1);
              if (coordinate1.onmap && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[coordinate1.map].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
              {
                int num17 = 0;
                if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Location <= -1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn())
                {
                  if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].UnitCounter > -1 | this.ptemp2[coordinate1.x, coordinate1.y] > 0)
                    ++num17;
                  int tfacing2 = 1;
                  do
                  {
                    Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                    if (coordinate2.onmap && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime) == this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].UnitCounter > -1 | this.ptemp2[coordinate2.x, coordinate2.y] > 0)
                      ++num17;
                    ++tfacing2;
                  }
                  while (tfacing2 <= 6);
                  if (num17 == 0)
                    this.TempCounterOwner[coordinate1.x, coordinate1.y] = this.game.Data.UnitObj[unr1].Regime;
                }
              }
              ++tfacing1;
            }
            while (tfacing1 <= 6);
          }
        }
      }
      return counterMoveScore;
    }

    public int GetCounterAttackScore(ref SimpleList tempMove, bool makelog)
    {
      int[] numArray1 = new int[this.game.Data.UnitCounter + 1];
      int[] numArray2 = new int[this.game.Data.UnitCounter + 1];
      int[,] numArray3 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int Number1 = 0;
      int num1 = 1;
      do
      {
        int unitCounter1 = this.game.Data.UnitCounter;
        for (int index = 0; index <= unitCounter1; ++index)
          this.ptempb[index] = false;
        this.GetGroupHQ(this.OpGroup);
        int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
        for (int index1 = 0; index1 <= mapWidth1; ++index1)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int index2 = 0; index2 <= mapHeight; ++index2)
          {
            this.ptemp[index1, index2] = 0;
            this.ptemp2[index1, index2] = 0;
          }
        }
        if (Operators.CompareString(this.GroupName[this.OpGroup], "III Hungarian Corps", false) == 0)
          ;
        if (makelog)
          this.AddLog("Enemy Counter Attacks");
        int unitCounter2 = this.game.Data.UnitCounter;
        for (int index = 0; index <= unitCounter2; ++index)
        {
          if (this.GetRegime(this.game.Data.UnitObj[index].Regime) != this.GetGameDataTurn())
          {
            this.game.Data.UnitObj[index].TempX = -1;
            this.game.Data.UnitObj[index].TempY = -1;
            this.game.Data.UnitObj[index].DidAttack = false;
          }
        }
        int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
        int index3;
        int index4;
        for (index3 = 0; index3 <= mapWidth2; ++index3)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (index4 = 0; index4 <= mapHeight; ++index4)
          {
            this.TempCounterOwner[index3, index4] = this.TempOwner[index3, index4];
            this.ptemp[index3, index4] = -1;
          }
        }
        int moveMatrixCounter1 = this.MoveMatrixCounter;
        for (int index5 = 1; index5 <= moveMatrixCounter1; ++index5)
        {
          int index6 = this.MoveMatrixUnit[index5];
          index3 = this.game.Data.UnitObj[index6].TempX;
          index4 = this.game.Data.UnitObj[index6].TempY;
          if (index3 == -1)
          {
            index3 = this.game.Data.UnitObj[index6].X;
            index4 = this.game.Data.UnitObj[index6].Y;
          }
          this.ptemp[index3, index4] = index6;
        }
        int unitCounter3 = this.game.Data.UnitCounter;
        for (int index7 = 0; index7 <= unitCounter3; ++index7)
        {
          int num2 = 0;
          int index8 = index7;
          if (this.game.Data.UnitObj[index8].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index8].PreDef == -1)
          {
            if (this.game.Data.UnitObj[index8].AIGroup == this.OpGroup)
            {
              num2 = 1;
              index3 = this.game.Data.UnitObj[index8].TempX;
              index4 = this.game.Data.UnitObj[index8].TempY;
            }
            else if (this.game.Data.UnitObj[index8].X > -1 && this.ptemp2[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] < 1 && this.tArea[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] == 2)
            {
              num2 = 2;
              index3 = -1;
            }
          }
          if (num2 >= 1)
          {
            this.ptemp2[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] = 1;
            if (index3 == -1)
            {
              index3 = this.game.Data.UnitObj[index8].X;
              index4 = this.game.Data.UnitObj[index8].Y;
            }
            int Number2 = 0;
            int num3 = 0;
            int num4 = 0;
            int unitCounter4 = this.game.Data.UnitCounter;
            for (int index9 = 0; index9 <= unitCounter4; ++index9)
              this.ptempb[index9] = false;
            if (index3 > -1 & index4 > -1 && numArray3[index3, index4] < num1)
            {
              int enemyMatrixCounter = this.EnemyMatrixCounter;
              int unr;
              for (int index10 = 1; index10 <= enemyMatrixCounter; ++index10)
              {
                unr = this.EnemyMatrixUnit[index10];
                this.game.Data.UnitObj[unr].TempX = -1;
                this.game.Data.UnitObj[unr].TempY = -1;
                this.game.Data.UnitObj[unr].TempSlot = -1;
                int num5 = 0;
                int num6 = 0;
                int num7 = this.game.Data.UnitObj[unr].SupplyConsume <= 80 ? Math.Max(10, this.game.HandyFunctionsObj.GetAverageRdn(unr)) : Math.Min(120, this.game.HandyFunctionsObj.GetAverageRdn(unr) + 30);
                if (index3 == 48 & index4 == 34)
                  index3 = index3;
                Coordinate coordinate;
                if (this.EnemyMatrix[index10, index3, index4] <= num7)
                {
                  num6 = 1;
                  coordinate.x = index3;
                  coordinate.y = index4;
                  coordinate.onmap = true;
                  if (this.game.HandyFunctionsObj.HasUnitAirSF(unr))
                    num6 = 0;
                  while (num6 == 1 & !(coordinate.x == this.game.Data.UnitObj[unr].X & coordinate.y == this.game.Data.UnitObj[unr].Y))
                  {
                    num6 = 0;
                    if (this.EnemyMatrixCameFrom[index10, coordinate.x, coordinate.y].onmap)
                    {
                      sCoordinate sCoordinate = this.EnemyMatrixCameFrom[index10, coordinate.x, coordinate.y];
                      coordinate.x = (int) sCoordinate.x;
                      coordinate.y = (int) sCoordinate.y;
                      coordinate.onmap = sCoordinate.onmap;
                      num6 = 1;
                      int index11 = this.ptemp[coordinate.x, coordinate.y];
                      if (index11 > -1 & !(num1 == 2 & this.GetRegime(this.TempCounterOwner[coordinate.x, coordinate.y]) == this.GetGameDataTurn()))
                      {
                        num4 += this.game.Data.UnitObj[unr].TempUnitPower;
                        if (!this.ptempb[index11])
                        {
                          num5 += this.GetPrognosedAndRealDefendingPowerPointsOn(coordinate.x, coordinate.y, CounterAttack: true);
                          this.ptempb[index11] = true;
                          break;
                        }
                      }
                    }
                    else
                    {
                      coordinate.onmap = false;
                      coordinate.x = -1;
                    }
                  }
                }
                if (num6 == 1)
                {
                  sCoordinate sCoordinate = this.EnemyMatrixCameFrom[index10, index3, index4];
                  coordinate.x = (int) sCoordinate.x;
                  coordinate.y = (int) sCoordinate.y;
                  coordinate.onmap = sCoordinate.onmap;
                  this.game.Data.UnitObj[unr].TempX = coordinate.x;
                  this.game.Data.UnitObj[unr].TempY = coordinate.y;
                  this.game.Data.UnitObj[unr].TempSlot = index10;
                  Number2 += num5;
                  num3 += this.game.Data.UnitObj[unr].TempUnitPower;
                }
              }
              if (index3 == 46 & index4 == 35)
                index3 = index3;
              int Number3 = this.GetPrognosedEnemyLandAttackPowerPointsOn(index3, index4, OptimisticStack: true, LeaveFrontLineEmptyPenalty: true);
              int num8 = this.GetPrognosedEnemyStackPointsOn(index3, index4, OptimisticStack: true);
              if (makelog)
                this.AddLog("Tot enemy power on " + this.game.Data.UnitObj[index8].Name + "  = " + Conversion.Str((object) Number3) + ", block: " + Conversion.Str((object) Number2));
              if (Number3 > 100)
                Number3 = 100 + (int) Math.Round((double) (Number3 - 100) * 0.75);
              if (Number3 > 250)
                Number3 = 250 + (int) Math.Round((double) (Number3 - 250) * 0.66);
              if (Number3 > 500)
                Number3 = 500 + (int) Math.Round((double) (Number3 - 500) * 0.5);
              if (Number3 > 700)
                Number3 = 700 + (int) Math.Round((double) (Number3 - 700) * 0.5);
              if (Number3 > 900)
                Number3 = 900 + (int) Math.Round((double) (Number3 - 900) * 0.5);
              if (Number3 > 1300)
                Number3 = 1300 + (int) Math.Round((double) (Number3 - 1300) * 0.45);
              if (Number3 > 1700)
                Number3 = 1700 + (int) Math.Round((double) (Number3 - 1700) * 0.4);
              if (index3 == 47 & index4 == 34)
                index3 = index3;
              if (this.FrontlineArea[index3, index4] == 2)
              {
                num8 = (int) Math.Round((double) num8 / 1.5);
                Number3 *= 1;
              }
              if ((double) num8 > (double) this.game.Data.RuleVar[30] * 1.33)
                Number3 = (int) Math.Round((double) Number3 / ((double) num8 / ((double) this.game.Data.RuleVar[30] * 1.33)));
              if (!Information.IsNothing((object) this.game.EditObj.TempUnitList) && this.game.EditObj.TempUnitList.counter > 12)
                Number3 = (int) Math.Round((double) Number3 * ((double) this.game.EditObj.TempUnitList.counter / 12.0));
              if (index3 == 63 & index4 == 54)
                index3 = index3;
              int Number4;
              if (num3 > num4)
              {
                int num9 = (int) Math.Round((double) Number3 * ((double) num4 / (double) num3)) - Number2 * 5;
                if (0 > num9)
                  num9 = 0;
                Number4 = num9 + Number3 * (int) Math.Round((double) (num3 - num4) / (double) num3);
              }
              else
                Number4 = Number3 - Number2 * 5;
              if (0 > Number4)
                Number4 = 0;
              int Number5 = 0;
              int num10 = 0;
              int num11;
              if (num2 == 2)
              {
                Number5 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyOpGroup: true, CounterAttack: true);
                num10 = Number5;
              }
              else
              {
                int moveMatrixCounter2 = this.MoveMatrixCounter;
                for (int index12 = 0; index12 <= moveMatrixCounter2; ++index12)
                {
                  int OnlyUnit = this.MoveMatrixUnit[index12];
                  int num12 = 0;
                  int num13 = 0;
                  if (this.game.Data.UnitObj[OnlyUnit].TempX == index3 & this.game.Data.UnitObj[OnlyUnit].TempY == index4)
                  {
                    if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 2 | this.game.Data.UnitObj[OnlyUnit].TempCategory == 5 | this.game.Data.UnitObj[OnlyUnit].TempCategory == 3)
                    {
                      num12 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyOpGroup: true, OnlyUnit: OnlyUnit, CounterAttack: true);
                      num13 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, true, OnlyUnit, true);
                    }
                    else
                    {
                      num12 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyUnit: OnlyUnit, CounterAttack: true);
                      num13 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, OnlyUnit: OnlyUnit, CounterAttack: true);
                    }
                    int defendingPowerPointsOn = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, true, OnlyUnit, true);
                    if (defendingPowerPointsOn <= num13 & num13 > 0)
                    {
                      if (this.game.Data.UnitObj[OnlyUnit].IsHQ)
                        num12 = (int) Math.Round((double) num12 * (1.0 - (double) defendingPowerPointsOn / (double) num13) + 0.2 * (double) num12 * ((double) defendingPowerPointsOn / (double) num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 2)
                        num12 = (int) Math.Round((double) num12 * (1.0 - (double) defendingPowerPointsOn / (double) num13) + 0.1 * (double) num12 * ((double) defendingPowerPointsOn / (double) num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 5)
                        num12 = (int) Math.Round((double) num12 * (1.0 - (double) defendingPowerPointsOn / (double) num13) + 0.1 * (double) num12 * ((double) defendingPowerPointsOn / (double) num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 4)
                        num12 = (int) Math.Round((double) num12 * (1.0 - (double) defendingPowerPointsOn / (double) num13) + 0.2 * (double) num12 * ((double) defendingPowerPointsOn / (double) num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 3)
                        num12 = (int) Math.Round((double) num12 * (1.0 - (double) defendingPowerPointsOn / (double) num13) + 0.05 * (double) num12 * ((double) defendingPowerPointsOn / (double) num13));
                    }
                  }
                  if (num12 > 0)
                    num11 += this.game.Data.UnitObj[OnlyUnit].TempUnitPower;
                  Number5 += num12;
                  num10 += num13;
                }
                int unitCounter5 = this.game.Data.MapObj[0].HexObj[index3, index4].UnitCounter;
                for (int index13 = 0; index13 <= unitCounter5; ++index13)
                {
                  int unit = this.game.Data.MapObj[0].HexObj[index3, index4].UnitList[index13];
                  if (this.game.Data.UnitObj[unit].AIDefend == this.AreaMatrixNarrow[index3, index4] & this.game.Data.UnitObj[unit].AIGroup != this.OpGroup)
                  {
                    int defendingPowerPointsOn1 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyOpGroup: true, OnlyUnit: unit, CounterAttack: true);
                    int defendingPowerPointsOn2 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, true, unit, true);
                    Number5 += defendingPowerPointsOn1;
                    num10 += defendingPowerPointsOn2;
                  }
                }
              }
              float num14 = 1f;
              if (Number5 == 0)
                Number5 = 1;
              if (num10 > Number5)
                num14 = (float) num10 / (float) Number5;
              if ((double) num14 > 3.0)
                num14 = (float) (2.0 + Math.Sqrt((double) num14 - 2.0));
              int Number6 = (int) Math.Round(Math.Min(5.0, (double) Number4 / (double) Number5) * 20.0);
              int num15 = this.BottleNeckMatrix[index3, index4] <= 20 ? (this.BottleNeckMatrix[index3, index4] <= 5 ? (this.FrontlineArea[index3, index4] != 2 ? (int) Math.Round((double) this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.66) : (int) Math.Round((double) this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.6)) : (int) Math.Round((double) this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.55)) : (int) Math.Round((double) this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.5);
              if (Number6 >= num15)
              {
                int num16 = (int) Math.Round((double) this.game.Data.RuleVar[30]);
                int counter1 = this.game.EditObj.TempUnitList.counter;
                for (int index14 = 0; index14 <= counter1; ++index14)
                {
                  int num17 = this.game.EditObj.TempUnitList.unr[index14];
                  if (num17 > -1)
                  {
                    int[] numArray4 = numArray1;
                    int[] numArray5 = numArray4;
                    int index15 = num17;
                    int index16 = index15;
                    int num18 = numArray4[index15] + 1;
                    numArray5[index16] = num18;
                    if (num8 > num16)
                    {
                      int[] numArray6 = numArray2;
                      int[] numArray7 = numArray6;
                      int index17 = num17;
                      int index18 = index17;
                      int num19 = numArray6[index17] + (num8 - num16);
                      numArray7[index18] = num19;
                    }
                  }
                }
                if (index3 == 42 & index4 == 29)
                  index3 = index3;
                if (this.BottleNeckMatrix[index3, index4] > 20)
                {
                  if (Number6 >= (int) Math.Round((double) num15 * 1.25))
                    this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                }
                else if (this.BottleNeckMatrix[index3, index4] > 5)
                {
                  if (Number6 >= (int) Math.Round((double) num15 * 1.4))
                    this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                }
                else if (this.FrontlineArea[index3, index4] == 2)
                {
                  if (Number6 >= (int) Math.Round((double) num15 * 1.55))
                    this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                }
                else if (Number6 >= (int) Math.Round((double) num15 * 1.7))
                  this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                if (num11 > 0)
                {
                  int moveMatrixCounter3 = this.MoveMatrixCounter;
                  for (int index19 = 0; index19 <= moveMatrixCounter3; ++index19)
                  {
                    int index20 = this.MoveMatrixUnit[index19];
                    if (this.game.Data.UnitObj[index20].TempX == index3 & this.game.Data.UnitObj[index20].TempY == index4)
                    {
                      if (this.game.Data.UnitObj[index20].IsHQ)
                        Number6 += (int) Math.Round((double) (Number6 * 8) * ((double) this.game.Data.UnitObj[index20].TempUnitPower / (double) num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 2)
                        Number6 += (int) Math.Round((double) (Number6 * 4) * ((double) this.game.Data.UnitObj[index20].TempUnitPower / (double) num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 5)
                        Number6 += (int) Math.Round((double) (Number6 * 4) * ((double) this.game.Data.UnitObj[index20].TempUnitPower / (double) num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 4)
                        Number6 += (int) Math.Round((double) (Number6 * 4) * ((double) this.game.Data.UnitObj[index20].TempUnitPower / (double) num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 3)
                        Number6 += (int) Math.Round((double) (Number6 * 12) * ((double) this.game.Data.UnitObj[index20].TempUnitPower / (double) num11));
                    }
                  }
                }
                if (num1 == 2)
                  Number6 = (int) Math.Round((double) Number6 / 2.0);
                int Number7 = (int) Math.Round((double) ((float) Number6 * num14));
                int pointsOnOnlyPower = this.GetPrognosedDefendingPowerPointsOnOnlyPower(index3, index4);
                int num20 = 80;
                if ((double) this.game.Data.RuleVar[384] > 0.0)
                  num20 = (int) Math.Round((double) this.game.Data.RuleVar[384]);
                if (pointsOnOnlyPower > num20)
                {
                  Number7 = (int) Math.Round((double) Number7 * ((double) pointsOnOnlyPower / (double) num20));
                  if (makelog)
                    this.AddLog("Large Target Bonus. " + Conversion.Str((object) (100.0 * ((double) pointsOnOnlyPower / (double) num20) - 100.0)) + "% extra pts!");
                }
                if (this.BottleNeckMatrix[index3, index4] > 0)
                {
                  Number7 = (int) Math.Round((double) Number7 * Math.Sqrt(Math.Min(25.0, (double) this.BottleNeckMatrix[index3, index4] / 5.0)));
                  if (makelog)
                    this.AddLog("Multiply pts by: " + Math.Sqrt(Math.Min(100.0, (double) this.BottleNeckMatrix[index3, index4] / 3.0)).ToString() + " to make these more profitable to avoid .... Bottleneck Matrix Score was = " + this.BottleNeckMatrix[index3, index4].ToString());
                }
                if (makelog)
                  this.AddLog("EASY ROUTE Counterattack on <" + Conversion.Str((object) index3) + "," + Conversion.Str((object) index4) + ">.  With att = " + Conversion.Str((object) Number4) + " vs def = " + Conversion.Str((object) Number5) + ". Basicstack= " + num8.ToString() + "... Is " + Conversion.Str((object) Number7) + " points. ");
                if (makelog & this.game.EditObj.TempUnitList.counter > -1)
                {
                  int counter2 = this.game.EditObj.TempUnitList.counter;
                  for (int index21 = 0; index21 <= counter2; ++index21)
                  {
                    this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index21]].DidAttack = false;
                    this.AddLog("-WITH " + this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index21]].Name);
                  }
                }
                Number1 += Number7;
                this.CounterAttackPossible[index3, index4] = (int) Math.Round(100.0 * ((double) Number7 / (double) num15));
                numArray3[index3, index4] = num1;
              }
              else
              {
                if (makelog)
                  this.AddLog("NO easy counterattack on <" + Conversion.Str((object) index3) + "," + Conversion.Str((object) index4) + ">.  With att = " + Conversion.Str((object) Number4) + " vs def = " + Conversion.Str((object) Number5) + ". Basicstack= " + num8.ToString() + ". Is " + Conversion.Str((object) Number6) + " points. (tscore=" + Conversion.Str((object) this.GetTscore(index3, index4)) + ")");
                this.CounterAttackPossible[index3, index4] = (int) Math.Round(100.0 * ((double) Number6 / (double) num15));
                numArray3[index3, index4] = num1;
                if (!Information.IsNothing((object) this.game.EditObj.TempUnitList) && makelog & this.game.EditObj.TempUnitList.counter > -1)
                {
                  int counter = this.game.EditObj.TempUnitList.counter;
                  for (int index22 = 0; index22 <= counter; ++index22)
                  {
                    if (this.game.EditObj.TempUnitList.unr[index22] <= this.game.Data.UnitCounter)
                    {
                      this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index22]].DidAttack = false;
                      this.AddLog("-WITH " + this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index22]].Name);
                    }
                  }
                }
              }
            }
          }
        }
        ++num1;
      }
      while (num1 <= 2);
      int unitCounter6 = this.game.Data.UnitCounter;
      int num21;
      for (int index = 0; index <= unitCounter6; ++index)
      {
        if (numArray1[index] > 0)
          num21 += this.game.Data.UnitObj[index].TempUnitPower;
      }
      if (makelog)
        this.AddLog("Counterattack score before reduction = " + Conversion.Str((object) Number1));
      int unitCounter7 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter7; ++index)
      {
        if (numArray1[index] > 1)
        {
          float num22 = (float) this.game.Data.UnitObj[index].TempUnitPower / (float) num21;
          float num23 = 1f / (float) numArray1[index];
          float num24 = (float) (((double) numArray2[index] / (double) numArray1[index] + 100.0) / 100.0);
          int Number8 = (int) Math.Round((double) ((float) Number1 * num22 * num23 / num24));
          if (Number8 == 0)
            Number8 = 1;
          if (makelog)
            this.AddLog("Reduction for " + this.game.Data.UnitObj[index].Name + " " + Conversion.Str((object) Number8));
          Number1 -= Number8;
          if (0 > Number1)
            Number1 = 0;
        }
      }
      if (makelog)
        this.AddLog("Counterattack score FINAL = " + Conversion.Str((object) Number1));
      return Number1;
    }

    public int GetScoreForMovingIn(ref SimpleList tempMove, bool makelog)
    {
      int groupHq = this.GetGroupHQ(this.OpGroup);
      int powerPointsAbsolute = this.GetAverageUnitPowerPointsAbsolute();
      int num1 = 1;
      int moveMatrixCounter1 = this.MoveMatrixCounter;
      int unr1;
      for (int index = 0; index <= moveMatrixCounter1; ++index)
      {
        unr1 = this.MoveMatrixUnit[index];
        if (!this.game.Data.UnitObj[unr1].IsHQ & this.game.Data.UnitObj[unr1].TempGroup == -1)
          num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr1);
      }
      int num2 = 0;
      int scoreForMovingIn;
      do
      {
        SimpleList simpleList;
        if (num2 == 0)
          simpleList = this.MarkerList;
        if (num2 == 1)
          simpleList = this.ArtMarkerList;
        if (num2 == 2)
          simpleList = this.AirMarkerList;
        if (num2 == 3)
          simpleList = this.EngineerMarkerList;
        int counter1 = simpleList.Counter;
        for (int Number1 = 0; Number1 <= counter1; ++Number1)
        {
          int Number2 = 0;
          int Number3 = 0;
          int d = 0;
          int Number4 = 0;
          int num3 = 0;
          int counter2 = tempMove.Counter;
          for (int index = 0; index <= counter2; ++index)
          {
            unr1 = this.MoveMatrixUnit[tempMove.Data1[index]];
            int num4 = 0;
            if (num2 == 0 && this.game.Data.UnitObj[unr1].TempCategory == 1 | this.EngineerMarkerList.Counter == -1 & this.game.Data.UnitObj[unr1].TempCategory == 4)
              num4 = 1;
            if (num2 == 1 & this.game.Data.UnitObj[unr1].TempCategory == 2)
              num4 = 1;
            if (num2 == 1 & this.game.Data.UnitObj[unr1].TempCategory == 5)
              num4 = 1;
            if (num2 == 2 & this.game.Data.UnitObj[unr1].TempCategory == 3)
              num4 = 1;
            if (num2 == 3 && this.game.Data.UnitObj[unr1].TempCategory == 4 & this.EngineerMarkerList.Counter > -1)
              num4 = 1;
            if (this.game.Data.UnitObj[unr1].TempStrategic & !this.game.HandyFunctionsObj.HasHexRoad(this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY, 0))
              num4 = 0;
            if (num4 == 1 && tempMove.Data2[index] == Number1 && !this.game.Data.UnitObj[unr1].TempAttacked)
            {
              int num5 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y, 0, simpleList.Data1[Number1], simpleList.Data2[Number1], 0);
              int num6 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY, 0, simpleList.Data1[Number1], simpleList.Data2[Number1], 0);
              ++d;
              if (num5 > num6)
              {
                Number2 += num5;
                Number3 += num6;
                ++Number4;
                if (this.tArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] <= 0 && simpleList.Data5[Number1] > 0)
                  ++num3;
              }
            }
          }
          int num7 = simpleList.Data5[Number1] <= -1 ? 0 : (int) Math.Round(Math.Sqrt((double) (simpleList.Data5[Number1] * 10) * Math.Sqrt((double) d)));
          if (num7 > 100)
            num7 = 100 + (int) Math.Round(Math.Sqrt((double) (num7 - 100)) * 3.0);
          if (num3 > 0)
            num7 *= (int) Math.Round(10.0 * ((double) num3 / (double) Number4));
          if (Number2 == 0)
            num7 = 0;
          else if (Number2 > Number3)
          {
            if (num7 > 0)
            {
              num7 = (int) Math.Round((double) num7 * (1.0 - (double) Number3 / (double) Number2));
              if (num7 == 0)
                num7 = 1;
            }
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
            {
              num7 = (int) Math.Round(Math.Sqrt((double) num7));
              if (this.game.Data.UnitObj[unr1].TempCategory != 3)
              {
                if (this.FrontlineArea[this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY] == 1 & this.FrontlineArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == 1)
                {
                  if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[simpleList.Data1[Number1], simpleList.Data2[Number1]].Regime))
                    num7 = (int) Math.Round(Math.Sqrt((double) (num7 * Math.Min(3, num7))));
                  num7 = (int) Math.Round((double) num7 / 8.0);
                }
                else if (this.FrontlineArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == 0)
                  num7 *= Math.Min(8, this.DistFromFrontline[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y]);
                if (this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIDefend & this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] != this.game.Data.UnitObj[groupHq].AIDefend)
                {
                  num7 *= 2;
                  if (this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] != this.game.Data.UnitObj[groupHq].AIDefend)
                    num7 *= 3;
                }
              }
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY].Regime) == this.GetRegime(this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y].Regime))
                num7 = (int) Math.Round((double) num7 / 2.0);
            }
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 & num7 > 0)
              num7 = (int) Math.Round(Math.Sqrt((double) num7));
            if (Number4 > 1)
              num7 *= Number4;
            if (this.tArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] < 1 && this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIDefend | this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIFallback)
              num7 *= 10;
            if (this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == this.game.Data.UnitObj[groupHq].AIFallback && this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIDefend)
              num7 *= 5;
            if (makelog)
              this.AddLog("Normal Marker #" + Conversion.Str((object) Number1) + ", startsit=" + Conversion.Str((object) Number2) + "hex , enddist=" + Conversion.Str((object) Number3) + "hex, closecount=" + Conversion.Str((object) Number4) + " MOVING IN SCORE =" + Conversion.Str((object) num7));
          }
          if (num7 > 0)
            num7 = num7;
          scoreForMovingIn += num7;
        }
        ++num2;
      }
      while (num2 <= 3);
      int moveMatrixCounter2 = this.MoveMatrixCounter;
      int Number5;
      int Number6;
      int Number7;
      int num8;
      int Number8;
      int Number9;
      int Number10;
      int num9;
      for (int index1 = 0; index1 <= moveMatrixCounter2; ++index1)
      {
        int index2 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].TempCategory == 1 & !this.game.Data.UnitObj[index2].IsHQ & this.game.Data.UnitObj[index2].TempGroup == -1 && this.GetHexSpeedofUnit(index2, true) <= 6)
        {
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
          {
            if (this.game.Data.UnitObj[index2].X == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].Y == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y)
            {
              if (!(this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y))
              {
                Number5 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("DEFEND GARRISON: Unit Left = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
              if (this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y)
              {
                Number6 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("DEFEND GARRISON: Unit Stayed = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
            }
            if (this.game.Data.UnitObj[index2].FinalX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].FinalY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y)
            {
              int num10 = (int) Math.Round((double) this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].FinalX, this.game.Data.UnitObj[index2].FinalY, 0) / 3.0);
              if (num10 <= 0)
                num10 = 1;
              Number7 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
              num8 += (int) Math.Round((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2) / (double) num10);
              if (makelog)
                this.AddLog("DEFEND GARRISON: Unit Approaches / Is present = " + this.game.Data.UnitObj[index2].Name.ToString());
            }
          }
          if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
          {
            if (this.game.Data.UnitObj[index2].X == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].Y == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
            {
              if (!(this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y))
              {
                Number8 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("FALLBACK GARRISON: Unit Left = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
              if (this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
              {
                Number9 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("FALLBACK GARRISON: Unit Stayed = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
            }
            if (this.game.Data.UnitObj[index2].FinalX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].FinalY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
            {
              int num11 = (int) Math.Round((double) this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].FinalX, this.game.Data.UnitObj[index2].FinalY, 0) / 3.0);
              if (num11 <= 0)
                num11 = 1;
              Number10 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
              num9 += (int) Math.Round((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2) / (double) num11);
              if (makelog)
                this.AddLog("FALLBACK GARRISON: Unit Approaches / Is present = " + this.game.Data.UnitObj[index2].Name.ToString());
            }
          }
        }
      }
      int Number11;
      if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
      {
        int num12 = (int) Math.Round((double) num1 * 0.15);
        if ((double) num12 > (double) powerPointsAbsolute * 1.5)
          num12 = (int) Math.Round((double) powerPointsAbsolute * 1.5);
        if (num12 >= powerPointsAbsolute)
        {
          if (num12 < Number5)
            Number5 = num12;
          if (Number6 > 0)
          {
            Number5 -= Number6;
            if (0 > Number5)
              Number5 = 0;
          }
          int num13 = Number7 - Number5;
          if (num13 > 0)
          {
            if (num13 > num12)
              num13 = num12;
            Number11 = (int) Math.Round(0.4 * (double) num1 * ((double) num13 / (double) num12) * ((double) num8 / (double) Number7));
            scoreForMovingIn += Number11;
          }
          if (makelog)
            this.AddLog("DEFEND GARRISON. pts leaving=" + Strings.Trim(Conversion.Str((object) Number5)) + ", pts targetting " + Strings.Trim(Conversion.Str((object) Number7)) + ", pts being there " + Strings.Trim(Conversion.Str((object) Number6)) + "... SCORE BONUS =" + Conversion.Str((object) Number11));
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
      {
        int num14 = (int) Math.Round((double) num1 * 0.075);
        if (num14 > powerPointsAbsolute * 1)
          num14 = powerPointsAbsolute * 1;
        if (num14 >= powerPointsAbsolute)
        {
          if (num14 < Number8)
            Number8 = num14;
          if (Number9 > 0)
          {
            Number8 -= Number9;
            if (0 > Number8)
              Number8 = 0;
          }
          int num15 = Number10 - Number8;
          if (num15 > 0)
          {
            if (num15 > num14)
              num15 = num14;
            Number11 = (int) Math.Round(0.2 * (double) num1 * ((double) num15 / (double) num14) * ((double) num9 / (double) Number10));
            scoreForMovingIn += Number11;
          }
          if (makelog)
            this.AddLog("FALLBACK GARRISON. pts leaving=" + Strings.Trim(Conversion.Str((object) Number8)) + ", pts targetting " + Strings.Trim(Conversion.Str((object) Number10)) + ", pts being there " + Strings.Trim(Conversion.Str((object) Number9)) + "... SCORE BONUS =" + Conversion.Str((object) Number11));
        }
      }
      if (makelog)
        this.AddLog("DIVISIONAL STAY-CLOSE BONUS REWARD");
      int moveMatrixCounter3 = this.MoveMatrixCounter;
      for (int index = 0; index <= moveMatrixCounter3; ++index)
      {
        int unr2 = this.MoveMatrixUnit[index];
        int num16 = this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr2);
        if (num16 > 0)
        {
          num16 = (int) Math.Round((double) num16 / 10.0 * (double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr2));
          if (makelog)
            this.AddLog(this.game.Data.UnitObj[unr2].Name + " gets +" + num16.ToString() + " DIV BONUS");
          scoreForMovingIn += num16;
        }
      }
      return scoreForMovingIn;
    }

    public int getscoreforhexoccupation_hq(int pts, bool makelog)
    {
      int index1 = this.GetGroupHQ(this.OpGroup);
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index2 = 1; index2 <= moveMatrixCounter; ++index2)
      {
        int index3 = index2;
        if (index3 > -1)
        {
          int index4 = this.MoveMatrixUnit[index3];
          int x = this.game.Data.UnitObj[index4].X;
          int y = this.game.Data.UnitObj[index4].Y;
          int tempX = this.game.Data.UnitObj[index4].TempX;
          int tempY = this.game.Data.UnitObj[index4].TempY;
          if (this.game.Data.UnitObj[index4].IsHQ & this.game.Data.UnitObj[index4].AIGroup > -1)
          {
            int num = 0;
            if ((double) this.SupplyMatrixReal[tempX, tempY] <= (double) this.game.Data.RuleVar[51])
              num += (int) Math.Round((double) this.SupplyMatrixReal[tempX, tempY] / 2.0);
            if ((double) this.SupplyMatrixReal[tempX, tempY] > (double) this.game.Data.RuleVar[51])
              num += 200;
            if ((double) this.SupplyMatrixReal[tempX, tempY] > (double) this.game.Data.RuleVar[52])
              num += 500;
            if ((double) this.SupplyMatrixReal[tempX, tempY] > (double) this.game.Data.RuleVar[53])
              num += 1250;
            if (!this.game.HandyFunctionsObj.HasHexRoad(tempX, tempY, 0))
              num += 1000;
            if (this.AdvanceAxisMatrix[tempX, tempY] < 0)
              num += 50;
            if (this.AdvanceAxisMatrix[tempX, tempY] > 0)
              num += 50 * this.AdvanceAxisMatrix[tempX, tempY];
            if ((double) this.game.Data.RuleVar[365] > 0.0)
              num = (int) Math.Round((double) num * (double) this.game.Data.RuleVar[365] / 100.0);
            pts -= num;
            if (makelog)
              this.AddLog(" After supply+advance penalties = " + Conversion.Str((object) pts));
          }
        }
      }
      int unitCounter = this.game.Data.UnitCounter;
      int num1;
      int Number1;
      int num2;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].HQ == index1 && this.game.Data.UnitObj[unr].TempCategory != 3)
        {
          ++num1;
          int num3 = this.game.HandyFunctionsObj.Gethqpow(unr, true);
          Number1 += num3;
          if (index1 > -1)
          {
            int num4 = this.game.HandyFunctionsObj.Gethqpowifhqis(unr, index1, true);
            if (num4 < 1)
              num4 = -(10 * this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0));
            num2 += num4;
          }
        }
      }
      int num5 = 0;
      if (this.OpGroup == 1)
        index1 = index1;
      int groupPowerPoints = this.game.HandyFunctionsObj.GetGroupPowerPoints(index1);
      this.TempAverageHQPower = 0;
      if (num1 > 0)
      {
        this.TempAverageHQPower = (int) Math.Round((double) Number1 / (double) num1);
        Number1 = (int) Math.Round((double) Number1 / (double) num1);
        num5 = Number1 >= 100 ? 0 : groupPowerPoints - (int) Math.Round((double) groupPowerPoints * ((double) Number1 / 100.0));
      }
      if ((double) this.game.Data.RuleVar[366] > 0.0)
        num5 = (int) Math.Round((double) num5 * (double) this.game.Data.RuleVar[366] / 100.0);
      pts -= num5;
      if (makelog)
        this.AddLog(Conversion.Str((object) pts) + " penalty points due to REAL HQ (" + Conversion.Str((object) Number1) + " average hqpow)");
      if (index1 > -1 & num1 > 0)
      {
        int num6 = (int) Math.Round((double) groupPowerPoints / 2.0);
        int Number2 = (int) Math.Round((double) num2 / (double) num1);
        int num7 = Number2 >= 0 ? (Number2 >= 100 ? 0 : num6 - (int) Math.Round((double) num6 * ((double) Number2 / 100.0))) : (int) Math.Round((double) num6 + (double) num6 * ((double) Math.Abs(Number2) / 100.0));
        if ((double) this.game.Data.RuleVar[366] > 0.0)
          num7 = (int) Math.Round((double) num7 * (double) this.game.Data.RuleVar[366] / 100.0);
        pts -= num7;
        if (makelog)
          this.AddLog(Conversion.Str((object) pts) + " penalty points due to OPTIMAL OWN GROUP HQ (" + Conversion.Str((object) Number2) + " average hqpow)");
      }
      return pts;
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    public void getscoreforhexoccupation_setmove()
    {
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index1 = 1; index1 <= moveMatrixCounter; ++index1)
      {
        int index2 = index1;
        if (index2 > -1)
        {
          int index3 = this.MoveMatrixUnit[index2];
          int x1 = this.game.Data.UnitObj[index3].X;
          int y1 = this.game.Data.UnitObj[index3].Y;
          int index4 = this.game.Data.UnitObj[index3].TempX;
          int index5 = this.game.Data.UnitObj[index3].TempY;
          if (index4 == -1)
          {
            index4 = this.game.Data.UnitObj[index3].X;
            index5 = this.game.Data.UnitObj[index3].Y;
            if (index4 == -1)
            {
              int num = (int) Interaction.MsgBox((object) "-1 in getscorehexoccup_setmove");
              ProjectData.EndApp();
            }
          }
          if (this.game.Data.UnitObj[index3].TempCategory != 3)
          {
            Coordinate coordinate1;
            Coordinate coordinate2;
            do
            {
              coordinate1 = new Coordinate();
              coordinate2.onmap = false;
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index4, index5].Regime) != this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[index4, index5].UnitCounter > -1)
              {
                coordinate2.x = index4;
                coordinate2.y = index5;
                coordinate2.onmap = true;
              }
              sCoordinate sCoordinate = this.MoveMatrixCameFrom[index2, index4, index5];
              coordinate1.x = (int) sCoordinate.x;
              coordinate1.y = (int) sCoordinate.y;
              coordinate1.onmap = sCoordinate.onmap;
              index4 = coordinate1.x;
              index5 = coordinate1.y;
            }
            while (coordinate1.onmap & this.MoveMatrixCameFrom[index2, index4, index5].onmap & !(x1 == index4 & y1 == index5));
            int cx = this.game.Data.UnitObj[index3].TempX;
            int cy = this.game.Data.UnitObj[index3].TempY;
            if (cx == -1)
            {
              cx = this.game.Data.UnitObj[index3].X;
              cy = this.game.Data.UnitObj[index3].Y;
              if (cx == -1)
              {
                int num = (int) Interaction.MsgBox((object) "-1 in getscorehexoccup_setmove 2");
                ProjectData.EndApp();
              }
            }
            do
            {
              if (!coordinate2.onmap)
              {
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[cx, cy].Regime) != this.GetGameDataTurn())
                {
                  int[,] hexOccupyMatrix = this.HexOccupyMatrix;
                  int[,] numArray = hexOccupyMatrix;
                  int index6 = cx;
                  int index7 = index6;
                  int index8 = cy;
                  int index9 = index8;
                  int num = hexOccupyMatrix[index6, index8] + 1;
                  numArray[index7, index9] = num;
                  this.TempOwner[cx, cy] = this.GetGameDataTurn();
                }
                int tfacing1 = 1;
                do
                {
                  Coordinate coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing1);
                  if (coordinate3.onmap && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate3.x, coordinate3.y].Regime) != this.GetGameDataTurn())
                  {
                    int defendingPowerPointsOn = this.GetCurrentDefendingPowerPointsOn(coordinate3.x, coordinate3.y);
                    int tfacing2 = 1;
                    do
                    {
                      Coordinate coordinate4 = this.game.HandyFunctionsObj.HexNeighbour(coordinate3.x, coordinate3.y, 0, tfacing2);
                      if (coordinate3.onmap && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate4.x, coordinate4.y].Regime) != this.GetGameDataTurn())
                        defendingPowerPointsOn += this.GetCurrentDefendingPowerPointsOn(coordinate4.x, coordinate4.y);
                      ++tfacing2;
                    }
                    while (tfacing2 <= 6);
                    if (defendingPowerPointsOn == 0 & this.game.Data.MapObj[0].HexObj[coordinate3.x, coordinate3.y].Location <= -1)
                    {
                      int[,] hexOccupyMatrix = this.HexOccupyMatrix;
                      int[,] numArray = hexOccupyMatrix;
                      int x2 = coordinate3.x;
                      int index10 = x2;
                      int y2 = coordinate3.y;
                      int index11 = y2;
                      int num = hexOccupyMatrix[x2, y2] + 1;
                      numArray[index10, index11] = num;
                      this.TempOwner[coordinate3.x, coordinate3.y] = this.GetGameDataTurn();
                    }
                  }
                  ++tfacing1;
                }
                while (tfacing1 <= 6);
              }
              else if (cx == coordinate2.x & cy == coordinate2.y)
                coordinate2.onmap = false;
              sCoordinate sCoordinate = this.MoveMatrixCameFrom[index2, cx, cy];
              coordinate1.x = (int) sCoordinate.x;
              coordinate1.y = (int) sCoordinate.y;
              coordinate1.onmap = sCoordinate.onmap;
              cx = coordinate1.x;
              cy = coordinate1.y;
            }
            while (coordinate1.onmap & this.MoveMatrixCameFrom[index2, cx, cy].onmap & !(x1 == cx & y1 == cy));
          }
        }
      }
    }

    public int getscoreforhexoccupation_enemydistance(int pts, bool makelog)
    {
      int powerPointsAbsolute = this.GetAverageEnemyUnitPowerPointsAbsolute();
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index1 = 1; index1 <= moveMatrixCounter; ++index1)
      {
        int index2 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].IsHQ | this.game.Data.UnitObj[index2].TempCategory == 3)
        {
          int num1;
          if (this.game.Data.UnitObj[index2].AIGroup > -1)
          {
            if (this.GroupType[this.game.Data.UnitObj[index2].AIGroup] > 5)
              num1 = 10;
            else if (this.game.Data.UnitObj[index2].TempCategory == 3)
            {
              num1 = 6;
              if ((double) this.game.Data.RuleVar[361] > 0.0)
                num1 = (int) Math.Round((double) this.game.Data.RuleVar[361]);
            }
            else
            {
              num1 = 4;
              if ((double) this.game.Data.RuleVar[362] > 0.0)
                num1 = (int) Math.Round((double) this.game.Data.RuleVar[362]);
            }
          }
          else
          {
            num1 = 4;
            if ((double) this.game.Data.RuleVar[362] > 0.0)
              num1 = (int) Math.Round((double) this.game.Data.RuleVar[362]);
          }
          int Number = 99;
          int num2 = this.game.Data.UnitObj[index2].TempX - num1;
          int num3 = this.game.Data.UnitObj[index2].TempX + num1;
          for (int x2 = num2; x2 <= num3; ++x2)
          {
            int num4 = this.game.Data.UnitObj[index2].TempY - num1;
            int num5 = this.game.Data.UnitObj[index2].TempY + num1;
            for (int y2 = num4; y2 <= num5; ++y2)
            {
              if (x2 > -1 & y2 > -1 & x2 <= this.game.Data.MapObj[0].MapWidth & y2 <= this.game.Data.MapObj[0].MapHeight && this.GetRegime(this.game.Data.MapObj[0].HexObj[x2, y2].Regime) != this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter > -1)
              {
                int num6 = 0;
                int unitCounter = this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter;
                for (int index3 = 0; index3 <= unitCounter; ++index3)
                {
                  if ((double) this.GetUnitPower(this.game.Data.MapObj[0].HexObj[x2, y2].UnitList[index3], false) > (double) powerPointsAbsolute / 10.0)
                  {
                    if (this.game.Data.UnitObj[this.game.Data.MapObj[0].HexObj[x2, y2].UnitList[index3]].SupplyConsume > 50)
                    {
                      num6 = 1;
                      break;
                    }
                    num6 = 0;
                  }
                  else if (this.game.Data.UnitObj[index2].AIGroup > -1 && this.game.Data.UnitObj[index2].AIGroup > 5)
                  {
                    num6 = 1;
                    break;
                  }
                }
                if (num6 == 1)
                {
                  int num7 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, x2, y2, 0);
                  if (num7 < Number)
                    Number = num7;
                }
              }
            }
          }
          if (Number <= num1 && this.game.Data.UnitObj[index2].AIGroup > -1)
          {
            if (this.GroupType[this.game.Data.UnitObj[index2].AIGroup] > 5)
            {
              int num8 = 600;
              if (this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIDefend & this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIFallback)
                num8 *= 2;
              if ((double) this.game.Data.RuleVar[363] > 0.0)
                num8 = (int) Math.Round((double) this.game.Data.RuleVar[363]);
              if (Number <= num1)
              {
                pts -= (num1 + 1 - Number) * num8;
                if (makelog)
                  this.AddLog("HQ Distance to Enemy penalty. dist= " + Conversion.Str((object) Number) + " , penalty = " + Conversion.Str((object) ((num1 + 1 - Number) * num8)));
              }
            }
            else
            {
              int num9 = 400;
              if (this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIDefend & this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIFallback)
                num9 *= 3;
              if ((double) this.game.Data.RuleVar[363] > 0.0)
                num9 = (int) Math.Round((double) this.game.Data.RuleVar[363]);
              if (Number <= num1)
              {
                pts -= (num1 + 1 - Number) * num9;
                if (makelog)
                  this.AddLog("HQ/Air Distance to Enemy penalty. dist= " + Conversion.Str((object) Number) + " , penalty = " + Conversion.Str((object) ((num1 + 1 - Number) * num9)));
              }
            }
          }
          if (this.game.HandyFunctionsObj.IsHexPort(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0))
          {
            if (makelog)
              this.AddLog("HQ or Air unit in port hex. ");
            int num10 = 100;
            if ((double) this.game.Data.RuleVar[364] > 0.0)
              num10 = (int) Math.Round((double) this.game.Data.RuleVar[364]);
            pts -= num10;
          }
        }
      }
      return pts;
    }

    public int getscoreforhexoccupation_movemarkers(int pts, bool makelog)
    {
      int groupHq = this.GetGroupHQ(this.OpGroup);
      Coordinate coordinate;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle != 1)
      {
        int counter = this.MarkerList.Counter;
        for (int index = 0; index <= counter; ++index)
        {
          if (this.MarkerList.Weight[index] == 2)
          {
            coordinate.x = this.MarkerList.Data1[index];
            coordinate.y = this.MarkerList.Data2[index];
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime) != this.GetGameDataTurn() && this.HexOccupyMatrix[coordinate.x, coordinate.y] > 0)
            {
              int num = (int) Math.Round(Math.Sqrt((double) this.MarkerList.Data5[index]));
              if ((double) this.game.Data.RuleVar[266] > 0.0 && (double) (this.game.HandyFunctionsObj.GetRegimeVP(this.GetGameDataTurn()) + this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].VP) > (double) this.game.Data.RuleVar[266])
                num = (num + 200) * 10;
              if ((double) this.game.Data.RuleVar[359] > 0.0)
                num = (int) Math.Round((double) num * (double) this.game.Data.RuleVar[359] / 100.0);
              pts += num;
              if (makelog)
                this.AddLog("(" + Conversion.Str((object) coordinate.x) + "," + Conversion.Str((object) coordinate.y) + ") = " + Conversion.Str((object) this.MarkerList.Data5[index]) + " pts");
            }
          }
        }
      }
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
          this.ptemp[index1, index2] = 0;
      }
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
      {
        int counter = this.MarkerList.Counter;
        for (int index3 = 0; index3 <= counter; ++index3)
        {
          if (this.MarkerList.Weight[index3] == 3)
          {
            coordinate.x = this.MarkerList.Data1[index3];
            coordinate.y = this.MarkerList.Data2[index3];
            if (this.ptemp[coordinate.x, coordinate.y] == 0)
            {
              int moveMatrixCounter = this.MoveMatrixCounter;
              for (int index4 = 1; index4 <= moveMatrixCounter; ++index4)
              {
                int index5 = this.MoveMatrixUnit[index4];
                if (this.ptemp[coordinate.x, coordinate.y] == 0 && this.game.Data.UnitObj[index5].TempX == coordinate.x & this.game.Data.UnitObj[index5].TempY == coordinate.y)
                {
                  int num = (int) Math.Round(Math.Sqrt((double) this.MarkerList.Data5[index3]));
                  if ((double) this.game.Data.RuleVar[360] > 0.0)
                    num = (int) Math.Round((double) num * (double) this.game.Data.RuleVar[360] / 100.0);
                  pts += num;
                  this.ptemp[coordinate.x, coordinate.y] = 1;
                  if (makelog)
                    this.AddLog("(" + Conversion.Str((object) coordinate.x) + "," + Conversion.Str((object) coordinate.y) + ") = " + Conversion.Str((object) this.MarkerList.Data5[index3]) + " SQRT");
                }
              }
            }
          }
        }
      }
      return pts;
    }

    public int GetScoreForHexOccupationAndHQ2(ref SimpleList TempMove, bool makelog)
    {
      if (this.HexOccupyMatrix.GetUpperBound(0) < this.game.Data.MapObj[0].MapWidth)
        this.HexOccupyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      else if (this.HexOccupyMatrix.GetUpperBound(1) < this.game.Data.MapObj[0].MapHeight)
        this.HexOccupyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int pts = 0;
      this.GetGroupHQ(this.OpGroup);
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.HexOccupyMatrix[index1, index2] = 0;
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
          this.TempOwner[index1, index2] = this.game.Data.MapObj[0].HexObj[index1, index2].Regime;
        }
      }
      this.getscoreforhexoccupation_setmove();
      int num = -1;
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index3 = 1; index3 <= moveMatrixCounter; ++index3)
      {
        int index4;
        if (this.game.Data.UnitObj[index4].IsHQ & this.game.Data.UnitObj[index4].AIGroup > -1)
          num = index4;
      }
      return this.getscoreforhexoccupation_movemarkers(this.getscoreforhexoccupation_enemydistance(this.getscoreforhexoccupation_hq(pts, makelog), makelog), makelog);
    }

    public int GetScoreForEntrench(ref SimpleList TempMove, bool makelog)
    {
      if (this.HexOccupyMatrix.GetUpperBound(0) < this.game.Data.MapObj[0].MapWidth)
        this.HexOccupyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.HexOccupyMatrix[index1, index2] = 0;
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
        }
      }
      int groupHq = this.GetGroupHQ(this.OpGroup);
      int scoreForEntrench = 0;
      this.GetAverageEnemyUnitPowerPointsAbsolute();
      int powerPointsAbsolute = this.GetAverageUnitPowerPointsAbsolute();
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index3 = 1; index3 <= moveMatrixCounter; ++index3)
      {
        int index4 = index3;
        if (index4 > -1)
        {
          int unr = this.MoveMatrixUnit[index4];
          int x1;
          int y1;
          if (this.game.Data.UnitObj[unr].TempCategory == 1 | this.game.Data.UnitObj[unr].TempCategory == 2)
          {
            int x2 = this.game.Data.UnitObj[unr].X;
            int y2 = this.game.Data.UnitObj[unr].Y;
            x1 = this.game.Data.UnitObj[unr].TempX;
            y1 = this.game.Data.UnitObj[unr].TempY;
            if (x1 == -1)
            {
              x1 = this.game.Data.UnitObj[unr].X;
              y1 = this.game.Data.UnitObj[unr].Y;
            }
            int num1;
            if (x2 == x1 & y2 == y1)
            {
              num1 = this.game.HandyFunctionsObj.GetAverageEntrenchPredict(unr, true);
              if (this.game.Data.UnitObj[unr].TempAttacked)
                num1 = this.game.HandyFunctionsObj.GetAverageEntrenchPredict(unr, false);
            }
            else
              num1 = this.game.HandyFunctionsObj.GetAverageEntrenchPredict(unr, false);
            if (this.GetAverageUnitPowerPointsAbsolute() > 0)
              num1 = (int) Math.Round((double) num1 * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) powerPointsAbsolute));
            int d = num1 - this.game.HandyFunctionsObj.GetAverageEntrench(unr);
            if (!(this.tArea[x1, y1] == 2 | this.tArea[x1, y1] == 6))
              d = this.DistToTArea[x1, y1] <= 0 ? 0 : (int) Math.Round((double) d / (double) (2 * this.DistToTArea[x1, y1]));
            if (d > 0)
            {
              if (this.ptemp2[x1, y1] + d > 200)
              {
                if (this.ptemp2[x1, y1] < 200)
                {
                  int num2 = 200 - this.ptemp2[x1, y1];
                  d = num2 + (int) Math.Round(Math.Sqrt(Math.Pow((double) Math.Max(0, d - num2), 1.5)));
                }
                else
                  d = (int) Math.Round(Math.Pow(Math.Sqrt((double) d), 1.5));
              }
              int[,] ptemp2 = this.ptemp2;
              int[,] numArray = ptemp2;
              int index5 = x1;
              int index6 = index5;
              int index7 = y1;
              int index8 = index7;
              int num3 = ptemp2[index5, index7] + d;
              numArray[index6, index8] = num3;
            }
            int Number;
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
            {
              Number = (double) this.game.Data.RuleVar[377] <= 0.0 ? (int) Math.Round((double) d * 0.1) : (int) Math.Round((double) d * (double) this.game.Data.RuleVar[377] / 100.0);
              if (this.CounterAttackPossible[x1, y1] < 100)
                Number = (int) Math.Round((double) Number * 0.25) + (int) Math.Round((double) Number * 0.75 * ((double) this.CounterAttackPossible[x1, y1] / 100.0));
            }
            else
              Number = (double) this.game.Data.RuleVar[378] <= 0.0 ? (int) Math.Round((double) d * 0.5) : (int) Math.Round((double) d * (double) this.game.Data.RuleVar[378] / 100.0);
            if (this.game.Data.UnitObj[unr].TempEncircled == 1)
              Number = (int) Math.Round((double) Number / 8.0);
            if (this.game.Data.UnitObj[unr].TempEncircled == 2)
              Number = 0;
            if (makelog)
              this.AddLog("<" + this.game.Data.UnitObj[unr].Name + "> get " + Conversion.Str((object) Number) + " for entrenchment");
            scoreForEntrench += Number;
          }
          int stackPtsPrognosed = this.game.HandyFunctionsObj.GetHexStackPtsPrognosed(x1, y1, this.game.Data.Turn);
          if ((double) stackPtsPrognosed > (double) this.game.Data.RuleVar[30] * 1.33)
          {
            int Number = (int) Math.Round((double) (int) Math.Round((double) (int) Math.Round((double) stackPtsPrognosed - (double) this.game.Data.RuleVar[30] * 1.33) * ((double) this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) / (double) powerPointsAbsolute)) / 5.0);
            if (Number > 0 && this.game.Data.UnitObj[unr].TempX == this.game.Data.UnitObj[unr].FinalX & this.game.Data.UnitObj[unr].TempY == this.game.Data.UnitObj[unr].FinalY)
            {
              if ((double) this.game.Data.RuleVar[379] > 0.0)
                Number = (int) Math.Round((double) Number * (double) this.game.Data.RuleVar[379] / 100.0);
              if (makelog)
                this.AddLog("PENALTY <" + this.game.Data.UnitObj[unr].Name + "> get " + Conversion.Str((object) Number) + " for stacking");
              scoreForEntrench -= Number;
            }
          }
        }
      }
      return scoreForEntrench;
    }

    public int GetScoreForAttacks(bool Prognosis, bool MakeLog)
    {
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        this.game.Data.UnitObj[index].TempArtDam = 0;
        this.game.Data.UnitObj[index].TempAttacked = false;
      }
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
          this.ptemp3[index1, index2] = 0;
      }
      int counter1 = this.AirMarkerList.Counter;
      Coordinate coordinate;
      int scoreForAttacks;
      for (int index = 0; index <= counter1; ++index)
      {
        if (this.AirMarkerList.Weight[index] == 1)
        {
          coordinate.x = this.AirMarkerList.Data3[index];
          coordinate.y = this.AirMarkerList.Data4[index];
          if (coordinate.x > -1 & coordinate.y > -1 && this.ptemp3[coordinate.x, coordinate.y] == 0)
          {
            this.ptemp3[coordinate.x, coordinate.y] = 1;
            int Number = (int) Math.Round((double) this.GetScoreForAirAttack(coordinate.x, coordinate.y, Prognosis, MakeLog) * ((double) this.AirMarkerList.Data5[index] / 100.0));
            if (Number > 0 && MakeLog)
              this.AddLog("After score modifcation air= " + Conversion.Str((object) Number));
            scoreForAttacks += Number;
          }
        }
      }
      int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
      for (int index3 = 0; index3 <= mapWidth2; ++index3)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index4 = 0; index4 <= mapHeight; ++index4)
          this.ptemp3[index3, index4] = 0;
      }
      int counter2 = this.ArtMarkerList.Counter;
      for (int index = 0; index <= counter2; ++index)
      {
        if (this.ArtMarkerList.Weight[index] == 1)
        {
          coordinate.x = this.ArtMarkerList.Data3[index];
          coordinate.y = this.ArtMarkerList.Data4[index];
          if (this.ptemp3[coordinate.x, coordinate.y] == 0)
          {
            this.ptemp3[coordinate.x, coordinate.y] = 1;
            int Number = (int) Math.Round((double) this.GetScoreForArtAttack(coordinate.x, coordinate.y, Prognosis, MakeLog) * ((double) this.ArtMarkerList.Data5[index] / 100.0));
            if (Number > 0 & MakeLog)
              this.AddLog("After score modifcation art= " + Conversion.Str((object) Number));
            scoreForAttacks += Number;
          }
        }
      }
      int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
      for (int index5 = 0; index5 <= mapWidth3; ++index5)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index6 = 0; index6 <= mapHeight; ++index6)
          this.ptemp3[index5, index6] = 0;
      }
      int counter3 = this.MarkerList.Counter;
      for (int index7 = 0; index7 <= counter3; ++index7)
      {
        if (this.MarkerList.Weight[index7] == 1 && this.MarkerList.Data5[index7] > 0)
        {
          coordinate.x = this.MarkerList.Data3[index7];
          coordinate.y = this.MarkerList.Data4[index7];
          if (this.ptemp3[coordinate.x, coordinate.y] == 0)
          {
            this.ptemp3[coordinate.x, coordinate.y] = 1;
            int num1 = this.GetScoreForAttack(coordinate.x, coordinate.y, Prognosis, MakeLog);
            if (num1 == 0 & (double) this.SupplyMatrixEnemyReal[coordinate.x, coordinate.y] > (double) this.game.Data.RuleVar[3] & this.GetAverageSupplyConsume(coordinate.x, coordinate.y) > 90)
            {
              num1 = this.GetScoreForContainment(coordinate.x, coordinate.y, MakeLog);
              int counter4 = this.game.EditObj.TempUnitList.counter;
              for (int index8 = 0; index8 <= counter4; ++index8)
                this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index8]].TempAttacked = true;
            }
            if (num1 > 0)
            {
              int num2 = this.MarkerList.Data5[index7];
              if (num2 > 300)
                num2 = 300 + (int) Math.Round(Math.Sqrt((double) (num2 - 300)));
              if (num2 < 30)
                num2 = 30;
              int Number = (int) Math.Round((double) num1 * ((double) num2 / 100.0)) + (int) Math.Round((double) num2 / 2.0);
              if (this.AreaMatrixNarrow[coordinate.x, coordinate.y] > 0 && this.AreaIsExtra[this.AreaMatrixNarrow[coordinate.x, coordinate.y]])
              {
                int num3 = num2 + 75;
              }
              if (Number > 0 & MakeLog)
                this.AddLog("After score modifcation norm= " + Conversion.Str((object) Number));
              scoreForAttacks += Number;
            }
          }
        }
      }
      return scoreForAttacks;
    }

    public int GetScoreForContainment(int ix, int iy, bool makelog)
    {
      int Number = 0;
      int attackPowerPointsOn = this.GetPrognosedLandAttackPowerPointsOn(ix, iy, FullAp: true, ForContainment: true);
      int defendingPowerPointsOn = this.GetCurrentDefendingPowerPointsOn(ix, iy, WithoutEntrench: true);
      this.GetGroupHQ(this.OpGroup);
      if (attackPowerPointsOn > 0 & defendingPowerPointsOn > 0)
      {
        Number = (int) Math.Round(Math.Min(1.0, (double) attackPowerPointsOn / (double) defendingPowerPointsOn) * 50.0);
        if (makelog)
          this.AddLog("Containment on Hex <" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ">, Att= " + Conversion.Str((object) attackPowerPointsOn) + ", Def= " + Conversion.Str((object) defendingPowerPointsOn) + ". Gave points for hypothetical attack = " + Conversion.Str((object) Number));
      }
      return Number;
    }

    public int GetScoreForAttack(int ix, int iy, bool Prognosis, bool MakeLog)
    {
      int Number1 = 0;
      int num1 = 0;
      Coordinate landAttackStackOn;
      if (Prognosis)
      {
        Number1 = this.GetPrognosedLandAttackPowerPointsOn(ix, iy, true);
        landAttackStackOn = this.GetPrognosedLandAttackStackOn(ix, iy, true);
        num1 = this.GetPrognosedLandAttackPowerPointsOn(ix, iy, true);
      }
      else if (!Prognosis)
      {
        Number1 = this.GetRealLandAttackPowerPointsOn(ix, iy, true);
        landAttackStackOn = this.GetRealLandAttackStackOn(ix, iy, true);
        num1 = this.GetRealLandAttackPowerPointsOn(ix, iy, true);
      }
      int Number2 = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis);
      int defendingPowerPointsOn = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis, true);
      this.GetCurrentDefendingStackOn(ix, iy, Prognosis);
      if (Number1 > 150 & landAttackStackOn.x < 40)
        Number1 = Number1;
      if (Number1 == 0)
        return 0;
      if (Number1 > 0)
        Number1 = Number1;
      if (this.AreaMatrixNarrow[ix, iy] > 0 && this.AreaIsExtra[this.AreaMatrixNarrow[ix, iy]])
        Number1 = (int) Math.Round((double) Number1 * 1.5);
      if (this.Attacker)
      {
        int pointstempdampercent = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, true);
        if (pointstempdampercent > 100)
          Number1 = (int) Math.Round((double) Number1 * ((double) pointstempdampercent / 100.0));
      }
      if (Number2 == 0 & this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter == -1)
      {
        if (MakeLog)
          this.AddLog("Attack on (" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ") Attacker = " + Conversion.Str((object) Number1) + ", Defender =" + Conversion.Str((object) Number2));
        if (MakeLog)
          this.AddLog("No Defenders. Attack gives 100 pts.");
        return 100;
      }
      this.CorpsTopRatio = (float[]) Utils.CopyArray((Array) this.CorpsTopRatio, (Array) new float[this.GroupCounter + 1]);
      if (this.Attacker && (double) this.CorpsTopRatio[this.OpGroup] > 1.0)
        Number2 = Math.Max((int) Math.Round((double) (defendingPowerPointsOn + Number2) / 2.0), (int) Math.Round((double) Number2 / Math.Sqrt((double) this.CorpsTopRatio[this.OpGroup])));
      float num2 = (float) Number1 / (float) Number2;
      if ((double) num2 > 1.5)
        num2 = 1.5f + (float) Math.Sqrt((double) num2 - 1.5);
      if ((double) num2 > 8.0)
        num2 = 8f;
      int Number3 = (int) Math.Round((double) Conversion.Int(num2 * 20f));
      float num3 = (float) num1 / (float) Number2;
      if ((double) num3 > 2.5)
        num3 = (float) (1.0 + Math.Sqrt((double) num3 - 2.5));
      if ((double) num3 > 8.0)
        num3 = 8f;
      int num4 = (int) Math.Round((double) Conversion.Int(num3 * 20f));
      int val1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
      int groupHq = this.GetGroupHQ(this.OpGroup);
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
        val1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
        val1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
      if (this.Attacker)
      {
        if (this.GetPercentTempUnits() > 20)
          Number3 = (int) Math.Round((double) Number3 * 1.2);
        else if (this.GetPercentTempUnits() > 40)
          Number3 = (int) Math.Round((double) Number3 * 1.4);
        else if (this.GetPercentTempUnits() > 60)
          Number3 = (int) Math.Round((double) Number3 * 1.6);
      }
      if (this.Attacker && (double) this.CorpsTopRatio[this.OpGroup] > 1.0)
        val1 = (int) Math.Round((double) val1 / Math.Sqrt((double) Math.Min(9f, this.CorpsTopRatio[this.OpGroup])));
      if (ix == 42 & iy == 29 & Number3 > 17)
        ix = ix;
      if (ix == 32 & iy == 70 & Number3 > 23)
        ix = ix;
      if (Number3 > 15)
        Number3 = Number3;
      if (Operators.CompareString(this.GroupName[this.OpGroup], "6th Army", false) == 0 & Number3 > 30)
        val1 = val1;
      if (Number1 > 150 & landAttackStackOn.x < 50)
        Number1 = Number1;
      if (Number3 >= Math.Min(val1, (int) Math.Round((double) val1 * ((double) this.AverageSupplyPercentage / 75.0))))
      {
        if (this.Attacker)
        {
          if ((double) this.CorpsTopRatio[this.OpGroup] > 10.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 3;
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 5;
          }
          else if ((double) this.CorpsTopRatio[this.OpGroup] > 7.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 4;
          }
          else if ((double) this.CorpsTopRatio[this.OpGroup] > 5.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
          }
          else if ((double) this.CorpsTopRatio[this.OpGroup] > 3.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 = (int) Math.Round((double) Number3 * 1.25);
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
          }
        }
        if (landAttackStackOn.x > landAttackStackOn.y && this.AverageSupplyPercentage > 50)
        {
          if (MakeLog)
            this.AddLog("Stacking mod " + Conversion.Str((object) ((double) landAttackStackOn.y / (double) landAttackStackOn.x)));
          Number3 = (int) Math.Round(0.2 * (double) Number3) + (int) Math.Round(0.8 * ((double) Number3 * ((double) landAttackStackOn.y / (double) landAttackStackOn.x)));
        }
        if (MakeLog)
          this.GetPrognosedLandUnitOn(ix, iy);
        if (MakeLog)
          this.AddLog("Attack on (" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ") Attacker = " + Conversion.Str((object) Number1) + ", Defender =" + Conversion.Str((object) Number2));
        if (MakeLog)
          this.AddLog("Attack gives " + Conversion.Str((object) Number3) + " pts.");
        int num5 = MakeLog ? 1 : 0;
        int unitCounter = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (int index = 0; index <= unitCounter; ++index)
        {
          int unit = this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index];
          if (this.game.Data.UnitObj[unit].TempCategory == 2 | this.game.Data.UnitObj[unit].TempCategory == 4)
          {
            Number3 = (int) Math.Round((double) Number3 * 1.25);
            if (MakeLog)
              this.AddLog("Attack pts *1.25 cause artillery here");
          }
          if (this.game.Data.UnitObj[unit].TempCategory == 3)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("Attack pts *2 cause air here");
          }
          if (this.game.Data.UnitObj[unit].IsHQ)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("Attack pts *2 cause HQ here");
          }
        }
        int pointstempdampercent = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, Prognosis);
        if (pointstempdampercent > 100)
        {
          Number3 = (int) Math.Round((double) Number3 * ((double) pointstempdampercent / 100.0));
          if (MakeLog)
            this.AddLog("Attack gets bonus for supporting an artillery/air attack " + Conversion.Str((object) pointstempdampercent) + "%");
        }
        int pointsOnOnlyPower = this.GetRealDefendingPowerPointsOnOnlyPower(ix, iy);
        int num6 = 80;
        if ((double) this.game.Data.RuleVar[384] > 0.0)
          num6 = (int) Math.Round((double) this.game.Data.RuleVar[384]);
        if (pointsOnOnlyPower > num6)
        {
          Number3 = (int) Math.Round((double) Number3 * ((double) pointsOnOnlyPower / (double) num6));
          if (MakeLog)
            this.AddLog("Large Target Bonus. " + Conversion.Str((object) (100.0 * ((double) pointsOnOnlyPower / (double) num6) - 100.0)) + "% extra pts!");
        }
        else if ((double) pointsOnOnlyPower < (double) num6 / 8.0)
        {
          Number3 = Math.Max(val1 + 3, (int) Math.Round((double) Number3 * 0.2));
          if (MakeLog)
            this.AddLog("Super small bigunit/8 unit. -80% of pts. ");
        }
        else if ((double) pointsOnOnlyPower < (double) num6 / 4.0)
        {
          Number3 = Math.Max(val1 + 1, (int) Math.Round((double) Number3 * 0.2));
          if (MakeLog)
            this.AddLog("small bigunit/4 unit. -50% of pts. ");
        }
        if (this.DistanceFromSuppliedHex[ix, iy] <= 1)
        {
          if (this.AverageSupplyPercentage < 10)
          {
            Number3 *= 8;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *8");
          }
          else if (this.AverageSupplyPercentage < 30)
          {
            Number3 *= 4;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *4");
          }
          else if (this.AverageSupplyPercentage < 50)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *2");
          }
        }
        else if (this.DistanceFromSuppliedHex[ix, iy] <= 2)
        {
          if (this.AverageSupplyPercentage < 10)
          {
            Number3 *= 4;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *4");
          }
          else if (this.AverageSupplyPercentage < 30)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *2");
          }
        }
        else if (this.DistanceFromSuppliedHex[ix, iy] <= 3 && this.AverageSupplyPercentage < 10)
        {
          Number3 *= 2;
          if (MakeLog)
            this.AddLog("points multiplied due to out of supply situation *2");
        }
        if (MakeLog)
          this.AddLog("Attack after mods gives " + Conversion.Str((object) Number3) + " pts.");
        if (Number3 == 0 && MakeLog)
          this.AddLog("ATTACK CANCELLED. 0 PTS.");
        int counter = this.game.EditObj.TempUnitList.counter;
        for (int index = 0; index <= counter; ++index)
          this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].TempAttacked = true;
        if (Prognosis & (double) num4 >= (double) val1 * 1.5)
        {
          this.TempOwner[ix, iy] = this.GetGameDataTurn();
          if (MakeLog)
            this.AddLog("****** attack leads to conquest of hex!");
        }
      }
      else
      {
        if (Number3 > 0)
        {
          if (MakeLog)
            this.AddLog("To little forces for attack on (" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ") Attacker = " + Conversion.Str((object) Number1) + ", Defender =" + Conversion.Str((object) Number2));
          int counter = this.game.EditObj.TempUnitList.counter;
          for (int index = 0; index <= counter; ++index)
          {
            if (MakeLog)
              this.AddLog("-" + this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].Name);
          }
        }
        Number3 = 0;
      }
      return Number3;
    }

    public float IsDefendingAndAttackingAtRightPlace(int ophq, int ix, int iy, UnitList UL)
    {
      int num1;
      if (this.game.Data.UnitObj[ophq].AIAttack > -1)
      {
        num1 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
        if (num1 == 0)
          num1 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
      }
      int num2;
      if (this.game.Data.UnitObj[ophq].AIDefend > -1)
      {
        num2 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
        if (num2 == 0)
          num2 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
      }
      int num3 = this.AreaMatrixNarrow[ix, iy];
      if (num3 == 0)
        num3 = this.AreaMatrixWide[ix, iy];
      int num4;
      int num5;
      if (num2 > 0 & num3 > 0)
      {
        int counter = UL.counter;
        for (int index = 0; index <= counter; ++index)
        {
          int num6 = this.AreaMatrixNarrow[this.game.Data.UnitObj[UL.unr[index]].X, this.game.Data.UnitObj[UL.unr[index]].Y];
          if (num6 == 0)
          {
            int num7 = this.AreaMatrixWide[this.game.Data.UnitObj[UL.unr[index]].X, this.game.Data.UnitObj[UL.unr[index]].Y];
          }
          if (num6 != num2 & num6 != num1)
          {
            num4 += this.GetUnitPower(UL.unr[index], true);
          }
          else
          {
            num4 += this.GetUnitPower(UL.unr[index], true);
            num5 += this.GetUnitPower(UL.unr[index], true);
          }
        }
      }
      return num4 <= 0 ? 0.0f : (float) num5 / (float) num4;
    }

    public float IsMovingAtRightPlace(int ophq, int ix, int iy)
    {
      int num1;
      if (this.game.Data.UnitObj[ophq].AIAttack > -1)
      {
        num1 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
        if (num1 == 0)
          num1 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
      }
      int num2;
      if (this.game.Data.UnitObj[ophq].AIDefend > -1)
      {
        num2 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
        if (num2 == 0)
          num2 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
      }
      int num3 = this.AreaMatrixNarrow[ix, iy];
      if (num3 == 0)
        num3 = this.AreaMatrixWide[ix, iy];
      return num2 > 0 & num3 > 0 && num3 != num2 & !(num3 == num1 & num1 > 0) ? 0.0f : 1f;
    }

    public int GetScoreForArtAttack(int ix, int iy, bool Prognosis, bool MakeLog)
    {
      int num1 = 0;
      int attackPowerPointsOn;
      if (Prognosis)
        num1 += this.GetPrognosedLandArtAttackPowerPointsOn(ix, iy, true);
      else if (!Prognosis)
      {
        attackPowerPointsOn = this.GetPrognosedLandArtAttackPowerPointsOn(ix, iy, true);
        num1 += this.GetRealLandArtAttackPowerPointsOn(ix, iy, true);
      }
      int defendingPowerPointsOn = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis);
      if (num1 == 0 & attackPowerPointsOn > 0)
        num1 = num1;
      if (num1 == 0)
        return 0;
      if (defendingPowerPointsOn == 0)
      {
        if (MakeLog)
          this.AddLog("ARTILLERY Attack on (" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ") Attacker = " + Conversion.Str((object) num1) + ", Defender =" + Conversion.Str((object) defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("No Defenders. Attack gives 100 pts.");
        return 100;
      }
      int Number = Math.Min(num1, 30000);
      if (Number > 0)
      {
        if (MakeLog)
          this.AddLog("ARTILLERY Attack on (" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ") Attacker = " + Conversion.Str((object) num1) + ", Defender =" + Conversion.Str((object) defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("ARTILLERY Attack gives " + Conversion.Str((object) Number) + " pts.");
        int num2 = 0;
        int unitCounter1 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (int index = 0; index <= unitCounter1; ++index)
          num2 += this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index], false);
        int unitCounter2 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (int index1 = 0; index1 <= unitCounter2; ++index1)
        {
          int unitPower = this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index1], false);
          UnitClass[] unitObj = this.game.Data.UnitObj;
          UnitClass[] unitClassArray = unitObj;
          int[] unitList = this.game.Data.MapObj[0].HexObj[ix, iy].UnitList;
          int[] numArray = unitList;
          int index2 = index1;
          int index3 = index2;
          int index4 = numArray[index3];
          unitClassArray[index4].TempArtDam = unitObj[unitList[index2]].TempArtDam + (int) Math.Round((double) Number * ((double) unitPower / (double) num2));
          if (MakeLog)
            this.AddLog(Conversion.Str((object) (int) Math.Round((double) Number * ((double) unitPower / (double) num2))) + " dam on " + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy));
        }
        int tscore = this.GetTscore(ix, iy);
        Number = tscore <= 0 ? 0 : (int) Math.Round((double) Number * ((double) tscore / 100.0));
        int counter = this.game.EditObj.TempUnitList.counter;
        for (int index = 0; index <= counter; ++index)
          this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].TempAttacked = true;
        int pointstempdampercent = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, Prognosis);
        if (pointstempdampercent > 100)
        {
          Number = (int) Math.Round((double) Number * ((double) pointstempdampercent / 100.0));
          if (MakeLog)
            this.AddLog("Attack gets bonus for supporting an artillery/air attack " + Conversion.Str((object) pointstempdampercent) + "%");
        }
      }
      return (int) Math.Round((double) ((float) Number / (8f * this.CONST_ARTMULTI)));
    }

    public int GetScoreForAirAttack(int ix, int iy, bool Prognosis, bool MakeLog)
    {
      int num1 = 0;
      if (ix == -1 | iy == -1)
        return 0;
      if (Prognosis)
        num1 += this.GetPrognosedAirAttackPowerPointsOn(ix, iy, true);
      else if (!Prognosis)
        num1 += this.GetRealAirAttackPowerPointsOn(ix, iy, true);
      int defendingPowerPointsOn = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis);
      if (num1 > 0)
        MakeLog = MakeLog;
      if (num1 == 0)
        return 0;
      int fighterPowerPointsOn = this.GetPrognosedorRealFighterPowerPointsOn(ix, iy, true, Prognosis: Prognosis);
      if (this.Attacker)
      {
        if ((double) this.FighterMatrix[ix, iy] * 0.5 > (double) fighterPowerPointsOn)
          return 0;
      }
      else if (this.FighterMatrix[ix, iy] * 1 > fighterPowerPointsOn)
        return 0;
      if (defendingPowerPointsOn == 0)
      {
        if (MakeLog)
          this.AddLog("AIR Attack on (" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ") Attacker = " + Conversion.Str((object) num1) + ", Defender =" + Conversion.Str((object) defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("No Defenders. Attack gives 100 pts.");
        return 0;
      }
      int Number = Math.Min(num1, 100000);
      if (Number > 0)
      {
        if (MakeLog)
          this.AddLog("AIR Attack on (" + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy) + ") Attacker = " + Conversion.Str((object) num1) + ", Defender =" + Conversion.Str((object) defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("AIR Attack gives " + Conversion.Str((object) Number) + " pts.");
        int num2 = 0;
        int unitCounter1 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (int index = 0; index <= unitCounter1; ++index)
          num2 += this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index], false);
        int unitCounter2 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (int index1 = 0; index1 <= unitCounter2; ++index1)
        {
          int unitPower = this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index1], false);
          UnitClass[] unitObj = this.game.Data.UnitObj;
          UnitClass[] unitClassArray = unitObj;
          int[] unitList = this.game.Data.MapObj[0].HexObj[ix, iy].UnitList;
          int[] numArray = unitList;
          int index2 = index1;
          int index3 = index2;
          int index4 = numArray[index3];
          unitClassArray[index4].TempArtDam = unitObj[unitList[index2]].TempArtDam + (int) Math.Round((double) Number * ((double) unitPower / (double) num2));
          if (MakeLog)
            this.AddLog(Conversion.Str((object) (int) Math.Round((double) Number * ((double) unitPower / (double) num2))) + " air dam on " + Conversion.Str((object) ix) + "," + Conversion.Str((object) iy));
        }
        int tscore = this.GetTscore(ix, iy);
        Number = tscore <= 0 ? 0 : (int) Math.Round((double) Number * (100.0 / (double) tscore));
        int counter = this.game.EditObj.TempUnitList.counter;
        for (int index = 0; index <= counter; ++index)
          this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].TempAttacked = true;
        int pointstempdampercent = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, Prognosis);
        if (pointstempdampercent > 100)
        {
          Number = (int) Math.Round((double) Number * ((double) pointstempdampercent / 100.0));
          if (MakeLog)
            this.AddLog("Attack gets bonus for supporting an artillery/air attack " + Conversion.Str((object) pointstempdampercent) + "%");
        }
      }
      return (int) Math.Round((double) ((float) Number / (8f * this.CONST_AIRMULTI)));
    }

    public int GetFreeAP(bool ModifiedForStrength)
    {
      int unitCounter1 = this.game.Data.UnitCounter;
      int num1;
      int num2;
      for (int unr = 0; unr <= unitCounter1; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup & this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].PreDef == -1)
        {
          num1 += this.game.HandyFunctionsObj.GetPower(unr, this.game.Data.Turn);
          ++num2;
        }
      }
      if (num2 < 1)
        return 0;
      int num3 = (int) Math.Round(Conversion.Int((double) num1 / (double) num2));
      int num4 = 0;
      int unitCounter2 = this.game.Data.UnitCounter;
      for (int unr = 0; unr <= unitCounter2; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup & this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].PreDef == -1)
        {
          int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(unr);
          int num5 = this.game.Data.UnitObj[unr].TempX <= -1 ? lowestAp : lowestAp - this.MoveMatrix[this.game.Data.UnitObj[unr].TempSlot, this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY];
          if (ModifiedForStrength)
            num5 = (int) Math.Round((double) ((float) num5 * ((float) this.game.HandyFunctionsObj.GetPower(unr, this.game.Data.Turn) / (float) num3)));
          num4 += num5;
        }
      }
      return (int) Math.Round(Conversion.Int((double) num4 / (double) num2));
    }

    public float GetAverageCombatScore(
      int attsftype,
      int x,
      int y,
      bool isArtilleryattack = false,
      bool EnemyVersusTempLocs = false)
    {
      float num1 = 0.0f;
      int num2 = 0;
      if (!EnemyVersusTempLocs)
      {
        int unitCounter = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
        for (int index1 = 0; index1 <= unitCounter; ++index1)
        {
          int unit = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index1];
          int sfCount = this.game.Data.UnitObj[unit].SFCount;
          for (int index2 = 0; index2 <= sfCount; ++index2)
          {
            int index3 = this.game.Data.UnitObj[unit].SFList[index2];
            int type = this.game.Data.SFObj[index3].Type;
            if (attsftype == 68)
              index3 = index3;
            int num3 = (int) Math.Round((double) ((float) (this.game.Data.SFObj[index3].Qty * this.game.Data.SFTypeObj[type].PowerPts) * this.CombatMatrix[attsftype, type]));
            if (isArtilleryattack)
              num3 = (int) Math.Round((double) num3 / ((double) (this.game.Data.SFObj[index3].CurrentEntrench + 70) / 70.0));
            if (this.game.Data.SFTypeObj[type].BackBench)
            {
              num1 += (float) (int) Math.Round((double) num3 / 4.0);
              num2 += (int) Math.Round((double) (this.game.Data.SFObj[index3].Qty * this.game.Data.SFTypeObj[type].PowerPts) / 4.0);
            }
            else
            {
              num1 += (float) num3;
              num2 += this.game.Data.SFObj[index3].Qty * this.game.Data.SFTypeObj[type].PowerPts;
            }
          }
        }
      }
      else
      {
        int moveMatrixCounter = this.MoveMatrixCounter;
        for (int index4 = 0; index4 <= moveMatrixCounter; ++index4)
        {
          int index5 = this.MoveMatrixUnit[index4];
          if (index5 > -1 && this.game.Data.UnitObj[index5].TempX == x & this.game.Data.UnitObj[index5].TempY == y)
          {
            int sfCount = this.game.Data.UnitObj[index5].SFCount;
            for (int index6 = 0; index6 <= sfCount; ++index6)
            {
              int sf = this.game.Data.UnitObj[index5].SFList[index6];
              int type = this.game.Data.SFObj[sf].Type;
              int num4 = (int) Math.Round((double) ((float) (this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts) * this.CombatMatrix[attsftype, type]));
              if (this.game.Data.SFTypeObj[type].BackBench)
              {
                num1 += (float) (int) Math.Round((double) num4 / 4.0);
                num2 += (int) Math.Round((double) (this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts) / 4.0);
              }
              else
              {
                num1 += (float) num4;
                num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
              }
            }
          }
        }
      }
      return num2 == 0 | (double) num1 == 0.0 ? 1f : num1 / (float) num2;
    }

    public int GetDivisionalPower(int unr, int grp)
    {
      int divisionalPower = 0;
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr1 = 0; unr1 <= unitCounter; ++unr1)
      {
        if (this.game.Data.UnitObj[unr1].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr1].PreDef == -1 & this.game.Data.UnitObj[unr1].X > -1 && this.game.Data.UnitObj[unr].Historical == this.game.Data.UnitObj[unr1].Historical && this.game.Data.UnitObj[unr1].AIGroup == grp | grp == -1)
          divisionalPower += this.GetUnitPower(unr1, false);
      }
      return divisionalPower;
    }

    public int GetCurrentDefendingPowerPointsOn(
      int x,
      int y,
      bool Prognosis = false,
      bool WithoutEntrench = false,
      bool DontCountAir = false)
    {
      int unitCounter = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      int defendingPowerPointsOn;
      int num1;
      for (int index = 0; index <= unitCounter; ++index)
      {
        int unit = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        int num2;
        if (!DontCountAir | !this.game.HandyFunctionsObj.HasUnitAirSF(unit))
        {
          if (WithoutEntrench)
          {
            num2 = this.GetUnitPower(unit, false, WithoutEntrench: WithoutEntrench);
          }
          else
          {
            num2 = this.game.Data.UnitObj[unit].TempUnitPower;
            int num3 = (int) Math.Round((double) num2 / (1.0 + (double) this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 100.0));
            if (num3 <= 0)
              num3 = 1;
            if (Prognosis && this.game.Data.UnitObj[unit].TempArtDam > 0)
            {
              int num4 = (int) Math.Round((double) this.game.Data.UnitObj[unit].TempArtDam / (1.0 + (double) this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 100.0));
              num2 = (int) Math.Round(((double) Math.Max(0, num3 - num4) * ((double) num4 / (double) num3) * 2.0 + (double) (Math.Max(0, num2 - num4) * 1)) / (1.0 + 2.0 * ((double) num4 / (double) num3)));
              if ((double) num3 * 0.33 > (double) num2)
                num2 = (int) Math.Round((double) num3 / 3.0);
            }
          }
        }
        defendingPowerPointsOn += num2;
        num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unit);
      }
      if ((double) num1 > (double) this.game.Data.RuleVar[30])
        defendingPowerPointsOn = (int) Math.Round((double) Conversion.Int((float) defendingPowerPointsOn * (this.game.Data.RuleVar[30] / (float) num1)));
      return defendingPowerPointsOn;
    }

    public int GetAverageSupplyConsume(int x, int y)
    {
      int unitCounter = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      int num1;
      int num2;
      for (int index = 0; index <= unitCounter; ++index)
      {
        int unit = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        int unitPower = this.GetUnitPower(unit, false);
        num1 += unitPower;
        num2 += unitPower * this.game.Data.UnitObj[unit].SupplyConsume;
      }
      if (num1 == 0)
        num1 = 1;
      if (num2 == 0)
        num2 = 100;
      return (int) Math.Round((double) num2 / (double) num1);
    }

    public int GetCurrentDefendingStackOn(int x, int y, bool Prognosis = false, bool WithoutEntrench = false)
    {
      int unitCounter = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      int defendingStackOn;
      for (int index = 0; index <= unitCounter; ++index)
      {
        int unit = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        int num1 = this.GetUnitPower(unit, false, WithoutEntrench: WithoutEntrench);
        int num2 = (int) Math.Round((double) num1 / (1.0 + (double) this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 100.0));
        if (num2 <= 1)
          num2 = 1;
        if (Prognosis && this.game.Data.UnitObj[unit].TempArtDam > 0)
        {
          int num3 = this.game.Data.UnitObj[unit].TempArtDam;
          if (num3 > 80)
            num3 = num3;
          int num4 = (int) Math.Round((double) num3 / (1.0 + (double) this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 2.0 / 100.0));
          num1 = (int) Math.Round(((double) Math.Max(0, num2 - num4) * ((double) num4 / (double) num2) * 2.0 + (double) (Math.Max(0, num1 - num4) * 1)) / (1.0 + 2.0 * ((double) num4 / (double) num2)));
          if ((double) num2 * 0.5 > (double) num1)
            num1 = (int) Math.Round((double) num2 / 2.0);
        }
        int num5;
        num5 += num1;
        defendingStackOn += this.game.HandyFunctionsObj.GetUnitStackPts(unit);
      }
      return defendingStackOn;
    }

    public int GetCurrentDefendingPowerPointstempdampercent(int x, int y, bool Prognosis = false)
    {
      int unitCounter = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      int num1;
      int num2;
      for (int index = 0; index <= unitCounter; ++index)
      {
        int unit = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        int unitPower = this.GetUnitPower(unit, false);
        int num3 = 0;
        if (Prognosis && this.game.Data.UnitObj[unit].TempArtDam > 0)
          num3 = this.game.Data.UnitObj[unit].TempArtDam * 2;
        num1 += unitPower;
        num2 += num3;
      }
      if (num1 == 0)
        return 0;
      int pointstempdampercent = (int) Math.Round(100.0 * ((double) num2 / (double) num1));
      if (pointstempdampercent > 160)
        pointstempdampercent = 160;
      return pointstempdampercent;
    }

    public int GetPrognosedDefendingPowerPointsOnOnlyPower(int x, int y)
    {
      int unitCounter = this.game.Data.UnitCounter;
      int pointsOnOnlyPower;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].TempX == x & this.game.Data.UnitObj[unr].TempY == y && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn())
        {
          int powerPtsAbsolute = this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          pointsOnOnlyPower += powerPtsAbsolute;
        }
      }
      return pointsOnOnlyPower;
    }

    public int GetRealDefendingPowerPointsOnOnlyPower(int x, int y)
    {
      int unitCounter = this.game.Data.UnitCounter;
      int pointsOnOnlyPower;
      for (int unr = 0; unr <= unitCounter; ++unr)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X == x & this.game.Data.UnitObj[unr].Y == y)
        {
          int powerPtsAbsolute = this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          pointsOnOnlyPower += powerPtsAbsolute;
        }
      }
      return pointsOnOnlyPower;
    }

    public int GetPrognosedDefendingPowerPointsOn(
      int x,
      int y,
      bool WithStack = true,
      bool OnlyOpGroup = false,
      int OnlyUnit = -1,
      bool CounterAttack = false)
    {
      int unitCounter = this.game.Data.UnitCounter;
      int defendingPowerPointsOn;
      int num1;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].TempX == x & this.game.Data.UnitObj[index].TempY == y | this.game.Data.UnitObj[index].X == x & this.game.Data.UnitObj[index].Y == y && OnlyUnit == -1 | OnlyUnit == index)
        {
          int num2 = 0;
          if (!OnlyOpGroup | this.game.Data.UnitObj[index].AIGroup == this.OpGroup & this.game.Data.UnitObj[index].TempX == x & this.game.Data.UnitObj[index].TempY == y)
            num2 = 1;
          else if (this.game.Data.UnitObj[index].AIGroup != this.OpGroup)
          {
            num2 = this.game.Data.UnitObj[index].AIDefend != this.AreaMatrixNarrow[x, y] ? 2 : 1;
            if (this.game.Data.UnitObj[index].IsHQ)
              num2 = 0;
          }
          if (num2 >= 1)
          {
            int unr = index;
            int num3 = !(CounterAttack & this.game.Data.UnitObj[unr].TempX > -1) ? this.game.Data.UnitObj[unr].TempUnitPower : this.GetUnitPower(unr, false, UseTempCoords: true);
            if (num2 == 2)
              num3 = -((double) num3 == (double) num3 / 3.0 ? 1 : 0);
            int num4 = (int) Math.Round((double) num3 * ((double) (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num4;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
        }
      }
      if ((double) num1 > (double) this.game.Data.RuleVar[30] & WithStack)
        defendingPowerPointsOn = (int) Math.Round(Conversion.Int((double) defendingPowerPointsOn * 0.33) + Conversion.Int((double) defendingPowerPointsOn * 0.66 * ((double) this.game.Data.RuleVar[30] / (double) num1)));
      return defendingPowerPointsOn;
    }

    public int GetPrognosedAndRealDefendingPowerPointsOn(
      int x,
      int y,
      bool WithStack = true,
      bool CounterAttack = false)
    {
      int moveMatrixCounter = this.MoveMatrixCounter;
      int defendingPowerPointsOn;
      int num1;
      for (int index1 = 0; index1 <= moveMatrixCounter; ++index1)
      {
        int index2 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index2].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[index2].TempX == x & this.game.Data.UnitObj[index2].TempY == y)
          {
            int unr = index2;
            int num2 = (int) Math.Round((!(CounterAttack & this.game.Data.UnitObj[unr].TempX > -1) ? (double) this.game.Data.UnitObj[unr].TempUnitPower : (double) this.GetUnitPower(unr, false, UseTempCoords: true)) * ((double) (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num2;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
          else if (this.game.Data.UnitObj[index2].TempX == -1 && this.game.Data.UnitObj[index2].X == x & this.game.Data.UnitObj[index2].Y == y)
          {
            int unr = index2;
            int num3 = (int) Math.Round((!(CounterAttack & this.game.Data.UnitObj[unr].TempX > -1) ? (double) this.game.Data.UnitObj[unr].TempUnitPower : (double) this.GetUnitPower(unr, false, UseTempCoords: true)) * ((double) (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num3;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
        }
      }
      int unitCounter = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        int unit = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        if (this.game.Data.UnitObj[unit].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unit].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[unit].TempX == x & this.game.Data.UnitObj[unit].TempY == y)
          {
            int unr = unit;
            int num4 = (int) Math.Round((double) this.game.Data.UnitObj[unr].TempUnitPower * ((double) (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num4;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
          else if (this.game.Data.UnitObj[unit].TempX == -1 && this.game.Data.UnitObj[unit].X == x & this.game.Data.UnitObj[unit].Y == y)
          {
            int unr = unit;
            int num5 = (int) Math.Round((double) this.game.Data.UnitObj[unr].TempUnitPower * ((double) (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num5;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
        }
      }
      if ((double) num1 > (double) this.game.Data.RuleVar[30] & WithStack)
        defendingPowerPointsOn = (int) Math.Round(Conversion.Int((double) defendingPowerPointsOn * 0.33) + Conversion.Int((double) defendingPowerPointsOn * 0.66 * ((double) this.game.Data.RuleVar[30] / (double) num1)));
      return defendingPowerPointsOn;
    }

    public float GetRiverMod(int unr, int riv)
    {
      int sfCount = this.game.Data.UnitObj[unr].SFCount;
      float num1;
      int num2;
      for (int index = 0; index <= sfCount; ++index)
      {
        int sf = this.game.Data.UnitObj[unr].SFList[index];
        int unitGroup = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup;
        float num3 = 1f - this.game.Data.RiverTypeObj[riv].AttackPenalty[unitGroup];
        num1 += num3 * (float) this.game.Data.SFObj[sf].Qty * (float) this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      return num1 / (float) num2;
    }

    public int GetPrognosedEnemyLandAttackPowerPointsOn(
      int x,
      int y,
      bool UseTempCoord = false,
      bool OptimisticStack = false,
      bool LeaveFrontLineEmptyPenalty = false)
    {
      UnitList unitList = new UnitList();
      if (x == -1 | y == -1 | x > this.game.Data.MapObj[0].MapWidth | y > this.game.Data.MapObj[0].MapHeight)
        return 0;
      int attackPowerPointsOn = 0;
      int num1;
      if (UseTempCoord)
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int index = 0; index <= unitCounter; ++index)
        {
          if (this.game.Data.UnitObj[index].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index].Regime) != this.GetGameDataTurn() & this.game.Data.UnitObj[index].TempSlot > -1)
          {
            Coordinate coordinate1;
            coordinate1.x = this.game.Data.UnitObj[index].TempX;
            coordinate1.y = this.game.Data.UnitObj[index].TempY;
            if (coordinate1.x > -1 & coordinate1.y > -1)
            {
              int tfacing = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
                if (coordinate2.onmap && coordinate1.x == coordinate2.x & coordinate1.y == coordinate2.y && Math.Min(120, this.game.HandyFunctionsObj.GetAverageRdn(index) + 30) - this.EnemyMatrix[this.game.Data.UnitObj[index].TempSlot, x, y] >= 0)
                {
                  int unitPower = this.GetUnitPower(index, true, x, y, tfacing - 1, EnemyAttack: true);
                  num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                  attackPowerPointsOn += unitPower;
                  unitList.add(index);
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      else
      {
        int enemyMatrixCounter = this.EnemyMatrixCounter;
        for (int index1 = 1; index1 <= enemyMatrixCounter; ++index1)
        {
          int index2 = this.EnemyMatrixUnit[index1];
          if (Math.Min(120, this.game.HandyFunctionsObj.GetAverageRdn(index2) + 30) - this.EnemyMatrix[index1, x, y] >= 0)
          {
            int num2;
            int num3 = this.GetUnitPower(index2, true, x, y, num2 - 1, EnemyAttack: true);
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index2);
            this.game.Data.UnitObj[index2].TempX = (int) this.EnemyMatrixCameFrom[index1, x, y].x;
            this.game.Data.UnitObj[index2].TempY = (int) this.EnemyMatrixCameFrom[index1, x, y].y;
            if (this.game.Data.UnitObj[index2].TempX != this.game.Data.UnitObj[index2].X & this.game.Data.UnitObj[index2].TempY != this.game.Data.UnitObj[index2].Y)
            {
              int num4 = this.EnemyMatrix[index1, x, y] - this.EnemyMatrix[index1, this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] + 30;
              if (num4 > 0 & num4 < 70)
                num3 -= (int) Math.Round((double) num3 * ((double) num4 / 70.0));
              else
                num3 = 0;
              if (LeaveFrontLineEmptyPenalty && this.EnemyFrontlineArea[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] > 0)
                num3 = (int) Math.Round((double) num3 / 3.0);
            }
            if (num3 > 0)
            {
              attackPowerPointsOn += num3;
              unitList.add(index2);
            }
          }
        }
      }
      if (attackPowerPointsOn > 0)
      {
        this.game.EditObj.OrderX = x;
        this.game.EditObj.OrderY = y;
        this.game.EditObj.TargetX = x;
        this.game.EditObj.TargetY = y;
        this.game.EditObj.TempUnitList = unitList;
        attackPowerPointsOn = (int) Math.Round((double) ((float) attackPowerPointsOn * this.game.HandyFunctionsObj.GetConcentricBonus2Prognosis(false)));
        int num5 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
        this.game.EditObj.TargetX = -1;
        this.game.EditObj.TargetY = -1;
        if (num1 > num5)
        {
          if (!OptimisticStack)
            attackPowerPointsOn = (int) Math.Round(0.15 * (double) attackPowerPointsOn + 0.85 * (double) (int) Math.Round((double) attackPowerPointsOn * ((double) num5 / (double) num1)));
          else if (num1 > num5)
            attackPowerPointsOn = (int) Math.Round(0.25 * (double) attackPowerPointsOn + 0.75 * (double) (int) Math.Round((double) attackPowerPointsOn * ((double) num5 / (double) num1)));
        }
      }
      return attackPowerPointsOn;
    }

    public int GetPrognosedEnemyStackPointsOn(
      int x,
      int y,
      bool UseTempCoord = false,
      bool OptimisticStack = false)
    {
      UnitList unitList = new UnitList();
      if (x == -1 | y == -1 | x > this.game.Data.MapObj[0].MapWidth | y > this.game.Data.MapObj[0].MapHeight)
        return 0;
      int enemyStackPointsOn;
      if (UseTempCoord)
      {
        int unitCounter = this.game.Data.UnitCounter;
        for (int unr = 0; unr <= unitCounter; ++unr)
        {
          if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) != this.GetGameDataTurn() & this.game.Data.UnitObj[unr].TempSlot > -1)
          {
            Coordinate coordinate1;
            coordinate1.x = this.game.Data.UnitObj[unr].TempX;
            coordinate1.y = this.game.Data.UnitObj[unr].TempY;
            if (coordinate1.x > -1 & coordinate1.y > -1)
            {
              int tfacing = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
                if (coordinate2.onmap && coordinate1.x == coordinate2.x & coordinate1.y == coordinate2.y && this.game.HandyFunctionsObj.GetAverageRdn(unr) - this.EnemyMatrix[this.game.Data.UnitObj[unr].TempSlot, x, y] >= 0)
                  enemyStackPointsOn += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      else
      {
        int enemyMatrixCounter = this.EnemyMatrixCounter;
        for (int index = 1; index <= enemyMatrixCounter; ++index)
        {
          int unr = this.EnemyMatrixUnit[index];
          if (this.game.HandyFunctionsObj.GetAverageRdn(unr) - this.EnemyMatrix[index, x, y] >= 0)
            enemyStackPointsOn += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
        }
      }
      return enemyStackPointsOn;
    }

    public int GetAIRolePercent(int unr, int rolenr)
    {
      int sfCount = this.game.Data.UnitObj[unr].SFCount;
      int num1;
      int num2;
      for (int index = 0; index <= sfCount; ++index)
      {
        int sf = this.game.Data.UnitObj[unr].SFList[index];
        int type = this.game.Data.SFObj[sf].Type;
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
        if (this.game.Data.SFTypeObj[type].AIRoleScore[rolenr] > 0)
          num2 += (int) Math.Round((double) (this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts) * ((double) this.game.Data.SFTypeObj[type].AIRoleScore[rolenr] / 100.0));
      }
      return num1 == 0 ? 0 : (int) Math.Round(Conversion.Int((double) (100 * num2) / (double) num1));
    }

    public int GetReinforcementTypePercent(int unr, int rolenr)
    {
      int sfCount = this.game.Data.UnitObj[unr].SFCount;
      int num1;
      int num2;
      for (int index = 0; index <= sfCount; ++index)
      {
        int sf = this.game.Data.UnitObj[unr].SFList[index];
        int type = this.game.Data.SFObj[sf].Type;
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
        if (this.game.Data.SFTypeObj[type].ReinforcementType == rolenr)
          num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
      }
      return num1 == 0 ? 0 : (int) Math.Round(Conversion.Int((double) (100 * num2) / (double) num1));
    }

    public int GetPrognosedLandAttackPowerPointsOn(
      int x,
      int y,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = new UnitList();
      int tfacing = 1;
      int num1;
      int attackPowerPointsOn;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          int moveMatrixCounter = this.MoveMatrixCounter;
          for (int index1 = 1; index1 <= moveMatrixCounter; ++index1)
          {
            int index2 = this.MoveMatrixUnit[index1];
            if (this.game.Data.UnitObj[index2].TempX == coordinate.x & this.game.Data.UnitObj[index2].TempY == coordinate.y && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 1 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup & !this.game.Data.UnitObj[index2].IsHQ)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ((double) this.game.HandyFunctionsObj.GetAverageRdn(index2) >= 70.0 * ((1.0 + (double) Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index2].SupplyIn == 0)
              {
                int num2 = FullAp ? this.game.Data.UnitObj[index2].SupplyConsume : this.game.HandyFunctionsObj.GetLowestAp(index2) - this.MoveMatrix[this.game.Data.UnitObj[index2].TempSlot, coordinate.x, coordinate.y];
                int x1 = this.game.HandyFunctionsObj.MoveApCostPreview(index2, coordinate.x, coordinate.y, coordinate.x, coordinate.y, 0, x, y, 0, true).x;
                if (num2 >= x1)
                {
                  int num3 = this.GetUnitPower(index2, true, x, y, tfacing - 1);
                  num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index2);
                  if (AdjustedForAp)
                  {
                    int num4 = num2;
                    num3 = num4 > 25 ? (int) Math.Round((double) num3 * ((double) (num4 - 25) / (double) num4)) : 0;
                  }
                  if (ForContainment && this.game.Data.UnitObj[index2].SupplyConsume > 0 && (double) this.game.Data.UnitObj[index2].SupplyIn < (double) this.game.Data.UnitObj[index2].SupplyInReq * 0.25)
                    num3 *= 10;
                  attackPowerPointsOn += num3;
                  unitList.add(index2);
                }
              }
            }
          }
        }
        ++tfacing;
      }
      while (tfacing <= 6);
      if (attackPowerPointsOn > 0)
      {
        this.game.EditObj.OrderX = x;
        this.game.EditObj.OrderY = y;
        this.game.EditObj.TargetX = x;
        this.game.EditObj.TargetY = y;
        this.game.EditObj.TempUnitList = unitList;
        attackPowerPointsOn = (int) Math.Round((double) (int) Math.Round((double) ((float) attackPowerPointsOn * this.game.HandyFunctionsObj.GetConcentricBonus2Prognosis(false))) * ((double) (100 + this.game.HandyFunctionsObj.GetDivBonusForAttackPrognosis(x, y)) / 100.0));
        int num5 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
        this.game.EditObj.TargetX = -1;
        this.game.EditObj.TargetY = -1;
        int num6 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
        if (num6 > num5)
          attackPowerPointsOn = (double) this.CorpsTopRatio[this.OpGroup] <= 9.0 ? ((double) this.CorpsTopRatio[this.OpGroup] <= 6.0 ? ((double) this.CorpsTopRatio[this.OpGroup] <= 4.0 ? ((double) this.CorpsTopRatio[this.OpGroup] <= 3.0 ? ((double) this.CorpsTopRatio[this.OpGroup] <= 2.0 ? ((double) this.CorpsTopRatio[this.OpGroup] <= 1.5 ? (int) Math.Round(0.4 * (double) attackPowerPointsOn + 0.6 * (double) attackPowerPointsOn * ((double) num5 / (double) num6)) : (int) Math.Round(0.45 * (double) attackPowerPointsOn + 0.55 * (double) attackPowerPointsOn * ((double) num5 / (double) num6))) : (int) Math.Round(0.5 * (double) attackPowerPointsOn + 0.5 * (double) attackPowerPointsOn * ((double) num5 / (double) num6))) : (int) Math.Round(0.55 * (double) attackPowerPointsOn + 0.45 * (double) attackPowerPointsOn * ((double) num5 / (double) num6))) : (int) Math.Round(0.6 * (double) attackPowerPointsOn + 0.4 * (double) attackPowerPointsOn * ((double) num5 / (double) num6))) : (int) Math.Round(0.7 * (double) attackPowerPointsOn + 0.3 * (double) attackPowerPointsOn * ((double) num5 / (double) num6))) : (int) Math.Round(0.8 * (double) attackPowerPointsOn + 0.2 * (double) attackPowerPointsOn * ((double) num5 / (double) num6));
      }
      return attackPowerPointsOn;
    }

    public void GetPrognosedLandUnitOn(int x, int y)
    {
      UnitList unitList = new UnitList();
      string s = "PARTICIPANTS: ";
      int tfacing = 1;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          int unitCounter = this.game.Data.UnitCounter;
          for (int index = 0; index <= unitCounter; ++index)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].TempX == coordinate.x & this.game.Data.UnitObj[index].TempY == coordinate.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & !this.game.Data.UnitObj[index].IsHQ)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ((double) this.game.HandyFunctionsObj.GetAverageRdn(index) >= 70.0 * ((1.0 + (double) Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index].SupplyIn == 0)
              {
                int Number = this.game.HandyFunctionsObj.GetLowestAp(index) - this.MoveMatrix[this.game.Data.UnitObj[index].TempSlot, coordinate.x, coordinate.y];
                HandyFunctionsclass handyFunctionsObj = this.game.HandyFunctionsObj;
                int unr = index;
                int x1 = coordinate.x;
                int y1 = coordinate.y;
                int x2 = x;
                int y2 = y;
                CustomDC2AICalls customDc2AiCalls = (CustomDC2AICalls) null;
                ref CustomDC2AICalls local = ref customDc2AiCalls;
                int num1 = handyFunctionsObj.MoveApCostPreview3(unr, x1, y1, 0, x2, y2, 0, true, tcustomAi: (ref local));
                if (Number > num1)
                {
                  int unitPower = this.GetUnitPower(index, true, x, y, tfacing - 1);
                  int num2;
                  num2 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                  s = s + this.game.Data.UnitObj[index].Name + " (" + Conversion.Str((object) Number) + "ap), ";
                  int num3;
                  num3 += unitPower;
                  unitList.add(index);
                }
              }
            }
          }
        }
        ++tfacing;
      }
      while (tfacing <= 6);
      this.AddLog(s);
    }

    public Coordinate GetPrognosedLandAttackStackOn(
      int x,
      int y,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = new UnitList();
      int tfacing = 1;
      Coordinate landAttackStackOn;
      int num1;
      do
      {
        landAttackStackOn = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (landAttackStackOn.onmap)
        {
          int unitCounter = this.game.Data.UnitCounter;
          for (int index = 0; index <= unitCounter; ++index)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].TempX == landAttackStackOn.x & this.game.Data.UnitObj[index].TempY == landAttackStackOn.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & !this.game.Data.UnitObj[index].IsHQ)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ((double) this.game.HandyFunctionsObj.GetAverageRdn(index) >= 70.0 * ((1.0 + (double) Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index].SupplyIn == 0 && (FullAp ? this.game.Data.UnitObj[index].SupplyConsume : this.game.HandyFunctionsObj.GetLowestAp(index) - this.MoveMatrix[this.game.Data.UnitObj[index].TempSlot, landAttackStackOn.x, landAttackStackOn.y]) >= this.game.HandyFunctionsObj.MoveApCostPreview(index, landAttackStackOn.x, landAttackStackOn.y, landAttackStackOn.x, landAttackStackOn.y, 0, x, y, 0, true).x)
              {
                int num2 = this.GetUnitPower(index, true, x, y, tfacing - 1);
                num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                if (AdjustedForAp)
                {
                  int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(index);
                  num2 = lowestAp > 25 ? (int) Math.Round((double) num2 * ((double) (lowestAp - 25) / (double) lowestAp)) : 0;
                }
                if (ForContainment && this.game.Data.UnitObj[index].SupplyConsume > 0 && (double) this.game.Data.UnitObj[index].SupplyIn < (double) this.game.Data.UnitObj[index].SupplyInReq * 0.25)
                  num2 *= 10;
                int num3;
                num3 += num2;
                unitList.add(index);
              }
            }
          }
        }
        ++tfacing;
      }
      while (tfacing <= 6);
      this.game.EditObj.TargetX = x;
      this.game.EditObj.TargetY = y;
      this.game.EditObj.TempUnitList = unitList;
      int num4 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
      int num5 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
      landAttackStackOn.x = num5;
      landAttackStackOn.y = num4;
      return landAttackStackOn;
    }

    public int GetPrognosedAirAttackPowerPointsOn(
      int x,
      int y,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = new UnitList();
      int moveMatrixCounter = this.MoveMatrixCounter;
      int num1;
      int num2;
      int num3;
      int attackPowerPointsOn;
      for (int index1 = 1; index1 <= moveMatrixCounter; ++index1)
      {
        int index2 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].TempCategory == 3 && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 3 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup)
        {
          float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
          if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0)
            val2 = 1f;
          if ((double) this.game.HandyFunctionsObj.GetAverageAirRdn(index2) >= 80.0 * ((2.0 + (double) Math.Min(1f, val2)) / 3.0))
          {
            int num4;
            if (!FullAp)
            {
              int num5 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, 0) * this.GetSlowestAirSpeed(index2);
              num4 = this.game.HandyFunctionsObj.GetLowestAirAp(index2) - num5;
            }
            else
              num4 = this.game.Data.UnitObj[index2].SupplyConsume;
            int num6 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, x, y, 0) * this.GetSlowestAirSpeed(index2);
            if (num4 >= num6)
            {
              int num7 = this.GetUnitPower(index2, true, x, y, IsArtilleryAttack: true, LimitCombatmod: 2f);
              num1 += (int) Math.Round((double) num7 * ((double) this.GetAIRolePercent(index2, 13) / 100.0));
              num2 = num2 + (int) Math.Round((double) num7 * ((double) this.GetAIRolePercent(index2, 14) / 100.0)) + (int) Math.Round((double) num7 * ((double) this.GetAIRolePercent(index2, 15) / 100.0));
              if (AdjustedForAp)
              {
                int lowestAirAp = this.game.HandyFunctionsObj.GetLowestAirAp(index2);
                num7 = lowestAirAp > 10 ? (int) Math.Round((double) num7 * ((double) (lowestAirAp - 10) / (double) lowestAirAp)) : 0;
              }
              num3 += this.game.HandyFunctionsObj.GetUnitairStackPts(index2);
              attackPowerPointsOn += num7;
              unitList.add(index2);
            }
          }
        }
      }
      this.game.EditObj.TempUnitList = unitList;
      this.GetCurrentDefendingPowerPointsOn(x, y);
      if (attackPowerPointsOn > 0 & num3 > 0 & (double) this.game.Data.RuleVar[833] > 0.0)
      {
        int num8 = (int) Math.Round((double) this.game.Data.RuleVar[834]);
        int num9 = num3 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStackAir(this.game.Data.Turn);
        if (num9 > num8)
          attackPowerPointsOn = (int) Math.Round(0.3 * (double) attackPowerPointsOn + 0.7 * (double) attackPowerPointsOn * ((double) num8 / (double) num9));
      }
      if (num2 > 0 & this.FighterMatrix[x, y] > 0)
        attackPowerPointsOn = (int) Math.Round((double) attackPowerPointsOn * Math.Min(1.0, (double) num1 / (double) num2));
      return attackPowerPointsOn;
    }

    public int GetPrognosedorRealFighterPowerPointsOn(
      int x,
      int y,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false,
      bool Prognosis = true)
    {
      UnitList unitList = new UnitList();
      int moveMatrixCounter = this.MoveMatrixCounter;
      int fighterPowerPointsOn;
      int num1;
      int num2;
      for (int index1 = 1; index1 <= moveMatrixCounter; ++index1)
      {
        int index2 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].TempCategory == 3 && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 3 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup && this.game.HandyFunctionsObj.GetAverageAirRdn(index2) >= 66)
        {
          int num3;
          if (!FullAp)
          {
            if (Prognosis)
            {
              int num4 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, 0) * this.GetSlowestAirSpeed(index2);
              num3 = this.game.HandyFunctionsObj.GetLowestAirAp(index2) - num4;
            }
            else
              num3 = this.game.HandyFunctionsObj.GetLowestAirAp(index2);
          }
          else
            num3 = this.game.Data.UnitObj[index2].SupplyConsume;
          int num5 = !Prognosis ? this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, 0, x, y, 0) * this.GetSlowestAirSpeed(index2) : this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, x, y, 0) * this.GetSlowestAirSpeed(index2);
          if (num3 >= num5)
          {
            int num6 = this.GetUnitPower(index2, true, x, y, IsArtilleryAttack: true);
            if (AdjustedForAp)
            {
              int lowestAirAp = this.game.HandyFunctionsObj.GetLowestAirAp(index2);
              num6 = lowestAirAp > 10 ? (int) Math.Round((double) num6 * ((double) (lowestAirAp - 10) / (double) lowestAirAp)) : 0;
            }
            fighterPowerPointsOn += (int) Math.Round((double) num6 * ((double) this.GetAIRolePercent(index2, 13) / 100.0));
            num1 = num1 + (int) Math.Round((double) num6 * ((double) this.GetAIRolePercent(index2, 14) / 100.0)) + (int) Math.Round((double) num6 * ((double) this.GetAIRolePercent(index2, 15) / 100.0));
            num2 += num6;
            unitList.add(index2);
          }
        }
      }
      int defendingPowerPointsOn = this.GetCurrentDefendingPowerPointsOn(x, y);
      if (defendingPowerPointsOn > num2 & num2 > 0)
        num2 = (int) Math.Round((double) num2 * 0.25 + (double) num2 * 0.75 * ((double) num2 / (double) defendingPowerPointsOn));
      if (num1 > 0)
      {
        int num7 = (int) Math.Round((double) num2 * Math.Min(1.0, (double) fighterPowerPointsOn / (double) num1));
      }
      return fighterPowerPointsOn;
    }

    public int GetRealAirAttackPowerPointsOn(
      int x,
      int y,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = new UnitList();
      int unitCounter = this.game.Data.UnitCounter;
      int attackPowerPointsOn;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 3 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup)
        {
          float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
          if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0)
            val2 = 1f;
          if ((double) this.game.HandyFunctionsObj.GetAverageAirRdn(index) >= 80.0 * ((2.0 + (double) Math.Min(1f, val2)) / 3.0) && (FullAp ? this.game.Data.UnitObj[index].SupplyConsume : this.game.HandyFunctionsObj.GetLowestAirAp(index)) >= this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y, 0, x, y, 0) * this.GetSlowestAirSpeed(index))
          {
            int num = this.GetUnitPower(index, true, x, y, LimitCombatmod: 2f);
            if (AdjustedForAp)
            {
              int lowestAirAp = this.game.HandyFunctionsObj.GetLowestAirAp(index);
              num = lowestAirAp > 10 ? (int) Math.Round((double) num * ((double) (lowestAirAp - 10) / (double) lowestAirAp)) : 0;
            }
            attackPowerPointsOn += num;
            unitList.add(index);
          }
        }
      }
      if (!(x > -1 & y > -1))
        return 0;
      this.GetCurrentDefendingPowerPointsOn(x, y);
      return attackPowerPointsOn;
    }

    public int GetSlowestAirSpeed(int unr)
    {
      int num1 = -1;
      int sfCount = this.game.Data.UnitObj[unr].SFCount;
      for (int index = 0; index <= sfCount; ++index)
      {
        int type = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 2)
        {
          int num2 = (int) Math.Round((double) this.game.Data.LandscapeTypeObj[0].MoveCost[this.game.Data.SFTypeObj[type].MoveType] * ((double) this.game.Data.MoveTypePenalty[this.game.Data.SFTypeObj[type].MoveType] / 100.0));
          if (num2 > num1)
            num1 = num2;
        }
      }
      return num1 == -1 ? 999 : num1;
    }

    public int GetRealLandAttackPowerPointsOn(int x, int y, bool adjustedforap = false)
    {
      UnitList unitList1 = new UnitList();
      int attackPowerPointsOn = 0;
      UnitList unitList2 = new UnitList();
      int tfacing = 1;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          int moveMatrixCounter = this.MoveMatrixCounter;
          for (int index1 = 1; index1 <= moveMatrixCounter; ++index1)
          {
            int index2 = this.MoveMatrixUnit[index1];
            if (index2 > -1 && this.game.Data.UnitObj[index2].X == coordinate.x & this.game.Data.UnitObj[index2].Y == coordinate.y && this.IsUnitPartOfMarker(index2, x, y) & !this.game.Data.UnitObj[index2].IsHQ && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup & this.game.Data.UnitObj[index2].TempCategory == 1)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ((double) this.game.HandyFunctionsObj.GetAverageRdn(index2) >= 70.0 * ((1.0 + (double) Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index2].SupplyIn == 0 && this.game.HandyFunctionsObj.GetLowestAp(index2) >= this.game.HandyFunctionsObj.MoveApCostPreview(index2, coordinate.x, coordinate.y, coordinate.x, coordinate.y, 0, x, y, 0, true).x)
              {
                unitList2.add(index2);
                int num = this.GetUnitPower(index2, true, x, y, tfacing - 1);
                if (adjustedforap)
                {
                  int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(index2);
                  num = lowestAp > 25 ? (int) Math.Round((double) num * ((double) (lowestAp - 25) / (double) lowestAp)) : 0;
                }
                attackPowerPointsOn += num;
              }
            }
          }
        }
        ++tfacing;
      }
      while (tfacing <= 6);
      if (attackPowerPointsOn > 0)
      {
        this.game.EditObj.OrderX = x;
        this.game.EditObj.OrderY = y;
        this.game.EditObj.TargetX = x;
        this.game.EditObj.TargetY = y;
        this.game.EditObj.TempUnitList = unitList2;
        attackPowerPointsOn = (int) Math.Round((double) (int) Math.Round((double) ((float) attackPowerPointsOn * this.game.HandyFunctionsObj.GetConcentricBonus2())) * ((double) (100 + this.game.HandyFunctionsObj.GetDivBonusForAttack(x, y, 0)) / 100.0));
        int num1 = this.game.HandyFunctionsObj.maxAttackStack();
        this.game.EditObj.TargetX = -1;
        this.game.EditObj.TargetY = -1;
        int num2;
        int num3 = num2 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
        if (num3 > num1)
          attackPowerPointsOn = (int) Math.Round(0.3 * (double) attackPowerPointsOn + 0.7 * (double) attackPowerPointsOn * ((double) num1 / (double) num3));
      }
      return attackPowerPointsOn;
    }

    public Coordinate GetRealLandAttackStackOn(int x, int y, bool adjustedforap = false)
    {
      UnitList unitList1 = new UnitList();
      int num1 = 0;
      UnitList unitList2 = new UnitList();
      int tfacing = 1;
      Coordinate landAttackStackOn;
      int num2;
      do
      {
        landAttackStackOn = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (landAttackStackOn.onmap)
        {
          int unitCounter = this.game.Data.UnitCounter;
          for (int index = 0; index <= unitCounter; ++index)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == landAttackStackOn.x & this.game.Data.UnitObj[index].Y == landAttackStackOn.y && this.game.Data.UnitObj[index].TempSlot > -1 && this.IsUnitPartOfMarker(index, x, y) & !this.game.Data.UnitObj[index].IsHQ && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & this.game.Data.UnitObj[index].TempCategory == 1)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ((double) this.game.Data.RuleVar[813] == 0.0 | (double) this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ((double) this.game.HandyFunctionsObj.GetAverageRdn(index) >= 70.0 * ((1.0 + (double) Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index].SupplyIn == 0 && this.game.HandyFunctionsObj.GetLowestAp(index) >= this.game.HandyFunctionsObj.MoveApCostPreview(index, landAttackStackOn.x, landAttackStackOn.y, landAttackStackOn.x, landAttackStackOn.y, 0, x, y, 0, true).x)
              {
                unitList2.add(index);
                int num3 = this.GetUnitPower(index, true, x, y, tfacing - 1);
                num2 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                if (adjustedforap)
                {
                  int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(index);
                  num3 = lowestAp > 10 ? (int) Math.Round((double) num3 * ((double) (lowestAp - 10) / (double) lowestAp)) : 0;
                }
                num1 += num3;
              }
            }
          }
        }
        ++tfacing;
      }
      while (tfacing <= 6);
      this.game.EditObj.TargetX = x;
      this.game.EditObj.TargetY = y;
      this.game.EditObj.TempUnitList = unitList2;
      int num4 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
      int num5 = num2 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
      landAttackStackOn.x = num5;
      landAttackStackOn.y = num4;
      return landAttackStackOn;
    }

    public int GetPrognosedLandArtAttackPowerPointsOn(
      int x,
      int y,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = new UnitList();
      Coordinate target;
      target.onmap = true;
      target.x = x;
      target.y = y;
      int attackPowerPointsOn = 0;
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
        this.ptempb[index] = false;
      int tfacing1 = 1;
      int num1;
      do
      {
        Coordinate coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing1);
        if (coordinate1.onmap)
        {
          int tfacing2 = 1;
          do
          {
            Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
            if (coordinate2.onmap)
            {
              int moveMatrixCounter = this.MoveMatrixCounter;
              for (int index1 = 1; index1 <= moveMatrixCounter; ++index1)
              {
                int index2 = this.MoveMatrixUnit[index1];
                if (index2 > -1 && this.game.Data.UnitObj[index2].TempX == coordinate2.x & this.game.Data.UnitObj[index2].TempY == coordinate2.y | this.game.Data.UnitObj[index2].TempX == coordinate1.x & this.game.Data.UnitObj[index2].TempY == coordinate1.y && !this.ptempb[index2] && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 2 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup & this.game.HandyFunctionsObj.CanDoArtAttack(index2, target, true))
                {
                  int num2 = FullAp ? this.game.Data.UnitObj[index2].SupplyConsume : this.game.HandyFunctionsObj.GetLowestlandartAp(index2, this.game.HandyFunctionsObj.GetMaxArtRange(index2, 0)) - this.MoveMatrix[this.game.Data.UnitObj[index2].TempSlot, coordinate2.x, coordinate2.y];
                  int num3 = 10;
                  if (num2 >= num3)
                  {
                    int num4 = this.GetUnitPower(index2, true, x, y, IsArtilleryAttack: true);
                    this.ptempb[index2] = true;
                    if (AdjustedForAp)
                      num4 = (int) Math.Round((double) num4 * ((double) num2 / 100.0));
                    attackPowerPointsOn += num4;
                    unitList.add(index2);
                    num1 += this.game.HandyFunctionsObj.GetUnitartStackPts(index2);
                  }
                }
              }
            }
            ++tfacing2;
          }
          while (tfacing2 <= 6);
        }
        ++tfacing1;
      }
      while (tfacing1 <= 6);
      int num5 = (int) Math.Round((double) this.GetCurrentDefendingPowerPointsOn(x, y) / 2.0);
      if (attackPowerPointsOn > 0 & num1 > 0 & (double) this.game.Data.RuleVar[834] > 0.0)
      {
        int num6 = (int) Math.Round((double) this.game.Data.RuleVar[834]);
        int num7 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStackArt(this.game.Data.Turn);
        if (num7 > num6)
          attackPowerPointsOn = (int) Math.Round(0.3 * (double) attackPowerPointsOn + 0.7 * (double) attackPowerPointsOn * ((double) num6 / (double) num7));
      }
      this.game.EditObj.TempUnitList = unitList;
      return attackPowerPointsOn;
    }

    public int GetRealLandArtAttackPowerPointsOn(int x, int y, bool adjustedforap = false)
    {
      UnitList unitList = new UnitList();
      bool[] flagArray = new bool[this.game.Data.UnitCounter + 1];
      int tfacing1 = 1;
      int num1;
      int attackPowerPointsOn;
      do
      {
        Coordinate coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing1);
        if (coordinate1.onmap)
        {
          int tfacing2 = 1;
          do
          {
            Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
            if (coordinate2.onmap)
            {
              int unitCounter = this.game.Data.UnitCounter;
              for (int index = 0; index <= unitCounter; ++index)
              {
                if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == coordinate2.x & this.game.Data.UnitObj[index].Y == coordinate2.y && this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 2 && this.IsUnitPartOfMarker(index, x, y) & !flagArray[index] && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.HandyFunctionsObj.GetLowestAp(index) >= 10 & this.game.HandyFunctionsObj.Distance(x, y, 0, coordinate2.x, coordinate2.y, 0) <= 2)
                {
                  int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(index);
                  int num2 = 10;
                  if (lowestAp >= num2)
                  {
                    flagArray[index] = true;
                    int num3 = this.GetUnitPower(index, true, x, y, IsArtilleryAttack: true);
                    num1 += this.game.HandyFunctionsObj.GetUnitartStackPts(index);
                    if (adjustedforap)
                      num3 = (int) Math.Round((double) num3 * ((double) lowestAp / 100.0));
                    attackPowerPointsOn += num3;
                    unitList.add(index);
                  }
                }
              }
            }
            ++tfacing2;
          }
          while (tfacing2 <= 6);
        }
        ++tfacing1;
      }
      while (tfacing1 <= 6);
      int num4 = (int) Math.Round((double) this.GetCurrentDefendingPowerPointsOn(x, y) / 2.0);
      if (attackPowerPointsOn > 0 & num1 > 0 & (double) this.game.Data.RuleVar[834] > 0.0)
      {
        int num5 = (int) Math.Round((double) this.game.Data.RuleVar[834]);
        int num6 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStackArt(this.game.Data.Turn);
        if (num6 > num5)
          attackPowerPointsOn = (int) Math.Round(0.3 * (double) attackPowerPointsOn + 0.7 * (double) attackPowerPointsOn * ((double) num5 / (double) num6));
      }
      this.game.EditObj.TempUnitList = unitList;
      return attackPowerPointsOn;
    }

    public int JoinUnitsInLandAttack(int x, int y, ref UnitList TempUnitList)
    {
      int tfacing = 1;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          int unitCounter = this.game.Data.UnitCounter;
          for (int index = 0; index <= unitCounter; ++index)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == coordinate.x & this.game.Data.UnitObj[index].Y == coordinate.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.Data.UnitObj[index].TempCategory == 1 && this.game.HandyFunctionsObj.GetLowestAp(index) >= this.game.HandyFunctionsObj.MoveApCostPreview(index, coordinate.x, coordinate.y, coordinate.x, coordinate.y, 0, x, y, 0, true).x)
              TempUnitList.add(index);
          }
        }
        ++tfacing;
      }
      while (tfacing <= 6);
      int num;
      return num;
    }

    public int JoinUnitsArtilleryAttack(int x, int y, ref UnitList TempUnitList)
    {
      int tfacing1 = 1;
      do
      {
        Coordinate coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing1);
        if (coordinate1.onmap)
        {
          int tfacing2 = 1;
          do
          {
            Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
            if (coordinate2.onmap)
            {
              int unitCounter = this.game.Data.UnitCounter;
              for (int index = 0; index <= unitCounter; ++index)
              {
                if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == coordinate2.x & this.game.Data.UnitObj[index].Y == coordinate2.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.Data.UnitObj[index].TempCategory == 2 && this.game.HandyFunctionsObj.GetLowestAp(index) >= 10 & this.game.HandyFunctionsObj.Distance(coordinate1.x, coordinate1.y, 0, x, y, 0) <= 2 && !TempUnitList.CheckIfPresent(index))
                  TempUnitList.add(index);
              }
            }
            ++tfacing2;
          }
          while (tfacing2 <= 6);
        }
        ++tfacing1;
      }
      while (tfacing1 <= 6);
      int num;
      return num;
    }

    public int JoinUnitsAirAttack(int x, int y, ref UnitList TempUnitList)
    {
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.Data.UnitObj[index].TempCategory == 3 && this.game.HandyFunctionsObj.GetLowestAirAp(index) >= this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y, 0, x, y, 0) * this.GetSlowestAirSpeed(index) && !TempUnitList.CheckIfPresent(index))
          TempUnitList.add(index);
      }
      int num;
      return num;
    }

    public bool IsUnitPartOfMarker(int unr, int x, int y)
    {
      if (this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn)
        return false;
      int moveMatrixCounter = this.MoveMatrixCounter;
      for (int index = 1; index <= moveMatrixCounter; ++index)
      {
        if (this.MoveMatrixUnit[index] == unr && this.MoveMatrixUnitMarker[index] > -1)
        {
          if (this.game.Data.UnitObj[unr].TempCategory == 1)
          {
            if (this.MoveMatrixUnitMarker[index] > this.MarkerList.Counter)
              return false;
            if (this.MarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.MarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
              return true;
          }
          else if (this.game.Data.UnitObj[unr].TempCategory == 2 | this.game.Data.UnitObj[unr].TempCategory == 5)
          {
            if (this.MoveMatrixUnitMarker[index] > this.ArtMarkerList.Counter)
              return false;
            if (this.ArtMarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.ArtMarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
              return true;
          }
          else if (this.game.Data.UnitObj[unr].TempCategory == 3)
          {
            if (this.MoveMatrixUnitMarker[index] > this.AirMarkerList.Counter)
              return false;
            if (this.AirMarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.AirMarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
              return true;
          }
          else if (this.game.Data.UnitObj[unr].TempCategory == 4)
          {
            if (this.EngineerMarkerList.Counter > -1)
            {
              if (this.MoveMatrixUnitMarker[index] > this.EngineerMarkerList.Counter)
                return false;
              if (this.EngineerMarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.EngineerMarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
                return true;
            }
            else
            {
              if (this.MoveMatrixUnitMarker[index] > this.MarkerList.Counter)
                return false;
              if (this.MarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.MarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
                return true;
            }
          }
        }
      }
      return false;
    }

    public Coordinate MarkerHasCoord(int slot)
    {
      Coordinate coordinate;
      coordinate.onmap = false;
      if (slot == -1)
        return coordinate;
      int index = this.MoveMatrixUnit[slot];
      if (this.MoveMatrixUnitMarker[slot] > -1)
      {
        if (this.game.Data.UnitObj[index].TempCategory == 1)
        {
          coordinate.x = this.MarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.MarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
        if (this.game.Data.UnitObj[index].TempCategory == 2 | this.game.Data.UnitObj[index].TempCategory == 5)
        {
          coordinate.x = this.ArtMarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.ArtMarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
        if (this.game.Data.UnitObj[index].TempCategory == 3)
        {
          coordinate.x = this.AirMarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.AirMarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
        if (this.game.Data.UnitObj[index].TempCategory == 4)
        {
          if (this.EngineerMarkerList.Counter > -1)
          {
            coordinate.x = this.EngineerMarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
            coordinate.y = this.EngineerMarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
            coordinate.onmap = true;
            return coordinate;
          }
          coordinate.x = this.MarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.MarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
      }
      coordinate.onmap = false;
      return coordinate;
    }

    public void MakeMoveMatrix(bool OnlyOutside, bool OnlyInside)
    {
      int Slot = 0;
      int upperBound = this.MoveMatrixUnit.GetUpperBound(0);
      this.MoveMatrixCounter = 0;
      int unitCounter = this.game.Data.UnitCounter;
      for (int unr1 = 0; unr1 <= unitCounter; ++unr1)
      {
        if (this.game.Data.UnitObj[unr1].PreDef == -1 && this.game.Data.UnitObj[unr1].AIGroup == this.OpGroup & this.game.Data.UnitObj[unr1].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr1].X > -1)
        {
          int num = 1;
          if (OnlyInside)
            num = 0;
          if (this.game.Data.UnitObj[unr1].AIAttack == -1 & this.game.Data.UnitObj[unr1].AIDefend > -1 && this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == this.game.Data.UnitObj[unr1].AIDefend)
          {
            num = 0;
            if (!OnlyOutside)
              num = 1;
          }
          if (num == 1 && Slot < upperBound)
          {
            ++Slot;
            ++this.MoveMatrixCounter;
            this.MoveMatrixUnit[Slot] = unr1;
            this.game.Data.UnitObj[unr1].TempSlot = Slot;
            this.MoveMatrixUnitMarker[Slot] = -1;
            if (this.game.Data.UnitObj[unr1].IsHQ)
              unr1 = unr1;
            Coordinate closeFriendlyRoadHex;
            if (this.game.Data.UnitObj[unr1].TempStrategic)
              closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y, 4);
            this.MoveMatrixCloseRoad[Slot] = closeFriendlyRoadHex;
            HandyFunctionsclass handyFunctionsObj = this.game.HandyFunctionsObj;
            int unr2 = unr1;
            int x = this.game.Data.UnitObj[unr1].X;
            int y = this.game.Data.UnitObj[unr1].Y;
            CustomDC2AICalls customDc2AiCalls = (CustomDC2AICalls) null;
            ref CustomDC2AICalls local = ref customDc2AiCalls;
            handyFunctionsObj.MakeMovePrediction3(unr2, x, y, 0, ismove: true, tcustomAi: (ref local));
            int mapWidth = this.game.Data.MapObj[0].MapWidth;
            for (int index1 = 0; index1 <= mapWidth; ++index1)
            {
              int mapHeight = this.game.Data.MapObj[0].MapHeight;
              for (int index2 = 0; index2 <= mapHeight; ++index2)
              {
                this.MoveMatrix[Slot, index1, index2] = this.game.EditObj.TempValue[0].Value[index1, index2];
                this.MoveMatrixCameFrom[Slot, index1, index2].x = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].x;
                this.MoveMatrixCameFrom[Slot, index1, index2].y = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].y;
                this.MoveMatrixCameFrom[Slot, index1, index2].map = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].map;
                this.MoveMatrixCameFrom[Slot, index1, index2].onmap = this.game.EditObj.TempCameFrom[0].Value[index1, index2].onmap;
                if (this.game.EditObj.TempCameFrom[0].Value[index1, index2].onmap)
                  index1 = index1;
              }
            }
            if (!this.game.HandyFunctionsObj.HasUnitAirSF(unr1))
              this.CompleteMoveMatrix(Slot);
          }
        }
      }
    }

    public void MakeEnemyMoveMatrix()
    {
      this.EnemyMatrixUnit.GetUpperBound(0);
      this.EnemyMatrixCounter = 0;
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter1; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index].Regime) != this.GetGameDataTurn())
        {
          this.game.Data.UnitObj[index].TempSlot = -1;
          this.game.Data.UnitObj[index].TempX = -1;
          this.game.Data.UnitObj[index].TempY = -1;
        }
      }
      if (this.GroupType[this.OpGroup] >= 5 & this.MoveMatrixCounter <= 1)
        this.SetEnemyMatrixUnits(4);
      else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 250)
        this.SetEnemyMatrixUnits(16);
      else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
        this.SetEnemyMatrixUnits(10);
      else
        this.SetEnemyMatrixUnits(8);
      int unitCounter2 = this.game.Data.UnitCounter;
      for (int unr1 = 0; unr1 <= unitCounter2; ++unr1)
      {
        if (this.game.Data.UnitObj[unr1].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr1].Regime) != this.GetGameDataTurn() && this.game.Data.UnitObj[unr1].TempSlot > -1)
        {
          int tempSlot = this.game.Data.UnitObj[unr1].TempSlot;
          int sfCount = this.game.Data.UnitObj[unr1].SFCount;
          for (int index = 0; index <= sfCount; ++index)
            this.game.Data.SFObj[this.game.Data.UnitObj[unr1].SFList[index]].Ap = 0;
          HandyFunctionsclass handyFunctionsObj1 = this.game.HandyFunctionsObj;
          int unr2 = unr1;
          int x1 = this.game.Data.UnitObj[unr1].X;
          int y1 = this.game.Data.UnitObj[unr1].Y;
          int increaseap1 = Math.Min(this.game.Data.UnitObj[unr1].SupplyConsume, this.game.HandyFunctionsObj.GetAverageRdn(unr1));
          CustomDC2AICalls customDc2AiCalls1 = (CustomDC2AICalls) null;
          ref CustomDC2AICalls local1 = ref customDc2AiCalls1;
          handyFunctionsObj1.MakeMovePrediction3(unr2, x1, y1, 0, attack: true, increaseap: increaseap1, gothroughenemy: 999999, tcustomAi: (ref local1));
          int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
          for (int index1 = 0; index1 <= mapWidth1; ++index1)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int index2 = 0; index2 <= mapHeight; ++index2)
            {
              this.EnemyMatrix[tempSlot, index1, index2] = this.game.EditObj.TempValue[0].Value[index1, index2];
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].x = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].x;
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].y = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].y;
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].map = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].map;
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].onmap = this.game.EditObj.TempCameFrom[0].Value[index1, index2].onmap;
            }
          }
          this.CompleteEnemyMoveMatrix(tempSlot);
          HandyFunctionsclass handyFunctionsObj2 = this.game.HandyFunctionsObj;
          int unr3 = unr1;
          int x2 = this.game.Data.UnitObj[unr1].X;
          int y2 = this.game.Data.UnitObj[unr1].Y;
          int increaseap2 = Math.Min(this.game.Data.UnitObj[unr1].SupplyConsume, this.game.HandyFunctionsObj.GetAverageRdn(unr1));
          CustomDC2AICalls customDc2AiCalls2 = (CustomDC2AICalls) null;
          ref CustomDC2AICalls local2 = ref customDc2AiCalls2;
          handyFunctionsObj2.MakeMovePrediction3(unr3, x2, y2, 0, attack: true, increaseap: increaseap2, gothroughenemy: 999999, ExtraForEnemyHex: 15, tcustomAi: (ref local2));
          int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
          for (int index3 = 0; index3 <= mapWidth2; ++index3)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int index4 = 0; index4 <= mapHeight; ++index4)
            {
              this.EnemyMatrix2[tempSlot, index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].x = (byte) this.game.EditObj.TempCameFrom[0].Value[index3, index4].x;
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].y = (byte) this.game.EditObj.TempCameFrom[0].Value[index3, index4].y;
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].map = (byte) this.game.EditObj.TempCameFrom[0].Value[index3, index4].map;
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].onmap = this.game.EditObj.TempCameFrom[0].Value[index3, index4].onmap;
            }
          }
        }
      }
    }

    public bool SetEnemyMatrixUnits(int dist)
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[] numArray2 = new int[100];
      int upperBound = this.EnemyMatrixUnit.GetUpperBound(0);
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
          numArray1[index1, index2] = -1;
      }
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter1; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].X > -1 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & (this.game.Data.UnitObj[index].IsHQ | this.tArea[this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y] > 0))
          numArray1[this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y] = 0;
      }
      int groupHq = this.GetGroupHQ(this.OpGroup);
      if (groupHq == -1)
        return true;
      if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
        numArray1[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y] = 0;
      if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
        numArray1[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y] = 0;
      int num1 = 1;
      int num2 = -1;
      while (num1 >= 0 & num2 < dist)
      {
        --num1;
        ++num2;
        int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth2; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (numArray1[cx, cy] == num2)
            {
              int tfacing = 1;
              do
              {
                Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && numArray1[coordinate.x, coordinate.y] == -1)
                {
                  numArray1[coordinate.x, coordinate.y] = this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] <= -1 ? num2 + 1 : num2 + 1;
                  num1 = 1;
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
      for (int index3 = 0; index3 <= mapWidth3; ++index3)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index4 = 0; index4 <= mapHeight; ++index4)
        {
          if (numArray1[index3, index4] > 0)
          {
            int unitCounter2 = this.game.Data.MapObj[0].HexObj[index3, index4].UnitCounter;
            for (int index5 = 0; index5 <= unitCounter2; ++index5)
            {
              int unit = this.game.Data.MapObj[0].HexObj[index3, index4].UnitList[index5];
              if (this.GetRegime(this.game.Data.UnitObj[unit].Regime) != this.GetGameDataTurn() & !this.game.HandyFunctionsObj.HasUnitAirSF(unit) && this.EnemyMatrixCounter < upperBound & this.game.Data.UnitObj[unit].TempType > -1)
              {
                if (this.game.Data.UnitObj[unit].IsVirtual)
                  this.MakeTempMovementType(unit);
                int num3 = this.game.Data.LandscapeTypeObj[(int) Math.Round((double) this.game.Data.RuleVar[38])].MoveCost[this.game.Data.SFTypeObj[this.game.Data.UnitObj[unit].TempType].MoveType];
                int num4 = (int) Math.Round(60.0 + (double) (dist * 5) / (double) num3);
                if (numArray1[index3, index4] <= num4)
                {
                  ++this.EnemyMatrixCounter;
                  this.EnemyMatrixUnit[this.EnemyMatrixCounter] = unit;
                  this.game.Data.UnitObj[unit].TempSlot = this.EnemyMatrixCounter;
                }
              }
            }
          }
        }
      }
      bool flag;
      return flag;
    }

    public void CompleteMoveMatrix(int Slot)
    {
      int[,] numArray = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth1; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          if (this.MoveMatrix[Slot, index1, index2] < 9999)
            numArray[index1, index2] = 1;
        }
      }
      int index = this.MoveMatrixUnit[Slot];
      int num1 = 30;
      Math.Max(this.game.Data.UnitObj[index].X - num1, this.CMS1.x);
      Math.Min(this.game.Data.UnitObj[index].X + num1, this.CMS2.x);
      Math.Max(this.game.Data.UnitObj[index].Y - num1, this.CMS1.y);
      Math.Min(this.game.Data.UnitObj[index].Y + num1, this.CMS2.y);
      int num2 = 1;
      while (num2 == 1)
      {
        num2 = 0;
        int num3;
        ++num3;
        int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth2; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            Coordinate coordinate1;
            coordinate1.x = cx;
            coordinate1.y = cy;
            coordinate1.map = 0;
            coordinate1.onmap = true;
            if (numArray[cx, cy] == num3)
            {
              int tfacing = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate2.onmap)
                {
                  int num4;
                  if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime), this.GetGameDataTurn()))
                    num4 = this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] <= -1 ? (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType != 6 ? (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea ? Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 20) : 9999) : Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 100)) : Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 5);
                  else if (this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime))
                  {
                    if (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].UnitCounter > -1)
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 125);
                    else if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea)
                      num4 = 9999;
                    else if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                    {
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 33);
                      if (num4 > 300 & this.FullAdvanceMatrix[cx, cy] == 0 & this.TscoreMatrix[cx, cy] <= 0)
                        num4 = 9999;
                    }
                    else if (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType == 6)
                    {
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 100);
                      if (num4 > 300 & this.FullAdvanceMatrix[cx, cy] == 0 & this.TscoreMatrix[cx, cy] <= 0)
                        num4 = 9999;
                    }
                    else
                    {
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 50);
                      if (num4 > 300 & this.FullAdvanceMatrix[cx, cy] == 0 & this.TscoreMatrix[cx, cy] <= 0)
                        num4 = 9999;
                    }
                  }
                  else
                    num4 = 9999;
                  if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Bridge[tfacing - 1])
                    num4 += 140;
                  if (num4 < this.MoveMatrix[Slot, coordinate2.x, coordinate2.y] & num4 < 9999)
                  {
                    this.MoveMatrix[Slot, coordinate2.x, coordinate2.y] = num4;
                    this.MoveMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].x = (byte) coordinate1.x;
                    this.MoveMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].y = (byte) coordinate1.y;
                    this.MoveMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].onmap = coordinate1.onmap;
                    num2 = 1;
                    numArray[coordinate2.x, coordinate2.y] = num3 + 1;
                  }
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
    }

    public void CompleteEnemyMoveMatrix(int Slot)
    {
      int[,] numArray = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          if (this.EnemyMatrix[Slot, index1, index2] < 9999)
            numArray[index1, index2] = 1;
        }
      }
      int index = this.EnemyMatrixUnit[Slot];
      int num1 = 10;
      int num2 = Math.Max(this.game.Data.UnitObj[index].X - num1, 0);
      int num3 = Math.Min(this.game.Data.UnitObj[index].X + num1, this.game.Data.MapObj[0].MapWidth);
      int num4 = Math.Max(this.game.Data.UnitObj[index].Y - num1, 0);
      int num5 = Math.Min(this.game.Data.UnitObj[index].Y + num1, this.game.Data.MapObj[0].MapHeight);
      int num6 = 1;
      while (num6 == 1)
      {
        num6 = 0;
        int num7;
        ++num7;
        int num8 = num2;
        int num9 = num3;
        for (int cx = num8; cx <= num9; ++cx)
        {
          int num10 = num4;
          int num11 = num5;
          for (int cy = num10; cy <= num11; ++cy)
          {
            Coordinate coordinate1;
            coordinate1.x = cx;
            coordinate1.y = cy;
            coordinate1.map = 0;
            coordinate1.onmap = true;
            if (numArray[cx, cy] == num7)
            {
              int tfacing = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate2.onmap)
                {
                  int num12 = !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea ? (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] <= -1 ? (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType != 6 ? Math.Max(105, this.EnemyMatrix[Slot, cx, cy] + 40) : Math.Max(105, this.EnemyMatrix[Slot, cx, cy] + 100)) : Math.Max(105, this.EnemyMatrix[Slot, cx, cy] + 25)) : 9999;
                  if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Bridge[tfacing - 1])
                    num12 += 40;
                  if (num12 < this.EnemyMatrix[Slot, coordinate2.x, coordinate2.y] & num12 < 9999)
                  {
                    this.EnemyMatrix[Slot, coordinate2.x, coordinate2.y] = num12;
                    this.EnemyMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].x = (byte) coordinate1.x;
                    this.EnemyMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].y = (byte) coordinate1.y;
                    this.EnemyMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].onmap = coordinate1.onmap;
                    num6 = 1;
                    numArray[coordinate2.x, coordinate2.y] = num7 + 1;
                  }
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
    }

    public void SetTArea()
    {
      int groupHq = this.GetGroupHQ(this.OpGroup);
      this.DistToTArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.DistFromTArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.FrontlineArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.EnemyFrontlineArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.DistFromFrontline = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.FrontlineCount = 0;
      int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
      Coordinate coordinate;
      for (int cx = 0; cx <= mapWidth1; ++cx)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int cy = 0; cy <= mapHeight; ++cy)
        {
          this.tArea[cx, cy] = 0;
          this.DistToTArea[cx, cy] = 9999;
          this.DistFromFrontline[cx, cy] = 9999;
          if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIAttack)
          {
            this.tArea[cx, cy] = 1;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIDefend)
          {
            this.tArea[cx, cy] = 2;
            this.DistToTArea[cx, cy] = 0;
            int num = 0;
            int tfacing = 1;
            do
            {
              coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate.onmap && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime, this.game.Data.Turn) && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
              {
                ++num;
                this.EnemyFrontlineArea[coordinate.x, coordinate.y] = 1;
              }
              ++tfacing;
            }
            while (tfacing <= 6);
            if (num > 0 & num <= 3)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                ++this.FrontlineCount;
              this.FrontlineArea[cx, cy] = 1;
              this.DistFromFrontline[cx, cy] = 0;
            }
            else if (num >= 4)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                ++this.FrontlineCount;
              this.FrontlineArea[cx, cy] = 2;
              this.DistFromFrontline[cx, cy] = 0;
            }
          }
          else if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIFollowup)
          {
            this.tArea[cx, cy] = 5;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIFallback)
          {
            this.tArea[cx, cy] = 6;
            this.DistToTArea[cx, cy] = 0;
            int num = 0;
            int tfacing = 1;
            do
            {
              coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate.onmap && this.AreaMatrixNarrow[coordinate.x, coordinate.y] == this.game.Data.UnitObj[groupHq].AIAttack && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                ++num;
              ++tfacing;
            }
            while (tfacing <= 6);
            if (num > 0 & num <= 3)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                ++this.FrontlineCount;
              this.FrontlineArea[cx, cy] = 1;
              this.DistFromFrontline[cx, cy] = 0;
            }
            else if (num >= 4)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                ++this.FrontlineCount;
              this.FrontlineArea[cx, cy] = 2;
              this.DistFromFrontline[cx, cy] = 0;
            }
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIAttack)
          {
            this.tArea[cx, cy] = 1;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIDefend)
          {
            this.tArea[cx, cy] = 2;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIFollowup)
          {
            this.tArea[cx, cy] = 5;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIFallback)
          {
            this.tArea[cx, cy] = 6;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.SupplyMatrix[cx, cy] == this.OpGroup)
          {
            this.tArea[cx, cy] = 3;
            this.DistToTArea[cx, cy] = 0;
          }
        }
      }
      int num1 = 0;
      do
      {
        int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth2; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (this.DistToTArea[cx, cy] == num1)
            {
              int tfacing = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.DistToTArea[coordinate.x, coordinate.y] > num1)
                {
                  this.DistToTArea[coordinate.x, coordinate.y] = num1 + 1;
                  this.DistFromTArea[coordinate.x, coordinate.y] = num1 <= 0 ? this.tArea[cx, cy] : this.DistFromTArea[cx, cy];
                }
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
        ++num1;
      }
      while (num1 <= 9);
      int num2 = 0;
      do
      {
        int mapWidth3 = this.game.Data.MapObj[0].MapWidth;
        for (int cx = 0; cx <= mapWidth3; ++cx)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int cy = 0; cy <= mapHeight; ++cy)
          {
            if (this.DistFromFrontline[cx, cy] == num2)
            {
              int tfacing = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.DistFromFrontline[coordinate.x, coordinate.y] > num2)
                  this.DistFromFrontline[coordinate.x, coordinate.y] = num2 + 1;
                ++tfacing;
              }
              while (tfacing <= 6);
            }
          }
        }
        ++num2;
      }
      while (num2 <= 9);
    }

    public int GetLoseHexScore(int ix, int iy) => 0;

    public int GetTscore(int ix, int iy, int j = -1, bool IsCounterAttack = false, bool MakeLog = false)
    {
      int tscore = !IsCounterAttack ? this.TscoreMatrix[ix, iy] : this.TscoreCounterMatrix[ix, iy];
      if (j > -1 && this.game.Data.MapObj[0].HexObj[ix, iy].RiverType[j] > -1)
        tscore = (int) Math.Round((double) tscore * 0.25);
      return tscore;
    }

    public int GetTScore2(int ix, int iy, bool IsCounterAttack = false, bool MakeLog = false)
    {
      int index1 = this.TempGroupHQ[this.OpGroup];
      int Number = 0;
      if (this.game.Data.UnitObj[index1].AIAttackStyle == 3 | this.game.Data.UnitObj[index1].AIAttackStyle == 2)
      {
        if (this.FrontlineArea[ix, iy] > 0)
          ix = ix;
        if (this.tArea[ix, iy] == 1)
          Number = 100;
        if (this.tArea[ix, iy] == 5)
          Number = !IsCounterAttack ? 50 : 100;
        if (this.tArea[ix, iy] == 2)
        {
          if (this.game.Data.UnitObj[index1].AIDefend > -1)
            Number = !IsCounterAttack ? 50 : 150;
          if (this.MoveMatrixCounter > 0 & this.FrontlineCount > 0 && this.FrontlineArea[ix, iy] == 1)
            Number += (int) Math.Round((double) Number * ((double) this.MoveMatrixCounter / (double) this.FrontlineCount));
        }
        if (this.tArea[ix, iy] == 6)
          Number = !IsCounterAttack ? 35 : 225;
        if (this.tArea[ix, iy] == 3)
          Number = (int) Math.Round(50.0 / (double) (this.SupplyMatrixDistance[ix, iy] + 1));
        if (this.AdvanceAxisMatrix[ix, iy] > 0 & Number < 100)
          Number = 100;
        if (this.tArea[ix, iy] == 0 & this.DistToTArea[ix, iy] < 10 & this.DistToTArea[ix, iy] > 0 && !IsCounterAttack)
        {
          if (this.DistFromTArea[ix, iy] == 1)
            Number = (int) Math.Round(100.0 / (double) this.DistToTArea[ix, iy]);
          if (this.DistFromTArea[ix, iy] == 5)
            Number = (int) Math.Round(50.0 / (double) this.DistToTArea[ix, iy]);
          if (this.DistFromTArea[ix, iy] == 2)
            Number = (int) Math.Round(50.0 / (double) this.DistToTArea[ix, iy]);
        }
      }
      else if (this.game.Data.UnitObj[index1].AIAttackStyle == 1)
      {
        if (this.tArea[ix, iy] == 2)
          Number = 50;
        if (this.tArea[ix, iy] == 6)
          Number = 20;
        if (this.game.Data.UnitObj[index1].AIDefend > -1 & this.game.Data.UnitObj[index1].AIDefend <= this.AreaCount && this.AreaCenter[this.game.Data.UnitObj[index1].AIDefend].x == ix && this.AreaCenter[this.game.Data.UnitObj[index1].AIDefend].y == iy)
          Number = 100;
        if (this.tArea[ix, iy] == 3)
          Number = (int) Math.Round(24.0 / (double) (this.SupplyMatrixDistance[ix, iy] + 1));
        if (this.tArea[ix, iy] == 0 & this.DistToTArea[ix, iy] < 10 & this.DistToTArea[ix, iy] > 0 && !IsCounterAttack)
        {
          if (this.DistFromTArea[ix, iy] == 6)
            Number = (int) Math.Round(20.0 / (double) this.DistToTArea[ix, iy]);
          if (this.DistFromTArea[ix, iy] == 2)
            Number = (int) Math.Round(50.0 / (double) this.DistToTArea[ix, iy]);
        }
      }
      if (Number > 0)
      {
        Coordinate coordinate;
        if (this.game.Data.UnitObj[index1].AIAttackStyle == 1 & this.tArea[ix, iy] == 2)
        {
          int num1 = 0;
          int num2 = 0;
          int index2 = 0;
          do
          {
            if (this.game.Data.MapObj[0].HexObj[ix, iy].RoadType[index2] > -1)
              num1 = 1;
            coordinate = this.game.HandyFunctionsObj.HexNeighbour(ix, iy, 0, index2 + 1);
            if (coordinate.onmap)
            {
              int num3 = 0;
              do
              {
                if (this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].RoadType[index2] > -1)
                  num2 = 1;
                ++num3;
              }
              while (num3 <= 5);
            }
            ++index2;
          }
          while (index2 <= 5);
          if (num1 == 1)
          {
            if (Number < 50)
              Number = 50;
            Number = (int) Math.Round((double) Number * 1.5);
          }
          else if (num2 == 1)
          {
            if (Number < 25)
              Number = 25;
            Number = (int) Math.Round((double) Number * 1.25);
          }
        }
        if (this.game.Data.MapObj[0].HexObj[ix, iy].Location > -1 | this.game.HandyFunctionsObj.HasHexBridge(ix, iy, 0))
        {
          Number = (int) Math.Round((double) Number * 1.5);
          if (IsCounterAttack)
            Number = (int) Math.Round((double) Number * 2.5);
        }
        else
        {
          int num4 = 0;
          do
          {
            coordinate = this.game.HandyFunctionsObj.HexNeighbour(ix, iy, 0, num4 + 1);
            if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Location > -1)
            {
              int num5 = (int) Math.Round((double) Number * 1.25);
              int num6 = this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[coordinate.x, coordinate.y];
              Number = !(num6 > this.AverageVP & num5 > 0) ? num5 * 1 : (int) Math.Round((double) num5 * (1.0 + (double) num6 / (double) this.AverageVP));
              if (IsCounterAttack)
                Number *= 1;
            }
            ++num4;
          }
          while (num4 <= 5);
        }
        if (this.game.Data.MapObj[0].HexObj[ix, iy].Location > -1)
          Number *= 2;
        if (this.game.Data.MapObj[0].HexObj[ix, iy].VP > 0 | this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[ix, iy] > 0)
        {
          int num = this.game.Data.MapObj[0].HexObj[ix, iy].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[ix, iy];
          if (num > this.AverageVP & Number > 0)
            Number = (int) Math.Round((double) Number * (2.0 + (double) num / (double) this.AverageVP * 2.0));
          else
            Number *= 2;
        }
        int aiAttack = this.game.Data.UnitObj[index1].AIAttack;
        if (aiAttack > -1 & aiAttack <= this.AreaCount && this.AreaCenter[aiAttack].x == ix & this.AreaCenter[aiAttack].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        int aiDefend = this.game.Data.UnitObj[index1].AIDefend;
        if (aiDefend > -1 & aiDefend <= this.AreaCount && this.AreaCenter[aiDefend].x == ix & this.AreaCenter[aiDefend].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        int aiFollowup = this.game.Data.UnitObj[index1].AIFollowup;
        if (aiFollowup > -1 & aiFollowup <= this.AreaCount && this.AreaCenter[aiFollowup].x == ix & this.AreaCenter[aiFollowup].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        int aiFallback = this.game.Data.UnitObj[index1].AIFallback;
        if (aiFallback > -1 & aiFallback <= this.AreaCount && this.AreaCenter[aiFallback].x == ix & this.AreaCenter[aiFallback].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        if (this.game.Data.UnitObj[index1].AIAttackStyle == 3)
        {
          if (this.AdvanceAxisMatrix[ix, iy] == 0)
            Number *= 1;
          if (this.AdvanceAxisMatrix[ix, iy] == 1)
            Number *= 2;
          if (this.AdvanceAxisMatrix[ix, iy] == 2)
            Number = (int) Math.Round((double) Number * 1.8);
          if (this.AdvanceAxisMatrix[ix, iy] >= 3)
            Number = (int) Math.Round((double) Number * 1.6);
        }
        else if (this.game.Data.UnitObj[index1].AIAttackStyle == 2)
        {
          if (this.AdvanceAxisMatrix[ix, iy] == 0)
            Number = (int) Math.Round((double) Number * 1.25);
          if (this.AdvanceAxisMatrix[ix, iy] == 1)
            Number *= 4;
          if (this.AdvanceAxisMatrix[ix, iy] == 2)
            Number *= 3;
          if (this.AdvanceAxisMatrix[ix, iy] >= 3)
            Number = (int) Math.Round((double) Number * 1.5);
        }
        else if (this.game.Data.UnitObj[index1].AIAttackStyle != 1)
          ;
        if (IsCounterAttack && this.AdvanceAxisMatrix[ix, iy] == 0)
          Number *= 2;
        if ((double) this.game.Data.RuleVar[53] < (double) this.SupplyMatrixPrognosisEasyRoads[ix, iy])
          Number = 0;
        else if ((double) this.game.Data.RuleVar[52] < (double) this.SupplyMatrixPrognosisEasyRoads[ix, iy])
          Number = (int) Math.Round((double) Number * 0.75);
        else if ((double) this.game.Data.RuleVar[51] < (double) this.SupplyMatrixPrognosisEasyRoads[ix, iy])
          Number = (int) Math.Round((double) Number * 0.5);
      }
      if (MakeLog)
        this.AddLog("Final score = " + Conversion.Str((object) Number));
      return Number;
    }

    public void AddMarkers()
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray3 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray4 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray5 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray6 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      SimpleList simpleList = new SimpleList();
      this.MarkerList = new SimpleList();
      this.ArtMarkerList = new SimpleList();
      this.AirMarkerList = new SimpleList();
      this.EngineerMarkerList = new SimpleList();
      Coordinate averageCorpsUnitCoord = this.GetAverageCorpsUnitCoord(this.OpGroup);
      if (this.MoveAndAttackRound != 1)
        ;
      int groupHq = this.GetGroupHQ(this.OpGroup);
      int moveMatrixCounter = this.MoveMatrixCounter;
      int num1;
      int num2;
      for (int index = 1; index <= moveMatrixCounter; ++index)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 1)
          numArray4[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 2)
        {
          numArray5[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
          ++num1;
        }
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 5)
          numArray5[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 3)
        {
          numArray6[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
          ++num2;
        }
      }
      Coordinate coordinate1;
      int tid1;
      int tdata5;
      if (num2 > 0)
      {
        if (groupHq > -1)
        {
          bool[] flagArray = new bool[1000];
          int num3 = -1;
          int index1;
          if (this.game.Data.UnitObj[groupHq].AIAttack > -1)
            index1 = this.game.Data.UnitObj[groupHq].AIAttack;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
            index1 = this.game.Data.UnitObj[groupHq].AIDefend;
          if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
            index1 = this.game.Data.UnitObj[groupHq].AIFallback;
          if (index1 > -1)
          {
            int areaCount = this.AreaCount;
            for (int index2 = 0; index2 <= areaCount; ++index2)
            {
              if (this.AreaBorder[index1, index2] > 0)
              {
                ++num3;
                flagArray[index2] = true;
              }
            }
          }
          int tid2 = 0;
          int mapWidth = this.game.Data.MapObj[0].MapWidth;
          for (int index3 = 0; index3 <= mapWidth; ++index3)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int index4 = 0; index4 <= mapHeight; ++index4)
            {
              int num4 = 0;
              if (this.game.HandyFunctionsObj.IsHexAirfield(index3, index4, 0) & this.GetRegime(this.game.Data.MapObj[0].HexObj[index3, index4].Regime) == this.GetGameDataTurn() && this.GetRegime(this.game.Data.MapObj[0].HexObj[index3, index4].Regime) == this.GetGameDataTurn())
              {
                if (this.AreaMatrixNarrow[index3, index4] == this.game.Data.UnitObj[groupHq].AIDefend)
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] == this.game.Data.UnitObj[groupHq].AIAttack)
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] == this.game.Data.UnitObj[groupHq].AIFallback)
                  num4 = 1;
                if (numArray6[index3, index4] > 0)
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] > -1 && flagArray[this.AreaMatrixNarrow[index3, index4]])
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] < 0)
                  num4 = 0;
                if (this.AreaMatrixNarrow[index3, index4] > 0 & this.game.Data.UnitObj[groupHq].AIDefend > -1 && this.AreaSteps[this.AreaMatrixNarrow[index3, index4], this.game.Data.UnitObj[groupHq].AIDefend] <= 2)
                  num4 = 1;
                if (num4 == 1 | numArray6[index3, index4] > 0)
                {
                  coordinate1 = averageCorpsUnitCoord;
                  int tweight = this.game.HandyFunctionsObj.Distance(index3, index4, 0, coordinate1.x, coordinate1.y, 0);
                  if ((double) tweight <= 20.0)
                    tweight = 20;
                  if (this.AreaMatrixNarrow[index3, index4] > -1 && this.AreaClosestEnemy[this.AreaMatrixNarrow[index3, index4]] < 9)
                    tweight += (10 - this.AreaClosestEnemy[this.AreaMatrixNarrow[index3, index4]]) * 1000;
                  coordinate1 = averageCorpsUnitCoord;
                  if (coordinate1.onmap)
                    tweight += this.game.HandyFunctionsObj.Distance(index3, index4, 0, coordinate1.x, coordinate1.y, 0);
                  ++tid2;
                  simpleList.Add(tid2, tweight, index3, index4);
                }
              }
            }
          }
        }
        simpleList.Sort();
        int num5 = Math.Min(5, simpleList.Counter);
        for (int index = 0; index <= num5; ++index)
        {
          ++tid1;
          tdata5 = this.GetTscore(simpleList.Data1[index], simpleList.Data2[index]);
          this.AirMarkerList.Add(tid1, 1, simpleList.Data1[index], simpleList.Data2[index], -1, -1, tdata5);
        }
      }
      if (this.CorpsEngineer[this.OpGroup])
      {
        int mapWidth = this.game.Data.MapObj[0].MapWidth;
        for (int index5 = 0; index5 <= mapWidth; ++index5)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int index6 = 0; index6 <= mapHeight; ++index6)
          {
            int num6 = 0;
            if (this.SupplyMatrix[index5, index6] == this.OpGroup & this.SupplyMatrixDistance[index5, index6] == 0)
              num6 = 1;
            if (this.AdvanceAxisMatrix[index5, index6] >= 0)
              num6 = 1;
            if (num6 == 1)
            {
              int index7 = 0;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index5, index6, 0, index7 + 1);
                if (coordinate1.onmap && this.game.Data.MapObj[0].HexObj[index5, index6].RoadType[index7] > -1 & this.game.Data.MapObj[0].HexObj[index5, index6].RiverType[index7] > -1 && !this.game.Data.MapObj[0].HexObj[index5, index6].Bridge[index7])
                {
                  int num7 = 0;
                  if (this.SupplyMatrix[index5, index6] == this.OpGroup & this.SupplyMatrixDistance[index5, index6] == 0)
                    num7 = 1;
                  if (this.AdvanceAxisMatrix[index5, index6] >= 0)
                    num7 = 1;
                  if (num7 == 1)
                  {
                    ++tid1;
                    this.EngineerMarkerList.Add(tid1, 6, index5, index6, coordinate1.x, coordinate1.y, 100);
                  }
                }
                ++index7;
              }
              while (index7 <= 5);
            }
          }
        }
      }
      int num8 = 0;
      do
      {
        int mapWidth = this.game.Data.MapObj[0].MapWidth;
        for (int index8 = 0; index8 <= mapWidth; ++index8)
        {
          int mapHeight = this.game.Data.MapObj[0].MapHeight;
          for (int index9 = 0; index9 <= mapHeight; ++index9)
          {
            if (index8 == 49 & index9 == 33)
              index8 = index8;
            Coordinate coordinate2;
            if (this.BottleNeckMatrix[index8, index9] > 0 | this.tArea[index8, index9] > 0 | numArray4[index8, index9] > 0 | numArray5[index8, index9] > 0 | numArray6[index8, index9] > 0)
            {
              if (this.game.Data.MapObj[0].HexObj[index8, index9].UnitCounter > -1 & num8 == 0)
              {
                if (this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index8, index9].Regime))
                {
                  if (simpleList.Counter > -1)
                  {
                    if (this.game.Data.MapObj[0].HexObj[index8, index9].MaxRecon > 0)
                    {
                      ++tid1;
                      tdata5 = this.GetTscore(index8, index9);
                      this.AirMarkerList.Add(tid1, 1, simpleList.Data1[0], simpleList.Data2[0], index8, index9, tdata5);
                      if (simpleList.Counter > 0)
                      {
                        ++tid1;
                        this.AirMarkerList.Add(tid1, 1, simpleList.Data1[1], simpleList.Data2[1], index8, index9, tdata5);
                      }
                      if (simpleList.Counter > 1)
                      {
                        ++tid1;
                        this.AirMarkerList.Add(tid1, 1, simpleList.Data1[2], simpleList.Data2[2], index8, index9, tdata5);
                      }
                      int[,] numArray7 = numArray3;
                      int[,] numArray8 = numArray7;
                      int x = coordinate1.x;
                      int index10 = x;
                      int y = coordinate1.y;
                      int index11 = y;
                      int num9 = numArray7[x, y] + 1;
                      numArray8[index10, index11] = num9;
                    }
                    else if (numArray3[simpleList.Data1[2], simpleList.Data2[2]] == 0)
                    {
                      this.AirMarkerList.Add(tid1, 1, simpleList.Data1[2], simpleList.Data2[2], -1, -1, tdata5);
                      int[,] numArray9 = numArray3;
                      int[,] numArray10 = numArray9;
                      int[] data1 = simpleList.Data1;
                      int[] numArray11 = data1;
                      int index12 = 2;
                      int index13 = index12;
                      int index14 = numArray11[index13];
                      int[] data2 = simpleList.Data2;
                      int[] numArray12 = data2;
                      int index15 = 2;
                      int index16 = index15;
                      int index17 = numArray12[index16];
                      int num10 = numArray9[data1[index12], data2[index15]] + 1;
                      numArray10[index14, index17] = num10;
                    }
                  }
                  int tfacing1 = 1;
                  do
                  {
                    coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index8, index9, 0, tfacing1);
                    if (coordinate1.onmap && this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].UnitCounter == -1 | this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn() && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
                    {
                      tdata5 = (int) Math.Round((double) (this.GetTscore(index8, index9, tfacing1 - 1) + this.GetTscore(coordinate1.x, coordinate1.y)) / 2.0);
                      if (tdata5 > 0)
                      {
                        ++tid1;
                        this.MarkerList.Add(tid1, 1, coordinate1.x, coordinate1.y, index8, index9, tdata5);
                        int[,] numArray13 = numArray1;
                        int[,] numArray14 = numArray13;
                        int index18 = index8;
                        int index19 = index18;
                        int index20 = index9;
                        int index21 = index20;
                        int num11 = numArray13[index18, index20] + 1;
                        numArray14[index19, index21] = num11;
                        this.ArtMarkerList.Add(tid1, 1, coordinate1.x, coordinate1.y, index8, index9, (int) Math.Round((double) tdata5 * 0.66));
                        int[,] numArray15 = numArray2;
                        int[,] numArray16 = numArray15;
                        int index22 = index8;
                        int index23 = index22;
                        int index24 = index9;
                        int index25 = index24;
                        int num12 = numArray15[index22, index24] + 1;
                        numArray16[index23, index25] = num12;
                        tdata5 = this.GetTscore(index8, index9, tfacing1 - 1);
                        if (num1 > 0)
                        {
                          int tfacing2 = 1;
                          do
                          {
                            coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                            if (coordinate2.onmap && this.game.HandyFunctionsObj.Distance(index8, index9, 0, coordinate2.x, coordinate2.y, 0) == 2 && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime) == this.GetGameDataTurn() | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].UnitCounter == -1 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea)
                            {
                              ++tid1;
                              this.ArtMarkerList.Add(tid1, 1, coordinate2.x, coordinate2.y, index8, index9, tdata5);
                              int[,] numArray17 = numArray2;
                              int[,] numArray18 = numArray17;
                              int x = coordinate2.x;
                              int index26 = x;
                              int y = coordinate2.y;
                              int index27 = y;
                              int num13 = numArray17[x, y] + 1;
                              numArray18[index26, index27] = num13;
                            }
                            ++tfacing2;
                          }
                          while (tfacing2 <= 6);
                        }
                      }
                    }
                    ++tfacing1;
                  }
                  while (tfacing1 <= 6);
                  index8 = index8;
                }
                else
                {
                  int unit = this.game.Data.MapObj[0].HexObj[index8, index9].UnitList[0];
                  if (this.game.Data.UnitObj[unit].AIGroup == this.OpGroup | this.game.Data.UnitObj[unit].HQ == groupHq | unit == groupHq | numArray6[index8, index9] > 0 & numArray4[index8, index9] > 0 | numArray5[index8, index9] > 0)
                  {
                    tdata5 = this.GetTscore(index8, index9) + this.BottleNeckMatrix[index8, index9] * 2;
                    if (numArray4[index8, index9] > 0 & numArray1[index8, index9] == 0)
                    {
                      ++tid1;
                      this.MarkerList.Add(tid1, 5, index8, index9, -1, -1, tdata5);
                      int[,] numArray19 = numArray1;
                      int[,] numArray20 = numArray19;
                      int index28 = index8;
                      int index29 = index28;
                      int index30 = index9;
                      int index31 = index30;
                      int num14 = numArray19[index28, index30] + 1;
                      numArray20[index29, index31] = num14;
                    }
                    if (numArray5[index8, index9] > 0 & numArray2[index8, index9] == 0)
                    {
                      tdata5 = (int) Math.Round((double) tdata5 / 2.0);
                      ++tid1;
                      this.ArtMarkerList.Add(tid1, 5, index8, index9, -1, -1, tdata5);
                      int[,] numArray21 = numArray2;
                      int[,] numArray22 = numArray21;
                      int index32 = index8;
                      int index33 = index32;
                      int index34 = index9;
                      int index35 = index34;
                      int num15 = numArray21[index32, index34] + 1;
                      numArray22[index33, index35] = num15;
                    }
                  }
                }
              }
              else if (num8 == 1)
              {
                int num16 = 0;
                int num17;
                if (this.game.Data.MapObj[0].HexObj[index8, index9].Location > -1 | this.game.HandyFunctionsObj.HasHexBridge(index8, index9, 0))
                  num17 = 0;
                else if (this.game.HandyFunctionsObj.HasHexRoad(index8, index9, 0))
                  num17 = 0;
                else if (this.FrontlineArea[index8, index9] == 1)
                  num17 = 0;
                else if (this.BottleNeckMatrix[index8, index9] > 0)
                {
                  num17 = 0;
                }
                else
                {
                  num17 = 0;
                  if (this.game.Data.MapObj[0].HexObj[index8, index9].LandscapeType == 6)
                    num17 = 1;
                  if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index8, index9].LandscapeType].IsSea)
                    num17 = 1;
                  int tfacing3 = 1;
                  do
                  {
                    coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index8, index9, 0, tfacing3);
                    if (coordinate1.onmap)
                    {
                      if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].VP > 0 & this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
                      {
                        num17 = 0;
                        break;
                      }
                      if (numArray1[coordinate1.x, coordinate1.y] > 0)
                      {
                        num17 = 1;
                        int tfacing4 = 1;
                        do
                        {
                          coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing4);
                          if (coordinate2.onmap && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && numArray1[coordinate2.x, coordinate2.y] > 0)
                            num17 = 1;
                          ++tfacing4;
                        }
                        while (tfacing4 <= 6);
                      }
                    }
                    ++tfacing3;
                  }
                  while (tfacing3 <= 6);
                }
                if (groupHq > -1 && this.game.Data.UnitObj[groupHq].AIDefend > -1 && index8 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x && index9 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y && numArray1[index8, index9] == 0)
                {
                  num17 = 0;
                  num16 = 1;
                }
                if (groupHq > -1 && this.game.Data.UnitObj[groupHq].AIFallback > -1 && index8 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x && index9 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y && numArray1[index8, index9] == 0)
                {
                  num17 = 0;
                  num16 = 1;
                }
                if (num17 == 0)
                {
                  tdata5 = (int) Math.Round((double) this.GetTscore(index8, index9) / 2.0);
                  if (this.BottleNeckMatrix[index8, index9] > 0)
                  {
                    num16 = 1;
                    tdata5 += this.BottleNeckMatrix[index8, index9] * 2;
                  }
                  if (index8 == 29 & index9 == 7)
                    index8 = index8;
                  if (tdata5 > 0)
                  {
                    ++tid1;
                    if (!this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index8, index9].Regime))
                    {
                      if (numArray1[index8, index9] == 0 && num16 == 1 | this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
                      {
                        this.MarkerList.Add(tid1, 3, index8, index9, -1, -1, tdata5);
                        int[,] numArray23 = numArray1;
                        int[,] numArray24 = numArray23;
                        int index36 = index8;
                        int index37 = index36;
                        int index38 = index9;
                        int index39 = index38;
                        int num18 = numArray23[index36, index38] + 1;
                        numArray24[index37, index39] = num18;
                        this.ArtMarkerList.Add(tid1, 3, index8, index9, -1, -1, tdata5);
                        int[,] numArray25 = numArray2;
                        int[,] numArray26 = numArray25;
                        int index40 = index8;
                        int index41 = index40;
                        int index42 = index9;
                        int index43 = index42;
                        int num19 = numArray25[index40, index42] + 1;
                        numArray26[index41, index43] = num19;
                      }
                    }
                    else if (numArray2[index8, index9] == 0)
                    {
                      this.MarkerList.Add(tid1, 2, index8, index9, -1, -1, tdata5);
                      int[,] numArray27 = numArray1;
                      int[,] numArray28 = numArray27;
                      int index44 = index8;
                      int index45 = index44;
                      int index46 = index9;
                      int index47 = index46;
                      int num20 = numArray27[index44, index46] + 1;
                      numArray28[index45, index47] = num20;
                      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
                      {
                        this.ArtMarkerList.Add(tid1, 2, index8, index9, -1, -1, tdata5);
                        int[,] numArray29 = numArray2;
                        int[,] numArray30 = numArray29;
                        int index48 = index8;
                        int index49 = index48;
                        int index50 = index9;
                        int index51 = index50;
                        int num21 = numArray29[index48, index50] + 1;
                        numArray30[index49, index51] = num21;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        ++num8;
      }
      while (num8 <= 1);
    }

    public void AddExtraMarkers()
    {
      int[,] numArray1 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray3 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray4 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray5 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[,] numArray6 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      SimpleList simpleList = new SimpleList();
      int counter1 = this.MarkerList.Counter;
      for (int index = 0; index <= counter1; ++index)
        numArray1[this.MarkerList.Data1[index], this.MarkerList.Data2[index]] = 1;
      int counter2 = this.ArtMarkerList.Counter;
      for (int index = 0; index <= counter2; ++index)
        numArray2[this.ArtMarkerList.Data1[index], this.ArtMarkerList.Data2[index]] = 1;
      this.SetTArea();
      int tid = 9999;
      int moveMatrixCounter1 = this.MoveMatrixCounter;
      for (int index1 = 1; index1 <= moveMatrixCounter1; ++index1)
      {
        int unr = this.MoveMatrixUnit[index1];
        if (unr > -1 && this.game.Data.UnitObj[unr].TempCategory == 1)
        {
          int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(unr);
          int mapWidth = this.game.Data.MapObj[0].MapWidth;
          for (int index2 = 0; index2 <= mapWidth; ++index2)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int index3 = 0; index3 <= mapHeight; ++index3)
            {
              if (numArray1[index2, index3] == 0 && this.MoveMatrix[index1, index2, index3] >= lowestAp)
              {
                numArray1[index2, index3] = 1;
                ++tid;
                int tscore = this.GetTscore(index2, index3);
                if (tscore > 0)
                  this.MarkerList.Add(tid, 2, index2, index3, -1, -1, tscore);
              }
            }
          }
        }
      }
      int moveMatrixCounter2 = this.MoveMatrixCounter;
      for (int index4 = 1; index4 <= moveMatrixCounter2; ++index4)
      {
        int unr = this.MoveMatrixUnit[index4];
        if (unr > -1 && this.game.Data.UnitObj[unr].TempCategory == 2)
        {
          int lowestAp = this.game.HandyFunctionsObj.GetLowestAp(unr);
          int mapWidth = this.game.Data.MapObj[0].MapWidth;
          for (int index5 = 0; index5 <= mapWidth; ++index5)
          {
            int mapHeight = this.game.Data.MapObj[0].MapHeight;
            for (int index6 = 0; index6 <= mapHeight; ++index6)
            {
              if (numArray2[index5, index6] == 0 && this.MoveMatrix[index4, index5, index6] >= lowestAp)
              {
                numArray2[index5, index6] = 1;
                ++tid;
                int tscore = this.GetTscore(index5, index6);
                if (tscore > 0)
                  this.ArtMarkerList.Add(tid, 2, index5, index6, -1, -1, tscore);
              }
            }
          }
        }
      }
    }

    public void Screenshot(int typ, string fileextension, ref int[,] tObj)
    {
      FileStream fileStream;
      try
      {
        fileStream = new FileStream(this.game.AppPath + "logs/screenshot_typ" + Strings.Trim(Conversion.Str((object) typ)) + "_pl" + Strings.Trim(Conversion.Str((object) this.game.Data.Turn)) + fileextension + ".jpg", FileMode.Create);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        fileextension = "name error";
        fileStream = new FileStream(this.game.AppPath + "logs/screenshot_typ" + Strings.Trim(Conversion.Str((object) typ)) + "_pl" + Strings.Trim(Conversion.Str((object) this.game.Data.Turn)) + fileextension + ".jpg", FileMode.Create);
        ProjectData.ClearProjectError();
      }
      Bitmap bitmap = new Bitmap(this.game.Data.MapObj[0].MapWidth * 40 + 80, this.game.Data.MapObj[0].MapHeight * 32 + 68, PixelFormat.Format24bppRgb);
      bitmap.SetResolution((float) DrawMod.DPIx, (float) DrawMod.DPIy);
      Graphics Expression = Graphics.FromImage((Image) bitmap);
      if (typ == 1)
      {
        DrawMod.DrawText(ref Expression, "Matrix", new Font("Times New Roman", 11f, FontStyle.Bold, GraphicsUnit.Pixel), 10, bitmap.Height - 15);
        this.Screenshotgrid(ref Expression);
        this.Screenshot1(ref Expression, ref tObj);
      }
      if (!Information.IsNothing((object) Expression))
        Expression.Dispose();
      bitmap.Save((Stream) fileStream, ImageFormat.Jpeg);
      fileStream.Close();
    }

    public void Screenshotgrid(ref Graphics g)
    {
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          CustomBitmapClass customBitmapObj = this.game.CustomBitmapObj;
          int cx = index1;
          int cy = index2;
          Bitmap bitmap = (Bitmap) null;
          ref Bitmap local1 = ref bitmap;
          bool flag = false;
          ref bool local2 = ref flag;
          Bitmap objBitmap = customBitmapObj.DrawHex(cx, cy, 0, neverusehistory: true, gBitmap: (ref local1), tFromMapPopup: (ref local2));
          if (index1 == 0 | index1 % 2 == 0)
          {
            DrawMod.DrawScaled(ref g, ref objBitmap, index1 * 40, index2 * 32, 40, 32);
            DrawMod.DrawRectangle(ref g, index1 * 40, index2 * 32, 40, 32, (int) byte.MaxValue, (int) byte.MaxValue, (int) byte.MaxValue, (int) byte.MaxValue);
          }
          else
          {
            DrawMod.DrawScaled(ref g, ref objBitmap, index1 * 40, index2 * 32 + 16, 40, 32);
            DrawMod.DrawRectangle(ref g, index1 * 40, index2 * 32 + 16, 40, 32, (int) byte.MaxValue, (int) byte.MaxValue, (int) byte.MaxValue, (int) byte.MaxValue);
          }
        }
      }
    }

    public void Screenshot1(ref Graphics g, ref int[,] tObj)
    {
      int[,] numArray = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          if (tObj[index1, index2] > -1)
          {
            if (index1 == 0 | index1 % 2 == 0)
              DrawMod.DrawTextOutline(ref g, Conversion.Str((object) tObj[index1, index2]), new Font("Times New Roman", 13f, FontStyle.Bold, GraphicsUnit.Pixel), index1 * 40 + 2, index2 * 32 + 2);
            else
              DrawMod.DrawTextOutline(ref g, Conversion.Str((object) tObj[index1, index2]), new Font("Times New Roman", 13f, FontStyle.Bold, GraphicsUnit.Pixel), index1 * 40 + 2, index2 * 32 + 2 + 16);
          }
        }
      }
    }

    public void CloseAI()
    {
      this.game.Data.RegimeObj[this.GetGameDataTurn()].OldAINarrow[0] = new MapMatrix2(this.game.Data.MapObj[0].MapWidth, this.game.Data.MapObj[0].MapHeight);
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          this.game.Data.RegimeObj[this.GetGameDataTurn()].OldAINarrow[0].Value[index1, index2] = this.AreaMatrixNarrow[index1, index2] <= this.RealAreaCount ? 0 : this.AreaMatrixNarrow[index1, index2];
          this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerAbove = 0;
          this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerMulti = 0;
        }
      }
      int historicalUnitCounter = this.game.Data.HistoricalUnitCounter;
      for (int index = 0; index <= historicalUnitCounter; ++index)
      {
        this.game.Data.HistoricalUnitObj[index].TempAttack = -1;
        this.game.Data.HistoricalUnitObj[index].TempDefend = -1;
        this.game.Data.HistoricalUnitObj[index].TempStance = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetX = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetY = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetAttackX = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetAttackY = -1;
      }
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
        this.game.Data.UnitObj[index].TempUnitSelectable = false;
      this.game.EditObj.TargetX = -1;
      this.game.EditObj.TargetY = -1;
      this.WriteLog();
      this.WriteLog2();
    }

    public void AddLog2(string s)
    {
      ++this.LogCounter2;
      this.LogTxt2 = (string[]) Utils.CopyArray((Array) this.LogTxt2, (Array) new string[this.LogCounter2 + 1]);
      this.LogTxt2[this.LogCounter2] = s;
    }

    public void WriteLog2()
    {
      int num1 = this.game.HandyFunctionsObj.CheckDiskSpace(Strings.Left(this.game.AppPath, Strings.InStr(this.game.AppPath, ":")));
      if (num1 > 0 & num1 < 50)
      {
        int num2 = (int) Interaction.MsgBox((object) "Not of space left to write to disk.");
      }
      else
      {
        StreamWriter text = File.CreateText(this.game.AppPath + "logs/AItimer.txt");
        int logCounter2 = this.LogCounter2;
        for (int index = 0; index <= logCounter2; ++index)
          text.WriteLine(this.LogTxt2[index]);
        text.Close();
      }
    }

    public void AddLog(string s)
    {
      ++this.LogCounter;
      if (this.LogTxt.GetUpperBound(0) < this.LogCounter)
        this.LogTxt = (string[]) Utils.CopyArray((Array) this.LogTxt, (Array) new string[this.LogCounter + 1000 + 1]);
      this.LogTxt[this.LogCounter] = s;
    }

    public void WriteLog()
    {
      int num1 = this.game.HandyFunctionsObj.CheckDiskSpace(Strings.Left(this.game.AppPath, Strings.InStr(this.game.AppPath, ":")));
      if (num1 > 0 & num1 < 50)
      {
        int num2 = (int) Interaction.MsgBox((object) "Not of space left to write to disk.");
      }
      else
      {
        StreamWriter text = File.CreateText(this.game.AppPath + "logs/AIlog_" + Conversion.Str((object) this.game.Data.Turn) + ".txt");
        int logCounter = this.LogCounter;
        for (int index = 0; index <= logCounter; ++index)
          text.WriteLine(this.LogTxt[index]);
        text.Close();
      }
    }

    public void WriteLog(string name)
    {
      int num1 = this.game.HandyFunctionsObj.CheckDiskSpace(Strings.Left(this.game.AppPath, Strings.InStr(this.game.AppPath, ":")));
      if (num1 > 0 & num1 < 50)
      {
        int num2 = (int) Interaction.MsgBox((object) "Not of space left to write to disk.");
      }
      else
      {
        StreamWriter text = File.CreateText(this.game.AppPath + "logs/FullAILog_" + Conversion.Str((object) this.game.Data.Turn) + "_" + name + ".txt");
        int logCounter = this.LogCounter;
        for (int index = 0; index <= logCounter; ++index)
          text.WriteLine(this.LogTxt[index]);
        text.Close();
      }
    }

    public bool IsDefinedArea(int ix, int iy, int area) => area != -1 && this.game.Data.AreaObj[area].Code == this.game.Data.MapObj[0].HexObj[ix, iy].AreaCode[this.game.Data.AreaObj[area].Slot];

    public bool IsAIArea(int ix, int iy, int area) => area != -1 && this.AreaMatrixWide[ix, iy] == area;

    ~NewAIClass() => base.Finalize();

    public void InitStrategicTransfers(bool makelog)
    {
      if (makelog)
        this.AddLog("INIT STRATEGIC TRANSFERS");
      int unitCounter1 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter1; ++index)
        this.game.Data.UnitObj[index].TempStrategic = false;
      int Number1 = 0;
      do
      {
        if (makelog)
          this.AddLog("==>CAPTYPE: " + Conversion.Str((object) Number1));
        int unitCounter2 = this.game.Data.UnitCounter;
        for (int index1 = 0; index1 <= unitCounter2; ++index1)
        {
          if (this.game.Data.UnitObj[index1].IsHQ & this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].Regime == this.game.Data.Turn)
          {
            int num1 = 0;
            int theater;
            if (Number1 == 0 & this.game.Data.UnitObj[index1].LandCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (Number1 == 1 & this.game.Data.UnitObj[index1].NavyCap > 0)
            {
              num1 = 1;
              theater = 1;
            }
            if (Number1 == 2 & this.game.Data.UnitObj[index1].AirCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (num1 == 1)
            {
              if (makelog)
                this.AddLog("==>INIT SHQ: " + this.game.Data.UnitObj[index1].Name);
              int mapWidth1 = this.game.Data.MapObj[0].MapWidth;
              for (int index2 = 0; index2 <= mapWidth1; ++index2)
              {
                int mapHeight = this.game.Data.MapObj[0].MapHeight;
                for (int index3 = 0; index3 <= mapHeight; ++index3)
                  this.SupplyMatrixReal[index2, index3] = 9999;
              }
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, (int) Math.Round((double) this.game.Data.RuleVar[Number1]), theater, (int) Math.Round((double) this.game.Data.RuleVar[78]), this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0);
              int mapWidth2 = this.game.Data.MapObj[0].MapWidth;
              for (int index4 = 0; index4 <= mapWidth2; ++index4)
              {
                int mapHeight = this.game.Data.MapObj[0].MapHeight;
                for (int index5 = 0; index5 <= mapHeight; ++index5)
                {
                  this.SupplyMatrixReal[index4, index5] = this.game.EditObj.TempValue[0].Value[index4, index5];
                  this.SupplyMatrixRealCameFrom[index4, index5] = this.game.EditObj.TempCameFrom[0].Value[index4, index5];
                }
              }
              SimpleList simpleList = new SimpleList();
              int unitCounter3 = this.game.Data.UnitCounter;
              Coordinate closeFriendlyRoadHex;
              for (int index6 = 0; index6 <= unitCounter3; ++index6)
              {
                if (!this.game.Data.UnitObj[index6].TempStrategic && this.game.Data.UnitObj[index6].AIGroup > 0 & this.game.Data.UnitObj[index6].X > -1 & this.game.Data.UnitObj[index6].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn())
                {
                  int index7 = this.game.Data.UnitObj[index6].AIAttackStyle != 3 ? this.game.Data.UnitObj[index6].AIDefend : this.game.Data.UnitObj[index6].AIAttack;
                  if (index7 > -1 & index7 <= this.AreaCount)
                  {
                    this.game.Data.UnitObj[index6].FinalX = this.AreaCenter[index7].x;
                    this.game.Data.UnitObj[index6].FinalY = this.AreaCenter[index7].y;
                    if (this.game.Data.UnitObj[index6].PreDef == -1 && this.game.Data.UnitObj[index6].AIGroup > -1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index6].PreDef == -1 & this.game.Data.UnitObj[index6].X > -1 && index6 != index1 & !this.game.HandyFunctionsObj.HasUnitAirSF(index6) & !this.game.HandyFunctionsObj.HasUnitNavySF(index6) && this.game.Data.UnitObj[index6].X != this.game.Data.UnitObj[index6].FinalX & this.game.Data.UnitObj[index6].Y != this.game.Data.UnitObj[index6].FinalY && this.game.Data.UnitObj[index6].FinalX > -1 & this.game.Data.UnitObj[index6].FinalY > -1)
                    {
                      closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y, 3);
                      if (closeFriendlyRoadHex.onmap)
                      {
                        closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[index6].FinalX, this.game.Data.UnitObj[index6].FinalY, 4);
                        if (closeFriendlyRoadHex.onmap)
                        {
                          int num2 = this.game.HandyFunctionsObj.Distance(closeFriendlyRoadHex.x, closeFriendlyRoadHex.y, 0, this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y, 0);
                          int num3 = this.SupplyMatrixReal[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y];
                          this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0, this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y, 0);
                          int num4 = this.SupplyMatrixReal[this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y];
                          int index8 = this.game.Data.UnitObj[index6].AIAttackStyle != 3 ? this.game.Data.UnitObj[index6].AIDefend : this.game.Data.UnitObj[index6].AIAttack;
                          if (index8 > -1 & num3 < 9999 & num4 < 9999 & (double) this.GetHexSpeedofUnit(index6, true) * 3.5 < (double) num2)
                          {
                            int tweight = (int) Math.Round((double) ((this.AreaFuzzyVP[index8] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index8].x, this.AreaCenter[index8].y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[index8].x, this.AreaCenter[index8].y].VP) * 1000) / ((double) num2 / 2.0));
                            simpleList.Add(index6, tweight);
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (simpleList.Counter > -1)
              {
                simpleList.Sort();
                for (int counter = simpleList.Counter; counter >= 0; counter += -1)
                {
                  if (makelog)
                    this.AddLog(this.game.Data.UnitObj[simpleList.Id[counter]].Name + " , PRIORITY = " + Conversion.Str((object) simpleList.Weight[counter]));
                }
                int Number2;
                if (Number1 == 0)
                  Number2 = this.game.Data.UnitObj[index1].LandCap;
                if (Number1 == 1)
                  Number2 = this.game.Data.UnitObj[index1].NavyCap;
                if (Number1 == 2)
                  Number2 = this.game.Data.UnitObj[index1].AirCap;
                if ((double) this.game.Data.RuleVar[802] == 1.0)
                  Number2 = 9999999;
                for (int counter = simpleList.Counter; counter >= 0; counter += -1)
                {
                  int unr = simpleList.Id[counter];
                  closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[unr].FinalX, this.game.Data.UnitObj[unr].FinalY, 4);
                  if (closeFriendlyRoadHex.onmap)
                  {
                    DrawMod.TGame.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.UnitObj[index1].Regime, (int) Math.Round((double) this.game.Data.RuleVar[Number1]), theater, (int) Math.Round((double) this.game.Data.RuleVar[78]), this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, overruleRoadType: 0);
                    this.game.EditObj.TargetX = closeFriendlyRoadHex.x;
                    this.game.EditObj.TargetY = closeFriendlyRoadHex.y;
                    this.game.EditObj.OrderUnit = unr;
                    this.game.EditObj.OrderTarget = index1;
                    int num5 = (this.game.EditObj.TempValue[0].Value[this.game.EditObj.TargetX, this.game.EditObj.TargetY] + (int) Math.Round((double) this.game.Data.RuleVar[351])) * this.game.HandyFunctionsObj.GetUnitWeight(unr, true);
                    if (num5 <= Number2)
                    {
                      if (makelog)
                        this.AddLog(this.game.Data.UnitObj[unr].Name + " PROGNOSED MOVED FROM " + Conversion.Str((object) this.game.Data.UnitObj[unr].X) + "," + Conversion.Str((object) this.game.Data.UnitObj[unr].Y) + " TO " + Conversion.Str((object) this.game.EditObj.TargetX) + "," + Conversion.Str((object) this.game.EditObj.TargetY));
                      this.game.Data.UnitObj[unr].TempStrategic = true;
                      this.game.Data.UnitObj[unr].TempCapHQ = index1;
                      this.game.Data.UnitObj[unr].TempCapType = Number1;
                      Number2 -= num5;
                      if (makelog)
                        this.AddLog("PROGNOSED RAIL CAP LEFT AT HIGHHQ = " + Conversion.Str((object) Number2));
                    }
                    else
                    {
                      int num6;
                      ++num6;
                      if (num6 > 2)
                        break;
                    }
                  }
                }
                this.game.EditObj.TargetX = -1;
                this.game.EditObj.TargetY = -1;
                this.game.EditObj.OrderTarget = -1;
                this.game.EditObj.OrderUnit = -1;
              }
            }
          }
        }
        ++Number1;
      }
      while (Number1 <= 2);
    }

    public void ExecuteStrategicTransfers(bool makelog)
    {
      if (makelog)
        this.AddLog("EXECUTE STRATEGIC TRANSFERS");
      this.TempGroupHQ[this.OpGroup] = this.GetGroupHQ(this.OpGroup);
      int Number = 0;
      do
      {
        if (makelog)
          this.AddLog("==>CAPTYPE: " + Conversion.Str((object) Number));
        int unitCounter1 = this.game.Data.UnitCounter;
        for (int index1 = 0; index1 <= unitCounter1; ++index1)
        {
          if (this.game.Data.UnitObj[index1].IsHQ & this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].Regime == this.game.Data.Turn)
          {
            int num1 = 0;
            int theater;
            if (Number == 0 & this.game.Data.UnitObj[index1].LandCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (Number == 1 & this.game.Data.UnitObj[index1].NavyCap > 0)
            {
              num1 = 1;
              theater = 1;
            }
            if (Number == 2 & this.game.Data.UnitObj[index1].AirCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (num1 == 1)
            {
              if (makelog)
                this.AddLog("==>SHQ: " + this.game.Data.UnitObj[index1].Name);
              SimpleList simpleList = new SimpleList();
              DrawMod.TGame.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.UnitObj[index1].Regime, (int) Math.Round((double) this.game.Data.RuleVar[Number]), theater, (int) Math.Round((double) this.game.Data.RuleVar[78]), this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0);
              int mapWidth = this.game.Data.MapObj[0].MapWidth;
              for (int index2 = 0; index2 <= mapWidth; ++index2)
              {
                int mapHeight = this.game.Data.MapObj[0].MapHeight;
                for (int index3 = 0; index3 <= mapHeight; ++index3)
                  this.SupplyMatrixReal[index2, index3] = this.game.EditObj.TempValue[0].Value[index2, index3];
              }
              int unitCounter2 = this.game.Data.UnitCounter;
              Coordinate coordinate;
              for (int index4 = 0; index4 <= unitCounter2; ++index4)
              {
                if (this.game.Data.UnitObj[index4].TempStrategic & this.game.Data.UnitObj[index4].TempCapType == Number && this.game.Data.UnitObj[index4].PreDef == -1 & this.game.Data.UnitObj[index4].TempCapHQ == index1 && this.game.Data.UnitObj[index4].AIGroup > -1 & this.game.Data.UnitObj[index4].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index4].PreDef == -1 & this.game.Data.UnitObj[index4].X > -1 && index4 != index1 & !this.game.HandyFunctionsObj.HasUnitAirSF(index4) & !this.game.HandyFunctionsObj.HasUnitNavySF(index4) && this.game.Data.UnitObj[index4].X != this.game.Data.UnitObj[index4].FinalX & this.game.Data.UnitObj[index4].Y != this.game.Data.UnitObj[index4].FinalY && this.game.HandyFunctionsObj.HasHexRoad(this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0) && this.game.Data.UnitObj[index4].FinalX > -1 & this.game.Data.UnitObj[index4].FinalY > -1 && this.game.HandyFunctionsObj.HasHexRoad(this.game.Data.UnitObj[index4].FinalX, this.game.Data.UnitObj[index4].FinalY, 0))
                {
                  coordinate.x = this.game.Data.UnitObj[index4].FinalX;
                  coordinate.y = this.game.Data.UnitObj[index4].FinalY;
                  int num2 = this.game.HandyFunctionsObj.Distance(coordinate.x, coordinate.y, 0, this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0);
                  int num3 = this.SupplyMatrixReal[coordinate.x, coordinate.y];
                  if (num3 >= 999 && this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend > -1)
                  {
                    coordinate.x = this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].x;
                    coordinate.y = this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].y;
                    num2 = this.game.HandyFunctionsObj.Distance(coordinate.x, coordinate.y, 0, this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0);
                    num3 = this.SupplyMatrixReal[coordinate.x, coordinate.y];
                  }
                  this.game.HandyFunctionsObj.Distance(coordinate.x, coordinate.y, 0, this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0);
                  int num4 = this.SupplyMatrixReal[this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y];
                  int index5 = this.game.Data.UnitObj[index4].AIAttackStyle != 3 ? this.game.Data.UnitObj[index4].AIDefend : this.game.Data.UnitObj[index4].AIAttack;
                  if (index5 > -1 & num3 < 9999 & num4 < 9999 & (double) this.GetHexSpeedofUnit(index4, true) * 2.0 < (double) num2 && this.CanBeStrategiclyTransferred(index4))
                  {
                    int num5 = this.AreaFuzzyVP[index5] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index5].x, this.AreaCenter[index5].y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[index5].x, this.AreaCenter[index5].y].VP;
                    if (this.game.Data.UnitObj[index4].TempStrategic)
                      num5 *= 10;
                    int tweight = (int) Math.Round((double) (num5 * 1000) / ((double) num2 / 2.0));
                    simpleList.Add(index4, tweight, coordinate.x, coordinate.y);
                  }
                }
              }
              if (simpleList.Counter > -1)
              {
                simpleList.Sort();
                for (int counter = simpleList.Counter; counter >= 0; counter += -1)
                {
                  if (makelog)
                    this.AddLog(this.GroupName[this.game.Data.UnitObj[simpleList.Id[counter]].AIGroup] + " : " + this.game.Data.UnitObj[simpleList.Id[counter]].Name + " , PRIORITY = " + Conversion.Str((object) simpleList.Weight[counter]));
                }
                for (int counter = simpleList.Counter; counter >= 0; counter += -1)
                {
                  int unr = simpleList.Id[counter];
                  coordinate.x = simpleList.Data1[counter];
                  coordinate.y = simpleList.Data2[counter];
                  coordinate.map = 0;
                  coordinate.onmap = true;
                  if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].UnitCounter <= 14)
                  {
                    DrawMod.TGame.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.UnitObj[index1].Regime, (int) Math.Round((double) this.game.Data.RuleVar[Number]), theater, (int) Math.Round((double) this.game.Data.RuleVar[78]), this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0);
                    this.game.EditObj.TargetX = coordinate.x;
                    this.game.EditObj.TargetY = coordinate.y;
                    this.game.EditObj.OrderUnit = unr;
                    this.game.EditObj.OrderTarget = index1;
                    int num6 = (this.game.EditObj.TempValue[0].Value[this.game.EditObj.TargetX, this.game.EditObj.TargetY] + (int) Math.Round((double) this.game.Data.RuleVar[351])) * this.game.HandyFunctionsObj.GetUnitWeight(unr, true);
                    int num7;
                    if (Number == 0)
                      num7 = this.game.Data.UnitObj[index1].LandCap;
                    if (Number == 1)
                      num7 = this.game.Data.UnitObj[index1].NavyCap;
                    if (Number == 2)
                      num7 = this.game.Data.UnitObj[index1].AirCap;
                    if ((double) this.game.Data.RuleVar[802] == 1.0)
                    {
                      num7 = 9999999;
                      this.game.Data.UnitObj[index1].LandCap = num7;
                      this.game.Data.UnitObj[index1].NavyCap = num7;
                      this.game.Data.UnitObj[index1].AirCap = num7;
                    }
                    if (num6 <= num7)
                    {
                      if (makelog)
                        this.AddLog(this.game.Data.UnitObj[unr].Name + " MOVED FROM " + Conversion.Str((object) this.game.Data.UnitObj[unr].X) + "," + Conversion.Str((object) this.game.Data.UnitObj[unr].Y) + " TO " + Conversion.Str((object) this.game.EditObj.TargetX) + "," + Conversion.Str((object) this.game.EditObj.TargetY));
                      this.game.ProcessingObj.DoStrategicTransfer(this.game.EditObj.OrderTarget, this.game.EditObj.OrderUnit, 2, this.game.EditObj.TargetX, this.game.EditObj.TargetY, this.game.EditObj.TargetMap);
                      if (makelog)
                      {
                        if (Number == 0)
                          this.AddLog("LAND-CAP LEFT AT HIGHHQ = " + Conversion.Str((object) this.game.Data.UnitObj[index1].AirCap));
                        if (Number == 1)
                          this.AddLog("NAVY-CAP LEFT AT HIGHHQ = " + Conversion.Str((object) this.game.Data.UnitObj[index1].AirCap));
                        if (Number == 2)
                          this.AddLog("RAIL-CAP LEFT AT HIGHHQ = " + Conversion.Str((object) this.game.Data.UnitObj[index1].AirCap));
                      }
                    }
                    else
                    {
                      int num8;
                      ++num8;
                      if (num8 > 2)
                        break;
                    }
                  }
                }
                this.game.EditObj.TargetX = -1;
                this.game.EditObj.TargetY = -1;
                this.game.EditObj.OrderTarget = -1;
                this.game.EditObj.OrderUnit = -1;
              }
            }
          }
        }
        ++Number;
      }
      while (Number <= 2);
    }

    public void FindBestStrategy(bool alllog, bool OnlyOneRound)
    {
      SimpleList[] simpleListArray = new SimpleList[100];
      this.AreaIsHistoricalArea = (int[]) Utils.CopyArray((Array) this.AreaIsHistoricalArea, (Array) new int[this.AreaCount + 1]);
      VBMath.Randomize((double) (this.game.Data.Turn + this.game.Data.Round + this.game.Data.MapObj[0].MapWidth));
      this.AreaGroupRound = 0;
      if (alllog)
      {
        this.AddLog("");
        this.AddLog("FIND STRATEGY");
        this.AddLog("");
      }
      this.SetFindBestStrategyStuff(alllog);
      this.SetInitialAreaGroups(alllog);
      if (this.AreaGroupCount == 0)
      {
        int num1 = (int) Interaction.MsgBox((object) "No areas definied. See rulevar 267. This will probably result in crash of DC1 AI", Title: ((object) "Vics message"));
      }
      int[] numArray = new int[this.AreaCount + 1];
      if (this.FullLog)
        this.WriteLog("10_FindBestStrategy_01_setup");
      this.LogCounter = -1;
      int num2;
      int Number1;
      int Number2;
      int num3;
      int index1;
      int index2;
      int tdata1;
      int index3;
      while (this.AreaGroupCount > 1 | this.AreaGroupRound == 0 && !(this.AreaGroupRound == 1 & OnlyOneRound))
      {
        ++this.AreaGroupRound;
        simpleListArray[this.AreaGroupRound] = new SimpleList();
        if (this.AreaGroupRound > 1)
        {
          this.MergeAreaGroups();
          if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 250 && this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 100 && this.AreaGroupCount > 1)
            this.MergeAreaGroups();
        }
        num2 = this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 250 ? (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 100 ? 2 : 3) : 4;
        int areaGroupCount = this.AreaGroupCount;
        for (this.CurrentAreaGroup = 1; this.CurrentAreaGroup <= areaGroupCount; ++this.CurrentAreaGroup)
        {
          this.SetAreaExtraVP(alllog);
          this.TempGroupTarget = new int[this.GroupCounter + 1];
          this.CorpsLoc = (int[]) Utils.CopyArray((Array) this.CorpsLoc, (Array) new int[this.GroupCounter + 1]);
          Number1 = 0;
          this.BestStrategy = (SimpleList) null;
          this.HistoryMove = new SimpleList[9000];
          this.HistoryMoveCounter = 0;
          this.HistoryScoreList = new SimpleList();
          Random random = new Random(this.CurrentAreaGroup * 20 + this.game.Data.Round * 1000 + this.game.Data.Turn + this.game.Data.MapObj[0].MapWidth + this.game.Data.MapObj[0].MapHeight);
          Number2 = -999999;
          this.OpGroup = -1;
          int num4 = 99999;
          int num5 = 99999;
          num3 = (int) Math.Round((double) this.DIFFICULTY_LEVEL_STRATEGY_MOVES / (double) this.AreaGroupCount);
          if (!this.Attacker)
            num3 = (int) Math.Round((double) num3 / 2.0);
          int num6 = 0;
          int groupCounter1 = this.GroupCounter;
          for (int index4 = 0; index4 <= groupCounter1; ++index4)
          {
            if (this.AreaGroup[this.CorpsStartLoc[index4]] == this.CurrentAreaGroup)
              ++num6;
          }
          if (alllog)
            this.AddLog("AREAGROUP ROUND " + this.AreaGroupRound.ToString() + ", AREAGROUP " + Conversion.Str((object) this.CurrentAreaGroup));
          int Number3;
          ++Number3;
          while (Number1 < num3)
          {
            if (alllog)
              this.AddLog("");
            if (alllog)
              this.AddLog("Step: " + Number1.ToString() + " of " + num3.ToString());
            if (Number1 % 80 == 0)
              GC.Collect();
            if (Number1 % 10 == 0)
            {
              this.game.EditObj.AIProgressMax = num3;
              this.game.EditObj.AIProgressNow = Number1;
              this.game.EditObj.TempAIString = this.AreaGroupCount <= 1 ? "Final initialization" : "Prelimenary initializations. Round " + Strings.Trim(Conversion.Str((object) Number3));
            }
            ++Number1;
            SimpleList Straty = new SimpleList();
            this.AreaOwner = new int[this.AreaCount + 1];
            int areaCount1 = this.AreaCount;
            for (int index5 = 1; index5 <= areaCount1; ++index5)
              this.AreaOwner[index5] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index5].x, this.AreaCenter[index5].y].Regime;
            this.FriendlySupply = new int[this.AreaCount + 1];
            this.GetStrategyScore_FriendlySupply(false, 0);
            this.StartFriendlySupply = new int[this.AreaCount + 1];
            int areaCount2 = this.AreaCount;
            for (int index6 = 1; index6 <= areaCount2; ++index6)
              this.StartFriendlySupply[index6] = this.FriendlySupply[index6];
            int groupCounter2 = this.GroupCounter;
            for (int index7 = 0; index7 <= groupCounter2; ++index7)
            {
              if (this.AreaGroup[this.CorpsStartLoc[index7]] == this.CurrentAreaGroup & this.TempGroupHQ[index7] >= -1)
              {
                int num7 = 0;
                int index8 = 0;
                index1 = 0;
                index2 = 0;
                int num8 = 0;
                int tdata5 = 0;
                tdata1 = 0;
                int num9 = index7;
                int num10 = 0;
                if (this.TempGroupHQ[index7] > -1)
                {
                  int historical1 = this.game.Data.UnitObj[this.TempGroupHQ[index7]].Historical;
                  if (historical1 > -1 && this.game.Data.HistoricalUnitObj[historical1].TempAttack > -1 | this.game.Data.HistoricalUnitObj[historical1].TempDefend > -1)
                    num10 = 1;
                  if (this.CorpsTopGroup[index7] > -1 && this.TempGroupHQ[this.CorpsTopGroup[index7]] > -1)
                  {
                    int historical2 = this.game.Data.UnitObj[this.TempGroupHQ[this.CorpsTopGroup[index7]]].Historical;
                    if (historical2 > -1 && this.game.Data.HistoricalUnitObj[historical2].TempAttack > -1 | this.game.Data.HistoricalUnitObj[historical2].TempDefend > -1)
                      num10 = 1;
                  }
                }
                if (num10 == 1)
                {
                  if (alllog)
                    this.AddLog("event override: " + this.GroupName[index7]);
                  int historical = this.game.Data.UnitObj[this.GetGroupHQ(index7)].Historical;
                  if (historical > -1)
                  {
                    num7 = this.CorpsStartLoc[index7];
                    if (num7 > 0)
                    {
                      index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      if (index8 > 0)
                      {
                        index1 = this.GetRandomAreaNeighbour(index8, num7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        if (index1 > 0)
                        {
                          index2 = this.GetRandomAreaNeighbour(index1, num7, index8, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          if (index2 > 0)
                          {
                            num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, tAreaGroup: this.CurrentAreaGroup);
                            if (num8 > 0)
                              tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, tAreaGroup: this.CurrentAreaGroup);
                          }
                        }
                      }
                    }
                    tdata1 = random.Next(0, 100) <= 50 ? 3 : (random.Next(0, 100) <= 50 ? 2 : 1);
                    num4 = Number1;
                    if (historical > -1)
                    {
                      if (this.game.Data.HistoricalUnitObj[historical].TempAttack == -1)
                      {
                        if (this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                        {
                          SimpleList areaToAreaPath = this.GetAreaToAreaPath(num7, this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend));
                          if (areaToAreaPath.Counter > -1)
                          {
                            if (areaToAreaPath.Counter == 0)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = index8;
                              index2 = index8;
                              num8 = index8;
                              tdata5 = index8;
                            }
                            if (areaToAreaPath.Counter == 1)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = index1;
                              num8 = index2;
                              tdata5 = num8;
                            }
                            if (areaToAreaPath.Counter == 2)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = areaToAreaPath.Id[2];
                              num8 = index2;
                              tdata5 = num8;
                            }
                            if (areaToAreaPath.Counter == 3)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = areaToAreaPath.Id[2];
                              num8 = areaToAreaPath.Id[3];
                              tdata5 = num8;
                            }
                            if (areaToAreaPath.Counter > 3)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = areaToAreaPath.Id[2];
                              num8 = areaToAreaPath.Id[3];
                              tdata5 = areaToAreaPath.Id[4];
                            }
                          }
                          else
                          {
                            index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend);
                            index1 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend);
                            index2 = index1;
                            num8 = index1;
                            tdata5 = index1;
                          }
                        }
                      }
                      else if (num7 != this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend) & this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                      {
                        SimpleList areaToAreaPath = this.GetAreaToAreaPath(num7, this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend));
                        if (areaToAreaPath.Counter > -1)
                        {
                          if (areaToAreaPath.Counter == 0)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                            index2 = index1;
                            num8 = index1;
                            tdata5 = index1;
                          }
                          if (areaToAreaPath.Counter == 1)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                            num8 = index2;
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 2)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                          }
                          if (areaToAreaPath.Counter > 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = areaToAreaPath.Id[4];
                          }
                        }
                        else
                        {
                          index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend);
                          index1 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                          if (index1 == -1)
                            index1 = index8;
                          index2 = index1;
                          num8 = index1;
                          tdata5 = index1;
                        }
                      }
                      else if (num7 == this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend) & this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                      {
                        index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                        index1 = index8;
                        index2 = index1;
                        num8 = index1;
                        tdata5 = index1;
                      }
                      else
                      {
                        SimpleList areaToAreaPath = this.GetAreaToAreaPath(num7, this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack));
                        if (areaToAreaPath.Counter > -1)
                        {
                          if (areaToAreaPath.Counter == 0)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = index8;
                            index2 = index8;
                            num8 = index8;
                            tdata5 = index8;
                          }
                          if (areaToAreaPath.Counter == 1)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = index1;
                            num8 = index2;
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 2)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = index2;
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter > 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = areaToAreaPath.Id[4];
                          }
                        }
                        else
                        {
                          index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                          index1 = index8;
                          index2 = index1;
                          num8 = index1;
                          tdata5 = index1;
                        }
                      }
                    }
                    if (this.game.Data.HistoricalUnitObj[historical].TempStance > -1)
                      tdata1 = this.game.Data.HistoricalUnitObj[historical].TempStance;
                  }
                }
                else if (num10 == 0 & num5 >= Number1 & Number1 > 1)
                {
                  if (alllog)
                    this.AddLog("stayput: " + this.GroupName[index7]);
                  num5 = Number1;
                  num7 = this.CorpsStartLoc[index7];
                  index8 = num7;
                  index1 = num7;
                  index2 = num7;
                  num8 = num7;
                  tdata1 = 1;
                }
                else if ((double) Number1 < Math.Min(100.0, (double) num3 / 4.0) & this.AreaGroupRound == 1 | num4 == 1)
                {
                  if (alllog)
                    this.AddLog("random movement: " + this.GroupName[index7]);
                  num7 = this.CorpsStartLoc[index7];
                  if (num7 > 0)
                  {
                    index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                    if (index8 > 0)
                    {
                      index1 = this.GetRandomAreaNeighbour(index8, num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      if (index1 > 0)
                      {
                        index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        if (index2 > 0)
                        {
                          num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          if (num8 > 0)
                            tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        }
                      }
                    }
                  }
                  tdata1 = random.Next(0, 100) <= 50 ? 3 : (random.Next(0, 100) <= 50 ? 2 : 1);
                  if (this.Attacker)
                    tdata1 = 3;
                  if (!this.Attacker & random.Next(0, 100) > 40)
                    tdata1 = random.Next(0, 100) <= 50 ? 2 : 1;
                  if (!this.Attacker & random.Next(0, 100) > 90)
                  {
                    index8 = num7;
                    tdata1 = 1;
                  }
                  if (num7 == index8)
                    tdata1 = 1;
                }
                else
                {
                  if (alllog)
                    this.AddLog("take move from previous strategy: " + this.GroupName[index7]);
                  num7 = this.CorpsStartLoc[index7];
                  random = new Random(Number1 + this.game.Data.Round * 6540 * (this.game.Data.Turn * 500));
                  float num11 = (float) Math.Sqrt(Math.Sqrt((double) random.Next(0, 100000) / 100000.0));
                  int num12 = 0;
                  if (random.Next(0, 100) < 20)
                  {
                    if ((double) VBMath.Rnd() > 0.5)
                      num11 = 1f;
                    if (alllog)
                      this.AddLog("MODE: Mix old record with top record");
                  }
                  else if (random.Next(0, 100) > 20)
                  {
                    num11 = 1f;
                    if (alllog)
                      this.AddLog("MODE: Mutate top record");
                  }
                  else
                  {
                    num11 = (float) Math.Sqrt(Math.Sqrt((double) random.Next(0, 100) / 100.0));
                    if (alllog)
                      this.AddLog("MODE: Mix old record with other old record");
                  }
                  for (int counter = this.HistoryScoreList.Counter; counter >= 0; counter += -1)
                  {
                    int num13 = this.HistoryScoreList.Weight[this.HistoryScoreList.Counter] - this.HistoryScoreList.Weight[0];
                    if ((num13 <= 0 ? 0.0 : (double) ((float) (this.HistoryScoreList.Weight[counter] - this.HistoryScoreList.Weight[0]) / (float) num13)) <= (double) num11)
                    {
                      if (alllog)
                        this.AddLog("historic record number " + Conversion.Str((object) counter) + " with score = " + Conversion.Str((object) this.HistoryScoreList.Weight[counter]));
                      int index9 = this.HistoryScoreList.Id[counter];
                      if (index9 > -1)
                      {
                        int nr = this.HistoryMove[index9].FindNr(index7 + 99000);
                        this.HistoryMove[index9].FindNr(index7 + 199000);
                        tdata1 = !(nr > -1 & random.Next(0, 100) < 80) ? ((double) VBMath.Rnd() <= 0.5 ? 3 : ((double) VBMath.Rnd() <= 0.5 ? 2 : 1)) : this.HistoryMove[index9].Data1[nr];
                        if (this.Attacker & random.Next(0, 100) > 80)
                          tdata1 = 3;
                        if (!this.Attacker & random.Next(0, 100) > 90)
                          tdata1 = 1;
                        int index10 = this.HistoryMove[index9].FindNr(index7);
                        if (index10 > -1)
                        {
                          if (this.AreaGroupCount == 1)
                            index10 = index10;
                          if ((double) VBMath.Rnd() * 100.0 > Math.Min(50.0, 200.0 * (1.0 / (double) num6)))
                          {
                            if (alllog)
                              this.AddLog("copies full move");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            index2 = this.HistoryMove[index9].Data3[index10];
                            num8 = this.HistoryMove[index9].Data4[index10];
                            tdata5 = this.HistoryMove[index9].Data5[index10];
                          }
                          else if ((double) VBMath.Rnd() * 100.0 < 50.0 / (double) this.AreaGroupRound | num12 == 1)
                          {
                            if (alllog)
                              this.AddLog("random/scripted");
                            index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                            if (num7 == index8)
                              tdata1 = 1;
                            if (index8 > 0)
                            {
                              index1 = this.GetRandomAreaNeighbour(index8, num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (index1 > 0)
                              {
                                index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                if (index2 > 0)
                                {
                                  num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                  if (num8 > 0)
                                    tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                }
                              }
                            }
                          }
                          else if ((double) VBMath.Rnd() * 100.0 < 50.0 / Math.Max(1.0, (double) this.AreaGroupRound / 2.0))
                          {
                            if (alllog)
                              this.AddLog("copies 1 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            if (index8 > 0)
                            {
                              index1 = this.GetRandomAreaNeighbour(index8, num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (index1 > 0)
                              {
                                index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                if (index2 > 0)
                                {
                                  num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                  if (num8 > 0)
                                    tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                }
                              }
                            }
                          }
                          else if ((double) VBMath.Rnd() * 100.0 < 50.0 / Math.Max(1.0, (double) this.AreaGroupRound / 3.0))
                          {
                            if (alllog)
                              this.AddLog("copies 2 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            if (index1 > 0)
                            {
                              index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (index2 > 0)
                              {
                                num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                if (num8 > 0)
                                  tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              }
                            }
                          }
                          else if (random.Next(0, 100) < 50)
                          {
                            if (alllog)
                              this.AddLog("copies 3 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            index2 = this.HistoryMove[index9].Data3[index10];
                            if (index2 > 0)
                            {
                              num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (num8 > 0)
                                tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                            }
                          }
                          else
                          {
                            if (alllog)
                              this.AddLog("copies 4 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            index2 = this.HistoryMove[index9].Data3[index10];
                            num8 = this.HistoryMove[index9].Data4[index10];
                            if (num8 > 0)
                              tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          }
                          if (!this.Attacker & random.Next(0, 100) > 90)
                          {
                            index8 = num7;
                            tdata1 = 1;
                            break;
                          }
                          break;
                        }
                        break;
                      }
                      break;
                    }
                  }
                }
                if (num10 == 0 & (Number1 == 1 & this.AreaGroupRound == 1 | Number1 == 2 & this.AreaGroupRound > 1))
                {
                  if (alllog)
                    this.AddLog("give previous round moves: " + this.GroupName[index7]);
                  int groupHq = this.GetGroupHQ(index7);
                  if (groupHq > -1 && this.game.Data.UnitObj[groupHq].AIAttack <= this.AreaCount && this.game.Data.UnitObj[groupHq].AIDefend <= this.AreaCount & this.game.Data.UnitObj[groupHq].AIFollowup <= this.AreaCount)
                  {
                    if (this.game.Data.UnitObj[groupHq].AIAttack > -1)
                    {
                      if (!this.AreaIsExtra[this.game.Data.UnitObj[groupHq].AIAttack])
                      {
                        if (this.GetRegime(this.AreaOwner[this.game.Data.UnitObj[groupHq].AIAttack]) == this.GetGameDataTurn())
                        {
                          if (this.CorpsStartLoc[index7] == this.game.Data.UnitObj[groupHq].AIAttack)
                          {
                            index8 = this.game.Data.UnitObj[groupHq].AIFollowup;
                            if (index8 > -1 && this.AreaIsExtra[index8])
                              index8 = -1;
                            if (index8 == -1)
                              index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                            index1 = this.GetRandomAreaNeighbour(index8, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          }
                          else
                          {
                            index8 = this.game.Data.UnitObj[groupHq].AIAttack;
                            index1 = this.game.Data.UnitObj[groupHq].AIFollowup;
                            if (index1 > -1 && this.AreaIsExtra[index1])
                              index1 = -1;
                            if (index1 == -1)
                              index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          }
                        }
                        else
                        {
                          index8 = this.game.Data.UnitObj[groupHq].AIAttack;
                          index1 = this.game.Data.UnitObj[groupHq].AIFollowup;
                          if (index1 > -1 && this.AreaIsExtra[index1])
                            index1 = -1;
                          if (index1 == -1)
                            index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        }
                      }
                    }
                    else if (this.game.Data.UnitObj[groupHq].AIDefend > -1 && !this.AreaIsExtra[this.game.Data.UnitObj[groupHq].AIDefend])
                    {
                      if (this.GetRegime(this.AreaOwner[this.game.Data.UnitObj[groupHq].AIDefend]) == this.GetGameDataTurn())
                      {
                        index8 = this.game.Data.UnitObj[groupHq].AIDefend;
                        index1 = this.game.Data.UnitObj[groupHq].AIDefend;
                      }
                      else if (3 == this.game.Data.UnitObj[groupHq].AIAttackStyle)
                      {
                        index8 = this.game.Data.UnitObj[groupHq].AIDefend;
                        index1 = this.game.Data.UnitObj[groupHq].AIAttack;
                        if (index1 > -1 && this.AreaIsExtra[index1])
                          index1 = -1;
                        if (index1 == -1)
                          index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      }
                      else
                      {
                        index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      }
                    }
                    if (index1 > 0)
                    {
                      index2 = this.GetRandomAreaNeighbour(index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      if (index2 > 0)
                      {
                        num8 = this.GetRandomAreaNeighbour(index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        if (num8 > 0)
                          tdata5 = this.GetRandomAreaNeighbour(num8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      }
                    }
                    tdata1 = this.game.Data.UnitObj[groupHq].AIAttackStyle;
                    if (tdata1 < 1)
                      tdata1 = 1;
                  }
                }
                else if (num10 == 0 & Number1 == 1 & this.AreaGroupRound > 1)
                {
                  if (alllog)
                    this.AddLog("from last areagroupround: " + this.GroupName[index7]);
                  int nr1 = simpleListArray[this.AreaGroupRound - 1].FindNr(index7);
                  if (nr1 > -1)
                  {
                    index8 = simpleListArray[this.AreaGroupRound - 1].Data1[nr1];
                    index1 = simpleListArray[this.AreaGroupRound - 1].Data2[nr1];
                    index2 = simpleListArray[this.AreaGroupRound - 1].Data3[nr1];
                    num8 = simpleListArray[this.AreaGroupRound - 1].Data4[nr1];
                    tdata5 = simpleListArray[this.AreaGroupRound - 1].Data5[nr1];
                  }
                  int nr2 = simpleListArray[this.AreaGroupRound - 1].FindNr(index7 + 99000);
                  if (nr2 > -1)
                    tdata1 = simpleListArray[this.AreaGroupRound - 1].Data1[nr2];
                  int nr3 = simpleListArray[this.AreaGroupRound - 1].FindNr(index7 + 199000);
                  if (nr3 > -1)
                    num9 = simpleListArray[this.AreaGroupRound - 1].Data1[nr3];
                }
                if (this.GroupType[index7] > 5)
                  tdata1 = 1;
                if (index8 > -1 & num7 != index8)
                {
                  if (this.AreaOwner[index8] == -1)
                    tdata1 = 3;
                  if (index8 > -1 && this.AreaOwner[index8] == this.game.Data.Turn & index8 != index1)
                  {
                    if (this.AreaOwner[index1] == -1)
                      tdata1 = 3;
                    if (this.AreaOwner[index1] == this.game.Data.Turn && index2 > -1 && this.AreaOwner[index2] == -1)
                      tdata1 = 3;
                  }
                }
                if (index8 == 0)
                  index8 = num7;
                if (index1 == 0)
                  index1 = index8;
                if (index2 == 0)
                  index2 = index1;
                if (num8 == 0)
                  num8 = index2;
                if (tdata5 == 0)
                  tdata5 = num8;
                this.TempGroupTarget[index7] = index8;
                int index11 = this.CorpsStartLoc[index7];
                if ((this.AreaSteps[index11, index8] == 0 | this.AreaSteps[index11, index8] > 99) & index11 != index8)
                {
                  if (alllog)
                    this.AddLog("error override. stay put: " + this.GroupName[index7]);
                  index8 = index11;
                  index1 = index11;
                  index2 = index11;
                  num8 = index11;
                  tdata5 = index11;
                  this.TempGroupTarget[index7] = index11;
                }
                if (index11 == index8)
                  tdata1 = 1;
                Straty.Add(index7, 1, index8, index1, index2, num8, tdata5, false);
                Straty.Add(index7 + 99000, 1, tdata1, CheckExistence: false);
              }
            }
            int groupCounter3 = this.GroupCounter;
            for (int forgroup = 0; forgroup <= groupCounter3; ++forgroup)
            {
              if (this.AreaGroup[this.CorpsStartLoc[forgroup]] == this.CurrentAreaGroup)
              {
                int highestFuzzyVpGroup = this.GetHighestFuzzyVPGroup(forgroup);
                Straty.Add(forgroup + 199000, 1, highestFuzzyVpGroup, CheckExistence: false);
              }
            }
            int strategyScore = this.GetStrategyScore(ref Straty, false, (float) Number1 / (float) num3);
            if (alllog)
              this.AddLog("SCORE ====> " + Conversion.Str((object) strategyScore));
            if (strategyScore != Number2)
            {
              this.HistoryMove[this.HistoryMoveCounter] = Straty;
              this.HistoryScoreList.Add(this.HistoryMoveCounter, strategyScore, CheckExistence: false);
            }
            ++this.HistoryMoveCounter;
            this.HistoryScoreList.Sort();
            index3 = (int) Math.Round((double) random.Next(0, 100) / 100.0 * 0.5 * (double) this.HistoryScoreList.Counter);
            int num14 = this.HistoryScoreList.Id[index3];
            if (this.HistoryScoreList.Counter > 450)
            {
              if (alllog)
                this.AddLog("REMOVING NR " + Conversion.Str((object) num14) + " with score " + Conversion.Str((object) this.HistoryScoreList.Weight[index3]));
              this.HistoryScoreList.Remove(num14);
            }
            if (strategyScore > Number2)
            {
              if (alllog)
                this.AddLog("NEW BEST SCORE = " + Conversion.Str((object) strategyScore));
              this.BestStrategy = Straty;
              Number2 = strategyScore;
            }
            else if (alllog)
              this.AddLog("OLD BEST SCORE = " + Conversion.Str((object) Number2));
            if (Number1 % 20 == 0)
              this.AddLog(Conversion.Str((object) Number1) + ") Bestscore=" + Conversion.Str((object) Number2) + ", CurrentScore = " + Conversion.Str((object) strategyScore));
          }
          if (!Information.IsNothing((object) this.BestStrategy))
          {
            int counter = this.BestStrategy.Counter;
            for (int index12 = 0; index12 <= counter; ++index12)
              simpleListArray[this.AreaGroupRound].Add(this.BestStrategy.Id[index12], this.BestStrategy.Weight[index12], this.BestStrategy.Data1[index12], this.BestStrategy.Data2[index12], this.BestStrategy.Data3[index12], this.BestStrategy.Data4[index12], this.BestStrategy.Data5[index12], false);
          }
          if (this.FullLog)
            this.WriteLog("10_FindBestStrategy_02_arearound" + this.AreaGroupRound.ToString() + "_" + this.CurrentAreaGroup.ToString());
          this.LogCounter = -1;
        }
      }
      if (num2 > 0)
      {
        this.AddLog("START SYSTEMATICAL CORTEX");
        this.CorpsStrategic = new bool[this.GroupCounter + 1];
        int bestCapHq = this.GetBestCapHQ(this.game.Data.Turn);
        int airCap;
        if (bestCapHq > -1)
          airCap = this.game.Data.UnitObj[bestCapHq].AirCap;
        bool[] flagArray = new bool[this.GroupCounter + 1];
        int num15 = num2;
        for (int Number4 = 1; Number4 <= num15; ++Number4)
        {
          int tid = -1;
          int Number5 = -1;
          int Number6 = 0;
          int num16 = 1;
          while (num16 == 1)
          {
            num16 = 0;
            SimpleList Straty = new SimpleList();
            int counter = this.BestStrategy.Counter;
            for (int index13 = 0; index13 <= counter; ++index13)
              Straty.Add(this.BestStrategy.Id[index13], this.BestStrategy.Weight[index13], this.BestStrategy.Data1[index13], this.BestStrategy.Data2[index13], this.BestStrategy.Data3[index13], this.BestStrategy.Data4[index13], this.BestStrategy.Data5[index13], false);
            if (tid == -1)
              ++tid;
            int nr4 = Straty.FindNr(tid);
            if (nr4 > -1)
            {
              if (Number4 == 1)
                Number6 = 1 + this.AreaSupplyBorderCount[this.CorpsStartLoc[tid]];
              if (Number4 == 2)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data1[nr4]];
              if (Number4 == 3)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data2[nr4]];
              if (Number4 == 4)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data3[nr4]];
              if (Number4 == 5)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data4[nr4]];
              if (Number5 >= Number6)
              {
                ++tid;
                if (tid <= this.GroupCounter)
                {
                  if (Number4 == 1)
                    Number6 = 1 + this.AreaSupplyBorderCount[this.CorpsStartLoc[tid]];
                  if (Number4 == 2)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data1[nr4]];
                  if (Number4 == 3)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data2[nr4]];
                  if (Number4 == 4)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data3[nr4]];
                  if (Number4 == 5)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data4[nr4]];
                }
                Number5 = -1;
              }
              if (tid <= this.GroupCounter & nr4 > -1)
              {
                int num17 = 0;
                if (this.TempGroupHQ[tid] > -1)
                {
                  int historical = this.game.Data.UnitObj[this.TempGroupHQ[tid]].Historical;
                  if (historical > -1 && this.game.Data.HistoricalUnitObj[historical].TempAttack > -1 | this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                    num17 = 1;
                }
                if (num17 == 0 & !(Number4 > 1 & this.CorpsStartLoc[tid] == Straty.Data1[nr4] | Number4 > 2 & Straty.Data2[nr4] == Straty.Data1[nr4]) && !(Number4 > 3 & Straty.Data2[tid] == Straty.Data3[nr4] | Number4 > 4 & Straty.Data3[nr4] == Straty.Data4[nr4]))
                {
                  ++Number5;
                  int num18;
                  if (Number5 > Number6 - 1 & nr4 > -1)
                  {
                    if (Number4 == 1)
                      bestCapHq = this.CorpsStartLoc[tid];
                    if (Number4 == 2)
                      index3 = Straty.Data1[nr4];
                    if (Number4 == 3)
                      index1 = Straty.Data2[nr4];
                    if (Number4 == 4)
                      index2 = Straty.Data3[nr4];
                    if (Number4 == 5)
                      num18 = Straty.Data4[nr4];
                    if (Number4 == 1)
                      tdata1 = 1;
                  }
                  else
                  {
                    if (Number4 == 1)
                      bestCapHq = this.AreaSupplyBorder[this.CorpsStartLoc[tid], Number5];
                    if (Number4 >= 2)
                      nr4 = Straty.FindNr(tid);
                    if (nr4 > -1)
                    {
                      if (Number4 == 2)
                        index3 = this.AreaSupplyBorder[Straty.Data1[nr4], Number5];
                      if (Number4 == 3)
                        index1 = this.AreaSupplyBorder[Straty.Data2[nr4], Number5];
                      if (Number4 == 4)
                        index2 = this.AreaSupplyBorder[Straty.Data2[nr4], Number5];
                      if (Number4 == 5)
                        num18 = this.AreaSupplyBorder[Straty.Data2[nr4], Number5];
                    }
                    if (Number4 == 1)
                      tdata1 = 3;
                  }
                  if (nr4 > -1)
                  {
                    if (Number4 == 1)
                    {
                      Straty.Data1[nr4] = bestCapHq;
                      Straty.Data2[nr4] = bestCapHq;
                      Straty.Data3[nr4] = bestCapHq;
                      Straty.Data4[nr4] = bestCapHq;
                      Straty.Data5[nr4] = bestCapHq;
                    }
                    else if (Number4 == 2)
                    {
                      Straty.Data2[nr4] = index3;
                      Straty.Data3[nr4] = index3;
                      Straty.Data4[nr4] = index3;
                      Straty.Data5[nr4] = index3;
                    }
                    else if (Number4 == 3)
                    {
                      Straty.Data3[nr4] = index1;
                      Straty.Data4[nr4] = index1;
                      Straty.Data5[nr4] = index1;
                    }
                    else if (Number4 == 4)
                    {
                      Straty.Data4[nr4] = index2;
                      Straty.Data5[nr4] = index2;
                    }
                    else if (Number4 == 5)
                      Straty.Data5[nr4] = num18;
                    if (Number4 == 1)
                    {
                      int nr5 = Straty.FindNr(tid + 99000);
                      if (nr5 > -1)
                        Straty.Data1[nr5] = tdata1;
                    }
                    this.CurrentAreaGroup = 1;
                    this.CorpsStrategic = new bool[this.GroupCounter + 1];
                    int num19 = (int) Math.Round((double) airCap / 50.0);
                    if ((double) VBMath.Rnd() < 0.5)
                    {
                      int groupCounter = this.GroupCounter;
                      for (int index14 = 0; index14 <= groupCounter; ++index14)
                        this.CorpsStrategic[index14] = flagArray[index14];
                      num19 = -1;
                    }
                    int num20 = 0;
                    int num21 = (int) Math.Round((double) (VBMath.Rnd() * 99f));
                    if ((double) VBMath.Rnd() < 0.5)
                    {
                      while (num20 < num21)
                      {
                        ++num20;
                        int index15 = (int) Math.Round((double) Conversion.Int(VBMath.Rnd() * (float) (this.GroupCounter + 1)));
                        if (this.corpsstartStrength[index15] < num19 & this.GroupType[index15] <= 5)
                        {
                          this.CorpsStrategic[index15] = true;
                          num19 -= this.corpsstartStrength[index15];
                        }
                      }
                    }
                    int strategyScore = this.GetStrategyScore(ref Straty, false, (float) Number1 / (float) num3);
                    if (strategyScore > Number2)
                    {
                      this.AddLog("GROUP " + this.GroupName[tid] + " MOVE = " + Conversion.Str((object) Number5) + "/" + Conversion.Str((object) Number6));
                      this.AddLog(Conversion.Str((object) Number1) + ") New Bestscore=" + Conversion.Str((object) Number2) + ", CurrentScore = " + Conversion.Str((object) strategyScore));
                      this.BestStrategy = Straty;
                      Number2 = strategyScore;
                      int groupCounter = this.GroupCounter;
                      for (int index16 = 0; index16 <= groupCounter; ++index16)
                      {
                        if (this.CorpsStrategic[index16])
                          this.AddLog("GROUP " + this.GroupName[index16] + " is STRATEGIC");
                        flagArray[index16] = this.CorpsStrategic[index16];
                      }
                    }
                    if (Number5 == 0 & tid % 5 == 0)
                    {
                      this.game.EditObj.AIProgressMax = this.GroupCounter;
                      this.game.EditObj.AIProgressNow = tid;
                      this.game.EditObj.TempAIString = this.AreaGroupCount <= 1 ? "Systematical finetuning. Round " + Conversion.Str((object) Number4) : "Systematical finetuning. Round " + Conversion.Str((object) Number4);
                    }
                    num16 = 1;
                  }
                }
              }
            }
          }
        }
        int groupCounter4 = this.GroupCounter;
        for (int index17 = 0; index17 <= groupCounter4; ++index17)
          this.CorpsStrategic[index17] = flagArray[index17];
        simpleListArray[this.AreaGroupRound] = new SimpleList();
        int counter1 = this.BestStrategy.Counter;
        for (int index18 = 0; index18 <= counter1; ++index18)
          simpleListArray[this.AreaGroupRound].Add(this.BestStrategy.Id[index18], this.BestStrategy.Weight[index18], this.BestStrategy.Data1[index18], this.BestStrategy.Data2[index18], this.BestStrategy.Data3[index18], this.BestStrategy.Data4[index18], this.BestStrategy.Data5[index18], false);
        if (this.FullLog)
          this.WriteLog("10_FindBestStrategy_03_systematical_cortex");
        this.LogCounter = -1;
      }
      this.BestStrategy = new SimpleList();
      if (!Information.IsNothing((object) simpleListArray[this.AreaGroupRound]))
      {
        int counter = simpleListArray[this.AreaGroupRound].Counter;
        for (int index19 = 0; index19 <= counter; ++index19)
          this.BestStrategy.Add(simpleListArray[this.AreaGroupRound].Id[index19], simpleListArray[this.AreaGroupRound].Weight[index19], simpleListArray[this.AreaGroupRound].Data1[index19], simpleListArray[this.AreaGroupRound].Data2[index19], simpleListArray[this.AreaGroupRound].Data3[index19], simpleListArray[this.AreaGroupRound].Data4[index19], simpleListArray[this.AreaGroupRound].Data5[index19], false);
      }
      this.CurrentAreaGroup = 1;
    }

    public void SetFindBestStrategyStuff(bool tlog)
    {
      int[] numArray = new int[this.AreaCount + 1];
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("SET FIND BEST STRATEGY STUFF");
      }
      this.Meeting = false;
      this.Attacker = this.GetRegime(this.GetLargestArmy()) == this.GetGameDataTurn();
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 1)
        this.Attacker = true;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 2)
        this.Attacker = false;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 3)
      {
        this.Attacker = true;
        this.Meeting = true;
      }
      if (tlog)
        this.AddLog("Attacker = " + this.Attacker.ToString() + ", Meeting = " + this.Meeting.ToString());
      this.AreaOwner = new int[this.AreaCount + 1];
      int areaCount1 = this.AreaCount;
      for (int index = 1; index <= areaCount1; ++index)
        this.AreaOwner[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime;
      this.CorpsStrategic = new bool[this.GroupCounter + 1];
      this.CorpsPowerLeft = new int[this.GroupCounter + 1];
      this.GetStrategyScore_Prepare_TroopsPlace();
      this.AreaGroup = new int[this.AreaCount + 1];
      int areaCount2 = this.AreaCount;
      for (int index = 0; index <= areaCount2; ++index)
        this.AreaGroup[index] = 1;
      this.TempTotVP = this.GetTotalVPonMap();
      this.TempCurVP = this.GetStartVPonMap();
      if (tlog)
        this.AddLog("TempTotalVP = " + this.TempTotVP.ToString() + " , TempStartVP= " + this.TempCurVP.ToString());
      this.TempPowerAbove = new SimpleList();
      int mapWidth = this.game.Data.MapObj[0].MapWidth;
      for (int index1 = 0; index1 <= mapWidth; ++index1)
      {
        int mapHeight = this.game.Data.MapObj[0].MapHeight;
        for (int index2 = 0; index2 <= mapHeight; ++index2)
        {
          if (this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerAbove > 0)
          {
            int tid = this.AreaMatrixNarrow[index1, index2];
            if (tid > 0 && numArray[tid] == 0)
            {
              numArray[tid] = 1;
              this.TempPowerAbove.Add(tid, 1, this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerAbove, this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerMulti);
            }
          }
        }
      }
    }

    public void SetInitialAreaGroups(bool tlog)
    {
      this.AreaGroup = new int[this.AreaCount + 1];
      int[] numArray1 = new int[this.AreaCount + 1];
      this.AreaGroupRound = 0;
      this.CurrentAreaGroup = 0;
      this.AreaGroupCount = 0;
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("INITIAL AREAGROUPS SETTING : ");
      }
      if ((double) this.game.Data.RuleVar[267] > 0.0)
      {
        if (tlog)
          this.AddLog("Predefined areagroups are used (rulevar 267)");
        int areaCount = this.AreaCount;
        for (int index = 1; index <= areaCount; ++index)
        {
          if (this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[(int) Math.Round((double) this.game.Data.RuleVar[267])] > 0)
          {
            if (this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[(int) Math.Round((double) this.game.Data.RuleVar[267])] > this.AreaGroupCount)
              this.AreaGroupCount = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[(int) Math.Round((double) this.game.Data.RuleVar[267])];
            this.AreaGroup[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[(int) Math.Round((double) this.game.Data.RuleVar[267])];
          }
          else
            this.AreaGroup[index] = 0;
        }
      }
      if ((double) this.game.Data.RuleVar[267] < 1.0)
      {
        if (tlog)
          this.AddLog("Dynamic areagroups are used. Created on the fly.");
        int num1 = 1;
        int num2 = 4;
        int num3 = 0;
        while (num1 == 1)
        {
          num1 = 0;
          SimpleList simpleList = new SimpleList();
          int areaCount1 = this.AreaCount;
          for (int index1 = 1; index1 <= areaCount1; ++index1)
          {
            if (this.GetRegime(this.AreaOwner[index1]) == this.GetGameDataTurn() & this.AreaGroup[index1] == 0)
            {
              int areaCount2 = this.AreaCount;
              for (int index2 = 1; index2 <= areaCount2; ++index2)
              {
                if (this.GetAreaNarrowBorderSteps(index1, index2, 1) == 1 && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.AreaOwner[index2]) & this.AreaGroup[index2] == 0)
                {
                  simpleList.Add(index1, 0);
                  simpleList.Add(index2, 0);
                  num1 = 1;
                  ++num3;
                  this.AreaGroupCount = num3;
                  this.AreaGroup[index1] = num3;
                  this.AreaGroup[index2] = num3;
                  break;
                }
              }
              if (num1 == 1)
              {
                int num4 = 1;
                int maxstep = 1;
                while (num4 == 1)
                {
                  num4 = 0;
                  ++maxstep;
                  if (maxstep <= num2)
                  {
                    int areaCount3 = this.AreaCount;
                    for (int index3 = 1; index3 <= areaCount3; ++index3)
                    {
                      if (this.AreaGroup[index3] == 0 && simpleList.FindNr(index3) == -1 && this.GetAreaNarrowBorderSteps(index1, index3, maxstep) <= maxstep)
                      {
                        int num5 = 1;
                        int counter = simpleList.Counter;
                        for (int index4 = 0; index4 <= counter; ++index4)
                        {
                          if (this.GetAreaNarrowBorderSteps(index3, simpleList.Id[index4], maxstep) > maxstep)
                            num5 = 0;
                        }
                        if (num5 == 1)
                        {
                          num4 = 1;
                          simpleList.Add(index3, 0);
                          this.AreaGroup[index3] = num3;
                        }
                      }
                    }
                  }
                }
                break;
              }
            }
          }
        }
        if (this.AreaGroupCount == 0)
        {
          int areaCount = this.AreaCount;
          for (int index = 1; index <= areaCount; ++index)
          {
            this.AreaGroup[index] = 1;
            this.AreaGroupCount = 1;
          }
        }
        int[] numArray2 = new int[this.AreaCount + 1];
        int areaCount4 = this.AreaCount;
        for (int from = 1; from <= areaCount4; ++from)
        {
          if (this.GetRegime(this.AreaOwner[from]) != this.GetGameDataTurn() && this.AreaGroup[from] == 0)
          {
            SimpleList simpleList = new SimpleList();
            int areaCount5 = this.AreaCount;
            for (int index = 1; index <= areaCount5; ++index)
            {
              if (this.AreaGroup[index] > 0 & numArray2[index] == 0 && this.GetAreaNarrowBorderSteps(from, index, 3) <= 3)
                simpleList.Add(index, this.GetAreaNarrowBorderSteps(from, index, 3));
            }
            simpleList.Sort();
            if (simpleList.Counter > -1)
            {
              this.AreaGroup[from] = this.AreaGroup[simpleList.Id[0]];
              numArray2[from] = 1;
            }
          }
        }
        int[] numArray3 = new int[this.AreaCount + 1];
        int areaCount6 = this.AreaCount;
        for (int index = 1; index <= areaCount6; ++index)
        {
          if (this.AreaGroup[index] == 0)
          {
            SimpleList simpleList = new SimpleList();
            int areaCount7 = this.AreaCount;
            for (int tid = 1; tid <= areaCount7; ++tid)
            {
              if (this.AreaGroup[tid] > 0 & numArray3[tid] == 0)
                simpleList.Add(tid, this.AreaSteps[index, tid]);
            }
            simpleList.Sort();
            if (simpleList.Counter > -1)
            {
              this.AreaGroup[index] = this.AreaGroup[simpleList.Id[0]];
              numArray3[index] = 1;
            }
          }
        }
      }
      if (!tlog)
        return;
      int areaGroupCount = this.AreaGroupCount;
      for (int Number = 0; Number <= areaGroupCount; ++Number)
      {
        this.AddLog("");
        this.AddLog("AREAGROUP " + Conversion.Str((object) Number));
        int areaCount = this.AreaCount;
        for (int nr = 1; nr <= areaCount; ++nr)
        {
          if (this.AreaGroup[nr] == Number)
            this.AddLog("-" + this.GetAreaName(nr));
        }
      }
    }

    public void MergeAreaGroups()
    {
      int num1 = 0;
      while (num1 < this.AreaGroupCount)
      {
        ++num1;
        SimpleList simpleList = new SimpleList();
        int areaGroupCount = this.AreaGroupCount;
        for (int tid = 1; tid <= areaGroupCount; ++tid)
        {
          if (num1 != tid)
          {
            int areaCount1 = this.AreaCount;
            for (int index1 = 1; index1 <= areaCount1; ++index1)
            {
              if (this.AreaGroup[index1] == num1)
              {
                int areaCount2 = this.AreaCount;
                for (int index2 = 1; index2 <= areaCount2; ++index2)
                {
                  if (this.AreaGroup[index2] == tid)
                  {
                    if (this.AreaNarrowBorder[index1, index2] > 0)
                    {
                      int nr = simpleList.FindNr(tid);
                      int tweight = 100;
                      if (tid < num1)
                        tweight = 10;
                      if (nr == -1)
                      {
                        simpleList.Add(tid, tweight);
                      }
                      else
                      {
                        int[] weight = simpleList.Weight;
                        int[] numArray = weight;
                        int index3 = nr;
                        int index4 = index3;
                        int num2 = weight[index3] + tweight;
                        numArray[index4] = num2;
                      }
                    }
                    if (this.AreaBroadBorder[index1, index2] > 0)
                    {
                      int nr = simpleList.FindNr(tid);
                      int tweight = 20;
                      if (tid < num1)
                        tweight = 2;
                      if (nr == -1)
                      {
                        simpleList.Add(tid, tweight);
                      }
                      else
                      {
                        int[] weight = simpleList.Weight;
                        int[] numArray = weight;
                        int index5 = nr;
                        int index6 = index5;
                        int num3 = weight[index5] + tweight;
                        numArray[index6] = num3;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (simpleList.Counter > -1)
        {
          simpleList.Sort();
          int num4 = simpleList.Id[simpleList.Counter];
          int num5 = num1;
          if (num5 > this.AreaGroupCount - 1)
            num5 = this.AreaGroupCount - 1;
          int areaCount3 = this.AreaCount;
          for (int index7 = 1; index7 <= areaCount3; ++index7)
          {
            if (this.AreaGroup[index7] == num4)
              this.AreaGroup[index7] = num5;
            if (this.AreaGroup[index7] > num1)
            {
              int[] areaGroup = this.AreaGroup;
              int[] numArray = areaGroup;
              int index8 = index7;
              int index9 = index8;
              int num6 = areaGroup[index8] - 1;
              numArray[index9] = num6;
            }
          }
          --this.AreaGroupCount;
          if (this.AreaGroupCount <= 1)
          {
            int areaCount4 = this.AreaCount;
            for (int index = 1; index <= areaCount4; ++index)
              this.AreaGroup[index] = 1;
          }
        }
        else
        {
          this.AreaGroupCount = 1;
          int areaCount = this.AreaCount;
          for (int index = 1; index <= areaCount; ++index)
            this.AreaGroup[index] = 1;
        }
      }
      this.AddLog("AFTER MERGE - AREAGROUPS INFO : ");
      int areaGroupCount1 = this.AreaGroupCount;
      for (int Number = 0; Number <= areaGroupCount1; ++Number)
      {
        this.AddLog("AREAGROUP " + Conversion.Str((object) Number));
        int areaCount = this.AreaCount;
        for (int nr = 1; nr <= areaCount; ++nr)
        {
          if (this.AreaGroup[nr] == Number)
            this.AddLog("-" + this.GetAreaName(nr));
        }
      }
      this.WriteLog();
    }

    public void SetAreaExtraVP(bool tlog)
    {
      this.AreaExtraVP = new int[this.AreaCount + 1];
      SimpleList[] simpleListArray = new SimpleList[this.AreaCount + 1];
      int[] numArray1 = new int[this.AreaCount + 1];
      bool[] flagArray1 = new bool[this.AreaCount + 1];
      bool[] flagArray2 = new bool[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      this.OldExtraVP = (int[]) Utils.CopyArray((Array) this.OldExtraVP, (Array) new int[this.AreaCount + 1]);
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("SET AREA EXTRA VP");
        this.AddLog("");
      }
      if (!this.Attacker)
      {
        int areaCount = this.AreaCount;
        for (int index = 1; index <= areaCount; ++index)
        {
          this.AreaExtraVP[index] = 0;
          simpleListArray[index] = new SimpleList();
        }
      }
      else
      {
        if (this.AreaGroupRound > 1)
        {
          int areaCount = this.AreaCount;
          for (int index = 1; index <= areaCount; ++index)
          {
            simpleListArray[index] = new SimpleList();
            this.AreaExtraVP[index] = this.AreaGroup[index] != this.CurrentAreaGroup ? 0 : (int) Math.Round((double) this.OldExtraVP[index] / 3.0);
          }
        }
        else
        {
          int areaCount = this.AreaCount;
          for (int index = 1; index <= areaCount; ++index)
          {
            this.AreaExtraVP[index] = 0;
            simpleListArray[index] = new SimpleList();
          }
        }
        int areaCount1 = this.AreaCount;
        for (int index1 = 1; index1 <= areaCount1; ++index1)
        {
          int num1 = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index1].x, this.AreaCenter[index1].y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index1].x, this.AreaCenter[index1].y];
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index1].x, this.AreaCenter[index1].y].Regime) && this.AreaGroup[index1] != this.CurrentAreaGroup & num1 > 0)
          {
            int[] numArray3 = new int[this.AreaCount + 1];
            bool[] flagArray3 = new bool[this.AreaCount + 1];
            bool[] flagArray4 = new bool[this.AreaCount + 1];
            int num2 = 1;
            int num3 = 0;
            numArray3[index1] = num1;
            flagArray3[index1] = true;
            flagArray4[index1] = true;
            while (num2 == 1 & num3 == 0)
            {
              num2 = 0;
              int areaCount2 = this.AreaCount;
              for (int index2 = 1; index2 <= areaCount2; ++index2)
              {
                if (flagArray3[index2])
                {
                  int num4 = 0;
                  int areaCount3 = this.AreaCount;
                  for (int index3 = 1; index3 <= areaCount3; ++index3)
                  {
                    if (this.AreaGroup[index3] == this.CurrentAreaGroup && this.AreaNarrowBorder[index2, index3] > 0)
                      ++num4;
                  }
                  if (num4 > 0)
                  {
                    int num5 = Math.Max((int) Math.Round(Conversion.Int((double) num1 / (double) num4)), 1);
                    int areaCount4 = this.AreaCount;
                    for (int index4 = 1; index4 <= areaCount4; ++index4)
                    {
                      if (this.AreaGroup[index4] == this.CurrentAreaGroup && this.AreaNarrowBorder[index2, index4] > 0 && num5 > this.AreaExtraVP[index4])
                      {
                        this.AreaExtraVP[index4] = num5;
                        numArray2[index4] = index1;
                      }
                    }
                    num3 = 1;
                    break;
                  }
                  int areaCount5 = this.AreaCount;
                  for (int index5 = 1; index5 <= areaCount5; ++index5)
                  {
                    if (!flagArray4[index5] & !flagArray3[index5] && this.AreaNarrowBorder[index2, index5] > 0)
                    {
                      if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime) == this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index5].x, this.AreaCenter[index5].y].Regime))
                      {
                        flagArray3[index5] = true;
                        num2 = 1;
                      }
                      else
                        index5 = index5;
                    }
                  }
                  flagArray3[index2] = false;
                  flagArray4[index2] = true;
                }
              }
            }
          }
        }
        if (!tlog)
          return;
        int areaCount6 = this.AreaCount;
        for (int nr = 1; nr <= areaCount6; ++nr)
        {
          if (this.AreaExtraVP[nr] > this.OldExtraVP[nr])
            this.OldExtraVP[nr] = this.AreaExtraVP[nr];
          this.AddLog(this.GetAreaName(nr) + " => ExtraVP= " + this.AreaExtraVP[nr].ToString() + ", OldExtraVP = " + this.OldExtraVP[nr].ToString());
        }
      }
    }

    public void ImplementBestStrategy(bool tlog)
    {
      this.CorpsSource = new int[this.GroupCounter + 1];
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("IMPLEMENT BEST STRATEGY");
        this.AddLog("");
      }
      int groupCounter1 = this.GroupCounter;
      for (int index1 = 0; index1 <= groupCounter1; ++index1)
      {
        this.TempGroupHQ[index1] = this.GetGroupHQ(index1);
        if (this.TempGroupHQ[index1] > -1)
        {
          if (tlog)
          {
            this.AddLog("");
            if (tlog)
              this.AddLog(this.GroupName[index1] + ":");
          }
          int nr1 = this.BestStrategy.FindNr(index1);
          if (nr1 > -1)
          {
            int unitCounter1 = this.game.Data.UnitCounter;
            for (int index2 = 0; index2 <= unitCounter1; ++index2)
            {
              if (this.game.Data.UnitObj[index2].PreDef == -1 && this.game.Data.UnitObj[index2].X > -1 & this.game.Data.UnitObj[index2].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index2].Regime) == this.GetGameDataTurn())
              {
                this.game.Data.UnitObj[index2].AIDefend = -1;
                this.game.Data.UnitObj[index2].AIAttack = -1;
                this.game.Data.UnitObj[index2].AIFollowup = -1;
                this.game.Data.UnitObj[index2].AIFallback = -1;
                this.game.Data.UnitObj[index2].AIRightFlank = -1;
                this.game.Data.UnitObj[index2].AILeftFlank = -1;
              }
            }
            int groupHq1 = this.GetGroupHQ(index1);
            Coordinate coordinate;
            int num1;
            if (groupHq1 > -1)
            {
              int nr2 = -1;
              coordinate.onmap = true;
              coordinate.x = this.game.Data.UnitObj[groupHq1].X;
              coordinate.y = this.game.Data.UnitObj[groupHq1].Y;
              int startArea = this.GetStartArea(index1);
              this.CorpsStartLoc[index1] = startArea;
              if (startArea > 0 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[startArea].x, this.AreaCenter[startArea].y].Regime), this.GetGameDataTurn()))
              {
                nr2 = startArea;
                if (tlog)
                  this.AddLog("CorpsStartLoc is friendly = " + this.GetAreaName(nr2));
              }
              if (nr2 == -1)
              {
                coordinate.onmap = true;
                int groupHq2 = this.GetGroupHQ(index1);
                coordinate.x = this.game.Data.UnitObj[groupHq2].X;
                coordinate.y = this.game.Data.UnitObj[groupHq2].Y;
                for (; nr2 == -1 & coordinate.onmap; coordinate = this.SupplyMatrixPrognosisCameFrom[coordinate.x, coordinate.y])
                {
                  int index3 = this.AreaMatrixWide[coordinate.x, coordinate.y];
                  if (index3 > 0 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime), this.GetGameDataTurn()))
                  {
                    nr2 = index3;
                    if (tlog)
                      this.AddLog("First Friendly Area we can trace SupplyMatrixPrognosisCameFrom came from: " + this.GetAreaName(nr2));
                  }
                }
              }
              if (nr2 == -1)
              {
                int num2 = this.AreaMatrixWide[coordinate.x, coordinate.y];
                if (num2 > 0)
                {
                  nr2 = num2;
                  if (tlog)
                    this.AddLog("Just set to current AreaMatrixWide = " + this.GetAreaName(nr2));
                }
              }
              if (nr2 > -1)
              {
                int x = coordinate.x;
                int y = coordinate.y;
                int unitCounter2 = this.game.Data.UnitCounter;
                for (int index4 = 0; index4 <= unitCounter2; ++index4)
                {
                  if (this.game.Data.UnitObj[index4].X > -1 & this.game.Data.UnitObj[index4].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index4].Regime) == this.GetGameDataTurn())
                    this.game.Data.UnitObj[index4].AIDefend = nr2;
                }
                num1 = -1;
              }
              else if (tlog)
                this.AddLog("Defend has not been set.");
            }
            int num3 = 0;
            int groupHq3 = this.GetGroupHQ(index1);
            int num4 = 5;
            if (this.game.Data.UnitObj[groupHq3].AIAttackStyle == 2)
              ;
            if (this.game.Data.UnitObj[groupHq3].AIAttackStyle == 1)
              num4 = 3;
            int num5 = num4;
            for (int index5 = 1; index5 <= num5; ++index5)
            {
              if (tlog)
                this.AddLog("For-Next Step " + index5.ToString() + "/" + num4.ToString());
              int nr3 = -1;
              int nr4 = -1;
              int nr5 = -1;
              if (index5 == 1)
              {
                nr3 = this.BestStrategy.Data1[nr1];
                nr4 = this.BestStrategy.Data2[nr1];
                nr5 = this.CorpsStartLoc[index1];
              }
              if (index5 == 1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data1[nr1])
                num4 = 6;
              if (index5 == 2)
              {
                nr3 = this.BestStrategy.Data2[nr1];
                nr4 = this.BestStrategy.Data3[nr1];
                nr5 = this.BestStrategy.Data1[nr1];
              }
              if (index5 == 2 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data2[nr1])
                num4 = 6;
              if (index5 == 3)
              {
                nr3 = this.BestStrategy.Data3[nr1];
                nr4 = this.BestStrategy.Data4[nr1];
                nr5 = this.BestStrategy.Data2[nr1];
              }
              if (index5 == 3 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data3[nr1])
                num4 = 6;
              if (index5 == 4)
              {
                nr3 = this.BestStrategy.Data4[nr1];
                nr4 = this.BestStrategy.Data5[nr1];
                nr5 = this.BestStrategy.Data3[nr1];
              }
              if (index5 == 4 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data4[nr1])
                num4 = 6;
              if (index5 == 5)
              {
                nr3 = this.BestStrategy.Data5[nr1];
                nr4 = -1;
                nr5 = this.BestStrategy.Data4[nr1];
              }
              if (index5 == 1 & nr3 == this.CorpsStartLoc[index1])
              {
                int unitCounter3 = this.game.Data.UnitCounter;
                for (int index6 = 0; index6 <= unitCounter3; ++index6)
                {
                  if (this.game.Data.UnitObj[index6].PreDef == -1 && this.game.Data.UnitObj[index6].X > -1 & this.game.Data.UnitObj[index6].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index6].AIAttack = -1;
                    this.game.Data.UnitObj[index6].AIFollowup = -1;
                  }
                }
                num3 = 1;
                if (tlog)
                  this.AddLog("FIRST Target Area == CorpsStartLoc => Pure defensive. No Attack or Followup.");
                if (tlog)
                {
                  this.AddLog("Exit For");
                  break;
                }
                break;
              }
              if (nr3 == nr4 & this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr3].x, this.AreaCenter[nr3].y].Regime), this.GetGameDataTurn()))
              {
                int unitCounter4 = this.game.Data.UnitCounter;
                for (int index7 = 0; index7 <= unitCounter4; ++index7)
                {
                  if (this.game.Data.UnitObj[index7].PreDef == -1 && this.game.Data.UnitObj[index7].X > -1 & this.game.Data.UnitObj[index7].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index7].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index7].AIDefend = nr3;
                    this.game.Data.UnitObj[index7].AIAttack = -1;
                    this.game.Data.UnitObj[index7].AIFollowup = -1;
                  }
                }
                if (tlog)
                  this.AddLog("Current step Target == Next step Target & FRIENDLY AREA => defensive on this target.");
                if (tlog)
                  this.AddLog("Exit For");
                num3 = 1;
                break;
              }
              if (nr3 > 0 && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr3].x, this.AreaCenter[nr3].y].Regime), this.GetGameDataTurn()))
              {
                int unitCounter5 = this.game.Data.UnitCounter;
                for (int index8 = 0; index8 <= unitCounter5; ++index8)
                {
                  if (this.game.Data.UnitObj[index8].PreDef == -1 && this.game.Data.UnitObj[index8].X > -1 & this.game.Data.UnitObj[index8].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index8].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index8].AIFollowup = -1;
                    if (tlog)
                      this.AddLog("A target area thats enemy");
                    if (nr4 > -1 && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr3].x, this.AreaCenter[nr3].y].Regime), this.GetGameDataTurn()))
                    {
                      this.game.Data.UnitObj[index8].AIFollowup = nr4;
                      if (tlog)
                        this.AddLog("Set follow up to next target = " + this.GetAreaName(nr4));
                    }
                    this.game.Data.UnitObj[index8].AIAttack = nr3;
                    this.game.Data.UnitObj[index8].AIDefend = nr5;
                    if (tlog)
                      this.AddLog("Set attack to current target = " + this.GetAreaName(nr3));
                    if (tlog)
                      this.AddLog("Set defend to corps location = " + this.GetAreaName(nr5));
                  }
                }
                num3 = 1;
                if (tlog)
                {
                  this.AddLog("Exit För");
                  break;
                }
                break;
              }
            }
            if (num3 == 0)
            {
              if (tlog)
                this.AddLog("Not found yet... but must be only friendly targets in list");
              int nr6 = this.BestStrategy.Data5[nr1];
              if (tlog)
                this.AddLog("Move Target step 5: " + this.GetAreaName(nr6));
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data4[nr1])
              {
                nr6 = this.BestStrategy.Data4[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data4[nr1];
                if (tlog)
                  this.AddLog("Move Target step 4: " + this.GetAreaName(nr6));
              }
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data3[nr1])
              {
                nr6 = this.BestStrategy.Data3[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data3[nr1];
                if (tlog)
                  this.AddLog("Move Target step 3: " + this.GetAreaName(nr6));
              }
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data2[nr1])
              {
                nr6 = this.BestStrategy.Data2[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data2[nr1];
                if (tlog)
                  this.AddLog("Move Target step 2: " + this.GetAreaName(nr6));
              }
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data1[nr1])
              {
                nr6 = this.BestStrategy.Data1[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data1[nr1];
                if (tlog)
                  this.AddLog("Move Target step 1: " + this.GetAreaName(nr6));
              }
              if (nr6 > 0)
              {
                int unitCounter6 = this.game.Data.UnitCounter;
                for (int index9 = 0; index9 <= unitCounter6; ++index9)
                {
                  if (this.game.Data.UnitObj[index9].PreDef == -1 && this.game.Data.UnitObj[index9].X > -1 & this.game.Data.UnitObj[index9].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index9].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index9].AIFallback = -1;
                    this.game.Data.UnitObj[index9].AIDefend = nr6;
                    this.game.Data.UnitObj[index9].AIAttack = -1;
                    if (tlog)
                      this.AddLog("attack=-1 and defend has been set to: " + this.GetAreaName(nr6));
                    num1 = 1;
                  }
                }
              }
            }
            int unitCounter7 = this.game.Data.UnitCounter;
            for (int index10 = 0; index10 <= unitCounter7; ++index10)
            {
              if (this.game.Data.UnitObj[index10].PreDef == -1 && this.game.Data.UnitObj[index10].X > -1 & this.game.Data.UnitObj[index10].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index10].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index10].AIAttack > -1 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[index10].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index10].AIAttack].y].Regime), this.GetGameDataTurn()))
              {
                if (tlog)
                  this.AddLog("Error found. Attacking friendly. Attack set to -1, Defend to " + this.GetAreaName(this.game.Data.UnitObj[index10].AIAttack));
                this.game.Data.UnitObj[index10].AIDefend = this.game.Data.UnitObj[index10].AIAttack;
                this.game.Data.UnitObj[index10].AIAttack = -1;
                this.game.Data.UnitObj[index10].AIFollowup = -1;
              }
            }
            if (tlog)
              this.AddLog("finding fallback...");
            if (Operators.CompareString(this.GroupName[index1], "6th Army", false) == 0)
              index1 = index1;
            int groupHq4 = this.GetGroupHQ(index1);
            if (groupHq4 > -1 && this.game.Data.UnitObj[groupHq4].AIDefend > -1)
            {
              coordinate.onmap = true;
              coordinate.x = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].x;
              coordinate.y = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].y;
              int nr7 = -1;
              int aiDefend = this.game.Data.UnitObj[groupHq4].AIDefend;
              for (; nr7 == -1 & coordinate.onmap; coordinate = this.SupplyMatrixRealCameFrom[coordinate.x, coordinate.y])
              {
                int index11 = this.AreaMatrixNarrow[coordinate.x, coordinate.y];
                if (index11 > 0 & aiDefend != index11 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index11].x, this.AreaCenter[index11].y].Regime), this.GetGameDataTurn()))
                {
                  nr7 = index11;
                  if (tlog)
                    this.AddLog("tracing back over friendly hexes through supplymatrixrealcamefrom we found fallback region = " + this.GetAreaName(nr7));
                }
              }
              if (nr7 == -1)
              {
                coordinate.onmap = true;
                coordinate.x = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].x;
                coordinate.y = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].y;
                for (nr7 = -1; nr7 == -1 & coordinate.onmap; coordinate = this.SupplyMatrixPrognosisCameFrom[coordinate.x, coordinate.y])
                {
                  int index12 = this.AreaMatrixWide[coordinate.x, coordinate.y];
                  if (index12 > 0 & aiDefend != index12 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index12].x, this.AreaCenter[index12].y].Regime), this.GetGameDataTurn()))
                  {
                    nr7 = index12;
                    if (tlog)
                      this.AddLog("tracing back over ENEMY hexes through supplymatrixprognosiscamefrom we found fallback region = " + this.GetAreaName(nr7));
                  }
                }
              }
              if (nr7 > -1)
              {
                int unitCounter8 = this.game.Data.UnitCounter;
                for (int index13 = 0; index13 <= unitCounter8; ++index13)
                {
                  if (this.game.Data.UnitObj[index13].PreDef == -1 && this.game.Data.UnitObj[index13].X > -1 & this.game.Data.UnitObj[index13].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index13].Regime) == this.GetGameDataTurn())
                    this.game.Data.UnitObj[index13].AIFallback = nr7;
                }
              }
            }
          }
          int unitCounter9 = this.game.Data.UnitCounter;
          for (int index14 = 0; index14 <= unitCounter9; ++index14)
          {
            if (this.game.Data.UnitObj[index14].PreDef == -1 && this.game.Data.UnitObj[index14].X > -1 & this.game.Data.UnitObj[index14].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index14].Regime) == this.GetGameDataTurn())
              this.game.Data.UnitObj[index14].AIAttackStyle = 2;
          }
          int nr8 = this.BestStrategy.FindNr(index1 + 99000);
          if (nr8 > -1)
          {
            int unitCounter10 = this.game.Data.UnitCounter;
            for (int index15 = 0; index15 <= unitCounter10; ++index15)
            {
              if (this.game.Data.UnitObj[index15].PreDef == -1 && this.game.Data.UnitObj[index15].X > -1 & this.game.Data.UnitObj[index15].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index15].Regime) == this.GetGameDataTurn())
              {
                this.game.Data.UnitObj[index15].AIAttackStyle = this.BestStrategy.Data1[nr8];
                if (tlog)
                  this.AddLog("Attack Style = " + this.game.Data.UnitObj[index15].AIAttackStyle.ToString());
              }
            }
          }
        }
      }
      int unitCounter11 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter11; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[index].AIAttack > -1)
          {
            int aiAttack = this.game.Data.UnitObj[index].AIAttack;
            if (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[aiAttack].x, this.AreaCenter[aiAttack].y].Regime), this.GetGameDataTurn()) && this.game.Data.UnitObj[index].AIAttackStyle == 1)
            {
              if (tlog)
                this.AddLog("Switched attack style from defensive to offensive because the group is ordered to attack enemy hex instead of hold own.");
              this.game.Data.UnitObj[index].AIAttackStyle = 3;
            }
          }
          else
          {
            if (tlog)
              this.AddLog("No Attack target specified so style is overriden with defensive.");
            this.game.Data.UnitObj[index].AIAttackStyle = 1;
          }
        }
        if (this.game.Data.UnitObj[index].AIAttackStyle == 1)
        {
          if (tlog)
            this.AddLog("If defensive style then remove attack target.");
          if (this.game.Data.UnitObj[index].AIAttack > -1 & this.game.Data.UnitObj[index].AIDefend == -1)
            this.game.Data.UnitObj[index].AIDefend = this.game.Data.UnitObj[index].AIAttack;
          this.game.Data.UnitObj[index].AIAttack = -1;
          this.game.Data.UnitObj[index].AIFollowup = -1;
        }
        if (this.game.Data.UnitObj[index].AIFollowup == this.game.Data.UnitObj[index].AIDefend)
        {
          this.game.Data.UnitObj[index].AIFollowup = -1;
          if (tlog)
            this.AddLog("removed followup because it was same as defend area");
        }
        if (this.game.Data.UnitObj[index].AIFollowup == this.game.Data.UnitObj[index].AIFallback)
        {
          this.game.Data.UnitObj[index].AIFollowup = -1;
          if (tlog)
            this.AddLog("removed followup because it was same as fallback area");
        }
        if (this.game.Data.UnitObj[index].AIFollowup == this.game.Data.UnitObj[index].AIAttack)
        {
          this.game.Data.UnitObj[index].AIFollowup = -1;
          if (tlog)
            this.AddLog("removed followup because it was same as attack area");
        }
        if (this.game.Data.UnitObj[index].AIFallback == this.game.Data.UnitObj[index].AIDefend)
        {
          if (tlog)
            this.AddLog("removed fallback because it was same as defend area");
          this.game.Data.UnitObj[index].AIFallback = -1;
        }
      }
      int groupCounter2 = this.GroupCounter;
      for (int grp = 0; grp <= groupCounter2; ++grp)
      {
        int groupHq = this.GetGroupHQ(grp);
        if (groupHq > -1)
        {
          if (tlog)
            this.AddLog(this.GroupName[grp] + " ... FALLBACK = " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIFallback) + ", DEF = " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIDefend) + ", ATTACK = " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIAttack) + ", FOLLOWUP= " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIFollowup) + ", STANCE = " + Conversion.Str((object) this.game.Data.UnitObj[groupHq].AIAttackStyle));
          this.CorpsSource[grp] = this.game.Data.UnitObj[groupHq].AIDefend;
          this.CorpsTarget[grp] = this.game.Data.UnitObj[groupHq].AIAttack;
          if (this.CorpsSource[grp] == -1)
            this.CorpsSource[grp] = this.GetStartArea(grp);
        }
      }
      bool[] flagArray1 = new bool[this.GroupCounter + 1];
      bool[] flagArray2 = new bool[this.GroupCounter + 1];
      int groupCounter3 = this.GroupCounter;
      for (int index16 = 0; index16 <= groupCounter3; ++index16)
      {
        flagArray1[index16] = true;
        flagArray2[index16] = true;
        if (this.GroupType[index16] <= 5 & this.CorpsStartLoc[index16] > 0)
        {
          int groupCounter4 = this.GroupCounter;
          for (int index17 = 0; index17 <= groupCounter4; ++index17)
          {
            if (this.GroupType[index17] <= 5 & this.CorpsStartLoc[index17] == this.CorpsStartLoc[index16] && this.CorpsStrength[index17] > this.CorpsStrength[index16])
              flagArray1[index16] = false;
            if (this.GroupType[index17] <= 5 & this.game.Data.UnitObj[index16].AIAttack == this.game.Data.UnitObj[index17].AIAttack && this.CorpsStrength[index17] > this.CorpsStrength[index16])
              flagArray2[index16] = false;
          }
        }
      }
      SimpleList simpleList = new SimpleList();
      bool[] flagArray3 = new bool[this.game.Data.UnitCounter + 1];
      int groupCounter5 = this.GroupCounter;
      for (int forgroup = 0; forgroup <= groupCounter5; ++forgroup)
      {
        int nr = this.BestStrategy.FindNr(forgroup + 199000);
        if (nr > -1 && this.BestStrategy.Data1[nr] > -1)
        {
          int grp = this.BestStrategy.Data1[nr];
          this.WriteLog();
          if (grp > -1)
          {
            int Hqnr = this.GetGroupHQ(grp);
            if (Hqnr > -1)
            {
              if (!this.game.Data.UnitObj[Hqnr].IsHQ)
                Hqnr = this.game.Data.UnitObj[Hqnr].HQ;
              if (Hqnr > -1)
              {
                int unitCounter12 = this.game.Data.UnitCounter;
                for (int index = 0; index <= unitCounter12; ++index)
                {
                  if (this.game.Data.UnitObj[index].PreDef == -1 && !flagArray3[index] & this.game.Data.UnitObj[index].AIGroup == forgroup & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index].X > -1 && this.game.HandyFunctionsObj.HasUnitAirSF(index))
                  {
                    this.GetHighestFuzzyVPGroup(forgroup);
                    this.game.ProcessingObj.SetUnitHq(index, Hqnr);
                    if (tlog)
                      this.AddLog("Air from " + this.GroupName[forgroup] + " too " + this.GroupName[grp]);
                    this.game.Data.UnitObj[index].AIGroup = grp;
                    flagArray3[index] = true;
                  }
                }
              }
            }
          }
        }
      }
      if ((double) this.game.Data.RuleVar[832] > 0.0 & this.game.Data.Round > 1)
      {
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("INERTIA:");
          this.AddLog("");
        }
        int groupCounter6 = this.GroupCounter;
        for (int grp = 0; grp <= groupCounter6; ++grp)
        {
          int groupHq = this.GetGroupHQ(grp);
          if (groupHq > -1)
          {
            int aiAttack = this.game.Data.UnitObj[groupHq].AIAttack;
            int aiDefend = this.game.Data.UnitObj[groupHq].AIDefend;
            int aiFollowup = this.game.Data.UnitObj[groupHq].AIFollowup;
            int aiFallback = this.game.Data.UnitObj[groupHq].AIFallback;
            if (this.GroupAttack[grp] > 0 & this.GroupAttack[grp] != this.game.Data.UnitObj[groupHq].AIAttack && (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3 | this.Attacker) & this.GroupAttack[grp] <= this.AreaCount && this.game.Data.UnitObj[groupHq].AIAttack != this.GroupFollowUp[grp] && !this.AreaIsExtra[this.GroupAttack[grp]] && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.GroupAttack[grp]].x, this.AreaCenter[this.GroupAttack[grp]].y].Regime, this.game.Data.Turn))
            {
              int unitCounter13 = this.game.Data.UnitCounter;
              for (int index = 0; index <= unitCounter13; ++index)
              {
                if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup == grp & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index].X > -1)
                {
                  if (this.GroupAttack[grp] <= this.AreaCount & this.GroupDefend[grp] <= this.AreaCount & this.GroupFollowUp[grp] <= this.AreaCount & this.GroupFallBack[grp] <= this.AreaCount)
                  {
                    if (tlog)
                      this.AddLog("Inertia called on " + this.GroupName[grp] + ". new defend=" + this.GetAreaName(this.GroupDefend[grp]) + ", new attack=" + this.GetAreaName(this.GroupAttack[grp]));
                    this.game.Data.UnitObj[index].AIAttack = this.GroupAttack[grp];
                    this.game.Data.UnitObj[index].AIDefend = this.GroupDefend[grp];
                    this.game.Data.UnitObj[index].AIFollowup = this.GroupFollowUp[grp];
                    this.game.Data.UnitObj[index].AIFallback = this.GroupFallBack[grp];
                  }
                  else
                    index = index;
                }
              }
            }
            this.GetGroupHQ(grp);
            this.GroupAttack[grp] = aiAttack;
            this.GroupDefend[grp] = aiDefend;
            this.GroupFollowUp[grp] = aiFollowup;
            this.GroupFallBack[grp] = aiFallback;
          }
        }
      }
      else if ((double) this.game.Data.RuleVar[832] == 1.0)
      {
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("INERTIA: active. but this is round 1");
          this.AddLog("");
        }
        int groupCounter7 = this.GroupCounter;
        for (int grp = 0; grp <= groupCounter7; ++grp)
        {
          int groupHq = this.GetGroupHQ(grp);
          if (groupHq > -1)
          {
            this.GroupAttack[grp] = this.game.Data.UnitObj[groupHq].AIAttack;
            this.GroupDefend[grp] = this.game.Data.UnitObj[groupHq].AIDefend;
            this.GroupFollowUp[grp] = this.game.Data.UnitObj[groupHq].AIFollowup;
            this.GroupFallBack[grp] = this.game.Data.UnitObj[groupHq].AIFallback;
          }
        }
      }
      else if (tlog)
      {
        this.AddLog("");
        this.AddLog("INERTIA: not active. you can set with rulevar if you want.");
        this.AddLog("");
      }
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("TEMPORARY TRANSFERS:");
        this.AddLog("");
      }
      int unitCounter14 = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter14; ++index)
        this.game.Data.UnitObj[index].TempGroup = -1;
      int groupCounter8 = this.GroupCounter;
      for (int grp1 = 0; grp1 <= groupCounter8; ++grp1)
      {
        int groupCounter9 = this.GroupCounter;
        for (int grp2 = 0; grp2 <= groupCounter9; ++grp2)
        {
          int groupHq5 = this.GetGroupHQ(grp1);
          int groupHq6 = this.GetGroupHQ(grp2);
          if (groupHq5 > -1 & groupHq6 > -1 && this.CorpsStartLoc[grp1] == this.CorpsStartLoc[grp2] && this.game.Data.UnitObj[groupHq5].AIAttack == this.game.Data.UnitObj[groupHq6].AIAttack && this.game.Data.UnitObj[groupHq5].AIDefend == this.game.Data.UnitObj[groupHq6].AIDefend && this.game.Data.UnitObj[groupHq5].AIFollowup == this.game.Data.UnitObj[groupHq6].AIFollowup && this.CorpsLandStrength[grp1] > this.CorpsLandStrength[grp2])
          {
            int unitCounter15 = this.game.Data.UnitCounter;
            for (int index = 0; index <= unitCounter15; ++index)
            {
              if (this.game.Data.UnitObj[index].AIGroup == grp2 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].X > -1 & this.game.Data.UnitObj[index].PreDef == -1)
              {
                if (this.GetGroupUnits(grp1) < 50 & !(this.game.Data.UnitObj[index].TempCategory == 2 | this.game.Data.UnitObj[index].TempCategory == 3))
                {
                  if (index != groupHq6 | !this.game.Data.UnitObj[groupHq6].IsHQ)
                  {
                    this.game.Data.UnitObj[index].AIGroup = grp1;
                    if (this.game.Data.UnitObj[index].TempGroup == -1)
                      this.game.Data.UnitObj[index].TempGroup = grp2;
                    if (tlog)
                      this.AddLog("TEMPORARILY TRANSFER " + this.game.Data.UnitObj[index].Name + ", ORIGNAL FROM= " + this.GroupName[this.game.Data.UnitObj[index].TempGroup] + ", NOW FROM " + this.GroupName[grp2] + " TO " + this.GroupName[grp1]);
                  }
                }
                else if (this.GetGroupUnits(grp1) < 60 & (this.game.Data.UnitObj[index].TempCategory == 2 | this.game.Data.UnitObj[index].TempCategory == 3) && index != groupHq6 | !this.game.Data.UnitObj[groupHq6].IsHQ)
                {
                  this.game.Data.UnitObj[index].AIGroup = grp1;
                  if (this.game.Data.UnitObj[index].TempGroup == -1)
                    this.game.Data.UnitObj[index].TempGroup = grp2;
                  if (tlog)
                    this.AddLog("TEMPORARILY TRANSFER " + this.game.Data.UnitObj[index].Name + ", ORIGNAL FROM= " + this.GroupName[this.game.Data.UnitObj[index].TempGroup] + ", NOW FROM " + this.GroupName[grp2] + " TO " + this.GroupName[grp1]);
                }
              }
            }
          }
        }
      }
    }

    public void MakeTempMovementTypes(bool tlog)
    {
      if (tlog)
        this.AddLog("MAKETEMPMOVEMENTTYPES");
      if (tlog)
        this.AddLog("");
      int unitCounter = this.game.Data.UnitCounter;
      for (int index = 0; index <= unitCounter; ++index)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1)
        {
          this.MakeTempMovementType(index);
          if (tlog)
          {
            string str1 = Strings.Trim(Conversion.Str((object) index)) + ", " + this.game.Data.UnitObj[index].Name;
            string str2 = this.game.Data.UnitObj[index].TempType <= -1 ? str1 + "TempType = -1 " : str1 + "TempType = " + this.game.Data.TempString[this.game.Data.UnitObj[index].TempType];
            this.AddLog((this.game.Data.UnitObj[index].TempTypeRoad <= -1 ? str2 + ", TempTypeRoad = -1 " : str2 + ", TempTypeRoad = " + this.game.Data.TempString[this.game.Data.UnitObj[index].TempTypeRoad]) + " TempTheater = " + Strings.Trim(Conversion.Str((object) this.game.Data.UnitObj[index].TempTheater)));
          }
        }
      }
    }

    public void MakeTempMovementType(int unr)
    {
      if (this.game.Data.UnitObj[unr].PreDef > -1)
        return;
      int num1 = !this.game.HandyFunctionsObj.HasUnitNavySF(unr) ? (!this.game.HandyFunctionsObj.HasUnitAirSF(unr) ? (!this.game.HandyFunctionsObj.HasUnitlandSF(unr) ? -1 : 0) : 2) : 1;
      if (this.game.Data.UnitObj[unr].IsHQ)
        num1 = num1;
      if (num1 == -1)
        num1 = 0;
      int num2 = this.game.HandyFunctionsObj.GetLowestSpeed(unr, -1);
      if (num2 == -1)
        num2 = 0;
      this.game.Data.UnitObj[unr].TempType = num2;
      int num3 = this.game.HandyFunctionsObj.GetLowestSpeedOnRoad(unr, -1);
      if (num3 == -1)
        num3 = 0;
      this.game.Data.UnitObj[unr].TempTypeRoad = num3;
      this.game.Data.UnitObj[unr].TempTheater = num1;
    }
  }
}
