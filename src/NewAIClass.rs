// Decompiled with JetBrains decompiler
// Type: WindowsApplication1.NewAIClass
// Assembly: WindowsApplication1, Version=1.0.8020.28903, Culture=neutral, PublicKeyToken=null
// MVID: F52869E5-0850-48AD-BBBE-68E7A4900AFE
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Shadow Empire\ShadowEmpire.exe

// usingMicrosoft.VisualBasic;
// usingMicrosoft.VisualBasic.CompilerServices;
// usingSystem;
// usingSystem.Drawing;
// usingSystem.Drawing.Imaging;
// usingSystem.IO;
// usingSystem.Runtime.CompilerServices;
// usingSystem.Windows.Forms;

namespace WindowsApplication1
{
  pub class NewAIClass
  {
    pub Coordinate AAM1;
    pub Coordinate AAM2;
    pub Coordinate CMS1;
    pub Coordinate CMS2;
    pub FullLog: bool;
    pub DetailLog: bool;
    pub ScreenyLog: bool;
    pub MovingIn: bool;
    pub SimpleList MarkerList;
    pub SimpleList ArtMarkerList;
    pub SimpleList AirMarkerList;
    pub SimpleList EngineerMarkerList;
    pub OpGroup: i32;
    pub AverageVP: i32;
    pub AverageSupplyPercentage: i32;
    pub ptemp: Vec<i32>;
    pub ptemp2: Vec<i32>;
    pub ptemp3: Vec<i32>;
    pub atemp: Vec<i32>;
    pub atemp2: Vec<i32>;
    pub ptempb: Vec<bool>;
    pub stemp: Vec<i32>;
    pub MapMatrix2Boolean pmatrix;
    pub TscoreMatrix: Vec<i32>;
    pub TscoreCounterMatrix: Vec<i32>;
    pub AreaClosestEnemy: Vec<i32>;
    pub SupplyMatrix: Vec<i32>;
    pub SupplyCounterMatrix: Vec<i32>;
    pub SupplyTempOwnerMatrix: Vec<i32>;
    pub SupplyMatrixReal: Vec<i32>;
    pub SupplyMatrixPrognosis: Vec<i32>;
    pub SupplyMatrixPrognosisEasyRoads: Vec<i32>;
    pub DistanceFromSuppliedHex: Vec<i32>;
    pub BottleNeckMatrix: Vec<i32>;
    pub Coordinate[,] SupplyMatrixRealCameFrom;
    pub Coordinate[,] SupplyMatrixPrognosisCameFrom;
    pub SupplyMatrixOpHQReal: Vec<i32>;
    pub SupplyMatrixOpHQPrognosis: Vec<i32>;
    pub Coordinate[,] SupplyMatrixOpHQRealCameFrom;
    pub Coordinate[,] SupplyMatrixOpHQPrognosisCameFrom;
    pub DistFromFrontline: Vec<i32>;
    pub FullAdvanceMatrix: Vec<i32>;
    pub SupplyMatrixEnemyReal: Vec<i32>;
    pub SupplyMatrixEnemyPrognosis: Vec<i32>;
    pub Coordinate[,] SupplyMatrixEnemyRealCameFrom;
    pub Coordinate[,] SupplyMatrixEnemyPrognosisCameFrom;
    pub SupplyMatrixDistance: Vec<i32>;
    pub AdvanceAxisMatrix: Vec<i32>;
    pub HexOccupyMatrix: Vec<i32>;
    pub FighterMatrix: Vec<i32>;
    pub int[,,] MoveMatrix;
    pub sCoordinate[,,] MoveMatrixCameFrom;
    pub MoveMatrixUnit: Vec<i32>;
    pub Coordinate[] MoveMatrixCloseRoad;
    pub Attacker: bool;
    pub Meeting: bool;
    pub AreaSupplyBorderCount: Vec<i32>;
    pub AreaSupplyBorder: Vec<i32>;
    pub AreaSupplyBorderEither: Vec<i32>;
    pub AreasupplyborderSea: Vec<i32>;
    pub RandomAreaNeighbourCount: Vec<i32>;
    pub RandomAreaNeighbour: Vec<i32>;
    pub int[,,] EnemyMatrix;
    pub sCoordinate[,,] EnemyMatrixCameFrom;
    pub EnemyMatrixUnit: Vec<i32>;
    pub sCoordinate[,,] EnemyMatrix2CameFrom;
    pub int[,,] EnemyMatrix2;
    pub FriendlyPowerDispersed: Vec<i32>;
    pub EnemyPowerDispersed: Vec<i32>;
    pub MoveMatrixUnitMarker: Vec<i32>;
    pub TempMoveMatrixUnitMarker: Vec<i32>;
    pub MoveMatrixCounter: i32;
    pub EnemyMatrixCounter: i32;
    pub MadeMove: bool;
    pub MoveAndAttackRound: i32;
    pub SimpleList BestMove;
    pub SimpleList[] HistoryMove;
    pub HistoryMoveCounter: i32;
    pub SimpleList HistoryScoreList;
    pub float[,] CombatMatrix;
    pub tArea: Vec<i32>;
    pub DistToTArea: Vec<i32>;
    pub DistFromTArea: Vec<i32>;
    pub FrontlineArea: Vec<i32>;
    pub EnemyFrontlineArea: Vec<i32>;
    pub FrontlineCount: i32;
    pub TempOwner: Vec<i32>;
    pub TempCounterOwner: Vec<i32>;
    pub AreaCount: i32;
    pub RealAreaCount: i32;
    pub AreaGroup: Vec<i32>;
    pub AreaExtraVP: Vec<i32>;
    pub OldExtraVP: Vec<i32>;
    pub AreaGroupRound: i32;
    pub AreaGroupCount: i32;
    pub CurrentAreaGroup: i32;
    pub AreaMatrixNarrow: Vec<i32>;
    pub AreaMatrixWide: Vec<i32>;
    pub AreaBorderNoBridge: Vec<i32>;
    pub AreaIsExtra: Vec<bool>;
    pub AreaBroadBorder: Vec<i32>;
    pub AreaNarrowBorder: Vec<i32>;
    pub AreaBorder: Vec<i32>;
    pub AreaWideBorder: Vec<i32>;
    pub HisAreaDistance: Vec<i32>;
    pub HisAreaDistanceFriendly: Vec<i32>;
    pub Coordinate[] AreaCenter;
    pub SimpleList[] AreaBridges;
    pub AreaFuzzyVP: Vec<i32>;
    pub AreaDefensive: Vec<i32>;
    pub CorpsStrength: Vec<i32>;
    pub AreaStrength: Vec<i32>;
    pub SimpleList BestStrategy;
    pub tempextraaivp: bool;
    pub LastRegime: i32;
    pub CounterAttackPossible: Vec<i32>;
    pub CorpsStrategic: Vec<bool>;
    pub CorpsLoc: Vec<i32>;
    pub CorpsTarget: Vec<i32>;
    pub CorpsSource: Vec<i32>;
    pub CorpsMove: Vec<i32>;
    pub CorpsTopGroup: Vec<i32>;
    pub CorpsEngineer: Vec<bool>;
    pub AreaOwner: Vec<i32>;
    pub AreaEnemy: Vec<i32>;
    pub AreaStartEnemy: Vec<i32>;
    pub AreaIsHistoricalArea: Vec<i32>;
    pub AreaCounterPower: Vec<i32>;
    pub AreaCounterDirections: Vec<i32>;
    pub AreaCounterRegime: Vec<i32>;
    pub AreaCounterStep: Vec<i32>;
    pub AverageAreaEntrench: Vec<i32>;
    pub CorpsMoveProgress: Vec<i32>;
    pub CorpsStance: Vec<i32>;
    pub CorpsStartLoc: Vec<i32>;
    pub CorpsFirstAreaBattle: Vec<i32>;
    pub float[] CorpsTopRatio;
    pub CorpsBottleneck: Vec<i32>;
    pub CorpsOldDefend: Vec<i32>;
    pub TempGroupHQ: Vec<i32>;
    pub CorpsTempStrength: Vec<i32>;
    pub FriendlySupply: Vec<i32>;
    pub StartFriendlySupply: Vec<i32>;
    pub EnemySupply: Vec<i32>;
    pub AreaSteps: Vec<i32>;
    pub CorpsEntrench: Vec<i32>;
    pub EnemySupplyGone: Vec<i32>;
    pub StartEnemySupplyGone: Vec<i32>;
    pub CorpsAirStrength: Vec<i32>;
    pub CorpsTempAirStrength: Vec<i32>;
    pub CorpsAirEffect: Vec<i32>;
    pub corpsstartStrength: Vec<i32>;
    pub CorpsLandStrength: Vec<i32>;
    pub CorpsPowerLeft: Vec<i32>;
    pub CorpsAttack: Vec<i32>;
    pub CorpsDefend: Vec<i32>;
    pub SimpleList TempTroops;
    pub TempTotVP: i32;
    pub TempCurVP: i32;
     SimpleList TempPowerAbove;
    pub GlobalVar: i32;
    pub GroupCounter: i32;
    pub GroupType: Vec<i32>;
    pub GroupHis: Vec<i32>;
    pub GroupName: Vec<String>;
    pub GroupAttack: Vec<i32>;
    pub GroupDefend: Vec<i32>;
    pub GroupFallBack: Vec<i32>;
    pub GroupFollowUp: Vec<i32>;
    pub TempGroupTarget: Vec<i32>;
    pub GroupHQNeed: Vec<i32>;
    pub ErsatzGroupCounter: i32;
    pub TempAverageHQPower: i32;
    pub SeaCount: i32;
    pub SeaBorder: Vec<i32>;
    pub SeaMatrix: Vec<i32>;
    pub ATTACK_MINIMUM_ACTUAL_ATTACK: i32;
    pub float ATTACKERRATIO;
    pub DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE: i32;
    pub DIFFICULTY_LEVEL_STRATEGY_MOVES: i32;
     const let mut ATTACK_STYLE_DEFENSIVE: i32 = 1;
     const let mut ATTACK_STYLE_NORMAL: i32 = 2;
     const let mut ATTACK_STYLE_OFFENSIVE: i32 = 3;
     const let mut STRATEGY_MOVETYPE: i32 = 3;
     const let mut STRATEGY_MOVEDIVIDER: i32 = 20;
     const let mut STRATEGY_AIRMOVECOST: i32 = 4;
     const let mut STRATEGY_MINIMUMEPATURN: i32 = 50;
     const float STRATEGY_AVAILABLEFORSTRATEGIC = 2f;
     const let mut STRATEGY_MOUNTAINLT: i32 = 6;
    pub const CATEGORY_NORMAL: i32 = 1;
    pub const CATEGORY_ARTILLERY: i32 = 2;
    pub const CATEGORY_AIR: i32 = 3;
    pub const CATEGORY_ENGINEER: i32 = 4;
    pub const CATEGORY_FLAK: i32 = 5;
    pub const CATEGORY_CARGO: i32 = 6;
    pub const CATEGORY_NAVAL: i32 = 7;
    pub const CATEGORY_AIRTRANSPORT: i32 = 8;
    pub float CONST_ARTMULTI;
    pub float CONST_AIRMULTI;
    pub float CONST_LANDDEFMULTI;
    pub const ROLESTAFF: i32 = 1;
    pub const ROLELANDCAP: i32 = 2;
    pub const ROLESEACAP: i32 = 3;
    pub const ROLEAIRCAP: i32 = 4;
    pub const ROLEENGINEER: i32 = 5;
    pub const ROLEINFANTRY: i32 = 6;
    pub const ROLEINFANTRYSUPPORT: i32 = 7;
    pub const ROLEARTILLERY: i32 = 8;
    pub const ROLEMOBILIZER: i32 = 9;
    pub const ROLEARMOUR: i32 = 10;
    pub const ROLEPARATROOP: i32 = 11;
    pub const ROLEAA: i32 = 12;
    pub const ROLEFIGHTER: i32 = 13;
    pub const ROLETACTICALBOMBER: i32 = 14;
    pub const ROLESTRATEGICBOMBER: i32 = 15;
    pub const ROLETRANSPORTER: i32 = 16;
    pub const ROLECARGOSHIP: i32 = 17;
    pub const ROLESEASUPRIORITY: i32 = 18;
    pub const ROLERAIDER: i32 = 19;
    pub StrTempCorps: Vec<i32>;
    pub float[] StrTempCorpsMod;
    pub StrTempCorpsCounter: i32;
    pub StrCurSides: Vec<i32>;
    pub StrConsistSame: i32;
    pub StrConsistDifferent: i32;
    pub StrCounterAttack: Vec<i32>;
    pub StrLandEnemySupply: Vec<i32>;
    pub StartStrLandEnemySupply: Vec<i32>;
    pub StrOrigAreaOwner: Vec<i32>;
    pub StrAreaEntrench: Vec<i32>;
    pub StrAreaNegPow: Vec<i32>;
    pub game: GameClass;
    pub LogTxt: Vec<String>;
    pub LogCounter: i32;
    pub LogTxt2: Vec<String>;
    pub LogCounter2: i32;

    pub fn MakeFighterCoverage(bool alllog)
    {
      this.FighterMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (alllog)
        this.AddLog("MAKE FIGHTER COVERAGE (of enemy fighters! not our own)");
      if (alllog)
        this.AddLog("");
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn & this.game.Data.UnitObj[unr].PreDef == -1 && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.UnitObj[unr].Regime, this.game.Data.Turn) && this.game.HandyFunctionsObj.HasUnitAirSF(unr))
        {
          let mut aiRolePercent: i32 = this.GetAIRolePercent(unr, 13);
          if (aiRolePercent > 0)
          {
            let mut increaseap: i32 =  Math.Round( ( this.game.HandyFunctionsObj.GetLowestAirRdn(unr, true) * this.game.Data.RuleVar[147]));
            if (increaseap > 0)
            {
              if (alllog)
                this.AddLog("Enemy unit is adding to enemy fighter coverage: " + this.game.Data.UnitObj[unr].Name);
              this.game.HandyFunctionsObj.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, this.game.Data.UnitObj[unr].Map, false, PredictAirOnly: true, attack: true, increaseap: increaseap, OnlyFrontline: true);
              let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
              {
                let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
                {
                  if (this.game.EditObj.TempValue[0].Value[index1, index2] <= increaseap)
                  {
                    let mut num1: i32 =  Math.Round( this.GetUnitPower(unr, true, Theater: 2) * ( aiRolePercent / 100.0));
                    fighterMatrix: Vec<i32> = this.FighterMatrix;
                    numArray: Vec<i32> = fighterMatrix;
                    let mut index3: i32 = index1;
                    let mut index4: i32 = index3;
                    let mut index5: i32 = index2;
                    let mut index6: i32 = index5;
                    let mut num2: i32 = fighterMatrix[index3, index5] + num1;
                    numArray[index4, index6] = num2;
                  }
                }
              }
            }
          }
        }
      }
      if (!this.ScreenyLog)
        return;
      if (alllog)
        this.AddLog("Screenshot has been made.");
      this.Screenshot(1, "EnemyFighterMatrix",  this.FighterMatrix);
    }

    pub fn MakeAreaMatrix(bool tlog)
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      int[] numArray4 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray5 = new int[this.game.Data.AreaCounter + 1];
      bool flag = true;
      this.AreaCount = 0;
      this.SeaCount = 0;
      if (tlog)
        this.AddLog("MAKEAREAMATRIX");
      if (tlog)
        this.AddLog("");
      this.SeaMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      Coordinate coordinate1;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight1: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight1; index2 += 1)
        {
          if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index1, index2].LandscapeType].IsSea && this.SeaMatrix[index1, index2] == 0)
          {
            this += 1.SeaCount;
            this.SeaMatrix[index1, index2] = this.SeaCount;
            let mut num: i32 = 1;
            while (num == 1)
            {
              num = 0;
              let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
              {
                let mut mapHeight2: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut cy: i32 = 0; cy <= mapHeight2; cy += 1)
                {
                  if (this.SeaMatrix[cx, cy] == this.SeaCount && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[cx, cy].LandscapeType].IsSea && this.SeaMatrix[cx, cy] == this.SeaCount)
                  {
                    let mut tfacing: i32 = 1;
                    do
                    {
                      coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                      if (coordinate1.onmap && this.SeaMatrix[coordinate1.x, coordinate1.y] == 0 && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
                      {
                        this.SeaMatrix[coordinate1.x, coordinate1.y] = this.SeaCount;
                        num = 1;
                      }
                      tfacing += 1;
                    }
                    while (tfacing <= 6);
                  }
                }
              }
            }
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SEA ZONES");
      if (tlog)
        this.AddLog("(note that sea zone count of 0 = no sea zones)");
      if (tlog)
        this.AddLog("Sea Zone Count: " + Strings.Trim(Conversion.Str( this.SeaCount)));
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "SEA_ZONES",  this.SeaMatrix);
      }
      int[] numArray6 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray7 = new int[this.game.Data.AreaCounter + 1];
      tObj: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray8: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x: i32 = 0; x <= mapWidth3; x += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y: i32 = 0; y <= mapHeight; y += 1)
        {
          let mut num1: i32 = 0;
          this.AreaMatrixNarrow[x, y] = 0;
          this.AreaMatrixWide[x, y] = 0;
          let mut areaCounter: i32 = this.game.Data.AreaCounter;
          for (let mut area: i32 = 0; area <= areaCounter; area += 1)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num1 = 1;
              if (numArray6[area] == 0)
              {
                this += 1.AreaCount;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                numArray6[area] = this.AreaCount;
                this.AreaCenter[numArray6[area]].x = x;
                this.AreaCenter[numArray6[area]].y = y;
                this.AreaCenter[numArray6[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray6[area]].x, this.AreaCenter[numArray6[area]].y].Location == -1)
              {
                this.AreaCenter[numArray6[area]].x = x;
                this.AreaCenter[numArray6[area]].y = y;
              }
              numArray8[x, y] = 1;
              tObj[x, y] = numArray6[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray7[area])
              {
                this.AreaCenter[numArray6[area]].x = x;
                this.AreaCenter[numArray6[area]].y = y;
                this.AreaCenter[numArray6[area]].onmap = true;
                numArray7[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num1 == 0)
          {
            let mut num2: i32 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 &  this.game.Data.RuleVar[357] == 1.0)
              num2 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num2 = 1;
            if (num2 == 1)
            {
              this += 1.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray8[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAS");
      if (tlog)
        this.AddLog("(note that area count of 0 = no areas)");
      if (tlog)
        this.AddLog("Area Count: " + Strings.Trim(Conversion.Str( this.AreaCount)));
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAS",  tObj);
      }
      this.AreaBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaWideBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaBroadBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaNarrowBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaBorderNoBridge = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaIsHistoricalArea = new int[this.AreaCount + 1];
      let mut num3: i32 = 1;
      let mut num4: i32 = 0;
      for (; num3 >= -1; --num3)
      {
        num4 += 1;
        let mut mapWidth4: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth4; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray8[cx, cy] == num4)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray8[coordinate1.x, coordinate1.y] == 0)
                {
                  if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                  {
                    if (!this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                    {
                      tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                      numArray8[coordinate1.x, coordinate1.y] = numArray8[cx, cy] + 1;
                      num3 = 1;
                    }
                  }
                  else if (this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] <= -1 && !this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                  {
                    tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                    numArray8[coordinate1.x, coordinate1.y] = numArray8[cx, cy] + 2;
                    num3 = 1;
                  }
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      let mut mapWidth5: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index3: i32 = 0; index3 <= mapWidth5; index3 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
          this.AreaMatrixWide[index3, index4] = tObj[index3, index4];
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX WIDE");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_WIDE",  this.AreaMatrixWide);
      }
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index5: i32 = 1; index5 <= areaCount1; index5 += 1)
      {
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut index6: i32 = 1; index6 <= areaCount2; index6 += 1)
        {
          this.AreaBorder[index5, index6] = 0;
          this.AreaWideBorder[index5, index6] = 0;
          this.AreaNarrowBorder[index5, index6] = 0;
        }
      }
      let mut mapWidth6: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut cx: i32 = 0; cx <= mapWidth6; cx += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
        {
          if (tObj[cx, cy] > 0)
          {
            let mut tfacing: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[cx, cy] != tObj[coordinate1.x, coordinate1.y])
              {
                if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1 |  this.game.Data.RuleVar[385] == 1.0 && this.AreaBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] && numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] < 40 |  this.game.Data.RuleVar[385] == 0.0)
                {
                  this.AreaBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                  this.AreaBorder[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                }
                if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[cx, cy].LandscapeType].IsSea && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea && this.AreaWideBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaWideBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] && numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y] < 40 |  this.game.Data.RuleVar[385] == 0.0)
                {
                  this.AreaWideBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                  this.AreaWideBorder[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray8[cx, cy] + numArray8[coordinate1.x, coordinate1.y];
                }
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
        }
      }
      let mut areaCount3: i32 = this.AreaCount;
      for (let mut index7: i32 = 1; index7 <= areaCount3; index7 += 1)
      {
        let mut areaCount4: i32 = this.AreaCount;
        for (let mut index8: i32 = 1; index8 <= areaCount4; index8 += 1)
          this.AreaBroadBorder[index7, index8] = this.AreaBorder[index7, index8];
      }
      let mut areaCount5: i32 = this.AreaCount;
      for (let mut index9: i32 = 1; index9 <= areaCount5; index9 += 1)
      {
        let mut areaCount6: i32 = this.AreaCount;
        for (let mut index10: i32 = 1; index10 <= areaCount6; index10 += 1)
        {
          if (index9 != index10)
          {
            let mut areaCount7: i32 = this.AreaCount;
            for (let mut index11: i32 = 1; index11 <= areaCount7; index11 += 1)
            {
              if (this.AreaBroadBorder[index9, index11] > 0 & this.AreaBroadBorder[index10, index11] > 0 & (this.AreaBroadBorder[index9, index10] == 0 | this.AreaBroadBorder[index9, index10] > this.AreaBroadBorder[index9, index11] + this.AreaBroadBorder[index10, index11]) && this.AreaBroadBorder[index9, index11] + this.AreaBroadBorder[index10, index11] < 15)
                this.AreaBroadBorder[index9, index10] =  Math.Round( this.AreaBroadBorder[index9, index11] +  this.AreaBroadBorder[index10, index11] * 0.7);
            }
          }
        }
      }
      this.AreaCount = 0;
      int[] numArray9 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray10 = new int[this.game.Data.AreaCounter + 1];
      tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray11: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth7: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x: i32 = 0; x <= mapWidth7; x += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y: i32 = 0; y <= mapHeight; y += 1)
        {
          let mut num5: i32 = 0;
          let mut areaCounter: i32 = this.game.Data.AreaCounter;
          for (let mut area: i32 = 0; area <= areaCounter; area += 1)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num5 = 1;
              if (numArray9[area] == 0)
              {
                this += 1.AreaCount;
                this.AreaIsHistoricalArea[this.AreaCount] = area;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                numArray9[area] = this.AreaCount;
                this.AreaCenter[numArray9[area]].x = x;
                this.AreaCenter[numArray9[area]].y = y;
                this.AreaCenter[numArray9[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray9[area]].x, this.AreaCenter[numArray9[area]].y].Location == -1)
              {
                this.AreaCenter[numArray9[area]].x = x;
                this.AreaCenter[numArray9[area]].y = y;
              }
              numArray11[x, y] = 1;
              tObj[x, y] = numArray9[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray10[area])
              {
                this.AreaCenter[numArray9[area]].x = x;
                this.AreaCenter[numArray9[area]].y = y;
                this.AreaCenter[numArray9[area]].onmap = true;
                numArray10[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num5 == 0)
          {
            let mut num6: i32 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 &  this.game.Data.RuleVar[357] == 1.0)
              num6 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num6 = 1;
            if (num6 == 1)
            {
              this += 1.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray11[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      let mut mapWidth8: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index12: i32 = 0; index12 <= mapWidth8; index12 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index13: i32 = 0; index13 <= mapHeight; index13 += 1)
        {
          if (tObj[index12, index13] > 0 && this.game.Data.MapObj[0].HexObj[index12, index13].Regime != this.game.Data.MapObj[0].HexObj[this.AreaCenter[tObj[index12, index13]].x, this.AreaCenter[tObj[index12, index13]].y].Regime)
          {
            tObj[index12, index13] = 0;
            numArray11[index12, index13] = 0;
          }
        }
      }
      let mut num7: i32 = 2;
      let mut num8: i32 = 0;
      while (num7 >= 0)
      {
        --num7;
        num8 += 1;
        let mut mapWidth9: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth9; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray11[cx, cy] == num8)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray11[coordinate1.x, coordinate1.y] == 0 && this.game.Data.MapObj[0].HexObj[cx, cy].Regime == this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime && !this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                {
                  if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                  {
                    tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                    numArray11[coordinate1.x, coordinate1.y] = numArray11[cx, cy] + 1;
                    num7 = 2;
                  }
                  else if (this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] <= -1)
                  {
                    tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                    numArray11[coordinate1.x, coordinate1.y] = numArray11[cx, cy] + 3;
                    num7 = 2;
                  }
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      let mut mapWidth10: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index14: i32 = 0; index14 <= mapWidth10; index14 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index15: i32 = 0; index15 <= mapHeight; index15 += 1)
          this.AreaMatrixNarrow[index14, index15] = tObj[index14, index15];
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NARROW");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_NARROW",  this.AreaMatrixNarrow);
      }
      let mut mapWidth11: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut cx: i32 = 0; cx <= mapWidth11; cx += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
        {
          if (tObj[cx, cy] > 0)
          {
            let mut tfacing: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[cx, cy] != tObj[coordinate1.x, coordinate1.y] && this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1 |  this.game.Data.RuleVar[385] == 1.0 && this.AreaNarrowBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaNarrowBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y] && numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y] < 40 |  this.game.Data.RuleVar[385] == 0.0)
              {
                this.AreaNarrowBorder[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y];
                this.AreaNarrowBorder[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray11[cx, cy] + numArray11[coordinate1.x, coordinate1.y];
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
        }
      }
      this.AreaCount = 0;
      int[] numArray12 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray13 = new int[this.game.Data.AreaCounter + 1];
      tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray14: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth12: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x: i32 = 0; x <= mapWidth12; x += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y: i32 = 0; y <= mapHeight; y += 1)
        {
          let mut num9: i32 = 0;
          let mut areaCounter: i32 = this.game.Data.AreaCounter;
          for (let mut area: i32 = 0; area <= areaCounter; area += 1)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num9 = 1;
              if (numArray12[area] == 0)
              {
                this += 1.AreaCount;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                this.AreaBridges[this.AreaCount] = SimpleList::new();
                numArray12[area] = this.AreaCount;
                this.AreaCenter[numArray12[area]].x = x;
                this.AreaCenter[numArray12[area]].y = y;
                this.AreaCenter[numArray12[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray12[area]].x, this.AreaCenter[numArray12[area]].y].Location == -1)
              {
                this.AreaCenter[numArray12[area]].x = x;
                this.AreaCenter[numArray12[area]].y = y;
              }
              numArray14[x, y] = 1;
              tObj[x, y] = numArray12[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray13[area])
              {
                this.AreaCenter[numArray12[area]].x = x;
                this.AreaCenter[numArray12[area]].y = y;
                this.AreaCenter[numArray12[area]].onmap = true;
                numArray13[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num9 == 0)
          {
            let mut num10: i32 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 &  this.game.Data.RuleVar[357] == 1.0)
              num10 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num10 = 1;
            if (num10 == 1)
            {
              this += 1.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray14[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaBridges[this.AreaCount] = SimpleList::new();
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      let mut num11: i32 = 1;
      let mut num12: i32 = 0;
      while (num11 == 1)
      {
        num11 = 0;
        num12 += 1;
        let mut mapWidth13: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth13; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray14[cx, cy] == num12)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray14[coordinate1.x, coordinate1.y] == 0 && this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] == -1 && this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                {
                  tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                  numArray14[coordinate1.x, coordinate1.y] = numArray14[cx, cy] + 1;
                  num11 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      let mut mapWidth14: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut cx: i32 = 0; cx <= mapWidth14; cx += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
        {
          if (tObj[cx, cy] > 0)
          {
            let mut tfacing: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[cx, cy] != tObj[coordinate1.x, coordinate1.y] && (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1 |  this.game.Data.RuleVar[385] == 1.0) & this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] == -1 && this.AreaBorderNoBridge[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] == 0 | this.AreaBorderNoBridge[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] > numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y] && numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y] < 40 |  this.game.Data.RuleVar[385] == 0.0)
              {
                this.AreaBorderNoBridge[tObj[cx, cy], tObj[coordinate1.x, coordinate1.y]] = numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y];
                this.AreaBorderNoBridge[tObj[coordinate1.x, coordinate1.y], tObj[cx, cy]] = numArray14[cx, cy] + numArray14[coordinate1.x, coordinate1.y];
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NO BRIDGE (temporary)");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_NO_BRIDGE_TEMP",  tObj);
      }
      this.AreaCount = 0;
      int[] numArray15 = new int[this.game.Data.AreaCounter + 1];
      int[] numArray16 = new int[this.game.Data.AreaCounter + 1];
      tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray17: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth15: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x: i32 = 0; x <= mapWidth15; x += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y: i32 = 0; y <= mapHeight; y += 1)
        {
          let mut num13: i32 = 0;
          let mut areaCounter: i32 = this.game.Data.AreaCounter;
          for (let mut area: i32 = 0; area <= areaCounter; area += 1)
          {
            if (this.game.HandyFunctionsObj.IsHexArea(x, y, area))
            {
              num13 = 1;
              if (numArray15[area] == 0)
              {
                this += 1.AreaCount;
                this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
                this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
                this.AreaBridges[this.AreaCount] = SimpleList::new();
                numArray15[area] = this.AreaCount;
                this.AreaCenter[numArray15[area]].x = x;
                this.AreaCenter[numArray15[area]].y = y;
                this.AreaCenter[numArray15[area]].onmap = true;
              }
              else if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[numArray15[area]].x, this.AreaCenter[numArray15[area]].y].Location == -1)
              {
                this.AreaCenter[numArray15[area]].x = x;
                this.AreaCenter[numArray15[area]].y = y;
              }
              numArray17[x, y] = 1;
              tObj[x, y] = numArray15[area];
              if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > numArray16[area])
              {
                this.AreaCenter[numArray15[area]].x = x;
                this.AreaCenter[numArray15[area]].y = y;
                this.AreaCenter[numArray15[area]].onmap = true;
                numArray16[area] = this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y];
              }
            }
          }
          if (num13 == 0)
          {
            let mut num14: i32 = 0;
            if (this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] >= 1 &  this.game.Data.RuleVar[357] == 1.0)
              num14 = 1;
            if (this.game.Data.MapObj[0].HexObj[x, y].Location > -1 & (flag | this.game.Data.MapObj[0].HexObj[x, y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] > 0) && !this.game.Data.LocTypeObj[this.game.Data.LocObj[this.game.Data.MapObj[0].HexObj[x, y].Location].Type].Buildable)
              num14 = 1;
            if (num14 == 1)
            {
              this += 1.AreaCount;
              tObj[x, y] = this.AreaCount;
              numArray17[x, y] = 1;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaBridges[this.AreaCount] = SimpleList::new();
              this.AreaCenter[this.AreaCount].x = x;
              this.AreaCenter[this.AreaCount].y = y;
              this.AreaCenter[this.AreaCount].onmap = true;
            }
          }
        }
      }
      let mut mapWidth16: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index16: i32 = 0; index16 <= mapWidth16; index16 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index17: i32 = 0; index17 <= mapHeight; index17 += 1)
        {
          if (tObj[index16, index17] > 0 && !(index16 == this.AreaCenter[tObj[index16, index17]].x & index17 == this.AreaCenter[tObj[index16, index17]].y))
          {
            tObj[index16, index17] = 0;
            numArray17[index16, index17] = 0;
          }
        }
      }
      let mut num15: i32 = 1;
      let mut num16: i32 = 0;
      while (num15 == 1)
      {
        num15 = 0;
        num16 += 1;
        let mut mapWidth17: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth17; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray17[cx, cy] == num16)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray17[coordinate1.x, coordinate1.y] == 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[tObj[cx, cy]].x, this.AreaCenter[tObj[cx, cy]].y].Regime) != this.GetGameDataTurn() && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) != this.GetGameDataTurn() | this.game.Data.MapObj[0].HexObj[cx, cy].RiverType[tfacing - 1] == -1 && !this.game.HandyFunctionsObj.IsSleeping(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) && this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                {
                  tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                  numArray17[coordinate1.x, coordinate1.y] = numArray17[cx, cy] + 1;
                  num15 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      let mut mapWidth18: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index18: i32 = 0; index18 <= mapWidth18; index18 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index19: i32 = 0; index19 <= mapHeight; index19 += 1)
        {
          if (numArray17[index18, index19] > 0)
            numArray17[index18, index19] = 1;
        }
      }
      let mut num17: i32 = 1;
      let mut num18: i32 = 0;
      while (num17 == 1)
      {
        num17 = 0;
        num18 += 1;
        let mut mapWidth19: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth19; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray17[cx, cy] == num18)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray17[coordinate1.x, coordinate1.y] == 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[tObj[cx, cy]].x, this.AreaCenter[tObj[cx, cy]].y].Regime) == this.GetGameDataTurn())
                {
                  tObj[coordinate1.x, coordinate1.y] = tObj[cx, cy];
                  numArray17[coordinate1.x, coordinate1.y] = numArray17[cx, cy] + 1;
                  num17 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      let mut mapWidth20: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index20: i32 = 0; index20 <= mapWidth20; index20 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index21: i32 = 0; index21 <= mapHeight; index21 += 1)
        {
          if (tObj[index20, index21] > 0)
          {
            let mut tfacing: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index20, index21, 0, tfacing);
              if (coordinate1.onmap && tObj[coordinate1.x, coordinate1.y] > 0 & tObj[index20, index21] != tObj[coordinate1.x, coordinate1.y] && !(this.game.Data.MapObj[0].HexObj[index20, index21].RoadType[tfacing - 1] > -1 & this.game.Data.MapObj[0].HexObj[index20, index21].RiverType[tfacing - 1] == -1) && this.game.Data.MapObj[0].HexObj[index20, index21].RoadType[tfacing - 1] > -1 & this.game.Data.MapObj[0].HexObj[index20, index21].RiverType[tfacing - 1] > -1 & tObj[coordinate1.x, coordinate1.y] > 0)
                this.AreaBridges[tObj[index20, index21]].Add(tObj[coordinate1.x, coordinate1.y], 0, index20, index21, coordinate1.x, coordinate1.y);
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
        }
      }
      this.RealAreaCount = this.AreaCount;
      let mut num19: i32 = 1;
      this.AreaIsExtra = new bool[this.AreaCount + 1];
      let mut num20: i32 = -1;
      numArray18: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray19: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      while (num19 == 1)
      {
        num19 = 0;
        num20 += 1;
        let mut mapWidth21: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth21; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            let mut num21: i32 = 4;
            if (this.AreaMatrixNarrow[cx, cy] > 0 & this.game.Data.MapObj[0].HexObj[cx, cy].Regime != this.GetGameDataTurn() | numArray18[cx, cy] > 0 & numArray18[cx, cy] < num21 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[cx, cy].LandscapeType].IsSea && numArray18[cx, cy] == num20)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea && numArray18[coordinate1.x, coordinate1.y] == 0 && !(this.AreaMatrixNarrow[coordinate1.x, coordinate1.y] == 0 & this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == this.GetGameDataTurn()) && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime, this.game.Data.MapObj[0].HexObj[cx, cy].Regime) | num20 < num21)
                {
                  numArray19[coordinate1.x, coordinate1.y] = 1;
                  numArray18[coordinate1.x, coordinate1.y] = num20 + 1;
                  num19 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      let mut mapWidth22: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x1: i32 = 0; x1 <= mapWidth22; x1 += 1)
      {
        let mut mapHeight3: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y1: i32 = 0; y1 <= mapHeight3; y1 += 1)
        {
          if (this.AreaMatrixNarrow[x1, y1] == 0 & this.AreaMatrixWide[x1, y1] > 0 & numArray19[x1, y1] == 0)
          {
            if (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[x1, y1].LandscapeType].IsSea)
            {
              this += 1.AreaCount;
              this.AreaCenter = (Coordinate[]) Utils.CopyArray((Array) this.AreaCenter, (Array) new Coordinate[this.AreaCount + 1]);
              this.AreaBridges = (SimpleList[]) Utils.CopyArray((Array) this.AreaBridges, (Array) new SimpleList[this.AreaCount + 1]);
              this.AreaIsExtra = (bool[]) Utils.CopyArray((Array) this.AreaIsExtra, (Array) new bool[this.AreaCount + 1]);
              this.AreaBridges[this.AreaCount] = SimpleList::new();
              this.AreaIsExtra[this.AreaCount] = true;
              this.AreaCenter[this.AreaCount].x = x1;
              this.AreaCenter[this.AreaCount].y = y1;
              this.AreaCenter[this.AreaCount].onmap = true;
              tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
              numArray20: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
              numArray20[x1, y1] = 1;
              tObj[x1, y1] = 1;
              this.AreaMatrixNarrow[x1, y1] = this.AreaCount;
              this.AreaMatrixWide[x1, y1] = this.AreaCount;
              let mut num22: i32 = 1;
              let mut num23: i32 = 0;
              while (num22 == 1)
              {
                num22 = 0;
                num23 += 1;
                let mut mapWidth23: i32 = this.game.Data.MapObj[0].MapWidth;
                for (let mut cx: i32 = 0; cx <= mapWidth23; cx += 1)
                {
                  let mut mapHeight4: i32 = this.game.Data.MapObj[0].MapHeight;
                  for (let mut cy: i32 = 0; cy <= mapHeight4; cy += 1)
                  {
                    if (numArray20[cx, cy] == num23 & numArray19[cx, cy] == 0)
                    {
                      let mut tfacing1: i32 = 1;
                      do
                      {
                        coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing1);
                        if (coordinate1.onmap)
                        {
                          if (numArray20[coordinate1.x, coordinate1.y] == 0 & numArray19[coordinate1.x, coordinate1.y] == 0 && this.AreaMatrixNarrow[coordinate1.x, coordinate1.y] == 0 & this.AreaMatrixWide[coordinate1.x, coordinate1.y] > 0 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea && this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == this.game.Data.MapObj[0].HexObj[cx, cy].Regime)
                          {
                            tObj[coordinate1.x, coordinate1.y] = 1;
                            numArray20[coordinate1.x, coordinate1.y] = num23 + 1;
                            this.AreaMatrixNarrow[coordinate1.x, coordinate1.y] = this.AreaCount;
                            this.AreaMatrixWide[coordinate1.x, coordinate1.y] = this.AreaCount;
                            num22 = 1;
                          }
                          if (this.GetGameDataTurn() != this.GetRegime(this.game.Data.MapObj[0].HexObj[x1, y1].Regime) && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
                          {
                            let mut tfacing2: i32 = 1;
                            do
                            {
                              Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                              if (coordinate2.onmap && numArray20[coordinate2.x, coordinate2.y] == 0 & numArray19[coordinate2.x, coordinate2.y] == 0 && this.AreaMatrixNarrow[coordinate2.x, coordinate2.y] == 0 & this.AreaMatrixWide[coordinate2.x, coordinate2.y] > 0 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == this.game.Data.MapObj[0].HexObj[cx, cy].Regime)
                              {
                                tObj[coordinate2.x, coordinate2.y] = 1;
                                numArray20[coordinate2.x, coordinate2.y] = num23 + 1;
                                this.AreaMatrixNarrow[coordinate2.x, coordinate2.y] = this.AreaCount;
                                this.AreaMatrixWide[coordinate2.x, coordinate2.y] = this.AreaCount;
                                num22 = 1;
                              }
                              tfacing2 += 1;
                            }
                            while (tfacing2 <= 6);
                          }
                        }
                        tfacing1 += 1;
                      }
                      while (tfacing1 <= 6);
                    }
                  }
                }
              }
            }
          }
          else if (this.AreaMatrixNarrow[x1, y1] == 0 & this.AreaMatrixWide[x1, y1] > 0 & numArray19[x1, y1] == 1)
          {
            let mut num24: i32 = -1;
            let mut num25: i32 = 9999;
            let mut mapWidth24: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut x2: i32 = 0; x2 <= mapWidth24; x2 += 1)
            {
              let mut mapHeight5: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut y2: i32 = 0; y2 <= mapHeight5; y2 += 1)
              {
                let mut index: i32 = this.AreaMatrixWide[x2, y2];
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetRegime(this.game.Data.MapObj[0].HexObj[x1, y1].Regime))
                {
                  let mut num26: i32 = this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0, 9);
                  if (num26 > 0 & num26 < 10 && num26 < num25)
                  {
                    num25 = num26;
                    num24 = index;
                  }
                }
              }
            }
            if (num24 > -1)
            {
              this.AreaMatrixNarrow[x1, y1] = num24;
              this.AreaMatrixWide[x1, y1] = num24;
            }
          }
        }
      }
      tObj = new int[this.AreaCount + 1, this.AreaCount + 1];
      numArray21: Vec<i32> = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut upperBound1: i32 = this.AreaBorder.GetUpperBound(0);
      for (let mut index22: i32 = 0; index22 <= upperBound1; index22 += 1)
      {
        let mut upperBound2: i32 = this.AreaBorder.GetUpperBound(0);
        for (let mut index23: i32 = 0; index23 <= upperBound2; index23 += 1)
        {
          tObj[index22, index23] = this.AreaBorder[index22, index23];
          numArray21[index22, index23] = this.AreaWideBorder[index22, index23];
        }
      }
      this.AreaBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaWideBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut areaCount8: i32 = this.AreaCount;
      for (let mut index24: i32 = 0; index24 <= areaCount8; index24 += 1)
      {
        let mut areaCount9: i32 = this.AreaCount;
        for (let mut index25: i32 = 0; index25 <= areaCount9; index25 += 1)
        {
          this.AreaBorder[index24, index25] = tObj[index24, index25];
          this.AreaWideBorder[index24, index25] = numArray21[index24, index25];
        }
      }
      tObj = new int[this.AreaCount + 1, this.AreaCount + 1];
      numArray22: Vec<i32> = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut upperBound3: i32 = this.AreaNarrowBorder.GetUpperBound(0);
      for (let mut index26: i32 = 0; index26 <= upperBound3; index26 += 1)
      {
        let mut upperBound4: i32 = this.AreaNarrowBorder.GetUpperBound(0);
        for (let mut index27: i32 = 0; index27 <= upperBound4; index27 += 1)
        {
          tObj[index26, index27] = this.AreaBroadBorder[index26, index27];
          numArray22[index26, index27] = this.AreaNarrowBorder[index26, index27];
        }
      }
      this.AreaBroadBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaNarrowBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut areaCount10: i32 = this.AreaCount;
      for (let mut index28: i32 = 0; index28 <= areaCount10; index28 += 1)
      {
        let mut areaCount11: i32 = this.AreaCount;
        for (let mut index29: i32 = 0; index29 <= areaCount11; index29 += 1)
        {
          this.AreaBroadBorder[index28, index29] = tObj[index28, index29];
          this.AreaNarrowBorder[index28, index29] = numArray22[index28, index29];
        }
      }
      tObj = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut upperBound5: i32 = this.AreaBorderNoBridge.GetUpperBound(0);
      for (let mut index30: i32 = 0; index30 <= upperBound5; index30 += 1)
      {
        let mut upperBound6: i32 = this.AreaBorderNoBridge.GetUpperBound(0);
        for (let mut index31: i32 = 0; index31 <= upperBound6; index31 += 1)
          tObj[index30, index31] = this.AreaBorderNoBridge[index30, index31];
      }
      this.AreaBorderNoBridge = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut areaCount12: i32 = this.AreaCount;
      for (let mut index32: i32 = 0; index32 <= areaCount12; index32 += 1)
      {
        let mut areaCount13: i32 = this.AreaCount;
        for (let mut index33: i32 = 0; index33 <= areaCount13; index33 += 1)
          this.AreaBorderNoBridge[index32, index33] = tObj[index32, index33];
      }
      this.AreaIsExtra = (bool[]) Utils.CopyArray((Array) this.AreaIsExtra, (Array) new bool[this.AreaCount + 1]);
      let mut areaCount14: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount14; index += 1)
      {
        if (this.AreaIsExtra[index])
        {
          tObj = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
          numArray2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
        }
      }
      let mut mapWidth25: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut cx: i32 = 0; cx <= mapWidth25; cx += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
        {
          if (this.AreaMatrixNarrow[cx, cy] > 0)
          {
            let mut index34: i32 = this.AreaMatrixNarrow[cx, cy];
            if (this.AreaIsExtra[index34])
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap)
                {
                  let mut index35: i32 = this.AreaMatrixNarrow[coordinate1.x, coordinate1.y];
                  if (index35 > 0 & !this.AreaIsExtra[index35])
                  {
                    let mut num27: i32 = this.game.HandyFunctionsObj.Distance(this.AreaCenter[index34].x, this.AreaCenter[index34].y, 0, this.AreaCenter[index35].x, this.AreaCenter[index35].y, 0);
                    if (this.AreaBorder[index34, index35] == 0 | num27 < this.AreaBorder[index34, index35])
                    {
                      this.AreaBorder[index34, index35] = num27;
                      this.AreaWideBorder[index34, index35] = num27;
                      if (num27 > this.AreaBroadBorder[index34, index35])
                      {
                        this.AreaBroadBorder[index34, index35] = num27;
                        this.AreaBroadBorder[index35, index34] = num27;
                      }
                      this.AreaNarrowBorder[index34, index35] = num27;
                      this.AreaBorderNoBridge[index34, index35] = num27;
                      this.AreaBorder[index35, index34] = num27;
                      this.AreaWideBorder[index35, index34] = num27;
                      this.AreaNarrowBorder[index35, index34] = num27;
                      this.AreaBorderNoBridge[index35, index34] = num27;
                    }
                  }
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
              let mut num28: i32 = cx - 8;
              let mut num29: i32 = cx + 8;
              for (let mut index36: i32 = num28; index36 <= num29; index36 += 1)
              {
                let mut num30: i32 = cy - 8;
                let mut num31: i32 = cy - 8;
                for (let mut index37: i32 = num30; index37 <= num31; index37 += 1)
                {
                  if (index36 >= 0 & index36 <= this.game.Data.MapObj[0].MapWidth && index37 >= 0 & index37 <= this.game.Data.MapObj[0].MapHeight)
                  {
                    let mut index38: i32 = this.AreaMatrixNarrow[index36, index37];
                    if (index38 > 0 & !this.AreaIsExtra[index38])
                    {
                      let mut num32: i32 = this.game.HandyFunctionsObj.Distance(this.AreaCenter[index34].x, this.AreaCenter[index34].y, 0, this.AreaCenter[index38].x, this.AreaCenter[index38].y, 0);
                      if (num32 > this.AreaBroadBorder[index34, index38])
                      {
                        this.AreaBroadBorder[index34, index38] = num32;
                        this.AreaBroadBorder[index38, index34] = num32;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NARROW + WIDE AFTER EXTRA AREAS");
      if (tlog)
        this.AddLog("Real Area Count = " + Strings.Trim(Conversion.Str( this.RealAreaCount)));
      if (tlog)
        this.AddLog("(total) Area Count = " + Strings.Trim(Conversion.Str( this.AreaCount)));
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshots has been made.");
        this.Screenshot(1, "AREAMATRIX_NARROW_AFTER_EXTRA_AREA",  this.AreaMatrixNarrow);
        this.Screenshot(1, "AREAMATRIX_WIDE_AFTER_EXTRA_AREA",  this.AreaMatrixWide);
      }
      let mut mapWidth26: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index39: i32 = 0; index39 <= mapWidth26; index39 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index40: i32 = 0; index40 <= mapHeight; index40 += 1)
        {
          if (this.AreaMatrixNarrow[index39, index40] == 0 & this.AreaMatrixWide[index39, index40] > 0 & numArray19[index39, index40] == 1)
            this.AreaMatrixNarrow[index39, index40] = this.AreaMatrixWide[index39, index40];
        }
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("AREAMATRIX NARROW AFTER GIVING ANY 0 SETTINGS THE AREAMATRIX WIDE SETTING ");
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made.");
        this.Screenshot(1, "AREAMATRIX_NARROW_AFTER_WIDECHECK",  this.AreaMatrixNarrow);
      }
      this.SeaBorder = new int[this.SeaCount + 1, this.AreaCount + 1];
      let mut mapWidth27: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut cx: i32 = 0; cx <= mapWidth27; cx += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
        {
          if (this.SeaMatrix[cx, cy] > 0)
          {
            let mut tfacing: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate1.onmap && this.SeaMatrix[coordinate1.x, coordinate1.y] == 0 & this.AreaMatrixWide[coordinate1.x, coordinate1.y] > 0 && this.game.HandyFunctionsObj.IsHexPort(coordinate1.x, coordinate1.y, 0))
              {
                seaBorder: Vec<i32> = this.SeaBorder;
                numArray23: Vec<i32> = seaBorder;
                seaMatrix: Vec<i32> = this.SeaMatrix;
                numArray24: Vec<i32> = seaMatrix;
                let mut index41: i32 = cx;
                let mut index42: i32 = index41;
                let mut index43: i32 = cy;
                let mut index44: i32 = index43;
                let mut index45: i32 = numArray24[index42, index44];
                areaMatrixWide: Vec<i32> = this.AreaMatrixWide;
                numArray25: Vec<i32> = areaMatrixWide;
                let mut x: i32 = coordinate1.x;
                let mut index46: i32 = x;
                let mut y: i32 = coordinate1.y;
                let mut index47: i32 = y;
                let mut index48: i32 = numArray25[index46, index47];
                let mut num33: i32 = seaBorder[seaMatrix[index41, index43], areaMatrixWide[x, y]] + 1;
                numArray23[index45, index48] = num33;
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
        }
      }
      this.AreaStrength = new int[this.AreaCount + 1];
      this.AreaFuzzyVP = new int[this.AreaCount + 1];
      int[] numArray26 = new int[this.AreaCount + 1];
      let mut num34: i32 = 1;
      do
      {
        let mut areaCount15: i32 = this.AreaCount;
        for (let mut index49: i32 = 1; index49 <= areaCount15; index49 += 1)
        {
          if (num34 == 1)
          {
            this.AreaFuzzyVP[index49] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index49].x, this.AreaCenter[index49].y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index49].x, this.AreaCenter[index49].y];
            numArray26[index49] = this.AreaFuzzyVP[index49];
          }
          else
          {
            let mut num35: i32 = 0;
            let mut num36: i32 = 0;
            if (index49 == 47)
              index49 = index49;
            let mut areaCount16: i32 = this.AreaCount;
            for (let mut index50: i32 = 1; index50 <= areaCount16; index50 += 1)
            {
              if ((this.AreaBorder[index49, index50] > 0 | index49 == index50) & numArray26[index50] >= numArray26[index49])
              {
                if (index49 == index50)
                {
                  num35 += 10 * numArray26[index50];
                  num36 += 10;
                }
                else if (this.AreaBorder[index49, index50] <= 5)
                {
                  num35 += 10 * numArray26[index50];
                  num36 += 10;
                }
                else if (this.AreaBorder[index49, index50] <= 10)
                {
                  num35 += 6 * numArray26[index50];
                  num36 += 6;
                }
                else if (this.AreaBorder[index49, index50] <= 15)
                {
                  num35 += 3 * numArray26[index50];
                  num36 += 3;
                }
              }
            }
            if (num36 > 0)
              this.AreaFuzzyVP[index49] = Math.Max(0,  Math.Round( num35 /  num36));
          }
        }
        num34 += 1;
      }
      while (num34 <= 2);
      let mut areaCount17: i32 = this.AreaCount;
      for (let mut index: i32 = 0; index <= areaCount17; index += 1)
      {
        if (this.AreaFuzzyVP[index] < 1)
          this.AreaFuzzyVP[index] = 1;
      }
      this.AreaDefensive = new int[this.AreaCount + 1];
      if (!Information.IsNothing( this.game.Data.RegimeObj[this.GetGameDataTurn()].AIDefense[0]))
      {
        let mut mapWidth28: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut index51: i32 = 0; index51 <= mapWidth28; index51 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut index52: i32 = 0; index52 <= mapHeight; index52 += 1)
          {
            let mut num37: i32 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIDefense[0].Value[index51, index52];
            if (num37 > this.AreaDefensive[this.AreaMatrixNarrow[index51, index52]])
              this.AreaDefensive[this.AreaMatrixNarrow[index51, index52]] = num37;
          }
        }
      }
      this.CorpsTopRatio = new float[this.AreaCount + 1];
      if (!tlog)
        return;
      this.AddLog("");
      this.AddLog("AREA DATA CREATED:");
      let mut areaCount18: i32 = this.AreaCount;
      for (let mut index53: i32 = 1; index53 <= areaCount18; index53 += 1)
      {
        this.AddLog("");
        this.AddLog(Strings.Trim(Conversion.Str( index53)) + ", " + this.GetAreaName(index53, false) + " , " + Conversion.Str( this.AreaFuzzyVP[index53]) + " fuzzy VP, " + Strings.Trim(Conversion.Str( this.game.Data.MapObj[0].HexObj[this.AreaCenter[index53].x, this.AreaCenter[index53].y].VP)));
        this.AddLog("AreaDefensive is set to: " + Strings.Trim(Conversion.Str( this.AreaDefensive[index53])));
        this.AddLog("");
        this.AddLog("BRIDGES TOO:");
        let mut counter: i32 = this.AreaBridges[index53].Counter;
        for (let mut index54: i32 = 0; index54 <= counter; index54 += 1)
          this.AddLog("* " + this.GetAreaName(this.AreaBridges[index53].Id[index54]));
        this.AddLog("");
        this.AddLog("SEABORDER TOO:");
        let mut seaCount: i32 = this.SeaCount;
        for (let mut Number: i32 = 1; Number <= seaCount; Number += 1)
        {
          if (this.SeaBorder[Number, index53] > 0)
            this.AddLog("* Connection to Sea # " + Conversion.Str( Number));
        }
        this.AddLog("");
        this.AddLog("REGULAR BORDERS MATRIX:");
        let mut areaCount19: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount19; nr += 1)
        {
          if (this.AreaBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str( this.AreaBorder[index53, nr])));
        }
        this.AddLog("");
        this.AddLog("NARROW BORDERS MATRIX:");
        let mut areaCount20: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount20; nr += 1)
        {
          if (this.AreaNarrowBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str( this.AreaNarrowBorder[index53, nr])));
        }
        this.AddLog("");
        this.AddLog("BROAD BORDERS MATRIX:");
        let mut areaCount21: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount21; nr += 1)
        {
          if (this.AreaBroadBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str( this.AreaBroadBorder[index53, nr])));
        }
        this.AddLog("");
        this.AddLog("NO BRIDGE BORDERS MATRIX:");
        let mut areaCount22: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount22; nr += 1)
        {
          if (this.AreaBorder[index53, nr] > 0 | this.AreaNarrowBorder[index53, nr] > 0 | this.AreaBroadBorder[index53, nr] > 0)
            this.AddLog(this.GetAreaName(index53) + " => " + this.GetAreaName(nr) + " = " + Strings.Trim(Conversion.Str( this.AreaBorderNoBridge[index53, nr])));
        }
      }
    }

    pub fn ResetExtraAreaMemory(bool tlog)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("RESET EXTRA AREA MEMORY:");
      let mut num1: i32 = 0;
      do
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut Number: i32 = 0; Number <= unitCounter; Number += 1)
        {
          if (this.game.Data.UnitObj[Number].X > -1 & this.game.Data.UnitObj[Number].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[Number].Regime) == this.GetGameDataTurn())
          {
            num2: i32;
            switch (num1)
            {
              case 0:
                num2 = this.game.Data.UnitObj[Number].AIAttack;
                break;
              case 1:
                num2 = this.game.Data.UnitObj[Number].AIFollowup;
                break;
              case 2:
                num2 = this.game.Data.UnitObj[Number].AIDefend;
                break;
              case 3:
                num2 = this.game.Data.UnitObj[Number].AIFallback;
                break;
            }
            if (num2 > this.RealAreaCount)
            {
              switch (num1)
              {
                case 0:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str( Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIAttack is set to attack an extra area");
                    break;
                  }
                  break;
                case 1:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str( Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIFollowUp is set to attack an extra area");
                    break;
                  }
                  break;
                case 2:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str( Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIDefend is set to attack an extra area");
                    break;
                  }
                  break;
                case 3:
                  if (tlog)
                  {
                    this.AddLog("");
                    this.AddLog(Strings.Trim(Conversion.Str( Number)) + ", " + this.game.Data.UnitObj[Number].Name + " memory AIFallBack is set to attack an extra area");
                    break;
                  }
                  break;
              }
              int[] numArray2 = new int[this.AreaCount + 1];
              let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
              {
                let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
                {
                  if (this.AreaMatrixNarrow[index1, index2] > this.RealAreaCount && this.game.Data.RegimeObj[this.GetGameDataTurn()].OldAINarrow[0].Value[index1, index2] == this.game.Data.UnitObj[Number].AIAttack)
                  {
                    int[] numArray3 = numArray2;
                    int[] numArray4 = numArray3;
                    areaMatrixNarrow: Vec<i32> = this.AreaMatrixNarrow;
                    numArray5: Vec<i32> = areaMatrixNarrow;
                    let mut index3: i32 = index1;
                    let mut index4: i32 = index3;
                    let mut index5: i32 = index2;
                    let mut index6: i32 = index5;
                    let mut index7: i32 = numArray5[index4, index6];
                    let mut num3: i32 = numArray3[areaMatrixNarrow[index3, index5]] + 1;
                    numArray4[index7] = num3;
                  }
                }
              }
              let mut nr: i32 = 0;
              let mut num4: i32 = 0;
              let mut areaCount: i32 = this.AreaCount;
              for (let mut index: i32 = 0; index <= areaCount; index += 1)
              {
                if (numArray2[index] > num4)
                {
                  num4 = numArray2[index];
                  nr = index;
                }
              }
              if (nr > 0)
              {
                if (num1 == 0)
                  this.game.Data.UnitObj[Number].AIAttack = nr;
                if (num1 == 1)
                  this.game.Data.UnitObj[Number].AIFollowup = nr;
                if (num1 == 2)
                  this.game.Data.UnitObj[Number].AIDefend = nr;
                if (num1 == 3)
                  this.game.Data.UnitObj[Number].AIFallback = nr;
                this.AddLog(Strings.Trim(Conversion.Str( Number)) + ", " + this.game.Data.UnitObj[Number].Name + " has been given area " + this.GetAreaName(nr));
              }
              else
              {
                if (num1 == 0)
                  this.game.Data.UnitObj[Number].AIAttack = -1;
                if (num1 == 1)
                  this.game.Data.UnitObj[Number].AIFollowup = -1;
                if (num1 == 2)
                  this.game.Data.UnitObj[Number].AIDefend = -1;
                if (num1 == 3)
                  this.game.Data.UnitObj[Number].AIFallback = -1;
                this.AddLog(Strings.Trim(Conversion.Str( Number)) + ", " + this.game.Data.UnitObj[Number].Name + " is set to attack -1");
              }
            }
          }
        }
        num1 += 1;
      }
      while (num1 <= 3);
    }

    pub fn MakeDistanceEnemyToArea(bool tlog)
    {
      let mut powerPointsAbsolute: i32 = this.GetAverageEnemyUnitPowerPointsAbsolute();
      let mut num1: i32 = 8;
      this.AreaClosestEnemy = new int[this.AreaCount + 1];
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("MAKE DISTANCE ENEMY TO AREA:");
      let mut areaCount: i32 = this.AreaCount;
      for (let mut nr: i32 = 1; nr <= areaCount; nr += 1)
      {
        let mut x: i32 = this.AreaCenter[nr].x;
        let mut y: i32 = this.AreaCenter[nr].y;
        let mut Number: i32 = 99;
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
        {
          this.AreaClosestEnemy[nr] = 0;
        }
        else
        {
          let mut num2: i32 = x - num1;
          let mut num3: i32 = x + num1;
          for (let mut x2: i32 = num2; x2 <= num3; x2 += 1)
          {
            let mut num4: i32 = y - num1;
            let mut num5: i32 = y + num1;
            for (let mut y2: i32 = num4; y2 <= num5; y2 += 1)
            {
              if (x2 > -1 & y2 > -1 & x2 <= this.game.Data.MapObj[0].MapWidth & y2 <= this.game.Data.MapObj[0].MapHeight && this.GetRegime(this.game.Data.MapObj[0].HexObj[x2, y2].Regime) != this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter > -1)
              {
                let mut num6: i32 = 0;
                let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter;
                for (let mut index: i32 = 0; index <= unitCounter; index += 1)
                {
                  if ( this.GetUnitPower(this.game.Data.MapObj[0].HexObj[x2, y2].UnitList[index], false) >  powerPointsAbsolute / 10.0)
                  {
                    num6 = 1;
                    break;
                  }
                }
                if (num6 == 1)
                {
                  let mut num7: i32 = this.game.HandyFunctionsObj.Distance(x, y, 0, x2, y2, 0);
                  if (num7 < Number)
                    Number = num7;
                }
              }
            }
          }
          this.AreaClosestEnemy[nr] = Number;
          if (tlog)
            this.AddLog(this.GetAreaName(nr) + " => " + Strings.Trim(Conversion.Str( Number)));
        }
      }
    }

    pub fn MakeGroups(bool tlog)
    {
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("MAKE GROUPS:");
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      this.CorpsSource = new int[this.GroupCounter + 1];
      this.CorpsTopGroup = new int[this.GroupCounter + 1];
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount1; index += 1)
        numArray3[index] = -1;
      if (this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupCounter > 0)
      {
        this.GroupCounter = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupCounter;
        this.GroupType = new int[this.GroupCounter + 1];
        this.GroupHis = new int[this.GroupCounter + 1];
        this.GroupName = new string[this.GroupCounter + 1];
        this.GroupAttack = new int[this.GroupCounter + 1];
        this.GroupDefend = new int[this.GroupCounter + 1];
        this.GroupFallBack = new int[this.GroupCounter + 1];
        this.GroupFollowUp = new int[this.GroupCounter + 1];
        this.TempGroupTarget = new int[this.GroupCounter + 1];
        this.CorpsLoc = new int[this.GroupCounter + 1];
        this.CorpsTopGroup = new int[this.GroupCounter + 1];
        if (tlog)
          this.AddLog("");
        if (tlog)
          this.AddLog("IMPORT GROUPS FROM REGIME MEMORY");
        let mut groupCounter1: i32 = this.GroupCounter;
        for (let mut Number: i32 = 0; Number <= groupCounter1; Number += 1)
        {
          this.GroupType[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupType[Number];
          this.GroupName[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupName[Number];
          this.GroupHis[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupHis[Number];
          this.GroupAttack[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastAttack[Number];
          this.GroupDefend[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastDefend[Number];
          this.GroupFollowUp[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFollowUp[Number];
          this.GroupFallBack[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFallBack[Number];
          this.CorpsTopGroup[Number] = this.game.Data.RegimeObj[this.game.Data.Turn].AICorpsTopGroup[Number];
          if (tlog)
            this.AddLog(Strings.Trim(Conversion.Str( Number)) + ", " + this.GroupName[Number] + ", Type=" + Strings.Trim(Conversion.Str( this.GroupType[Number])));
        }
        if (tlog)
          this.AddLog("");
        if (tlog)
          this.AddLog("RESET UNITS THAT ARE SET TO NON-EXISTING GROUP");
        let mut unitCounter1: i32 = this.game.Data.UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
        {
          if (this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].PreDef == -1)
          {
            if (this.game.Data.UnitObj[index].AIGroup > this.GroupCounter)
            {
              this.game.Data.UnitObj[index].AIGroup = -1;
              if (tlog)
                this.AddLog(this.game.Data.UnitObj[index].Name + " has been reset to group -1");
            }
            let mut hq: i32 = this.game.Data.UnitObj[index].HQ;
            if (hq > -1 && this.GetRegime(this.game.Data.UnitObj[hq].Regime) != this.GetGameDataTurn())
              this.game.Data.UnitObj[index].HQ = -1;
          }
        }
        if (tlog)
          this.AddLog("");
        if (tlog)
          this.AddLog("REMOVE GROUPS DUE TO NO UNITS LEFT ASSIGNED TO IT");
        for (let mut groupCounter2: i32 = this.GroupCounter; groupCounter2 >= 0; groupCounter2 += -1)
        {
          if (this.GetGroupHQ(groupCounter2) == -1)
          {
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str( groupCounter2)) + ", " + this.GroupName[groupCounter2] + " is being removed.");
            let mut num1: i32 = groupCounter2;
            let mut num2: i32 = this.GroupCounter - 1;
            for (let mut index: i32 = num1; index <= num2; index += 1)
            {
              this.GroupType[index] = this.GroupType[index + 1];
              this.GroupName[index] = this.GroupName[index + 1];
              this.GroupAttack[index] = this.GroupAttack[index + 1];
              this.GroupDefend[index] = this.GroupDefend[index + 1];
              this.GroupFallBack[index] = this.GroupFallBack[index + 1];
              this.GroupFollowUp[index] = this.GroupFollowUp[index + 1];
              this.GroupHis[index] = this.GroupHis[index + 1];
            }
            --this.GroupCounter;
            let mut unitCounter2: i32 = this.game.Data.UnitCounter;
            for (let mut index: i32 = 0; index <= unitCounter2; index += 1)
            {
              if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup >= groupCounter2 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
                --this.game.Data.UnitObj[index].AIGroup;
            }
          }
        }
      }
      else if (this.game.Data.Round <= 1)
      {
        this.GroupType = new int[this.game.Data.UnitCounter + 1];
        this.GroupHis = new int[this.game.Data.UnitCounter + 1];
        this.GroupName = new string[this.game.Data.UnitCounter + 1];
        this.GroupAttack = new int[this.game.Data.UnitCounter + 1];
        this.GroupDefend = new int[this.game.Data.UnitCounter + 1];
        this.GroupFallBack = new int[this.game.Data.UnitCounter + 1];
        this.GroupFollowUp = new int[this.game.Data.UnitCounter + 1];
        this.TempGroupTarget = new int[this.GroupCounter + 1];
        this.CorpsLoc = new int[this.GroupCounter + 1];
        this.CorpsTopGroup = new int[this.GroupCounter + 1];
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount2; index += 1)
          numArray2[index] = -1;
        this.GroupCounter = -1;
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter; index += 1)
        {
          if (this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
            this.game.Data.UnitObj[index].AIGroup = -1;
        }
      }
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("START MAKING GROUPS AND ASSIGNING UNITS");
      }
      this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[991]);
      let mut unitCounter3: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter3; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup == -1 && this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].Historical > -1 && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.Data.UnitObj[unr].IsHQ)
        {
          let mut historical: i32 = this.game.Data.UnitObj[unr].Historical;
          this += 1.GroupCounter;
          this.GroupType[this.GroupCounter] = this.game.Data.HistoricalUnitObj[historical].Type;
          this.GroupHis[this.GroupCounter] = historical;
          this.CorpsTopGroup[this.GroupCounter] = -1;
          this.GroupName[this.GroupCounter] = this.game.Data.UnitObj[unr].Name;
          this.game.Data.UnitObj[unr].AIGroup = this.GroupCounter;
          let mut index: i32 = this.AreaMatrixWide[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
          if (index > 0 & this.GroupType[this.GroupCounter] <= 5)
            numArray3[index] = this.GroupCounter;
          if (tlog)
            this.AddLog("(A) Created Historical Group on " + this.game.Data.UnitObj[unr].Name + ", type=" + Strings.Trim(Conversion.Str( this.GroupType[this.GroupCounter])));
        }
      }
      let mut unitCounter4: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter4; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[unr].AIGroup == -1 && !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
        {
          let mut index1: i32 = this.game.Data.UnitObj[unr].HQ;
          if (this.game.Data.UnitObj[unr].IsHQ)
            index1 = -1;
          if (index1 > -1)
          {
            if (this.game.Data.UnitObj[index1].AIGroup > -1 && this.GroupType[this.game.Data.UnitObj[index1].AIGroup] <= 5 | this.game.HandyFunctionsObj.HasUnitAirSF(unr))
            {
              let mut historical: i32 = this.game.Data.UnitObj[index1].Historical;
              if (historical > -1)
              {
                let mut group: i32 = this.GetGroup(historical);
                if (group > -1)
                {
                  let mut x1: i32 = this.game.Data.UnitObj[unr].X;
                  let mut y1: i32 = this.game.Data.UnitObj[unr].Y;
                  let mut x2: i32 = this.game.Data.UnitObj[index1].X;
                  let mut y2: i32 = this.game.Data.UnitObj[index1].Y;
                  let mut num: i32 = 0;
                  if (this.AreaMatrixWide[x1, y1] == this.AreaMatrixWide[x2, y2])
                    num = 1;
                  if (this.AreaMatrixNarrow[x1, y1] == this.AreaMatrixWide[x2, y2])
                    num = 1;
                  if (this.AreaMatrixWide[x1, y1] == this.AreaMatrixNarrow[x2, y2])
                    num = 1;
                  if (this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0) <= 5)
                    num = 1;
                  if (this.game.HandyFunctionsObj.HasUnitAirSF(unr))
                    num = 1;
                  if (num == 1)
                  {
                    if (tlog)
                      this.AddLog("(A2) " + this.game.Data.UnitObj[unr].Name + " has been added to group " + Strings.Trim(Conversion.Str( group)) + " of HQ: " + this.game.Data.UnitObj[index1].Name);
                    this.game.Data.UnitObj[unr].AIGroup = group;
                  }
                }
              }
            }
          }
          else if (this.game.Data.UnitObj[unr].HQ == -1 & !this.game.Data.UnitObj[unr].IsHQ)
          {
            let mut index2: i32 = this.AreaMatrixWide[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
            if (index2 < 1)
              index2 = this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
            if (index2 > 0 && numArray3[index2] > -1)
              this.game.Data.UnitObj[unr].AIGroup = numArray3[index2];
          }
        }
      }
      let mut groupCounter3: i32 = this.GroupCounter;
      for (let mut index: i32 = 0; index <= groupCounter3; index += 1)
      {
        if (this.GroupType[index] <= 5)
        {
          let mut groupHq: i32 = this.GetGroupHQ(index);
          if (groupHq > -1)
          {
            let mut unitCounter5: i32 = this.game.Data.UnitCounter;
            for (let mut unr: i32 = 0; unr <= unitCounter5; unr += 1)
            {
              if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X > -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == -1 & !this.game.Data.UnitObj[unr].IsHQ && !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
              {
                let mut x3: i32 = this.game.Data.UnitObj[unr].X;
                let mut y3: i32 = this.game.Data.UnitObj[unr].Y;
                let mut x4: i32 = this.game.Data.UnitObj[groupHq].X;
                let mut y4: i32 = this.game.Data.UnitObj[groupHq].Y;
                let mut num: i32 = 0;
                if (this.AreaMatrixWide[x3, y3] == this.AreaMatrixWide[x4, y4])
                  num = 1;
                if (this.AreaMatrixNarrow[x3, y3] == this.AreaMatrixWide[x4, y4])
                  num = 1;
                if (this.AreaMatrixWide[x3, y3] == this.AreaMatrixNarrow[x4, y4])
                  num = 1;
                if (this.GroupType[index] == 1 & this.game.HandyFunctionsObj.Distance(x3, y3, 0, x4, y4, 0) <= 5)
                  num = 1;
                else if ( this.game.Data.RuleVar[888] == 1.0 & this.GroupType[index] == 5 & this.game.Data.UnitObj[unr].HQ == groupHq)
                  num = 1;
                if (this.game.HandyFunctionsObj.HasUnitAirSF(unr))
                  num = 1;
                if (num == 1)
                {
                  this.game.Data.UnitObj[unr].AIGroup = index;
                  if (tlog)
                    this.AddLog("(B) " + this.game.Data.UnitObj[unr].Name + " has been added to group: " + Strings.Trim(Conversion.Str( index)) + ", " + this.GroupName[index]);
                }
              }
            }
          }
        }
      }
      let mut groupCounter4: i32 = this.GroupCounter;
      index3: i32;
      for (index3 = 0; index3 <= groupCounter4; index3 += 1)
      {
        if (this.GroupType[index3] == 1)
        {
          let mut groupHq: i32 = this.GetGroupHQ(index3);
          if (groupHq > -1)
          {
            let mut index4: i32 = this.AreaMatrixNarrow[this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y];
            if (index4 > -1)
            {
              numArray2[index4] = index3;
              numArray1[index4] = 1;
            }
          }
        }
      }
      let mut unitCounter6: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter6; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() && !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.Data.UnitObj[unr].AIGroup == -1)
        {
          let mut x: i32 = this.game.Data.UnitObj[unr].X;
          let mut y: i32 = this.game.Data.UnitObj[unr].Y;
          let mut nr: i32 = this.AreaMatrixNarrow[x, y];
          if (nr < 1)
            nr = this.AreaMatrixWide[x, y];
          if (nr > 0)
          {
            if (numArray1[nr] == 0)
            {
              this += 1.GroupCounter;
              this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
              this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
              this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
              this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
              this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
              this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
              this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
              this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
              this.CorpsTopGroup[this.GroupCounter] = -1;
              this.GroupType[this.GroupCounter] = 1;
              this.GroupHis[this.GroupCounter] = -1;
              this.GroupName[this.GroupCounter] = "KAMPFGRUPPE " + this.GetAreaName(nr, false);
              this.game.Data.UnitObj[unr].AIGroup = this.GroupCounter;
              numArray1[nr] = 1;
              numArray2[nr] = this.GroupCounter;
              if (tlog)
                this.AddLog("(C) " + this.game.Data.UnitObj[unr].Name + " has been used to base a kampfgruppe on: " + Strings.Trim(Conversion.Str( index3)) + " , " + this.GroupName[index3]);
            }
            else if (numArray2[nr] > -1)
            {
              this.game.Data.UnitObj[unr].AIGroup = numArray2[nr];
              if (tlog)
                this.AddLog("(C) " + this.game.Data.UnitObj[unr].Name + " is added to existing kampfgruppe: " + Strings.Trim(Conversion.Str( numArray2[nr])) + " , " + this.GroupName[numArray2[nr]]);
            }
          }
        }
      }
      int[] numArray4 = new int[2];
      if ( this.game.Data.RuleVar[889] > 0.0)
      {
        let mut groupCounter5: i32 = this.GroupCounter;
        for (let mut index5: i32 = 0; index5 <= groupCounter5; index5 += 1)
        {
          if (this.GroupType[index5] == 5)
          {
            int[] numArray5 = new int[this.game.Data.UnitCounter + 1];
            SimpleList simpleList = SimpleList::new();
            let mut unitCounter7: i32 = this.game.Data.UnitCounter;
            for (let mut index6: i32 = 0; index6 <= unitCounter7; index6 += 1)
            {
              if (this.game.Data.UnitObj[index6].X > -1 & this.game.Data.UnitObj[index6].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index6].AIGroup == index5)
              {
                let mut historical: i32 = this.game.Data.UnitObj[index6].Historical;
                if (historical > -1 && this.game.Data.HistoricalUnitObj[historical].Type == 2)
                {
                  numArray5[index6] = 1;
                  let mut tweight: i32 = 1;
                  let mut unitCounter8: i32 = this.game.Data.UnitCounter;
                  for (let mut index7: i32 = 0; index7 <= unitCounter8; index7 += 1)
                  {
                    if (this.game.Data.UnitObj[index7].PreDef == -1 & this.game.Data.UnitObj[index7].X > -1 & this.game.Data.UnitObj[index7].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index7].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index7].AIGroup == index5 && historical == this.game.Data.UnitObj[index7].Historical)
                    {
                      numArray5[index7] = 1;
                      tweight += 1;
                    }
                  }
                  simpleList.Add(historical, tweight);
                }
              }
            }
            if (simpleList.Counter > 0)
            {
              let mut counter: i32 = simpleList.Counter;
              for (let mut index8: i32 = 0; index8 <= counter; index8 += 1)
              {
                let mut index9: i32 = simpleList.Id[index8];
                if (simpleList.Weight[index8] > 1)
                {
                  this += 1.GroupCounter;
                  this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
                  this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
                  this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
                  this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
                  this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
                  this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
                  this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
                  this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
                  this.GroupType[this.GroupCounter] = 2;
                  this.GroupHis[this.GroupCounter] = index9;
                  this.CorpsTopGroup[this.GroupCounter] = index5;
                  this.GroupName[this.GroupCounter] = "Subcorps " + this.game.Data.HistoricalUnitObj[index9].Name;
                  let mut unitCounter9: i32 = this.game.Data.UnitCounter;
                  for (let mut index10: i32 = 0; index10 <= unitCounter9; index10 += 1)
                  {
                    if (this.game.Data.UnitObj[index10].Historical == index9)
                      this.game.Data.UnitObj[index10].AIGroup = this.GroupCounter;
                  }
                  if (tlog)
                    this.AddLog("(D) Created Subcorps Group on " + this.GroupName[this.GroupCounter] + ", type=" + Strings.Trim(Conversion.Str( this.GroupType[this.GroupCounter])));
                }
              }
            }
          }
        }
      }
      if (this.GroupCounter > -1)
      {
        this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
        this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
        this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
        this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
        this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
        this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
        this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
        this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
        this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
      }
      this.CorpsStrength = new int[this.GroupCounter + 1];
      this.CorpsAirStrength = new int[this.GroupCounter + 1];
      this.CorpsTempAirStrength = new int[this.GroupCounter + 1];
    }

    pub fn MakeCorpsAndAreaAssesment(bool tlog)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      this.HisAreaDistance = new int[this.GroupCounter + 1, this.AreaCount + 1];
      this.HisAreaDistanceFriendly = new int[this.GroupCounter + 1, this.AreaCount + 1];
      this.CorpsStartLoc = new int[this.GroupCounter + 1];
      this.CorpsEngineer = new bool[this.GroupCounter + 1];
      this.CorpsLandStrength = new int[this.GroupCounter + 1];
      this.CorpsAirStrength = new int[this.GroupCounter + 1];
      this.CorpsBottleneck = new int[this.GroupCounter + 1];
      this.CorpsOldDefend = new int[this.GroupCounter + 1];
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("CORPS STRENGTH ASSESMENT");
      }
      let mut groupCounter1: i32 = this.GroupCounter;
      for (let mut grp: i32 = 0; grp <= groupCounter1; grp += 1)
      {
        this.CorpsOldDefend[grp] = -1;
        let mut Number1: i32 = 0;
        let mut Number2: i32 = 0;
        let mut num1: i32 = 0;
        let mut num2: i32 = 0;
        let mut num3: i32 = 1;
        SimpleList simpleList = SimpleList::new();
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
        {
          if (this.game.Data.UnitObj[unr].AIBottleneck > 0)
            unr = unr;
          if (this.game.Data.UnitObj[unr].PreDef == -1 && !this.game.Data.UnitObj[unr].IsHQ & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup == grp)
          {
            let mut unitPower: i32 = this.GetUnitPower(unr, true, Theater: 0);
            if (this.game.Data.UnitObj[unr].TempCategory == 1)
              num3 += unitPower;
            let mut num4: i32 = unitPower +  Math.Round( unitPower * ( this.GetAIRolePercent(unr, 10) / 200.0));
            let mut num5: i32 = num4 +  Math.Round( num4 * ( this.GetAIRolePercent(unr, 8) / 100.0));
            Number1 += num5;
            Number2 += this.GetUnitPower(unr, true, Theater: 2);
            num1 += this.game.HandyFunctionsObj.GetUnitEPGrowth(unr);
            if (this.game.Data.UnitObj[unr].TempCategory == 1)
            {
              int[] corpsLandStrength = this.CorpsLandStrength;
              int[] numArray4 = corpsLandStrength;
              let mut index1: i32 = grp;
              let mut index2: i32 = index1;
              let mut num6: i32 = corpsLandStrength[index1] + num5;
              numArray4[index2] = num6;
            }
            if (this.game.Data.UnitObj[unr].AIBottleneck > 0)
              num2 += this.game.Data.UnitObj[unr].AIBottleneck * num5;
            let mut aiDefend: i32 = this.game.Data.UnitObj[unr].AIDefend;
            if (aiDefend > -1)
            {
              let mut nr: i32 = simpleList.FindNr(aiDefend);
              if (nr == -1)
              {
                simpleList.Add(aiDefend, 1);
              }
              else
              {
                int[] weight = simpleList.Weight;
                int[] numArray5 = weight;
                let mut index3: i32 = nr;
                let mut index4: i32 = index3;
                let mut num7: i32 = weight[index3] + 1;
                numArray5[index4] = num7;
              }
            }
          }
        }
        if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 1.0)
          Number1 =  Math.Round( ( Number1 * (1f / this.game.Data.RegimeObj[this.game.Data.Turn].AIConservative)));
        this.CorpsStrength[grp] = Number1;
        this.CorpsBottleneck[grp] =  Math.Round( num2 /  num3) >= 10 ? ( Math.Round( num2 /  num3) >= 20 ? ( Math.Round( num2 /  num3) >= 30 ? ( Math.Round( num2 /  num3) >= 50 ? ( Math.Round( num2 /  num3) >= 80 ? 15 : 25) : 40) : 60) : 75) : 0;
        simpleList.Sort();
        this.CorpsOldDefend[grp] = -1;
        if (simpleList.Counter > -1)
          this.CorpsOldDefend[grp] = simpleList.Id[simpleList.Counter];
        this.CorpsAirStrength[grp] = Number2;
        if (num1 >= 50)
          this.CorpsEngineer[grp] = true;
        this.CorpsStartLoc[grp] = this.GetStartArea(grp);
        Coordinate averageCorpsUnitCoord1 = this.GetAverageCorpsUnitCoord(grp);
        if (tlog)
        {
          this.AddLog("");
          this.AddLog(this.GroupName[grp] + " ==> STARTLOC = " + this.GetAreaName(this.GetStartArea(grp)) + " ... CORPSSTRENGTH=" + Conversion.Str( Number1) + ", CORPSAIRSTRENGTH=" + Conversion.Str( Number2) + "  Engineer=" + Conversion.Str( this.CorpsEngineer[grp]) + "   (avgloc=" + Conversion.Str( averageCorpsUnitCoord1.x) + "," + Conversion.Str( averageCorpsUnitCoord1.y) + ")");
        }
        if (tlog)
        {
          this.AddLog("");
          this.AddLog(this.GroupName[grp] + " ==> OLDDEFENDAREA = " + this.GetAreaName(this.CorpsOldDefend[grp]) + " ... BOTTLENECK=" + Conversion.Str( this.CorpsBottleneck[grp]));
        }
        Coordinate averageCorpsUnitCoord2 = this.GetAverageCorpsUnitCoord(grp, ReturnRoadHex: true);
        let mut moveTypeCorpsUnit: i32 = this.GetAverageMoveTypeCorpsUnit(grp);
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, moveTypeCorpsUnit, 0, 600, averageCorpsUnitCoord2.x, averageCorpsUnitCoord2.y, 0, dontenterenemy: false, NoBridgePenalty: true);
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("HISAREADISTANCE:");
        }
        let mut areaCount1: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount1; nr += 1)
        {
          this.HisAreaDistance[grp, nr] = this.game.EditObj.TempValue[0].Value[this.AreaCenter[nr].x, this.AreaCenter[nr].y];
          if (this.HisAreaDistance[grp, nr] < 9999 && tlog)
            this.AddLog(this.GetAreaName(nr) + " => AP cost = " + Conversion.Str( this.HisAreaDistance[grp, nr]));
        }
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn, moveTypeCorpsUnit, 0, 600, averageCorpsUnitCoord2.x, averageCorpsUnitCoord2.y, 0, NoBridgePenalty: true);
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("HISAREADISTANCE FRIENDLY:");
        }
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount2; nr += 1)
        {
          this.HisAreaDistanceFriendly[grp, nr] = this.game.EditObj.TempValue[0].Value[this.AreaCenter[nr].x, this.AreaCenter[nr].y];
          if (this.HisAreaDistanceFriendly[grp, nr] < 9999 && tlog)
            this.AddLog(this.GetAreaName(nr) + " => AP cost (friendly) = " + Conversion.Str( this.HisAreaDistance[grp, nr]));
        }
      }
      this.AreaStrength = new int[this.AreaCount + 1];
      int[] numArray6 = new int[this.AreaCount + 1];
      int[] numArray7 = new int[this.AreaCount + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index5: i32 = 0; index5 <= mapWidth1; index5 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index6: i32 = 0; index6 <= mapHeight; index6 += 1)
        {
          let mut num8: i32 = this.AreaMatrixNarrow[index5, index6];
          if (num8 > 0)
          {
            let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[index5, index6].UnitCounter;
            for (let mut index7: i32 = 0; index7 <= unitCounter; index7 += 1)
            {
              let mut unit: i32 = this.game.Data.MapObj[0].HexObj[index5, index6].UnitList[index7];
              if (this.GetRegime(this.game.Data.UnitObj[unit].Regime) != this.GetGameDataTurn())
              {
                let mut unitPower: i32 = this.GetUnitPower(unit, false, WithoutEntrench: true);
                int[] areaStrength = this.AreaStrength;
                int[] numArray8 = areaStrength;
                let mut index8: i32 = num8;
                let mut index9: i32 = index8;
                let mut num9: i32 = areaStrength[index8] + unitPower;
                numArray8[index9] = num9;
                if (this.game.Data.UnitObj[unit].LastSupplyPercent > -1)
                {
                  int[] numArray9 = numArray6;
                  int[] numArray10 = numArray9;
                  let mut index10: i32 = num8;
                  let mut index11: i32 = index10;
                  let mut num10: i32 = numArray9[index10] + unitPower * this.game.Data.UnitObj[unit].LastSupplyPercent;
                  numArray10[index11] = num10;
                }
              }
            }
          }
        }
      }
      this.StartEnemySupplyGone = new int[this.AreaCount + 1];
      let mut areaCount3: i32 = this.AreaCount;
      for (let mut index12: i32 = 1; index12 <= areaCount3; index12 += 1)
      {
        this.StartEnemySupplyGone[index12] = 0;
        if (this.AreaStrength[index12] > 0 & this.game.Data.Round > 1)
        {
          let mut num: i32 =  Math.Round( numArray6[index12] /  this.AreaStrength[index12]);
          if (num < 10)
            this.StartEnemySupplyGone[index12] = 2;
          else if (num < 50)
            this.StartEnemySupplyGone[index12] = 1;
        }
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index12].x, this.AreaCenter[index12].y].Regime) != this.GetGameDataTurn())
        {
          let mut num11: i32 = 0;
          let mut areaCount4: i32 = this.AreaCount;
          for (let mut index13: i32 = 1; index13 <= areaCount4; index13 += 1)
          {
            if (this.AreaNarrowBorder[index13, index12] > 0 & this.AreaNarrowBorder[index13, index12] < 99 & index13 != index12 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index13].x, this.AreaCenter[index13].y].Regime) != this.GetGameDataTurn())
              num11 += 1;
          }
          if (num11 > 0)
          {
            let mut areaCount5: i32 = this.AreaCount;
            for (let mut index14: i32 = 1; index14 <= areaCount5; index14 += 1)
            {
              if (this.AreaNarrowBorder[index14, index12] > 0 & this.AreaNarrowBorder[index14, index12] < 99 & index14 != index12 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index14].x, this.AreaCenter[index14].y].Regime) != this.GetGameDataTurn())
              {
                int[] numArray11 = numArray1;
                int[] numArray12 = numArray11;
                let mut index15: i32 = index14;
                let mut index16: i32 = index15;
                let mut num12: i32 = numArray11[index15] +  Math.Round( this.AreaStrength[index12] / 3.0 /  num11);
                numArray12[index16] = num12;
                int[] numArray13 = numArray1;
                int[] numArray14 = numArray13;
                let mut index17: i32 = index12;
                let mut index18: i32 = index17;
                let mut num13: i32 = numArray13[index17] -  Math.Round( this.AreaStrength[index12] / 3.0 /  num11);
                numArray14[index18] = num13;
              }
            }
          }
        }
      }
      let mut areaCount6: i32 = this.AreaCount;
      for (let mut index19: i32 = 1; index19 <= areaCount6; index19 += 1)
      {
        int[] areaStrength = this.AreaStrength;
        int[] numArray15 = areaStrength;
        let mut index20: i32 = index19;
        let mut index21: i32 = index20;
        let mut num: i32 = areaStrength[index20] + numArray1[index19];
        numArray15[index21] = num;
      }
      this.AddLog("AREA STRENGTH ASSESMENT");
      this.AreaSupplyBorder = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreasupplyborderSea = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaSupplyBorderEither = new int[this.AreaCount + 1, this.AreaCount + 1];
      this.AreaSupplyBorderCount = new int[this.AreaCount + 1];
      if (tlog)
        this.AddLog("SUPPLYBORDER:");
      let mut areaCount7: i32 = this.AreaCount;
      for (let mut nr: i32 = 1; nr <= areaCount7; nr += 1)
      {
        this.AreaSupplyBorderCount[nr] = -1;
        let mut areaCount8: i32 = this.AreaCount;
        for (let mut index22: i32 = 1; index22 <= areaCount8; index22 += 1)
        {
          let mut num14: i32 = 0;
          if (this.AreaNarrowBorder[nr, index22] > 0)
          {
            num14 = 1;
            int[] supplyBorderCount = this.AreaSupplyBorderCount;
            int[] numArray16 = supplyBorderCount;
            let mut index23: i32 = nr;
            let mut index24: i32 = index23;
            let mut num15: i32 = supplyBorderCount[index23] + 1;
            numArray16[index24] = num15;
            this.AreaSupplyBorder[nr, this.AreaSupplyBorderCount[nr]] = index22;
            this.AreaSupplyBorderEither[nr, this.AreaSupplyBorderCount[nr]] = index22;
            if (tlog)
              this.AddLog("SUPPLY BORDER: " + this.GetAreaName(nr) + "," + this.GetAreaName(index22));
          }
          if (this.AreaSeaConnect(nr, index22))
          {
            if (num14 == 0)
            {
              int[] supplyBorderCount = this.AreaSupplyBorderCount;
              int[] numArray17 = supplyBorderCount;
              let mut index25: i32 = nr;
              let mut index26: i32 = index25;
              let mut num16: i32 = supplyBorderCount[index25] + 1;
              numArray17[index26] = num16;
            }
            this.AreasupplyborderSea[nr, this.AreaSupplyBorderCount[nr]] = index22;
            this.AreaSupplyBorderEither[nr, this.AreaSupplyBorderCount[nr]] = index22;
            if (tlog)
              this.AddLog("SUPPLY BORDER SEA/ EITHER: " + this.GetAreaName(nr) + "," + this.GetAreaName(index22));
          }
        }
      }
      if (tlog)
        this.AddLog("AREASTRENGTH:");
      let mut upperBound: i32 = this.AreaStrength.GetUpperBound(0);
      for (let mut Number: i32 = 1; Number <= upperBound; Number += 1)
      {
        hexName: String = this.game.HandyFunctionsObj.GetHexName(this.AreaCenter[Number].x, this.AreaCenter[Number].y, 0);
        if (this.AreaStrength[Number] > 0 & tlog)
          this.AddLog(Conversion.Str( Number) + ") " + hexName + " ==> " + Conversion.Str( this.AreaStrength[Number]) + ", EnemySupplyGone = " + Conversion.Str( this.StartEnemySupplyGone[Number]));
      }
      this.AreaSteps = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut areaCount9: i32 = this.AreaCount;
      for (let mut from: i32 = 1; from <= areaCount9; from += 1)
      {
        let mut areaCount10: i32 = this.AreaCount;
        for (let mut too: i32 = 1; too <= areaCount10; too += 1)
          this.AreaSteps[from, too] = from == too ? 9999 : this.GetAreaBorderSteps(from, too, 20);
      }
      let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
      num17: i32;
      num18: i32;
      for (let mut index27: i32 = 0; index27 <= mapWidth2; index27 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index28: i32 = 0; index28 <= mapHeight; index28 += 1)
        {
          if (this.game.Data.MapObj[0].HexObj[index27, index28].VP > 0 | this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index27, index28] > 0)
          {
            num17 += this.game.Data.MapObj[0].HexObj[index27, index28].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index27, index28];
            num18 += 1;
          }
          if (this.AreaMatrixNarrow[index27, index28] == 0)
            this.AreaMatrixNarrow[index27, index28] = this.AreaMatrixWide[index27, index28];
        }
      }
      this.AverageAreaEntrench = new int[this.AreaCount + 1];
      let mut areaCount11: i32 = this.AreaCount;
      for (let mut Area: i32 = 1; Area <= areaCount11; Area += 1)
        this.AverageAreaEntrench[Area] = this.GetAverageAreaEntrench(Area);
      this.AverageVP = num18 != 0 ?  Math.Round( num17 /  num18) : 0;
      this.TempGroupHQ = new int[this.GroupCounter + 1];
      let mut groupCounter2: i32 = this.GroupCounter;
      for (let mut grp: i32 = 0; grp <= groupCounter2; grp += 1)
        this.TempGroupHQ[grp] = this.GetGroupHQ(grp);
    }

    pub fn ReOrderGroups(bool alllog)
    {
      int[] arySrc = new int[this.GroupCounter + 1];
      this.CorpsStrength = new int[this.GroupCounter + 1];
      this.MakeTempCategories(false);
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      this.FriendlySupply = new int[this.AreaCount + 1];
      this.EnemySupply = new int[this.AreaCount + 1];
      this.atemp2 = new int[this.AreaCount + 1];
      if (alllog)
      {
        this.AddLog("REORDER GROUPS");
        this.AddLog("");
      }
      if (alllog)
        this.AddLog("");
      if (alllog)
        this.AddLog("Supply Providing Areas:");
      num1: i32;
      num2: i32;
      if ( this.game.Data.RuleVar[335] > 0.0)
      {
        let mut num3: i32 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num3 * 4)))] > 0)
          {
            let mut nr: i32 = this.AreaMatrixWide[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num3 * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num3 * 4)))]];
            num1 = 0;
            if (nr > 0 && nr > 0 & this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime) == this.GetGameDataTurn())
            {
              num1 = 1;
              this.atemp2[nr] = 1;
              this.FriendlySupply[nr] = 1;
              if (alllog)
                this.AddLog(this.GetAreaName(nr));
            }
            num2 = 0;
          }
          num3 += 1;
        }
        while (num3 <= 3);
      }
      else
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount; index += 1)
        {
          if (this.IsAreaSupplySource(index, this.game.Data.Turn))
          {
            num1 = 1;
            this.atemp2[index] = 1;
            this.FriendlySupply[index] = 1;
            if (alllog)
              this.AddLog(this.GetAreaName(index));
          }
        }
      }
      if (alllog)
        this.AddLog("");
      if (alllog)
        this.AddLog("Areas in supply:");
      while (num1 == 1)
      {
        num1 = 0;
        num2 += 1;
        let mut areaCount: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount; nr += 1)
        {
          if (this.atemp2[nr] == num2)
          {
            let mut num4: i32 = this.AreaSupplyBorderCount[nr];
            for (let mut index1: i32 = 0; index1 <= num4; index1 += 1)
            {
              let mut index2: i32 = this.AreaSupplyBorderEither[nr, index1];
              if (this.atemp2[index2] == 0 && (this.AreaNarrowBorder[nr, index2] > 0 | this.AreaSeaConnect(nr, index2)) & nr != index2 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime) == this.GetGameDataTurn())
              {
                this.atemp2[index2] = this.atemp2[nr] + 1;
                num1 = 1;
                this.FriendlySupply[index2] = 1;
                if (alllog)
                  this.AddLog(this.GetAreaName(index2));
              }
            }
          }
        }
      }
      if (alllog)
        this.AddLog("");
      if (alllog)
        this.AddLog("Re-ordering of groups:");
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index].AIGroup > -1 & !this.game.Data.UnitObj[index].IsHQ & this.game.Data.UnitObj[index].TempCategory == 1 && this.game.Data.UnitObj[index].AIGroup > this.GroupCounter)
        {
          this.GroupCounter = this.game.Data.UnitObj[index].AIGroup;
          this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
          this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
          this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
          this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
          this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
          this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
          this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
          this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
          this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
          this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
          arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
        }
      }
      let mut unitCounter2: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter2; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup > -1 & !this.game.Data.UnitObj[unr].IsHQ & this.game.Data.UnitObj[unr].TempCategory == 1)
        {
          if (this.game.Data.UnitObj[unr].TempGroup == -1)
          {
            int[] numArray3 = arySrc;
            int[] numArray4 = numArray3;
            let mut aiGroup1: i32 = this.game.Data.UnitObj[unr].AIGroup;
            let mut index3: i32 = aiGroup1;
            let mut num5: i32 = numArray3[aiGroup1] + 1;
            numArray4[index3] = num5;
            int[] corpsStrength = this.CorpsStrength;
            int[] numArray5 = corpsStrength;
            let mut aiGroup2: i32 = this.game.Data.UnitObj[unr].AIGroup;
            let mut index4: i32 = aiGroup2;
            let mut num6: i32 = corpsStrength[aiGroup2] + this.GetUnitPower(unr, false);
            numArray5[index4] = num6;
          }
          else
          {
            int[] numArray6 = arySrc;
            int[] numArray7 = numArray6;
            let mut tempGroup1: i32 = this.game.Data.UnitObj[unr].TempGroup;
            let mut index5: i32 = tempGroup1;
            let mut num7: i32 = numArray6[tempGroup1] + 1;
            numArray7[index5] = num7;
            int[] corpsStrength = this.CorpsStrength;
            int[] numArray8 = corpsStrength;
            let mut tempGroup2: i32 = this.game.Data.UnitObj[unr].TempGroup;
            let mut index6: i32 = tempGroup2;
            let mut num8: i32 = corpsStrength[tempGroup2] + this.GetUnitPower(unr, false);
            numArray8[index6] = num8;
          }
        }
      }
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount1; index += 1)
        this.AreaOwner[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime;
      for (let mut groupCounter1: i32 = this.GroupCounter; groupCounter1 >= 0; groupCounter1 += -1)
      {
        if (this.GroupType[groupCounter1] < 1 | (this.GroupType[groupCounter1] == 1 | this.GroupType[groupCounter1] == 5) &  this.game.Data.RuleVar[800] == 1.0)
        {
          let mut groupCounter2: i32 = this.GroupCounter;
          for (let mut index7: i32 = 0; index7 <= groupCounter2; index7 += 1)
          {
            if (this.CorpsSource[groupCounter1] == this.CorpsSource[index7] & groupCounter1 != index7 & this.GroupType[index7] <= 5 && arySrc[groupCounter1] + arySrc[index7] <= 40 && this.CorpsTarget[groupCounter1] == this.CorpsTarget[index7] & this.CorpsStartLoc[groupCounter1] == this.CorpsStartLoc[index7])
            {
              index8: i32;
              grp: i32;
              if (this.GroupType[index7] < 5)
              {
                index8 = index7;
                grp = groupCounter1;
              }
              else
              {
                index8 = groupCounter1;
                grp = index7;
              }
              let mut groupHq: i32 = this.GetGroupHQ(grp);
              if (groupHq > -1 && !this.HasThisHQNoSplit(groupHq))
              {
                if (alllog)
                  this.AddLog("REMOVING group " + this.GroupName[index8] + " by adding it to " + this.GroupName[grp]);
                if (alllog)
                  this.AddLog("we do this when a kampfgruppe (not a corps) is exactly mirroring a regular corps or other kampfgruppe group in defend and attack");
                int[] numArray9 = arySrc;
                int[] numArray10 = numArray9;
                let mut index9: i32 = grp;
                let mut index10: i32 = index9;
                let mut num9: i32 = numArray9[index9] + arySrc[index8];
                numArray10[index10] = num9;
                let mut unitCounter3: i32 = this.game.Data.UnitCounter;
                for (let mut index11: i32 = 0; index11 <= unitCounter3; index11 += 1)
                {
                  if (this.game.Data.UnitObj[index11].PreDef == -1 && this.game.Data.UnitObj[index11].AIGroup == index8 | this.game.Data.UnitObj[index11].AIGroup == grp & this.game.Data.UnitObj[index11].TempGroup == index8 && this.GetRegime(this.game.Data.UnitObj[index11].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index11].PreDef == -1)
                  {
                    this.game.Data.UnitObj[index11].AIGroup = grp;
                    this.game.Data.UnitObj[index11].TempGroup = -1;
                    this.game.Data.UnitObj[index11].AIAttack = this.game.Data.UnitObj[groupHq].AIAttack;
                    this.game.Data.UnitObj[index11].AIDefend = this.game.Data.UnitObj[groupHq].AIDefend;
                    this.game.Data.UnitObj[index11].AIFollowup = this.game.Data.UnitObj[groupHq].AIFollowup;
                    this.game.Data.UnitObj[index11].AIFallback = this.game.Data.UnitObj[groupHq].AIFallback;
                    this.game.Data.UnitObj[index11].AIAttackStyle = this.game.Data.UnitObj[groupHq].AIAttackStyle;
                    this.game.Data.UnitObj[index11].AILeftFlank = this.game.Data.UnitObj[groupHq].AILeftFlank;
                    this.game.Data.UnitObj[index11].AIRightFlank = this.game.Data.UnitObj[groupHq].AIRightFlank;
                  }
                }
                let mut unitCounter4: i32 = this.game.Data.UnitCounter;
                for (let mut index12: i32 = 0; index12 <= unitCounter4; index12 += 1)
                {
                  if (this.game.Data.UnitObj[index12].PreDef == -1 && this.game.Data.UnitObj[index12].AIGroup != grp & this.game.Data.UnitObj[index12].TempGroup == index8 && this.GetRegime(this.game.Data.UnitObj[index12].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index12].PreDef == -1)
                    this.game.Data.UnitObj[index12].TempGroup = -1;
                }
                int[] corpsStrength = this.CorpsStrength;
                int[] numArray11 = corpsStrength;
                let mut index13: i32 = grp;
                let mut index14: i32 = index13;
                let mut num10: i32 = corpsStrength[index13] + this.CorpsStrength[index8];
                numArray11[index14] = num10;
                let mut num11: i32 = index8;
                let mut num12: i32 = this.GroupCounter - 1;
                for (let mut index15: i32 = num11; index15 <= num12; index15 += 1)
                {
                  this.GroupType[index15] = this.GroupType[index15 + 1];
                  this.GroupName[index15] = this.GroupName[index15 + 1];
                  this.GroupHis[index15] = this.GroupHis[index15 + 1];
                  this.CorpsTarget[index15] = this.CorpsTarget[index15 + 1];
                  this.CorpsSource[index15] = this.CorpsSource[index15 + 1];
                  this.CorpsStrength[index15] = this.CorpsStrength[index15 + 1];
                  this.CorpsEngineer[index15] = this.CorpsEngineer[index15 + 1];
                  this.CorpsStance[index15] = this.CorpsStance[index15 + 1];
                  this.CorpsStartLoc[index15] = this.CorpsStartLoc[index15 + 1];
                  this.CorpsLandStrength[index15] = this.CorpsLandStrength[index15 + 1];
                }
                --this.GroupCounter;
                let mut unitCounter5: i32 = this.game.Data.UnitCounter;
                for (let mut index16: i32 = 0; index16 <= unitCounter5; index16 += 1)
                {
                  if (this.game.Data.UnitObj[index16].PreDef == -1)
                  {
                    if (this.game.Data.UnitObj[index16].AIGroup >= index8 & this.GetRegime(this.game.Data.UnitObj[index16].Regime) == this.GetGameDataTurn())
                      --this.game.Data.UnitObj[index16].AIGroup;
                    if (this.game.Data.UnitObj[index16].AILeftFlank >= index8 & this.GetRegime(this.game.Data.UnitObj[index16].Regime) == this.GetGameDataTurn())
                      --this.game.Data.UnitObj[index16].AILeftFlank;
                    if (this.game.Data.UnitObj[index16].AIRightFlank >= index8 & this.GetRegime(this.game.Data.UnitObj[index16].Regime) == this.GetGameDataTurn())
                      --this.game.Data.UnitObj[index16].AIRightFlank;
                  }
                }
                break;
              }
            }
          }
        }
      }
      let mut groupCounter3: i32 = this.GroupCounter;
      for (let mut index: i32 = 0; index <= groupCounter3; index += 1)
        arySrc[index] = 0;
      let mut unitCounter6: i32 = this.game.Data.UnitCounter;
      for (let mut index17: i32 = 0; index17 <= unitCounter6; index17 += 1)
      {
        if (this.game.Data.UnitObj[index17].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index17].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index17].AIGroup > -1 & !this.game.Data.UnitObj[index17].IsHQ & this.game.Data.UnitObj[index17].TempCategory == 1)
        {
          if (this.game.Data.UnitObj[index17].TempGroup == -1)
          {
            int[] numArray12 = arySrc;
            int[] numArray13 = numArray12;
            let mut aiGroup: i32 = this.game.Data.UnitObj[index17].AIGroup;
            let mut index18: i32 = aiGroup;
            let mut num13: i32 = numArray12[aiGroup] + 1;
            numArray13[index18] = num13;
          }
          else
          {
            int[] numArray14 = arySrc;
            int[] numArray15 = numArray14;
            let mut tempGroup: i32 = this.game.Data.UnitObj[index17].TempGroup;
            let mut index19: i32 = tempGroup;
            let mut num14: i32 = numArray14[tempGroup] + 1;
            numArray15[index19] = num14;
          }
        }
      }
      num15: i32;
      float ratioOnArea;
      if ( this.game.Data.RuleVar[827] == 0.0 |  this.game.Data.RuleVar[827] == 2.0 & this.Attacker)
      {
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut index20: i32 = 1; index20 <= areaCount2; index20 += 1)
        {
          if (this.GetRegime(this.AreaOwner[index20]) == this.GetGameDataTurn())
          {
            let mut areaCount3: i32 = this.AreaCount;
            for (let mut index21: i32 = 1; index21 <= areaCount3; index21 += 1)
            {
              if (this.AreaStartEnemy[index21] > 0 & this.AreaOwner[index21] > -1 & this.FriendlySupply[index21] == this.FriendlySupply[index20] && this.AreaNarrowBorder[index20, index21] > 0 & this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.AreaOwner[index21]))
              {
                let mut num16: i32 = 0;
                let mut groupCounter4: i32 = this.GroupCounter;
                for (let mut index22: i32 = 0; index22 <= groupCounter4; index22 += 1)
                {
                  if (this.CorpsSource[index22] == index20 | this.CorpsTarget[index22] == index20 | this.CorpsStartLoc[index22] == index20)
                    num16 = 1;
                }
                if (num16 == 0)
                {
                  SimpleList simpleList1 = SimpleList::new();
                  let mut groupCounter5: i32 = this.GroupCounter;
                  for (let mut index23: i32 = 0; index23 <= groupCounter5; index23 += 1)
                  {
                    if (this.CorpsSource[index23] > -1 & this.CorpsStrength[index23] > 0 & arySrc[index23] > 3 && !this.HasThisHQNoSplit(this.GetGroupHQ(index23)) && this.GetAbsoluteTempUnits(index23) < 1)
                    {
                      let mut areaStep: i32 = this.AreaSteps[this.CorpsSource[index23], index20];
                      if (areaStep > 0 & (areaStep <= 1 & this.Attacker | areaStep <= 2 & !this.Attacker))
                      {
                        let mut num17: i32 = this.CorpsStrength[index23];
                        simpleList1.Add(index23, num17 * areaStep);
                      }
                    }
                  }
                  if (simpleList1.Counter > -1)
                  {
                    simpleList1.Sort();
                    let mut index24: i32 = simpleList1.Id[0];
                    this += 1.GroupCounter;
                    this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
                    this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
                    this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
                    this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
                    this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
                    this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
                    arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
                    this.GroupName[this.GroupCounter] = "ALARMGROUP " + this.GetAreaName(index20, false);
                    this.GroupType[this.GroupCounter] = 1;
                    this.GroupHis[this.GroupCounter] = -1;
                    this.CorpsSource[this.GroupCounter] = index20;
                    this.CorpsTopGroup[this.GroupCounter] = -1;
                    this.CorpsTarget[this.GroupCounter] = -1;
                    this.CorpsStrength[this.GroupCounter] = 0;
                    this.CorpsStance[this.GroupCounter] = 1;
                    this.CorpsEngineer[this.GroupCounter] = false;
                    let mut groupCounter6: i32 = this.GroupCounter;
                    if (alllog)
                      this.AddLog("SPLITTING group " + this.GroupName[index24] + " and creating " + this.GroupName[groupCounter6]);
                    if (alllog)
                      this.AddLog("we do this when there is a threatened area with no group defending this.");
                    SimpleList simpleList2 = SimpleList::new();
                    let mut unitCounter7: i32 = this.game.Data.UnitCounter;
                    for (let mut tid: i32 = 0; tid <= unitCounter7; tid += 1)
                    {
                      if (this.game.Data.UnitObj[tid].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[tid].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[tid].AIGroup == index24 & !this.game.Data.UnitObj[tid].IsHQ && this.game.Data.UnitObj[tid].TempCategory != 3)
                      {
                        let mut tweight: i32 = 100 * this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y, 0, this.AreaCenter[index20].x, this.AreaCenter[index20].y, 0);
                        if (this.game.Data.UnitObj[tid].TempCategory == 1)
                          tweight =  Math.Round( tweight / 10.0);
                        simpleList2.Add(tid, tweight);
                      }
                    }
                    let mut num18: i32 = 0;
                    let mut num19: i32 = 0;
                    let mut num20: i32 = 0;
                    let mut num21: i32 = 0;
                    num15 = 0;
                    ratioOnArea = this.GetRatioOnArea(index20);
                    simpleList2.Sort();
                    if (simpleList2.Counter > -1)
                    {
                      let mut counter1: i32 = simpleList2.Counter;
                      for (let mut index25: i32 = 0; index25 <= counter1; index25 += 1)
                      {
                        if (simpleList2.Data1[index25] != 1)
                        {
                          num19 += 1;
                          if ( num18 <=  this.CorpsStrength[index24] / 3.0 & num18 * 2 <= this.GetEnemyOnArea(index20))
                          {
                            if (this.game.Data.UnitObj[simpleList2.Id[index25]].Historical > -1)
                            {
                              let mut counter2: i32 = simpleList2.Counter;
                              for (let mut index26: i32 = 0; index26 <= counter2; index26 += 1)
                              {
                                if (simpleList2.Data1[index26] != 1 && this.game.Data.UnitObj[simpleList2.Id[index25]].Historical == this.game.Data.UnitObj[simpleList2.Id[index26]].Historical &&  num18 <=  this.CorpsStrength[index24] / 3.0 & num18 * 2 < this.GetEnemyOnArea(index20))
                                {
                                  num21 += 1;
                                  num18 += this.GetUnitPower(simpleList2.Id[index25], false);
                                  num20 += this.GetUnitPower(simpleList2.Id[index25], false);
                                  if (alllog)
                                    this.AddLog("SPLITTING HIS.UNIT " + this.game.Data.UnitObj[simpleList2.Id[index26]].Name);
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIGroup = groupCounter6;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIAttack = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIDefend = index20;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIFollowup = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIFallback = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AILeftFlank = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIRightFlank = -1;
                                  this.game.Data.UnitObj[simpleList2.Id[index26]].AIAttackStyle = 1;
                                  simpleList2.Data1[index26] = 1;
                                }
                              }
                            }
                            else
                            {
                              num18 += this.GetUnitPower(simpleList2.Id[index25], false);
                              num20 += this.GetUnitPower(simpleList2.Id[index25], false);
                              num21 += 1;
                              if (alllog)
                                this.AddLog("SPLITTING UNIT " + this.game.Data.UnitObj[simpleList2.Id[index25]].Name);
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIGroup = groupCounter6;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIAttack = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIDefend = index20;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIFollowup = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIFallback = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AILeftFlank = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIRightFlank = -1;
                              this.game.Data.UnitObj[simpleList2.Id[index25]].AIAttackStyle = 1;
                              simpleList2.Data1[index25] = 1;
                            }
                          }
                        }
                      }
                    }
                    if (num21 == 0)
                    {
                      if (alllog)
                        this.AddLog("IMMEDIATLY REMOVING AGAIN BCAUESE WE COULD FIND NO UNITS");
                      --this.GroupCounter;
                    }
                    int[] numArray16 = arySrc;
                    int[] numArray17 = numArray16;
                    let mut index27: i32 = index24;
                    let mut index28: i32 = index27;
                    let mut num22: i32 = numArray16[index27] - num21;
                    numArray17[index28] = num22;
                    int[] corpsStrength = this.CorpsStrength;
                    int[] numArray18 = corpsStrength;
                    let mut index29: i32 = index24;
                    let mut index30: i32 = index29;
                    let mut num23: i32 = corpsStrength[index29] - num20;
                    numArray18[index30] = num23;
                    if (0 > this.CorpsStrength[index24])
                      this.CorpsStrength[index24] = 0;
                  }
                }
              }
            }
          }
        }
      }
      if ( this.game.Data.RuleVar[827] == 0.0 && this.Attacker)
      {
        let mut areaCount4: i32 = this.AreaCount;
        for (let mut index31: i32 = 1; index31 <= areaCount4; index31 += 1)
        {
          if (this.GetRegime(this.AreaOwner[index31]) != this.GetGameDataTurn())
          {
            let mut areaCount5: i32 = this.AreaCount;
            for (let mut nr: i32 = 1; nr <= areaCount5; nr += 1)
            {
              if (this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.AreaOwner[index31]) & this.AreaNarrowBorder[index31, nr] > 0)
              {
                let mut num24: i32 = 0;
                let mut groupCounter7: i32 = this.GroupCounter;
                for (let mut index32: i32 = 0; index32 <= groupCounter7; index32 += 1)
                {
                  if (this.GroupType[index32] <= 5 & this.CorpsSource[index32] == nr & this.CorpsTarget[index32] == index31)
                    num24 = 1;
                  if (this.GroupType[index32] <= 5 & this.CorpsSource[index32] == nr & (this.CorpsTarget[index32] == -1 | this.CorpsTarget[index32] == nr))
                    num24 = 1;
                }
                if (num24 == 0 &  this.GetRatioOnArea(index31) < 2.5)
                {
                  SimpleList simpleList3 = SimpleList::new();
                  let mut groupCounter8: i32 = this.GroupCounter;
                  for (let mut index33: i32 = 0; index33 <= groupCounter8; index33 += 1)
                  {
                    if (this.CorpsSource[index33] > -1 & this.CorpsStrength[index33] > 0 & arySrc[index33] > 3 && !this.HasThisHQNoSplit(this.GetGroupHQ(index33)) && this.GetAbsoluteTempUnits(index33) < 1)
                    {
                      let mut areaStep: i32 = this.AreaSteps[this.CorpsSource[index33], index31];
                      if (areaStep > 0 & areaStep <= 1)
                      {
                        let mut num25: i32 = this.CorpsStrength[index33];
                        simpleList3.Add(index33,  Math.Round( num25 /  areaStep));
                      }
                    }
                  }
                  if (simpleList3.Counter > -1)
                  {
                    simpleList3.Sort();
                    let mut index34: i32 = simpleList3.Id[simpleList3.Counter];
                    this += 1.GroupCounter;
                    this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
                    this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
                    this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
                    this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
                    this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
                    this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
                    this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
                    arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
                    this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
                    this.GroupName[this.GroupCounter] = "DETACHMENT" + this.GetAreaName(index31, false);
                    this.GroupType[this.GroupCounter] = 1;
                    this.CorpsTopGroup[this.GroupCounter] = -1;
                    this.GroupHis[this.GroupCounter] = -1;
                    this.CorpsSource[this.GroupCounter] = nr;
                    this.CorpsTarget[this.GroupCounter] = index31;
                    this.CorpsStrength[this.GroupCounter] = 0;
                    this.CorpsStance[this.GroupCounter] = 3;
                    this.CorpsEngineer[this.GroupCounter] = false;
                    let mut groupCounter9: i32 = this.GroupCounter;
                    if (alllog)
                      this.AddLog("SPLITTING group " + this.GroupName[index34] + " and creating " + this.GroupName[groupCounter9] + ", Corps source = " + this.GetAreaName(nr) + ", Corps target = " + this.GetAreaName(index31));
                    SimpleList simpleList4 = SimpleList::new();
                    let mut unitCounter8: i32 = this.game.Data.UnitCounter;
                    for (let mut tid: i32 = 0; tid <= unitCounter8; tid += 1)
                    {
                      if (this.game.Data.UnitObj[tid].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[tid].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[tid].AIGroup == index34 & !this.game.Data.UnitObj[tid].IsHQ && this.game.Data.UnitObj[tid].TempCategory != 3)
                      {
                        let mut tweight: i32 = 100 * this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y, 0, this.AreaCenter[index31].x, this.AreaCenter[index31].y, 0);
                        if (this.game.Data.UnitObj[tid].TempCategory == 1)
                          tweight =  Math.Round( tweight / 10.0);
                        simpleList4.Add(tid, tweight);
                      }
                    }
                    let mut num26: i32 = 0;
                    let mut num27: i32 = 0;
                    let mut num28: i32 = 0;
                    let mut num29: i32 = 0;
                    num15 = 0;
                    ratioOnArea = this.GetRatioOnArea(index31);
                    simpleList4.Sort();
                    if (simpleList4.Counter > -1)
                    {
                      let mut counter3: i32 = simpleList4.Counter;
                      for (let mut index35: i32 = 0; index35 <= counter3; index35 += 1)
                      {
                        if (simpleList4.Data1[index35] != 1)
                        {
                          num27 += 1;
                          if ( num26 <=  this.CorpsStrength[index34] / 3.0 & num26 * 2 < this.GetEnemyOnArea(index31))
                          {
                            if (this.game.Data.UnitObj[simpleList4.Id[index35]].Historical > -1)
                            {
                              let mut counter4: i32 = simpleList4.Counter;
                              for (let mut index36: i32 = 0; index36 <= counter4; index36 += 1)
                              {
                                if (simpleList4.Data1[index36] != 1 && this.game.Data.UnitObj[simpleList4.Id[index35]].Historical == this.game.Data.UnitObj[simpleList4.Id[index36]].Historical)
                                {
                                  num29 += 1;
                                  num26 += this.GetUnitPower(simpleList4.Id[index35], false);
                                  num28 += this.GetUnitPower(simpleList4.Id[index35], false);
                                  if (alllog)
                                    this.AddLog("SPLITTING HIS.UNIT " + this.game.Data.UnitObj[simpleList4.Id[index36]].Name);
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIGroup = groupCounter9;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIAttack = index31;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIDefend = nr;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIFollowup = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIFallback = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AILeftFlank = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIRightFlank = -1;
                                  this.game.Data.UnitObj[simpleList4.Id[index36]].AIAttackStyle = 3;
                                  simpleList4.Data1[index36] = 1;
                                }
                              }
                            }
                            else
                            {
                              num26 += this.GetUnitPower(simpleList4.Id[index35], false);
                              num28 += this.GetUnitPower(simpleList4.Id[index35], false);
                              num29 += 1;
                              if (alllog)
                                this.AddLog("SPLITTING UNIT " + this.game.Data.UnitObj[simpleList4.Id[index35]].Name);
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIGroup = groupCounter9;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIAttack = index31;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIDefend = nr;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIFollowup = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIFallback = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AILeftFlank = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIRightFlank = -1;
                              this.game.Data.UnitObj[simpleList4.Id[index35]].AIAttackStyle = 3;
                              simpleList4.Data1[index35] = 1;
                            }
                          }
                        }
                      }
                    }
                    if (num29 == 0)
                    {
                      if (alllog)
                        this.AddLog("IMMEDIATLY REMOVING AGAIN BCAUESE WE COULD FIND NO UNITS");
                      --this.GroupCounter;
                    }
                    int[] numArray19 = arySrc;
                    int[] numArray20 = numArray19;
                    let mut index37: i32 = index34;
                    let mut index38: i32 = index37;
                    let mut num30: i32 = numArray19[index37] - num29;
                    numArray20[index38] = num30;
                    int[] corpsStrength = this.CorpsStrength;
                    int[] numArray21 = corpsStrength;
                    let mut index39: i32 = index34;
                    let mut index40: i32 = index39;
                    let mut num31: i32 = corpsStrength[index39] - num28;
                    numArray21[index40] = num31;
                    if (0 > this.CorpsStrength[index34])
                      this.CorpsStrength[index34] = 0;
                  }
                }
              }
            }
          }
        }
      }
      let mut groupCounter10: i32 = this.GroupCounter;
      for (let mut grp: i32 = 0; grp <= groupCounter10; grp += 1)
      {
        if (this.GroupType[grp] > 5 & arySrc[grp] > 1 && !this.HasThisHQNoSplit(this.GetGroupHQ(grp)) && this.GetAbsoluteTempUnits(grp) < 1)
        {
          let mut index41: i32 = grp;
          this += 1.GroupCounter;
          this.GroupName = (string[]) Utils.CopyArray((Array) this.GroupName, (Array) new string[this.GroupCounter + 1]);
          this.GroupType = (int[]) Utils.CopyArray((Array) this.GroupType, (Array) new int[this.GroupCounter + 1]);
          this.GroupHis = (int[]) Utils.CopyArray((Array) this.GroupHis, (Array) new int[this.GroupCounter + 1]);
          this.GroupAttack = (int[]) Utils.CopyArray((Array) this.GroupAttack, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTopGroup = (int[]) Utils.CopyArray((Array) this.CorpsTopGroup, (Array) new int[this.GroupCounter + 1]);
          this.GroupDefend = (int[]) Utils.CopyArray((Array) this.GroupDefend, (Array) new int[this.GroupCounter + 1]);
          this.GroupFallBack = (int[]) Utils.CopyArray((Array) this.GroupFallBack, (Array) new int[this.GroupCounter + 1]);
          this.GroupFollowUp = (int[]) Utils.CopyArray((Array) this.GroupFollowUp, (Array) new int[this.GroupCounter + 1]);
          this.CorpsSource = (int[]) Utils.CopyArray((Array) this.CorpsSource, (Array) new int[this.GroupCounter + 1]);
          this.CorpsTarget = (int[]) Utils.CopyArray((Array) this.CorpsTarget, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStrength = (int[]) Utils.CopyArray((Array) this.CorpsStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsLandStrength = (int[]) Utils.CopyArray((Array) this.CorpsLandStrength, (Array) new int[this.GroupCounter + 1]);
          this.CorpsEngineer = (bool[]) Utils.CopyArray((Array) this.CorpsEngineer, (Array) new bool[this.GroupCounter + 1]);
          this.CorpsStance = (int[]) Utils.CopyArray((Array) this.CorpsStance, (Array) new int[this.GroupCounter + 1]);
          arySrc = (int[]) Utils.CopyArray((Array) arySrc, (Array) new int[this.GroupCounter + 1]);
          this.CorpsStartLoc = (int[]) Utils.CopyArray((Array) this.CorpsStartLoc, (Array) new int[this.GroupCounter + 1]);
          this.GroupName[this.GroupCounter] = "REINFORCEMENTS " + this.GetAreaName(this.CorpsSource[grp]);
          this.GroupType[this.GroupCounter] = 1;
          this.GroupHis[this.GroupCounter] = -1;
          this.CorpsTopGroup[this.GroupCounter] = -1;
          this.CorpsSource[this.GroupCounter] = this.CorpsSource[grp];
          this.CorpsTarget[this.GroupCounter] = -1;
          this.CorpsStrength[this.GroupCounter] = 0;
          this.CorpsStance[this.GroupCounter] = 1;
          this.CorpsEngineer[this.GroupCounter] = false;
          let mut groupCounter11: i32 = this.GroupCounter;
          if (alllog)
            this.AddLog("SPLITTING group " + this.GroupName[index41] + " and creating " + this.GroupName[groupCounter11]);
          SimpleList simpleList = SimpleList::new();
          let mut unitCounter9: i32 = this.game.Data.UnitCounter;
          for (let mut tid: i32 = 0; tid <= unitCounter9; tid += 1)
          {
            if (this.game.Data.UnitObj[tid].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[tid].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[tid].AIGroup == index41 & !this.game.Data.UnitObj[tid].IsHQ)
            {
              let mut tweight: i32 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[tid].X, this.game.Data.UnitObj[tid].Y, 0, this.AreaCenter[grp].x, this.AreaCenter[grp].y, 0);
              simpleList.Add(tid, tweight);
            }
          }
          let mut num32: i32 = 0;
          let mut num33: i32 = 0;
          simpleList.Sort();
          if (simpleList.Counter > -1)
          {
            let mut counter: i32 = simpleList.Counter;
            for (let mut index42: i32 = 0; index42 <= counter; index42 += 1)
            {
              num32 += this.GetUnitPower(simpleList.Id[index42], false);
              num33 += 1;
              if (alllog)
                this.AddLog("SPLITTING UNIT " + this.game.Data.UnitObj[simpleList.Id[index42]].Name);
              this.game.Data.UnitObj[simpleList.Id[index42]].AIGroup = groupCounter11;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIAttack = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIDefend = this.CorpsSource[grp];
              this.game.Data.UnitObj[simpleList.Id[index42]].AIFollowup = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIFallback = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AILeftFlank = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIRightFlank = -1;
              this.game.Data.UnitObj[simpleList.Id[index42]].AIAttackStyle = 1;
            }
          }
          int[] numArray22 = arySrc;
          int[] numArray23 = numArray22;
          let mut index43: i32 = index41;
          let mut index44: i32 = index43;
          let mut num34: i32 = numArray22[index43] - num33;
          numArray23[index44] = num34;
          int[] corpsStrength = this.CorpsStrength;
          int[] numArray24 = corpsStrength;
          let mut index45: i32 = index41;
          let mut index46: i32 = index45;
          let mut num35: i32 = corpsStrength[index45] - num32;
          numArray24[index46] = num35;
          if (0 > this.CorpsStrength[index41])
            this.CorpsStrength[index41] = 0;
        }
      }
      let mut groupCounter12: i32 = this.GroupCounter;
      for (let mut index47: i32 = 0; index47 <= groupCounter12; index47 += 1)
      {
        if (alllog)
          this.AddLog("");
        if (alllog)
          this.AddLog(this.GroupName[index47] + " (" + Conversion.Str( this.GroupType[index47]) + ")");
        let mut unitCounter10: i32 = this.game.Data.UnitCounter;
        for (let mut index48: i32 = 0; index48 <= unitCounter10; index48 += 1)
        {
          if (this.game.Data.UnitObj[index48].PreDef == -1 && this.game.Data.UnitObj[index48].X > -1 & this.GetRegime(this.game.Data.UnitObj[index48].Regime) == this.GetGameDataTurn())
          {
            if (this.game.Data.UnitObj[index48].AIGroup == index47)
            {
              if (this.game.Data.UnitObj[index48].TempGroup != -1 | this.game.Data.UnitObj[index48].TempGroup == index47)
              {
                if (alllog)
                  this.AddLog("(-)" + this.game.Data.UnitObj[index48].Name);
              }
              else if (alllog)
                this.AddLog("-" + this.game.Data.UnitObj[index48].Name);
            }
            else if (this.game.Data.UnitObj[index48].TempGroup == index47 && alllog)
              this.AddLog("( " + this.game.Data.UnitObj[index48].Name + " )");
          }
        }
      }
      if (!alllog)
        return;
      this.AddLog("");
    }

    pub fn ChangingHQs(bool alllog)
    {
      int[] numArray1 = new int[this.game.Data.UnitCounter + 1];
      object[,] objArray = new object[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (alllog)
        this.AddLog("CHANGING HQS");
      if (alllog)
        this.AddLog("");
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          objArray[index1, index2] =  9999;
      }
      if ( this.game.Data.RuleVar[335] > 0.0)
      {
        let mut num1: i32 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num1 * 4)))] > 0)
          {
            if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num1 * 4)))] > -1)
            {
              let mut num2: i32 = this.AreaMatrixWide[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num1 * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num1 * 4)))]];
              let mut x: i32 = this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num1 * 4)))];
              let mut y: i32 = this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num1 * 4)))];
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), x, y, 0, allowshoredrop: true, SeaBlock: true);
            }
            let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
              {
                if (Operators.ConditionalCompareObjectLess( this.game.EditObj.TempValue[0].Value[index3, index4], objArray[index3, index4], false))
                  objArray[index3, index4] =  this.game.EditObj.TempValue[0].Value[index3, index4];
              }
            }
          }
          num1 += 1;
        }
        while (num1 <= 3);
      }
      let mut num3: i32 = 7;
      num4: i32;
      do
      {
        let mut unitCounter1: i32 = this.game.Data.UnitCounter;
        for (let mut index5: i32 = 0; index5 <= unitCounter1; index5 += 1)
        {
          if (this.game.Data.UnitObj[index5].PreDef == -1 & this.game.Data.UnitObj[index5].IsHQ && this.game.Data.UnitObj[index5].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index5].X > -1 & this.game.Data.UnitObj[index5].PreDef == -1 && this.GroupType[this.game.Data.UnitObj[index5].AIGroup] == num3 && this.game.Data.UnitObj[index5].SupplyInReq > this.game.Data.UnitObj[index5].SupplyIn | this.game.Data.UnitObj[index5].SupplyInReq == 0)
          {
            this += 1.game.EditObj.AIProgressNow;
            if (this.game.EditObj.AIProgressNow > 100)
              this.game.EditObj.AIProgressNow = 0;
            let mut index6: i32 = this.game.Data.UnitObj[index5].HQ;
            if (index6 > -1)
            {
              if ( this.game.Data.RuleVar[887] > 0.0)
              {
                index6 = 0;
              }
              else
              {
                this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index5].X, this.game.Data.UnitObj[index5].Y, this.game.Data.UnitObj[index5].Map, allowshoredrop: true, SeaBlock: true);
                if ( this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y] >  this.game.Data.RuleVar[3])
                  index6 = -2;
                else if ( this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y] >  this.game.Data.RuleVar[52])
                  index6 = -1;
              }
            }
            if (index6 < 0)
            {
              if (alllog)
                this.AddLog("HQ " + this.game.Data.UnitObj[index5].Name + " has trouble receiving supply.");
              num4 = -1;
              let mut index7: i32 = -1;
              let mut num5: i32 = 9999;
              let mut unitCounter2: i32 = this.game.Data.UnitCounter;
              for (let mut index8: i32 = 0; index8 <= unitCounter2; index8 += 1)
              {
                if (this.game.Data.UnitObj[index8].PreDef == -1 & this.game.Data.UnitObj[index8].IsHQ && this.game.Data.UnitObj[index8].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index8].X > -1 & this.game.Data.UnitObj[index8].PreDef == -1 &&  this.game.Data.UnitObj[index8].SupplyIn >  this.game.Data.UnitObj[index8].SupplyInReq / 2.0 & this.GroupType[this.game.Data.UnitObj[index8].AIGroup] == num3 + 1 &&  this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] <=  this.game.Data.RuleVar[51] | index6 == -2 &  this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] <=  this.game.Data.RuleVar[3] && this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] < num5)
                {
                  index7 = index8;
                  num5 = this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y];
                }
              }
              if ( num5 <  this.game.Data.RuleVar[3])
              {
                if (alllog & this.game.Data.UnitObj[index5].HQ > -1)
                  this.AddLog("old HQ was = " + this.game.Data.UnitObj[this.game.Data.UnitObj[index5].HQ].Name);
                this.game.Data.UnitObj[index5].HQ = index7;
                if (alllog & index7 > -1)
                  this.AddLog("new HQ assigned is = " + this.game.Data.UnitObj[index7].Name);
              }
              else if (alllog)
                this.AddLog("no better hq found.");
            }
          }
        }
        num3 += -1;
      }
      while (num3 >= 5);
      let mut unitCounter3: i32 = this.game.Data.UnitCounter;
      for (let mut index9: i32 = 0; index9 <= unitCounter3; index9 += 1)
      {
        if (this.game.Data.Round > 1 & this.game.Data.UnitObj[index9].PreDef == -1 & !this.game.Data.UnitObj[index9].IsHQ && this.game.Data.UnitObj[index9].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index9].X > -1 & this.game.Data.UnitObj[index9].PreDef == -1 & this.game.Data.UnitObj[index9].AIGroup > -1 && this.game.Data.UnitObj[index9].SupplyInReq > this.game.Data.UnitObj[index9].SupplyIn & this.GroupType[this.game.Data.UnitObj[index9].AIGroup] <= 5)
        {
          let mut index10: i32 = this.game.Data.UnitObj[index9].HQ;
          this += 1.game.EditObj.AIProgressNow;
          if (this.game.EditObj.AIProgressNow > 100)
            this.game.EditObj.AIProgressNow = 0;
          if (index10 > -1)
          {
            if ( this.game.Data.RuleVar[887] > 0.0)
            {
              index10 = 0;
            }
            else
            {
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index9].X, this.game.Data.UnitObj[index9].Y, this.game.Data.UnitObj[index9].Map, allowshoredrop: true, SeaBlock: true);
              if ( this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index10].X, this.game.Data.UnitObj[index10].Y] >  this.game.Data.RuleVar[3])
                index10 = -2;
              else if ( this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index10].X, this.game.Data.UnitObj[index10].Y] >  this.game.Data.RuleVar[52])
                index10 = -1;
            }
          }
          if (index10 < 0)
          {
            if (alllog)
              this.AddLog("Unit " + this.game.Data.UnitObj[index9].Name + " has trouble receiving supply.");
            num4 = -1;
            let mut index11: i32 = -1;
            let mut num6: i32 = 9999;
            let mut unitCounter4: i32 = this.game.Data.UnitCounter;
            for (let mut index12: i32 = 0; index12 <= unitCounter4; index12 += 1)
            {
              if (this.game.Data.UnitObj[index12].PreDef == -1 & this.game.Data.UnitObj[index12].IsHQ && this.game.Data.UnitObj[index12].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index12].X > -1 & this.game.Data.UnitObj[index12].PreDef == -1 &&  this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y] <=  this.game.Data.RuleVar[51] | index10 == -2 &  this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y] <=  this.game.Data.RuleVar[3] && this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y] < num6)
              {
                index11 = index12;
                num6 = this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index12].X, this.game.Data.UnitObj[index12].Y];
              }
            }
            if ( num6 <  this.game.Data.RuleVar[3])
            {
              if (alllog & this.game.Data.UnitObj[index9].HQ > -1)
                this.AddLog("old HQ was = " + this.game.Data.UnitObj[this.game.Data.UnitObj[index9].HQ].Name);
              this.game.Data.UnitObj[index9].HQ = index11;
              if (alllog & index11 > -1)
                this.AddLog("new HQ assigned is = " + this.game.Data.UnitObj[index11].Name);
            }
            else if (alllog)
              this.AddLog("no better hq found.");
          }
        }
      }
      let mut unitCounter5: i32 = this.game.Data.UnitCounter;
      for (let mut index13: i32 = 0; index13 <= unitCounter5; index13 += 1)
      {
        if (this.game.Data.UnitObj[index13].PreDef == -1 && this.game.Data.UnitObj[index13].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index13].X > -1 & this.game.Data.UnitObj[index13].PreDef == -1)
        {
          if (this.game.Data.UnitObj[index13].HQ == -1)
          {
            this += 1.game.EditObj.AIProgressNow;
            if (this.game.EditObj.AIProgressNow > 100)
              this.game.EditObj.AIProgressNow = 0;
            if (this.game.Data.UnitObj[index13].IsHQ)
            {
              let mut bestCapHq: i32 = this.GetBestCapHQ(this.GetGameDataTurn());
              if (bestCapHq != index13)
                this.game.Data.UnitObj[index13].HQ = bestCapHq;
            }
            else
            {
              let mut index14: i32 = -1;
              let mut unitCounter6: i32 = this.game.Data.UnitCounter;
              for (let mut index15: i32 = 0; index15 <= unitCounter6; index15 += 1)
              {
                if (this.game.Data.UnitObj[index15].AIGroup == this.game.Data.UnitObj[index13].AIGroup & this.game.Data.UnitObj[index15].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index15].IsHQ)
                {
                  index14 = index15;
                  break;
                }
              }
              int[] numArray2 = new int[this.game.Data.UnitCounter + 1];
              let mut num7: i32 = 0;
              let mut num8: i32 = -1;
              if (index14 == -1)
              {
                let mut unitCounter7: i32 = this.game.Data.UnitCounter;
                for (let mut index16: i32 = 0; index16 <= unitCounter7; index16 += 1)
                {
                  if (this.game.Data.UnitObj[index16].PreDef == -1 && this.game.Data.UnitObj[index16].AIGroup == this.game.Data.UnitObj[index13].AIGroup & this.game.Data.UnitObj[index16].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index16].HQ > -1)
                  {
                    int[] numArray3 = numArray2;
                    int[] numArray4 = numArray3;
                    let mut hq: i32 = this.game.Data.UnitObj[index16].HQ;
                    let mut index17: i32 = hq;
                    let mut num9: i32 = numArray3[hq] + 1;
                    numArray4[index17] = num9;
                    if (numArray2[this.game.Data.UnitObj[index16].HQ] > num7)
                    {
                      num7 = numArray2[this.game.Data.UnitObj[index16].HQ];
                      num8 = this.game.Data.UnitObj[index16].HQ;
                    }
                  }
                }
                if (num8 > -1)
                  index14 = num8;
              }
              if (index14 == -1)
              {
                if ( this.game.Data.RuleVar[887] < 1.0)
                  this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index13].X, this.game.Data.UnitObj[index13].Y, this.game.Data.UnitObj[index13].Map, allowshoredrop: true, SeaBlock: true);
                let mut unitCounter8: i32 = this.game.Data.UnitCounter;
                for (let mut index18: i32 = 0; index18 <= unitCounter8; index18 += 1)
                {
                  if (this.game.Data.UnitObj[index18].PreDef == -1 & this.game.Data.UnitObj[index18].X > -1 && ( this.game.Data.RuleVar[887] > 0.0 |  this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index18].X, this.game.Data.UnitObj[index18].Y] <  this.game.Data.RuleVar[51]) & this.game.Data.UnitObj[index18].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index18].HQ > -1)
                  {
                    int[] numArray5 = numArray2;
                    int[] numArray6 = numArray5;
                    let mut hq: i32 = this.game.Data.UnitObj[index18].HQ;
                    let mut index19: i32 = hq;
                    let mut num10: i32 = numArray5[hq] + 1;
                    numArray6[index19] = num10;
                    if (numArray2[this.game.Data.UnitObj[index18].HQ] > num7)
                    {
                      num7 = numArray2[this.game.Data.UnitObj[index18].HQ];
                      num8 = this.game.Data.UnitObj[index18].HQ;
                    }
                  }
                }
                if (num8 > -1)
                  index14 = num8;
              }
              if (index14 > -1)
              {
                this.game.Data.UnitObj[index13].HQ = index14;
                if (alllog)
                  this.AddLog("Unit without HQ " + this.game.Data.UnitObj[index13].Name + " set to HQ: " + this.game.Data.UnitObj[index14].Name);
              }
              else if (alllog)
                this.AddLog("Unit without HQ " + this.game.Data.UnitObj[index13].Name + " not set to any HQ.");
            }
          }
          else if (!this.game.Data.UnitObj[index13].IsHQ && this.game.Data.UnitObj[this.game.Data.UnitObj[index13].HQ].AIGroup != this.game.Data.UnitObj[index13].AIGroup && this.game.Data.UnitObj[index13].TempGroup == -1)
          {
            if ( this.game.Data.RuleVar[887] < 1.0)
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[index13].X, this.game.Data.UnitObj[index13].Y, this.game.Data.UnitObj[index13].Map, allowshoredrop: true, SeaBlock: true);
            let mut index20: i32 = -1;
            let mut unitCounter9: i32 = this.game.Data.UnitCounter;
            for (let mut index21: i32 = 0; index21 <= unitCounter9; index21 += 1)
            {
              if (this.game.Data.UnitObj[index21].PreDef == -1 && this.game.Data.UnitObj[index21].AIGroup > 0 & this.game.Data.UnitObj[index21].AIGroup == this.game.Data.UnitObj[index13].AIGroup & this.game.Data.UnitObj[index21].Regime == this.game.Data.Turn && this.game.Data.UnitObj[index21].IsHQ)
              {
                if ( this.game.Data.RuleVar[887] < 1.0)
                {
                  if ( this.game.EditObj.TempValue[0].Value[this.game.Data.UnitObj[index21].X, this.game.Data.UnitObj[index21].Y] <  this.game.Data.RuleVar[51])
                  {
                    index20 = index21;
                    break;
                  }
                }
                else
                  index20 = index21;
              }
            }
            if (index20 > -1 & index13 != index20 & this.game.Data.UnitObj[index13].HQ != index20)
            {
              this.game.Data.UnitObj[index13].HQ = index20;
              if (alllog)
                this.AddLog("Unit with a HQ outside its own group " + this.game.Data.UnitObj[index13].Name + " found a HQ inside its own group: " + this.game.Data.UnitObj[index20].Name);
            }
          }
        }
      }
    }

    pub GetUnitPower: i32(
      unr: i32,
      bool Attack,
      let mut AttackX: i32 = -1,
      let mut AttackY: i32 = -1,
      let mut FromDirection: i32 = -1,
      let mut Theater: i32 = -1,
      bool IsArtilleryAttack = false,
      float LimitCombatmod = 5f,
      bool WithoutEntrench = false,
      bool EnemyAttack = false,
      bool UseTempCoords = false)
    {
      let mut unitPower: i32 = 0;
      if (this.game.Data.UnitObj[unr].SFCount <= -1)
        return 0;
      let mut sfCount: i32 = this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      float num2;
      num3: i32;
      for (let mut index: i32 = 0; index <= sfCount; index += 1)
      {
        let mut sf: i32 = this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 = this.game.Data.SFObj[sf].Type;
        if (this.game.Data.SFTypeObj[type].Theater == Theater | Theater == -1 && !IsArtilleryAttack | this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ArtRange > 0 | this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2)
        {
          let mut powerPts: i32 = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
          let mut num4: i32 = this.game.Data.SFObj[sf].Qty * powerPts;
          num1 += num4;
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].ArtRange > 0 & IsArtilleryAttack & Attack)
            num4 =  Math.Round( ( num4 * this.CONST_ARTMULTI));
          if (this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].Theater == 2 & IsArtilleryAttack & Attack)
            num4 =  Math.Round( ( num4 * this.CONST_AIRMULTI));
          let mut regime: i32 = this.game.Data.UnitObj[unr].Regime;
          let mut num5: i32 =  Math.Round( ( num4 * this.game.Data.PeopleObj[this.game.Data.SFObj[sf].People].BattleForMod[this.game.Data.PeopleObj[this.game.Data.RegimeObj[regime].People].PeopleGroup]));
          if (this.game.Data.Round > 1)
            num5 =  Math.Round( num5 * 0.2 +  num5 * 0.8 * ( this.game.Data.UnitObj[unr].SupplyConsume / 100.0));
          let mut num6: i32 =  Math.Round( num5 * ( this.game.Data.SFObj[sf].Mor / 50.0));
          if (this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpCombat > 0)
            num6 +=  Math.Round( num6 * ( this.game.Data.RegimeObj[this.game.Data.UnitObj[unr].Regime].AIHelpCombat / 100.0));
          let mut num7: i32 = !Attack ?  Math.Round( num6 * 0.3 +  num6 * 0.7 * ( this.game.Data.SFObj[sf].Rdn / 100.0)) :  Math.Round(  Math.Round( num6 * ( this.game.Data.SFObj[sf].Rdn / 100.0)) * ( this.game.Data.SFObj[sf].Rdn / 100.0));
          if (Attack & AttackX > -1)
            num7 =  Math.Round( (  Math.Round( ( num7 * this.game.Data.SFTypeObj[type].CombatModAtt[this.game.Data.MapObj[0].HexObj[AttackX, AttackY].LandscapeType])) * this.game.Data.SFTypeObj[type].CombatModAtt[this.game.Data.MapObj[0].HexObj[AttackX, AttackY].LandscapeType]));
          else if (!WithoutEntrench & !Attack)
            num7 = !(UseTempCoords & this.game.Data.UnitObj[unr].TempX > -1 & !(this.game.Data.UnitObj[unr].TempX == this.game.Data.UnitObj[unr].X & this.game.Data.UnitObj[unr].TempY == this.game.Data.UnitObj[unr].Y)) ?  Math.Round( (  Math.Round( ( num7 *  (1.0 + ( this.game.Data.SFObj[sf].CurrentEntrench +  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType].DefBonus[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup]) / 100.0))) * this.game.Data.SFTypeObj[type].CombatModDef[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y].LandscapeType])) :  Math.Round( (  Math.Round( ( num7 *  (1.0 + 1.0 *  this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY].LandscapeType].DefBonus[this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup] / 100.0))) * this.game.Data.SFTypeObj[type].CombatModDef[this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY].LandscapeType]));
          let mut Number: i32 =  Math.Round( (1 * num7) +  this.game.Data.SFObj[sf].Xp / 50.0 *  num7);
          if (this.game.Data.UnitObj[unr].HQ > -1 & this.game.Data.SFTypeObj[type].Theater == 0)
            Number =  Math.Round( ( Number *  ( this.game.HandyFunctionsObj.Gethqpow(unr, true) *  this.game.Data.UnitObj[unr].TempCombatImprovePercent / 100.0)));
          if (Attack & AttackX > -1 & !IsArtilleryAttack)
          {
            float num8 = this.GetAverageCombatScore(type, AttackX, AttackY, IsArtilleryAttack, EnemyAttack);
            if ( num8 >  LimitCombatmod)
              num8 = LimitCombatmod;
            if ( num8 < 1.0 /  LimitCombatmod)
              num8 = 1f / LimitCombatmod;
            num2 +=   Math.Round( (num8 *  (this.game.Data.SFObj[sf].Qty * powerPts)));
            num3 += this.game.Data.SFObj[sf].Qty * powerPts;
          }
          unitPower += Conversion.Int(Number);
        }
      }
      if (Attack & AttackX > -1 & !IsArtilleryAttack & FromDirection > -1)
      {
        if (this.game.Data.MapObj[0].HexObj[AttackX, AttackY].RiverType[FromDirection] > -1)
          unitPower =  Math.Round( ( unitPower * this.GetRiverMod(unr, this.game.Data.MapObj[0].HexObj[AttackX, AttackY].RiverType[FromDirection])));
      }
      else
        unitPower = unitPower;
      if (num3 > 0)
      {
        float num9 = num2 /  num3;
        unitPower =  Math.Round( ( unitPower * num9));
      }
      if (unitPower < 1 & num1 > 0)
        unitPower =  Math.Round(Math.Max(1.0,  num1 / 10.0));
      return unitPower;
    }

    pub fn MakeTempCategories(bool tlog)
    {
      if (tlog)
        this.AddLog("MAKETEMPCATEGORIES");
      if (tlog)
        this.AddLog("");
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1)
        {
          if (this.GetAIRolePercent(index, 8) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 2;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = ARTILLERY");
          }
          else if (this.GetAIRolePercent(index, 12) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 5;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = FLAK");
          }
          else if (this.GetAIRolePercent(index, 13) + this.GetAIRolePercent(index, 14) + this.GetAIRolePercent(index, 15) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 3;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = AIR");
          }
          else if (this.GetAIRolePercent(index, 5) > 20)
          {
            this.game.Data.UnitObj[index].TempCategory = 4;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = ENGINEER");
          }
          else if (this.game.HandyFunctionsObj.HasUnitNavySF(index))
          {
            if (this.game.HandyFunctionsObj.GetUnitCarryCap(index, 1) > 0)
            {
              this.game.Data.UnitObj[index].TempCategory = 6;
              if (tlog)
                this.AddLog(Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = NAVAL CARGO");
            }
            else
            {
              this.game.Data.UnitObj[index].TempCategory = 7;
              if (tlog)
                this.AddLog(Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = NAVAL ATTACK");
            }
          }
          else
          {
            this.game.Data.UnitObj[index].TempCategory = 1;
            if (tlog)
              this.AddLog(Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name + ", category = NORMAL");
          }
        }
      }
    }

    pub fn InitAI()
    {
      this.FullLog = true;
      this.ScreenyLog = false;
      if (!this.game.Data.DontShowAIMove)
        this.ScreenyLog = false;
      this.game.EditObj.TempAIString = "Preparing AI Initialization";
      this.game.EditObj.AIProgressNow = 0;
      this.game.EditObj.AIProgressMax = 100;
      this.LogCounter = -1;
      this.LogCounter2 = -1;
      if (this.LastRegime == this.game.Data.Turn)
        this.LastRegime = -1;
      else if (this.LastRegime > -1 & this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime == this.LastRegime)
      {
        this.game.AIRunning = false;
        return;
      }
      if (this.LastRegime > -1 && this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime > -1 & this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime == this.game.Data.RegimeObj[this.LastRegime].UberRegime)
      {
        this.game.AIRunning = false;
      }
      else
      {
        this.LastRegime = this.game.Data.Turn;
        this.InitialCalculations(this.FullLog);
        if (this.FullLog)
          this.WriteLog("01_InitialCalculations");
        this.LogCounter = -1;
        this.MakeCombatMatrix(this.FullLog);
        if (this.FullLog)
          this.WriteLog("02_MakeCombatMatrix");
        this.LogCounter = -1;
        this.MakeTempMovementTypes(this.FullLog);
        if (this.FullLog)
          this.WriteLog("03_MakeTempMovementTypes");
        this.LogCounter = -1;
        this.MakeTempCategories(this.FullLog);
        if (this.FullLog)
          this.WriteLog("04_MakeTempCategories");
        this.LogCounter = -1;
        this.MakeAreaMatrix(this.FullLog);
        if (this.FullLog)
          this.WriteLog("05_MakeAreaMatrix");
        this.LogCounter = -1;
        this.ResetExtraAreaMemory(this.FullLog);
        if (this.FullLog)
          this.WriteLog("06_ResetExtraAreaMemory");
        this.LogCounter = -1;
        this.MakeDistanceEnemyToArea(this.FullLog);
        if (this.FullLog)
          this.WriteLog("07_MakeDistanceEnemyToArea");
        this.LogCounter = -1;
        this.MakeGroups(this.FullLog);
        if (this.FullLog)
          this.WriteLog("08_MakeGroups");
        this.LogCounter = -1;
        if (this.GroupCounter < 0)
        {
          this.game.AIRunning = false;
        }
        else
        {
          this.game.EventRelatedObj.DoCheckEvents(6);
          this.MakeCorpsAndAreaAssesment(this.FullLog);
          if (this.FullLog)
            this.WriteLog("09_MakeCorpsAndAreaAssesment");
          this.LogCounter = -1;
          this.FindBestStrategy(this.FullLog, false);
          this.CurrentAreaGroup = 1;
          this.LogCounter = -1;
          this.GetStrategyScore( this.BestStrategy, true, 1f);
          if (this.FullLog)
            this.WriteLog("10_FindBestStrategy_04_the_best_strategy_score");
          this.LogCounter = -1;
          this.StrategyLog();
          if (this.FullLog)
            this.WriteLog("10_FindBestStrategy_05_the_best_strategy_moves");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Make Supply Matrix";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.MakeSupplyMatrix(this.FullLog, false);
          if (this.FullLog)
            this.WriteLog("11_MakeSupplyMatrix");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Implement Best Strategy";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.ImplementBestStrategy(this.FullLog);
          if (this.FullLog)
            this.WriteLog("12_ImplementBestStrategy");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Re-order Groups";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.ReOrderGroups(this.FullLog);
          if (this.FullLog)
            this.WriteLog("13_ReOrderGroups");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Changing HQs";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.ChangingHQs(this.FullLog);
          if (this.FullLog)
            this.WriteLog("14_ChangingHQs");
          this.LogCounter = -1;
          this.game.EditObj.TempAIString = "Init Strategic Transfers";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.InitStrategicTransfers(this.FullLog);
          if (this.FullLog)
            this.WriteLog("15_InitStrategicTransfers");
          this.LogCounter = -1;
          this.InitSetAirIntercept(this.FullLog);
          if (this.FullLog)
            this.WriteLog("16_InitSetAirIntercept");
          this.LogCounter = -1;
          this.MakeSupplyMatrix(false, false);
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut index: i32 = 0; index <= unitCounter; index += 1)
          {
            if (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index].AIGroup > -1)
              this.game.Data.UnitObj[index].TempAIString = this.GroupName[this.game.Data.UnitObj[index].AIGroup] + "\r\n... Fallback = " + this.GetAreaName(this.game.Data.UnitObj[index].AIFallback) + "\r\n, Defend = " + this.GetAreaName(this.game.Data.UnitObj[index].AIDefend) + "\r\n, Attack= " + this.GetAreaName(this.game.Data.UnitObj[index].AIAttack) + "\r\n, Followup = " + this.GetAreaName(this.game.Data.UnitObj[index].AIFollowup) + "\r\n, Stance = " + Conversion.Str( this.game.Data.UnitObj[index].AIAttackStyle);
          }
          let mut groupCounter1: i32 = this.GroupCounter;
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupCounter = groupCounter1;
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupType = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupName = new string[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupHis = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastAttack = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastDefend = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFollowUp = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFallBack = new int[groupCounter1 + 1];
          this.game.Data.RegimeObj[this.game.Data.Turn].AICorpsTopGroup = new int[groupCounter1 + 1];
          let mut groupCounter2: i32 = this.GroupCounter;
          for (let mut index: i32 = 0; index <= groupCounter2; index += 1)
          {
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupType[index] = this.GroupType[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupName[index] = this.GroupName[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupHis[index] = this.GroupHis[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastAttack[index] = this.GroupAttack[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastDefend[index] = this.GroupDefend[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFollowUp[index] = this.GroupFollowUp[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AIGroupLastFallBack[index] = this.GroupFallBack[index];
            this.game.Data.RegimeObj[this.game.Data.Turn].AICorpsTopGroup[index] = this.CorpsTopGroup[index];
          }
          this.game.EditObj.TempAIString = "Preparing AI execution";
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.AIProgressMax = 100;
          this.WriteLog();
          this.game.AIRunning = false;
        }
      }
    }

    pub fn StrategyLog()
    {
      this.AddLog("BEST STRATEGY");
      if (Information.IsNothing( this.BestStrategy))
        return;
      let mut counter: i32 = this.BestStrategy.Counter;
      for (let mut index1: i32 = 0; index1 <= counter; index1 += 1)
      {
        if (this.BestStrategy.Id[index1] < 99000)
          this.AddLog(this.GroupName[this.BestStrategy.Id[index1]] + ", STEP1=" + this.GetAreaName(this.BestStrategy.Data1[index1]) + ", STEP2=" + this.GetAreaName(this.BestStrategy.Data2[index1]) + ", STEP3=" + this.GetAreaName(this.BestStrategy.Data3[index1]) + ", STEP4=" + this.GetAreaName(this.BestStrategy.Data4[index1]) + ", STEP5=" + this.GetAreaName(this.BestStrategy.Data5[index1]));
        else if (this.BestStrategy.Id[index1] < 199000)
        {
          this.AddLog(this.GroupName[this.BestStrategy.Id[index1] - 99000] + ", STANCE=" + Conversion.Str( this.BestStrategy.Data1[index1]));
        }
        else
        {
          let mut index2: i32 = this.BestStrategy.Id[index1] - 199000;
          if (this.BestStrategy.Data1[index1] > -1)
            this.AddLog(this.GroupName[index2] + ", AIRFORCE TOO=" + this.GroupName[this.BestStrategy.Data1[index1]]);
        }
      }
    }

    pub fn InitialCalculations(bool tlog)
    {
      if (tlog)
        this.AddLog("INITIALCALCULATIONS()");
      GC.Collect();
      this.EnemyMatrix = new int[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.EnemyMatrixCameFrom = new sCoordinate[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.tArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.MoveMatrix = new int[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.MoveMatrixCameFrom = new sCoordinate[91, this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.TempOwner = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.TempCounterOwner = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
      {
        this.game.Data.UnitObj[index].FinalX = -1;
        this.game.Data.UnitObj[index].FinalY = -1;
        this.game.Data.UnitObj[index].OldX = this.game.Data.UnitObj[index].X;
        this.game.Data.UnitObj[index].OldY = this.game.Data.UnitObj[index].Y;
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SET UNIT VALUES");
      let mut unitCounter2: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter2; index += 1)
      {
        if (this.game.Data.UnitObj[index].X > -1 & this.game.Data.UnitObj[index].PreDef == -1)
        {
          this.game.Data.UnitObj[index].TempUnitPower = this.GetUnitPower(index, false);
          this.game.Data.UnitObj[index].TempCombatImprovePercent = this.game.HandyFunctionsObj.GetCombatImprovePercent(index);
          if (tlog)
            this.AddLog(Strings.Trim(Conversion.Str( index)) + ": " + this.game.Data.UnitObj[index].Name + ", TempUnitPower = " + Strings.Trim(Conversion.Str( this.game.Data.UnitObj[index].TempUnitPower)) + ", CombatImprovePercent = " + Strings.Trim(Conversion.Str( this.game.Data.UnitObj[index].TempCombatImprovePercent)));
        }
      }
      this.AreaMatrixNarrow = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.AreaMatrixWide = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.CombatMatrix = new float[this.game.Data.SFTypeCounter + 1, this.game.Data.SFTypeCounter + 1];
      if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 250)
      {
        this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 6800;
        this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 500;
      }
      else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
      {
        this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 4000;
        this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 350;
      }
      else
      {
        this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 2000;
        this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 200;
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SET DIFFICULTY SETTING");
      if (tlog)
        this.AddLog("Prod Bonus for regime was set to " + Strings.Trim(Conversion.Str( this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus)));
      if (tlog)
        this.AddLog("Strategy Moves = " + Strings.Trim(Conversion.Str( this.DIFFICULTY_LEVEL_STRATEGY_MOVES)));
      if (tlog)
        this.AddLog("Tactical Moves = " + Strings.Trim(Conversion.Str( this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE)));
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("SET ATTACK_MINIMUM_ACTUAL_ATTACK");
      this.ATTACK_MINIMUM_ACTUAL_ATTACK =  this.game.Data.RuleVar[358] > 0.0 ?  Math.Round( this.game.Data.RuleVar[358]) : 62;
      if (tlog)
        this.AddLog("set to: " + Strings.Trim(Conversion.Str( this.ATTACK_MINIMUM_ACTUAL_ATTACK)));
      if (!( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0))
        return;
      this.ATTACK_MINIMUM_ACTUAL_ATTACK =  Math.Round( ( this.ATTACK_MINIMUM_ACTUAL_ATTACK * this.game.Data.RegimeObj[this.game.Data.Turn].AIConservative));
      if (!tlog)
        return;
      this.AddLog("after modification with AIConservative setting: " + Strings.Trim(Conversion.Str( this.ATTACK_MINIMUM_ACTUAL_ATTACK)));
    }

    pub fn MakeOpHQSupplyMatrix(bool tlog)
    {
      this.SupplyMatrixOpHQPrognosis = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixOpHQReal = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixOpHQPrognosisCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixOpHQRealCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      if (groupHq > -1)
      {
        if (tlog)
          this.AddLog("MakeOPHQSupplyMatrix for " + this.game.Data.UnitObj[groupHq].Name);
      }
      else if (tlog)
        this.AddLog("MakeOPHQSupplyMatrix. But not HQ unit found.");
      if (tlog)
        this.AddLog("");
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.SupplyMatrixOpHQReal[index1, index2] = 9999;
          this.SupplyMatrixOpHQPrognosis[index1, index2] = 9999;
        }
      }
      this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y, 0);
      let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
        {
          this.SupplyMatrixOpHQReal[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
          this.SupplyMatrixOpHQRealCameFrom[index3, index4] = this.game.EditObj.TempCameFrom[0].Value[index3, index4];
        }
      }
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made of SupplyMatrixOPHQReal");
        this.Screenshot(1, "SUPPLYMATRIXOPHQREAL_" + this.GroupName[this.OpGroup],  this.SupplyMatrixOpHQReal);
      }
      this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y, 0, dontenterenemy: false, DontCountEnemyRoads: true);
      let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index5: i32 = 0; index5 <= mapWidth3; index5 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index6: i32 = 0; index6 <= mapHeight; index6 += 1)
        {
          this.SupplyMatrixOpHQPrognosis[index5, index6] = this.game.EditObj.TempValue[0].Value[index5, index6];
          this.SupplyMatrixOpHQPrognosisCameFrom[index5, index6] = this.game.EditObj.TempCameFrom[0].Value[index5, index6];
        }
      }
      if (!this.ScreenyLog)
        return;
      if (tlog)
        this.AddLog("Screenshot has been made of SupplyMatrixOPHQPrognosis");
      this.Screenshot(1, "SUPPLYMATRIXOPHQPROGNOSIS_" + this.GroupName[this.OpGroup],  this.SupplyMatrixOpHQReal);
    }

    pub fn MakeEnemySupplyMatrix(bool tlog)
    {
      let mut movetype: i32 =  Math.Round( this.game.Data.RuleVar[99]);
      if ( this.game.Data.RuleVar[890] > 0.0)
        movetype =  Math.Round( this.game.Data.RuleVar[890]);
      this.SupplyMatrixEnemyPrognosis = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixEnemyReal = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixEnemyPrognosisCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixEnemyRealCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (tlog)
        this.AddLog(nameof (MakeEnemySupplyMatrix));
      if (tlog)
        this.AddLog("");
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.SupplyMatrixEnemyReal[index1, index2] = 9999;
          this.SupplyMatrixEnemyPrognosis[index1, index2] = 9999;
        }
      }
      let mut regimeCounter: i32 = this.game.Data.RegimeCounter;
      for (let mut index3: i32 = 0; index3 <= regimeCounter; index3 += 1)
      {
        let mut regime: i32 = this.GetRegime(index3);
        if (regime != this.GetGameDataTurn())
        {
          if ( this.game.Data.RuleVar[335] > 0.0)
          {
            let mut num: i32 = 0;
            do
            {
              if (this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num * 4)))] > 0)
              {
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[index3].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[index3].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))], 0);
                let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
                for (let mut index4: i32 = 0; index4 <= mapWidth2; index4 += 1)
                {
                  let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                  for (let mut index5: i32 = 0; index5 <= mapHeight; index5 += 1)
                  {
                    if (this.SupplyMatrixEnemyReal[index4, index5] > this.game.EditObj.TempValue[0].Value[index4, index5])
                    {
                      this.SupplyMatrixEnemyReal[index4, index5] = this.game.EditObj.TempValue[0].Value[index4, index5];
                      this.SupplyMatrixEnemyRealCameFrom[index4, index5] = this.game.EditObj.TempCameFrom[0].Value[index4, index5];
                    }
                  }
                }
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[index3].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[index3].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))], 0, dontenterenemy: false, DontCountEnemyRoads: true);
                let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
                for (let mut index6: i32 = 0; index6 <= mapWidth3; index6 += 1)
                {
                  let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                  for (let mut index7: i32 = 0; index7 <= mapHeight; index7 += 1)
                  {
                    if (this.SupplyMatrixEnemyPrognosis[index6, index7] > this.game.EditObj.TempValue[0].Value[index6, index7])
                    {
                      this.SupplyMatrixEnemyPrognosis[index6, index7] = this.game.EditObj.TempValue[0].Value[index6, index7];
                      this.SupplyMatrixEnemyPrognosisCameFrom[index6, index7] = this.game.EditObj.TempCameFrom[0].Value[index6, index7];
                    }
                  }
                }
              }
              num += 1;
            }
            while (num <= 3);
          }
          else
          {
            let mut areaCount: i32 = this.AreaCount;
            for (let mut i: i32 = 0; i <= areaCount; i += 1)
            {
              if (this.IsAreaSupplySource(i, index3))
              {
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99,  Math.Round( this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0);
                let mut mapWidth4: i32 = this.game.Data.MapObj[0].MapWidth;
                for (let mut index8: i32 = 0; index8 <= mapWidth4; index8 += 1)
                {
                  let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                  for (let mut index9: i32 = 0; index9 <= mapHeight; index9 += 1)
                  {
                    if (this.SupplyMatrixEnemyReal[index8, index9] > this.game.EditObj.TempValue[0].Value[index8, index9])
                    {
                      this.SupplyMatrixEnemyReal[index8, index9] = this.game.EditObj.TempValue[0].Value[index8, index9];
                      this.SupplyMatrixEnemyRealCameFrom[index8, index9] = this.game.EditObj.TempCameFrom[0].Value[index8, index9];
                    }
                  }
                }
                this.game.HandyFunctionsObj.MakeMovePrediction2(regime, movetype, 99,  Math.Round( this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0, dontenterenemy: false, DontCountEnemyRoads: true);
                let mut mapWidth5: i32 = this.game.Data.MapObj[0].MapWidth;
                for (let mut index10: i32 = 0; index10 <= mapWidth5; index10 += 1)
                {
                  let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                  for (let mut index11: i32 = 0; index11 <= mapHeight; index11 += 1)
                  {
                    if (this.SupplyMatrixEnemyPrognosis[index10, index11] > this.game.EditObj.TempValue[0].Value[index10, index11])
                    {
                      this.SupplyMatrixEnemyPrognosis[index10, index11] = this.game.EditObj.TempValue[0].Value[index10, index11];
                      this.SupplyMatrixEnemyPrognosisCameFrom[index10, index11] = this.game.EditObj.TempCameFrom[0].Value[index10, index11];
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (this.ScreenyLog)
      {
        if (tlog)
          this.AddLog("Screenshot has been made of SupplyMatrixEnemyReal");
        this.Screenshot(1, "SUPPLYMATRIXOPHQPROGNOSIS_" + this.GroupName[this.OpGroup],  this.SupplyMatrixEnemyReal);
      }
      if (!this.ScreenyLog)
        return;
      if (tlog)
        this.AddLog("Screenshot has been made of SupplyMatrixEnemyPrognosis");
      this.Screenshot(1, "SUPPLYMATRIXOPHQPROGNOSIS_" + this.GroupName[this.OpGroup],  this.SupplyMatrixEnemyPrognosis);
    }

    pub fn MakeCombatMatrix(bool tlog)
    {
      if (tlog)
        this.AddLog("COMBATMATRIX");
      if (tlog)
        this.AddLog("");
      let mut sfTypeCounter1: i32 = this.game.Data.SFTypeCounter;
      for (let mut index1: i32 = 0; index1 <= sfTypeCounter1; index1 += 1)
      {
        if (tlog)
          this.AddLog("********* " + this.game.Data.SFTypeObj[index1].Name + " VERSUS: ");
        let mut sfTypeCounter2: i32 = this.game.Data.SFTypeCounter;
        for (let mut index2: i32 = 0; index2 <= sfTypeCounter2; index2 += 1)
        {
          let mut num1: i32 = this.game.Data.SFTypeObj[index1].AttackPower[this.game.Data.SFTypeObj[index2].UnitGroup] * this.game.Data.SFTypeObj[index1].Attacks;
          let mut num2: i32 = this.game.Data.SFTypeObj[index2].AttackPowerDef[this.game.Data.SFTypeObj[index1].UnitGroup] * this.game.Data.SFTypeObj[index2].Attacks;
          let mut num3: i32 = this.game.Data.SFTypeObj[index1].HitPoints[this.game.Data.SFTypeObj[index2].UnitGroup];
          let mut num4: i32 = this.game.Data.SFTypeObj[index2].HitPointsDef[this.game.Data.SFTypeObj[index1].UnitGroup];
          let mut num5: i32 = this.game.Data.SFTypeObj[index1].PowerPts;
          let mut num6: i32 = this.game.Data.SFTypeObj[index2].PowerPts;
          if (num6 == 0)
            num6 = 1;
          if (num5 == 0)
            num5 = 1;
          float num7 = 1f;
          float num8 = 1f;
          if (num5 > num6)
          {
            num2 =  Math.Round( num2 * ( num5 /  num6));
            num4 =  Math.Round( num4 * ( num5 /  num6));
            num8 *=  num5 /  num6;
          }
          else if (num6 > num5)
          {
            num1 =  Math.Round( num1 * ( num6 /  num5));
            num3 =  Math.Round( num3 * ( num6 /  num5));
            num7 *=  num6 /  num5;
          }
          if ( num7 *  this.game.Data.SFTypeObj[index1].Attacks >  num8 *  this.game.Data.SFTypeObj[index2].MaxAttacked)
            num1 =  Math.Round( ( num1 *  ( num8 *  this.game.Data.SFTypeObj[index2].MaxAttacked / ( num7 *  this.game.Data.SFTypeObj[index1].Attacks))));
          if ( num8 *  this.game.Data.SFTypeObj[index2].Attacks >  num7 *  this.game.Data.SFTypeObj[index1].MaxAttacked)
            num2 =  Math.Round( ( num2 *  ( num7 *  this.game.Data.SFTypeObj[index1].MaxAttacked / ( num8 *  this.game.Data.SFTypeObj[index2].Attacks))));
          float num9 =  num1 /  num4;
          float num10 =  num2 /  num3;
          float Number =  num10 <= 0.0 ? 25f : num9 / num10;
          if ( Number > 5.0)
            Number = 5f +  Math.Sqrt( Number - 4.0);
          if ( Number < 0.2)
            Number = 0.2f;
          let mut theater1: i32 = this.game.Data.SFTypeObj[index1].Theater;
          let mut theater2: i32 = this.game.Data.SFTypeObj[index2].Theater;
          if (theater1 == 0 & theater2 == 2)
            Number = 10f;
          this.CombatMatrix[index1, index2] = Number;
          if (theater1 == theater2 |  num9 > 0.0 && tlog)
            this.AddLog(this.game.Data.SFTypeObj[index2].Name + " = " + Conversion.Str( Number));
        }
      }
    }

    pub fn MakeBottleNeckMatrix()
    {
      this.BottleNeckMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      CoordList coordList1 = CoordList::new();
      let mut regime: i32 = this.GetRegime(this.GetLargestEnemy());
      let mut num1: i32 = 0;
      if (regime == -1)
        return;
      let mut num2: i32 = 0;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        this.game.Data.UnitObj[index].TempX = this.game.Data.UnitObj[index].X;
        this.game.Data.UnitObj[index].TempY = this.game.Data.UnitObj[index].Y;
        if (this.game.Data.UnitObj[index].AIGroup == this.OpGroup & this.game.Data.UnitObj[index].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index].X > -1)
        {
          let mut num3: i32 = 600;
          if ( this.game.Data.UnitObj[index].SupplyIn <  this.game.Data.UnitObj[index].SupplyInReq * 0.25)
            num3 =  Math.Round( num3 * 2.5);
          if ( this.game.Data.UnitObj[index].Supply <  this.game.Data.UnitObj[index].SupplyInReq * 0.1)
            num3 =  Math.Round( num3 * 1.5);
          if (this.game.Data.UnitObj[index].IsHQ)
            num3 *= 3;
          num2 += num3;
        }
      }
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.TempOwner[index1, index2] = this.game.Data.MapObj[0].HexObj[index1, index2].Regime;
          this.TempCounterOwner[index1, index2] = this.game.Data.MapObj[0].HexObj[index1, index2].Regime;
          this.BottleNeckMatrix[index1, index2] = 0;
        }
      }
      let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
        {
          let mut num4: i32 = 0;
          if (index3 == 47 & index4 == 34)
            index3 = index3;
          if (index3 == 49 & index4 == 33)
            index3 = index3;
          if (this.FrontlineArea[index3, index4] > 0)
            num4 = 1;
          Coordinate coordinate1;
          if (num4 == 0 & (this.tArea[index3, index4] == 2 | this.tArea[index3, index4] == 6 | this.tArea[index3, index4] == 3))
          {
            let mut tfacing: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index3, index4, 0, tfacing);
              if (coordinate1.onmap && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime))
                num4 = 1;
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
          if (num4 > 0)
          {
            CoordList coordList2 = CoordList::new();
            coordList2.AddCoord(index3, index4, 0);
            this.TempCounterOwner[index3, index4] = regime;
            SimpleList tempMove = SimpleList::new();
            let mut num5: i32 = this.GetOurSelvesEncircledScore( tempMove, false, true);
            if (num5 > 0)
              num5 = num5;
            this.BottleNeckMatrix[index3, index4] =  Math.Round( (num5 * 100) /  num2);
            let mut tfacing1: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index3, index4, 0, tfacing1);
              if (coordinate1.onmap)
              {
                coordList2.AddCoord(coordinate1.x, coordinate1.y, 0);
                this.TempCounterOwner[coordinate1.x, coordinate1.y] = regime;
              }
              tfacing1 += 1;
            }
            while (tfacing1 <= 6);
            tempMove = SimpleList::new();
            let mut num6: i32 = this.GetOurSelvesEncircledScore( tempMove, false, true);
            if (num6 > 0)
              num6 = num6;
            bottleNeckMatrix1: Vec<i32> = this.BottleNeckMatrix;
            numArray1: Vec<i32> = bottleNeckMatrix1;
            let mut index5: i32 = index3;
            let mut index6: i32 = index5;
            let mut index7: i32 = index4;
            let mut index8: i32 = index7;
            let mut num7: i32 = bottleNeckMatrix1[index5, index7] +  Math.Round( (num6 * 33) /  num2);
            numArray1[index6, index8] = num7;
            let mut tfacing2: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index3, index4, 0, tfacing2);
              if (coordinate1.onmap)
              {
                let mut num8: i32 = 1;
                do
                {
                  Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                  if (coordinate2.onmap)
                  {
                    coordList2.AddCoord(coordinate2.x, coordinate2.y, 0);
                    this.TempCounterOwner[coordinate2.x, coordinate2.y] = regime;
                  }
                  num8 += 1;
                }
                while (num8 <= 6);
              }
              tfacing2 += 1;
            }
            while (tfacing2 <= 6);
            tempMove = SimpleList::new();
            let mut num9: i32 = this.GetOurSelvesEncircledScore( tempMove, false, true);
            if ( Math.Round( (num9 * 12) /  num2) > 0)
              num9 = num9;
            bottleNeckMatrix2: Vec<i32> = this.BottleNeckMatrix;
            numArray2: Vec<i32> = bottleNeckMatrix2;
            let mut index9: i32 = index3;
            let mut index10: i32 = index9;
            let mut index11: i32 = index4;
            let mut index12: i32 = index11;
            let mut num10: i32 = bottleNeckMatrix2[index9, index11] +  Math.Round( (num9 * 12) /  num2);
            numArray2[index10, index12] = num10;
            if (this.BottleNeckMatrix[index3, index4] > num1)
              num1 = this.BottleNeckMatrix[index3, index4];
            let mut counter: i32 = coordList2.counter;
            for (let mut index13: i32 = 0; index13 <= counter; index13 += 1)
              this.TempCounterOwner[coordList2.coord[index13].x, coordList2.coord[index13].y] = this.game.Data.MapObj[0].HexObj[coordList2.coord[index13].x, coordList2.coord[index13].y].Regime;
          }
        }
      }
      if (num1 > 0)
        num1 = num1;
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index: i32 = 0; index <= moveMatrixCounter; index += 1)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Regime == this.game.Data.Turn & this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempGroup == -1)
          this.game.Data.UnitObj[this.MoveMatrixUnit[index]].AIBottleneck = num1;
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Regime == this.game.Data.Turn & this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempGroup > -1)
          this.game.Data.UnitObj[this.MoveMatrixUnit[index]].AIBottleneck = num1;
      }
    }

    pub fn MakeSupplyMatrix(bool tlog, bool OnlyReal)
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixPrognosis = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixPrognosisEasyRoads = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixReal = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixPrognosisCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixRealCameFrom = new Coordinate[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.DistanceFromSuppliedHex = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyMatrixDistance = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.SupplyMatrix[index1, index2] = -1;
          this.SupplyMatrixReal[index1, index2] = 9999;
          this.SupplyMatrixPrognosis[index1, index2] = 9999;
          this.SupplyMatrixDistance[index1, index2] = -1;
          numArray1[index1, index2] = 0;
        }
      }
      if ( this.game.Data.RuleVar[335] > 0.0)
      {
        let mut num: i32 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num * 4)))] > 0 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))]].Regime, this.GetGameDataTurn()))
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))], 0);
            let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
              {
                if (this.SupplyMatrixReal[index3, index4] > this.game.EditObj.TempValue[0].Value[index3, index4])
                {
                  this.SupplyMatrixReal[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
                  this.SupplyMatrixRealCameFrom[index3, index4] = this.game.EditObj.TempCameFrom[0].Value[index3, index4];
                }
              }
            }
            if (OnlyReal)
              return;
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))], 0, dontenterenemy: false);
            let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index5: i32 = 0; index5 <= mapWidth3; index5 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index6: i32 = 0; index6 <= mapHeight; index6 += 1)
              {
                if (this.SupplyMatrixPrognosisEasyRoads[index5, index6] > this.game.EditObj.TempValue[0].Value[index5, index6])
                  this.SupplyMatrixPrognosisEasyRoads[index5, index6] = this.game.EditObj.TempValue[0].Value[index5, index6];
              }
            }
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))], 0, dontenterenemy: false, DontCountEnemyRoads: true);
            let mut mapWidth4: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index7: i32 = 0; index7 <= mapWidth4; index7 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index8: i32 = 0; index8 <= mapHeight; index8 += 1)
              {
                if (this.SupplyMatrixPrognosis[index7, index8] > this.game.EditObj.TempValue[0].Value[index7, index8])
                {
                  this.SupplyMatrixPrognosis[index7, index8] = this.game.EditObj.TempValue[0].Value[index7, index8];
                  this.SupplyMatrixPrognosisCameFrom[index7, index8] = this.game.EditObj.TempCameFrom[0].Value[index7, index8];
                }
              }
            }
          }
          num += 1;
        }
        while (num <= 3);
      }
      else
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut i: i32 = 0; i <= areaCount; i += 1)
        {
          if (this.IsAreaSupplySource(i, this.game.Data.Turn))
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0);
            let mut mapWidth5: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index9: i32 = 0; index9 <= mapWidth5; index9 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index10: i32 = 0; index10 <= mapHeight; index10 += 1)
              {
                if (this.SupplyMatrixReal[index9, index10] > this.game.EditObj.TempValue[0].Value[index9, index10])
                {
                  this.SupplyMatrixReal[index9, index10] = this.game.EditObj.TempValue[0].Value[index9, index10];
                  this.SupplyMatrixRealCameFrom[index9, index10] = this.game.EditObj.TempCameFrom[0].Value[index9, index10];
                }
              }
            }
            if (OnlyReal)
              return;
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0, dontenterenemy: false);
            let mut mapWidth6: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index11: i32 = 0; index11 <= mapWidth6; index11 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index12: i32 = 0; index12 <= mapHeight; index12 += 1)
              {
                if (this.SupplyMatrixPrognosisEasyRoads[index11, index12] > this.game.EditObj.TempValue[0].Value[index11, index12])
                  this.SupplyMatrixPrognosisEasyRoads[index11, index12] = this.game.EditObj.TempValue[0].Value[index11, index12];
              }
            }
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.AreaCenter[i].x, this.AreaCenter[i].y, 0, dontenterenemy: false, DontCountEnemyRoads: true);
            let mut mapWidth7: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index13: i32 = 0; index13 <= mapWidth7; index13 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index14: i32 = 0; index14 <= mapHeight; index14 += 1)
              {
                if (this.SupplyMatrixPrognosis[index13, index14] > this.game.EditObj.TempValue[0].Value[index13, index14])
                {
                  this.SupplyMatrixPrognosis[index13, index14] = this.game.EditObj.TempValue[0].Value[index13, index14];
                  this.SupplyMatrixPrognosisCameFrom[index13, index14] = this.game.EditObj.TempCameFrom[0].Value[index13, index14];
                }
              }
            }
          }
        }
      }
      let mut groupCounter: i32 = this.GroupCounter;
      for (let mut grp: i32 = 0; grp <= groupCounter; grp += 1)
      {
        let mut groupHq: i32 = this.GetGroupHQ(grp);
        if (groupHq > -1 && this.GroupType[grp] <= 5)
        {
          let mut x: i32 = this.game.Data.UnitObj[groupHq].X;
          let mut y: i32 = this.game.Data.UnitObj[groupHq].Y;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1 && !(this.AreaMatrixWide[x, y] == this.game.Data.UnitObj[groupHq].AIDefend | this.AreaMatrixWide[x, y] == this.game.Data.UnitObj[groupHq].AIAttack) && this.game.Data.UnitObj[groupHq].AIDefend > 0 & this.game.Data.UnitObj[groupHq].AIDefend <= this.AreaCount)
          {
            x = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x;
            y = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y;
          }
          this.SupplyMatrix[x, y] = grp;
          numArray1[x, y] = 1;
          numArray2[x, y] = 1;
        }
      }
      let mut num1: i32 = 0;
      num2: i32;
      Coordinate coordinate;
      do
      {
        num2 = 0;
        num1 += 1;
        let mut mapWidth8: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut index15: i32 = 0; index15 <= mapWidth8; index15 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut index16: i32 = 0; index16 <= mapHeight; index16 += 1)
          {
            if (numArray1[index15, index16] == num1)
            {
              coordinate = this.game.EditObj.TempCameFrom[0].Value[index15, index16];
              if (coordinate.onmap & numArray1[coordinate.x, coordinate.y] == 0)
              {
                numArray1[coordinate.x, coordinate.y] = num1 + 1;
                num2 = 1;
              }
            }
          }
        }
      }
      while (num2 == 1);
      let mut num3: i32 = 0;
      num4: i32;
      do
      {
        num4 = 0;
        num3 += 1;
        let mut mapWidth9: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth9; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray2[cx, cy] == num3 & numArray1[cx, cy] > 0)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap & numArray1[coordinate.x, coordinate.y] > 0 & numArray2[coordinate.x, coordinate.y] == 0)
                {
                  numArray2[coordinate.x, coordinate.y] = num3 + 1;
                  this.SupplyMatrix[coordinate.x, coordinate.y] = this.SupplyMatrix[cx, cy];
                  num4 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num4 == 1);
      let mut mapWidth10: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index17: i32 = 0; index17 <= mapWidth10; index17 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index18: i32 = 0; index18 <= mapHeight; index18 += 1)
        {
          numArray1[index17, index18] = 0;
          if (this.SupplyMatrix[index17, index18] > -1)
          {
            numArray1[index17, index18] = 1;
            this.SupplyMatrixDistance[index17, index18] = 0;
          }
        }
      }
      let mut num5: i32 = 0;
      num6: i32;
      do
      {
        num6 = 0;
        num5 += 1;
        let mut mapWidth11: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth11; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray1[cx, cy] == num5)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[cx, cy].Regime == this.GetGameDataTurn() & numArray1[coordinate.x, coordinate.y] == 0)
                {
                  numArray1[coordinate.x, coordinate.y] = num5 + 1;
                  this.SupplyMatrix[coordinate.x, coordinate.y] = this.SupplyMatrix[cx, cy];
                  this.SupplyMatrixDistance[coordinate.x, coordinate.y] = num5;
                  num6 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num6 == 1 & num5 < 4);
      let mut mapWidth12: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index19: i32 = 0; index19 <= mapWidth12; index19 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index20: i32 = 0; index20 <= mapHeight; index20 += 1)
        {
          numArray1[index19, index20] = 0;
          if (index19 == 45 & index20 == 35)
            index19 = index19;
          if ( this.SupplyMatrixReal[index19, index20] <=  this.game.Data.RuleVar[53] & this.game.Data.MapObj[0].HexObj[index19, index20].Regime == this.GetGameDataTurn())
          {
            numArray1[index19, index20] = 1;
            this.DistanceFromSuppliedHex[index19, index20] = 1;
          }
          else
            this.DistanceFromSuppliedHex[index19, index20] = 9999;
        }
      }
      let mut num7: i32 = 0;
      num8: i32;
      do
      {
        num8 = 0;
        num7 += 1;
        let mut mapWidth13: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth13; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray1[cx, cy] == num7)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime != this.GetGameDataTurn() & numArray1[coordinate.x, coordinate.y] == 0)
                {
                  numArray1[coordinate.x, coordinate.y] = num7 + 1;
                  this.DistanceFromSuppliedHex[coordinate.x, coordinate.y] = num7;
                  num8 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num8 == 1 & num7 < 6);
      if (!(tlog & this.ScreenyLog))
        return;
      this.AddLog("MAKE SUPPLY MATRIX");
      this.AddLog("");
      this.AddLog("Screenshots have been made");
      this.Screenshot(1, "MakeSupplyMatrix_Real",  this.SupplyMatrixReal);
      this.Screenshot(1, "MakeSupplyMatrix_Prognosis",  this.SupplyMatrixPrognosis);
      this.Screenshot(1, nameof (MakeSupplyMatrix),  this.SupplyMatrix);
      this.Screenshot(1, "MakeSupplyMatrix_Distance",  this.SupplyMatrixDistance);
      this.Screenshot(1, "DistanceFromSuppliedHex",  this.DistanceFromSuppliedHex);
    }

    pub fn MoveAndAttackCorps()
    {
      this.MoveAndAttackRound = 0;
      if (this.OpGroup > this.TempGroupHQ.GetUpperBound(0))
        this.TempGroupHQ = (int[]) Utils.CopyArray((Array) this.TempGroupHQ, (Array) new int[this.OpGroup + 1]);
      this.TempGroupHQ[this.OpGroup] = this.GetGroupHQ(this.OpGroup);
      this.LogCounter = -1;
      this.MakeOpHQSupplyMatrix(this.FullLog);
      if (this.FullLog)
        this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_01_MakeOPHQSupplyMatrix");
      this.LogCounter = -1;
      this.MakeEnemySupplyMatrix(this.FullLog);
      if (this.FullLog)
        this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_02_MakeOPHQSupplyMatrix");
      this.LogCounter = -1;
      num1: i32;
      do
      {
        this.LogCounter = -1;
        this.TempGroupHQ[this.OpGroup] = this.GetGroupHQ(this.OpGroup);
        if (this.TempGroupHQ[this.OpGroup] != -1)
        {
          this += 1.MoveAndAttackRound;
          this.game.EditObj.AIProgressMax = 4;
          this.game.EditObj.AIProgressNow = 0;
          this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str( this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str(  Math.Round( this.game.EditObj.AIProgressNow /  this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
          bool flag = false;
          this.MadeMove = false;
          if (this.FullLog)
            this.AddLog("");
          if (this.FullLog)
            this.AddLog("Move And Attack Round #" + Conversion.Str( this.MoveAndAttackRound));
          if (this.SupplyMatrix.GetUpperBound(0) < this.game.Data.MapObj[0].MapWidth)
            this.MakeSupplyMatrix(false, false);
          this.MakeAdvanceAxisMatrix();
          this.SetTArea();
          this.MakeTScoreMatrix();
          this.game.EditObj.AIProgressMax = 4;
          this.game.EditObj.AIProgressNow = 1;
          this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Pre-processing round " + Conversion.Str( this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str(  Math.Round( this.game.EditObj.AIProgressNow /  this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
          this.MovingIn = false;
          if (this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend > -1 & this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend <= this.AreaCount & this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIAttack <= this.AreaCount)
          {
            if (this.MoveAndAttackRound == 1 & this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIAttackStyle == 1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].y].Regime) == this.GetGameDataTurn())
            {
              if (this.FullLog)
                this.AddLog("ONLY MOVE UNITS OUTSIDE THE CORE DEFENSIVE AREA. DO NOT PUT VIRTUAL UNITS IN.");
              this.MakeMoveMatrix(true, false);
              this.MadeMove = true;
              this.MovingIn = true;
            }
            else if (this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIAttackStyle == 1)
            {
              if (this.FullLog)
                this.AddLog("PUT VIRTUAL UNITS IN.");
              this.MakeMoveMatrix(false, true);
            }
            else
            {
              if (this.FullLog)
                this.AddLog("NO VIRTUAL UNITS / NO LIMITATIONS");
              this.MakeMoveMatrix(false, false);
            }
            this.game.EditObj.AIProgressMax = 4;
            this.game.EditObj.AIProgressNow = 2;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str( this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str(  Math.Round( this.game.EditObj.AIProgressNow /  this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
            Application.DoEvents();
            this.MarkerList = SimpleList::new();
            this.AirMarkerList = SimpleList::new();
            this.ArtMarkerList = SimpleList::new();
            this.EngineerMarkerList = SimpleList::new();
            power: i32;
            if (this.Meeting | !this.Attacker && !(this.MoveAndAttackRound == 1 & (this.Meeting | !this.Attacker)) && this.GetGroupHQ(this.OpGroup) > -1)
            {
              let mut aiDefend: i32 = this.game.Data.UnitObj[this.GetGroupHQ(this.OpGroup)].AIDefend;
              if (aiDefend > -1 & this.game.Data.UnitObj[this.GetGroupHQ(this.OpGroup)].AIAttack == -1 && this.AreaCounterStep[aiDefend] >= 3 | this.AreaCounterStep[aiDefend] >= 1 & this.AreaCounterDirections[aiDefend, 1] == 0)
              {
                let mut num2: i32 = 1;
                if (this.FullLog)
                  this.AddLog("AreaCounterPower: " + Conversion.Str( this.AreaCounterPower[aiDefend]) + ", AreaCounterStep: " + Conversion.Str( this.AreaCounterStep[aiDefend]));
                let mut Number: i32 = 1;
                do
                {
                  if (this.AreaCounterDirections[aiDefend, Number] > 0 && this.AreaCounterRegime[aiDefend, Number] > -1)
                  {
                    if (this.FullLog)
                      this.AddLog("Direction " + Conversion.Str( Number) + " = " + this.GetAreaName(this.AreaCounterDirections[aiDefend, Number]) + ", " + this.game.Data.RegimeObj[this.AreaCounterRegime[aiDefend, Number]].Name);
                    if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.AreaCounterDirections[aiDefend, Number]].x, this.AreaCenter[this.AreaCounterDirections[aiDefend, Number]].y].Regime) != this.GetGameDataTurn())
                      num2 = 0;
                  }
                  Number += 1;
                }
                while (Number <= 9);
                power = this.AreaCounterPower[aiDefend];
                if (power > 0 & num2 == 1)
                  this.AddVirtualUnits(aiDefend, power, this.FullLog);
              }
            }
            this.MakeEnemyMoveMatrix();
            this.game.EditObj.AIProgressMax = 4;
            this.game.EditObj.AIProgressNow = 4;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str( this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str(  Math.Round( this.game.EditObj.AIProgressNow /  this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
            if (this.FullLog)
              this.AddLog("Enemy Move Matrix");
            s: String = "Units: ";
            let mut enemyMatrixCounter: i32 = this.EnemyMatrixCounter;
            for (let mut index: i32 = 1; index <= enemyMatrixCounter; index += 1)
            {
              s = s + this.game.Data.UnitObj[this.EnemyMatrixUnit[index]].Name + ", ";
              power += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(this.EnemyMatrixUnit[index]);
            }
            if (this.FullLog)
              this.AddLog(s);
            this.SetTArea();
            numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
            let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut ix: i32 = 0; ix <= mapWidth; ix += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut iy: i32 = 0; iy <= mapHeight; iy += 1)
                numArray[ix, iy] = this.GetTscore(ix, iy);
            }
            this.MakeBottleNeckMatrix();
            this.AddMarkers();
            this.game.EditObj.AIProgressMax = 4;
            this.game.EditObj.AIProgressNow = 3;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str( this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str(  Math.Round( this.game.EditObj.AIProgressNow /  this.game.EditObj.AIProgressMax * 100.0))) + "% completed.";
            Application.DoEvents();
            if (this.FullLog)
            {
              this.AddLog("Normal Markers");
              let mut counter1: i32 = this.MarkerList.Counter;
              for (let mut Number: i32 = 0; Number <= counter1; Number += 1)
              {
                this.AddLog("Marker [[" + Conversion.Str( Number) + ") Type=" + Conversion.Str( this.MarkerList.Weight[Number]) + "," + Conversion.Str( this.MarkerList.Data1[Number]) + "," + Conversion.Str( this.MarkerList.Data2[Number]) + "," + Conversion.Str( this.MarkerList.Data3[Number]) + "," + Conversion.Str( this.MarkerList.Data4[Number]) + ", score= " + Conversion.Str( this.MarkerList.Data5[Number]) + " ]] ...  ");
                this.GetTscore(this.MarkerList.Data1[Number], this.MarkerList.Data2[Number], MakeLog: true);
                if (this.MarkerList.Data3[Number] > -1)
                  this.GetTscore(this.MarkerList.Data3[Number], this.MarkerList.Data4[Number], MakeLog: true);
              }
              this.AddLog("Artillery Markers");
              let mut counter2: i32 = this.ArtMarkerList.Counter;
              for (let mut Number: i32 = 0; Number <= counter2; Number += 1)
                this.AddLog("Marker [[" + Conversion.Str( Number) + ") Type=" + Conversion.Str( this.ArtMarkerList.Weight[Number]) + "," + Conversion.Str( this.ArtMarkerList.Data1[Number]) + "," + Conversion.Str( this.ArtMarkerList.Data2[Number]) + "," + Conversion.Str( this.ArtMarkerList.Data3[Number]) + "," + Conversion.Str( this.ArtMarkerList.Data4[Number]) + ", score= " + Conversion.Str( this.ArtMarkerList.Data5[Number]) + " ]]");
              this.AddLog("Air Markers");
              let mut counter3: i32 = this.AirMarkerList.Counter;
              for (let mut Number: i32 = 0; Number <= counter3; Number += 1)
                this.AddLog("Marker [[" + Conversion.Str( Number) + ") Type=" + Conversion.Str( this.AirMarkerList.Weight[Number]) + "," + Conversion.Str( this.AirMarkerList.Data1[Number]) + "," + Conversion.Str( this.AirMarkerList.Data2[Number]) + "," + Conversion.Str( this.AirMarkerList.Data3[Number]) + "," + Conversion.Str( this.AirMarkerList.Data4[Number]) + ", score= " + Conversion.Str( this.AirMarkerList.Data5[Number]) + " ]]");
              this.AddLog("Engineer Markers");
              let mut counter4: i32 = this.EngineerMarkerList.Counter;
              for (let mut Number: i32 = 0; Number <= counter4; Number += 1)
                this.AddLog("Eng Marker [[" + Conversion.Str( Number) + ") Type=" + Conversion.Str( this.EngineerMarkerList.Weight[Number]) + "," + Conversion.Str( this.EngineerMarkerList.Data1[Number]) + "," + Conversion.Str( this.EngineerMarkerList.Data2[Number]) + "," + Conversion.Str( this.EngineerMarkerList.Data3[Number]) + "," + Conversion.Str( this.EngineerMarkerList.Data4[Number]) + ", score= " + Conversion.Str( this.EngineerMarkerList.Data5[Number]) + " ]]");
            }
            if (this.FullLog)
              this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_10_Round_" + this.MoveAndAttackRound.ToString());
            this.LogCounter = -1;
            this.MakeEnemyPowerDispersed();
            this.FindBestMove();
            this.AddLog("BestMove");
            if (!Information.IsNothing( this.BestMove))
            {
              if (this.FullLog)
              {
                let mut counter: i32 = this.BestMove.Counter;
                for (let mut Number1: i32 = 0; Number1 <= counter; Number1 += 1)
                {
                  let mut Number2: i32 = this.BestMove.Data2[Number1];
                  if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 1)
                    this.AddLog(Conversion.Str( Number1) + ") Type=" + Conversion.Str( this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[" + Conversion.Str( Number2) + ") Type=" + Conversion.Str( this.MarkerList.Weight[Number2]) + "," + Conversion.Str( this.MarkerList.Data1[Number2]) + "," + Conversion.Str( this.MarkerList.Data2[Number2]) + "," + Conversion.Str( this.MarkerList.Data3[Number2]) + "," + Conversion.Str( this.MarkerList.Data4[Number2]) + ", score= " + Conversion.Str( this.MarkerList.Data5[Number2]) + " ]] , " + Conversion.Str( this.BestMove.Data3[Number1]) + "," + Conversion.Str( this.BestMove.Data4[Number1]));
                  else if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 2 | this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 5)
                    this.AddLog(Conversion.Str( Number1) + ") Type=" + Conversion.Str( this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[ART" + Conversion.Str( Number2) + ") Type=" + Conversion.Str( this.ArtMarkerList.Weight[Number2]) + "," + Conversion.Str( this.ArtMarkerList.Data1[Number2]) + "," + Conversion.Str( this.ArtMarkerList.Data2[Number2]) + "," + Conversion.Str( this.ArtMarkerList.Data3[Number2]) + "," + Conversion.Str( this.ArtMarkerList.Data4[Number2]) + ", score= " + Conversion.Str( this.ArtMarkerList.Data5[Number2]) + " ]] , " + Conversion.Str( this.BestMove.Data3[Number1]) + "," + Conversion.Str( this.BestMove.Data4[Number1]));
                  else if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 3)
                    this.AddLog(Conversion.Str( Number1) + ") Type=" + Conversion.Str( this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[AIR" + Conversion.Str( Number2) + ") Type=" + Conversion.Str( this.AirMarkerList.Weight[Number2]) + "," + Conversion.Str( this.AirMarkerList.Data1[Number2]) + "," + Conversion.Str( this.AirMarkerList.Data2[Number2]) + "," + Conversion.Str( this.AirMarkerList.Data3[Number2]) + "," + Conversion.Str( this.AirMarkerList.Data4[Number2]) + ", score= " + Conversion.Str( this.AirMarkerList.Data5[Number2]) + " ]] , " + Conversion.Str( this.BestMove.Data3[Number1]) + "," + Conversion.Str( this.BestMove.Data4[Number1]));
                  else if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].TempCategory == 4)
                  {
                    if (this.EngineerMarkerList.Counter > -1)
                      this.AddLog(Conversion.Str( Number1) + ") Type=" + Conversion.Str( this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[ENG" + Conversion.Str( Number2) + ") Type=" + Conversion.Str( this.EngineerMarkerList.Weight[Number2]) + "," + Conversion.Str( this.EngineerMarkerList.Data1[Number2]) + "," + Conversion.Str( this.EngineerMarkerList.Data2[Number2]) + "," + Conversion.Str( this.EngineerMarkerList.Data3[Number2]) + "," + Conversion.Str( this.EngineerMarkerList.Data4[Number2]) + ", score= " + Conversion.Str( this.EngineerMarkerList.Data5[Number2]) + " ]] , " + Conversion.Str( this.BestMove.Data3[Number1]) + "," + Conversion.Str( this.BestMove.Data4[Number1]));
                    else
                      this.AddLog(Conversion.Str( Number1) + ") Type=" + Conversion.Str( this.BestMove.Weight[Number1]) + "," + this.game.Data.UnitObj[this.MoveMatrixUnit[this.BestMove.Data1[Number1]]].Name + ", Marker [[" + Conversion.Str( Number2) + ") Type=" + Conversion.Str( this.MarkerList.Weight[Number2]) + "," + Conversion.Str( this.MarkerList.Data1[Number2]) + "," + Conversion.Str( this.MarkerList.Data2[Number2]) + "," + Conversion.Str( this.MarkerList.Data3[Number2]) + "," + Conversion.Str( this.MarkerList.Data4[Number2]) + ", score= " + Conversion.Str( this.MarkerList.Data5[Number2]) + " ]] , " + Conversion.Str( this.BestMove.Data3[Number1]) + "," + Conversion.Str( this.BestMove.Data4[Number1]));
                  }
                }
              }
              this.GetMoveScore(this.BestMove, true);
              this.ExecuteBestMove( this.BestMove, false);
              flag = this.MaybeeExecuteAttackMarkers();
              if (this.FullLog)
                this.WriteLog("30_" + this.GroupName[this.OpGroup] + "_20_Round_" + this.MoveAndAttackRound.ToString());
              this.LogCounter = -1;
            }
            this.removevirtualUnits();
            num1 = 0;
            if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100 & this.MoveAndAttackRound <= 4)
            {
              if (flag | this.MadeMove)
                num1 = 1;
            }
            else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 0 & this.MoveAndAttackRound <= 1)
            {
              if (flag | this.MadeMove)
                num1 = 1;
            }
            else if (this.MoveAndAttackRound <= 2 & flag & this.CorpsStance[this.OpGroup] == 3)
              num1 = 1;
            if (this.GroupType[this.OpGroup] >= 5 & this.MoveMatrixCounter <= 1 & !this.MovingIn)
              num1 = 0;
            this.MovingIn = false;
          }
          else
            goto label_99;
        }
        else
          goto label_98;
      }
      while (num1 == 1);
      goto label_100;
label_98:
      return;
label_99:
      return;
label_100:;
    }

    pub NewAIClass(tgame: GameClass)
    {
      this.ptemp = new int[161, 151];
      this.ptemp2 = new int[161, 151];
      this.ptemp3 = new int[161, 151];
      this.atemp = new int[9000];
      this.atemp2 = new int[9000];
      this.ptempb = new bool[9000];
      this.stemp = new int[9000];
      this.pmatrix = new MapMatrix2Boolean(160, 150);
      this.TscoreMatrix = new int[161, 151];
      this.TscoreCounterMatrix = new int[161, 151];
      this.AreaClosestEnemy = new int[1];
      this.SupplyMatrix = new int[2, 2];
      this.SupplyCounterMatrix = new int[2, 2];
      this.SupplyTempOwnerMatrix = new int[2, 2];
      this.SupplyMatrixReal = new int[2, 2];
      this.SupplyMatrixPrognosis = new int[2, 2];
      this.SupplyMatrixPrognosisEasyRoads = new int[2, 2];
      this.DistanceFromSuppliedHex = new int[2, 2];
      this.BottleNeckMatrix = new int[2, 2];
      this.SupplyMatrixRealCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixPrognosisCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixOpHQReal = new int[2, 2];
      this.SupplyMatrixOpHQPrognosis = new int[2, 2];
      this.SupplyMatrixOpHQRealCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixOpHQPrognosisCameFrom = new Coordinate[2, 2];
      this.DistFromFrontline = new int[2, 2];
      this.FullAdvanceMatrix = new int[161, 151];
      this.SupplyMatrixEnemyReal = new int[2, 2];
      this.SupplyMatrixEnemyPrognosis = new int[2, 2];
      this.SupplyMatrixEnemyRealCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixEnemyPrognosisCameFrom = new Coordinate[2, 2];
      this.SupplyMatrixDistance = new int[2, 2];
      this.AdvanceAxisMatrix = new int[161, 151];
      this.HexOccupyMatrix = new int[2, 2];
      this.FighterMatrix = new int[2, 2];
      this.MoveMatrix = new int[91, 161, 151];
      this.MoveMatrixCameFrom = new sCoordinate[91, 161, 151];
      this.MoveMatrixUnit = new int[91];
      this.MoveMatrixCloseRoad = new Coordinate[91];
      this.AreaSupplyBorderCount = new int[1];
      this.AreaSupplyBorder = new int[1, 1];
      this.AreaSupplyBorderEither = new int[1, 1];
      this.AreasupplyborderSea = new int[1, 1];
      this.RandomAreaNeighbourCount = new int[1];
      this.RandomAreaNeighbour = new int[1, 1];
      this.EnemyMatrix = new int[91, 161, 151];
      this.EnemyMatrixCameFrom = new sCoordinate[91, 161, 151];
      this.EnemyMatrixUnit = new int[91];
      this.EnemyMatrix2CameFrom = new sCoordinate[91, 161, 151];
      this.EnemyMatrix2 = new int[91, 161, 151];
      this.FriendlyPowerDispersed = new int[2, 2];
      this.EnemyPowerDispersed = new int[2, 2];
      this.MoveMatrixUnitMarker = new int[91];
      this.TempMoveMatrixUnitMarker = new int[91];
      this.HistoryMove = new SimpleList[9000];
      this.CombatMatrix = new float[2, 2];
      this.tArea = new int[2, 2];
      this.DistToTArea = new int[2, 2];
      this.DistFromTArea = new int[2, 2];
      this.FrontlineArea = new int[2, 2];
      this.EnemyFrontlineArea = new int[2, 2];
      this.TempOwner = new int[2, 2];
      this.TempCounterOwner = new int[2, 2];
      this.AreaGroup = new int[2];
      this.AreaExtraVP = new int[2];
      this.OldExtraVP = new int[2];
      this.AreaMatrixNarrow = new int[2, 2];
      this.AreaMatrixWide = new int[2, 2];
      this.AreaBorderNoBridge = new int[2, 2];
      this.AreaIsExtra = new bool[2];
      this.AreaBroadBorder = new int[2, 2];
      this.AreaNarrowBorder = new int[2, 2];
      this.AreaBorder = new int[2, 2];
      this.AreaWideBorder = new int[2, 2];
      this.HisAreaDistance = new int[2, 2];
      this.HisAreaDistanceFriendly = new int[2, 2];
      this.AreaCenter = new Coordinate[2];
      this.AreaBridges = new SimpleList[2];
      this.AreaFuzzyVP = new int[2];
      this.AreaDefensive = new int[2];
      this.CorpsStrength = new int[2];
      this.AreaStrength = new int[2];
      this.CounterAttackPossible = new int[2, 2];
      this.CorpsStrategic = new bool[2];
      this.CorpsLoc = new int[2];
      this.CorpsTarget = new int[2];
      this.CorpsSource = new int[2];
      this.CorpsMove = new int[2];
      this.CorpsTopGroup = new int[2];
      this.CorpsEngineer = new bool[2];
      this.AreaOwner = new int[2];
      this.AreaEnemy = new int[2];
      this.AreaStartEnemy = new int[2];
      this.AreaIsHistoricalArea = new int[2];
      this.AreaCounterPower = new int[2];
      this.AreaCounterDirections = new int[2, 10];
      this.AreaCounterRegime = new int[2, 10];
      this.AreaCounterStep = new int[2];
      this.AverageAreaEntrench = new int[2];
      this.CorpsMoveProgress = new int[2];
      this.CorpsStance = new int[2];
      this.CorpsStartLoc = new int[2];
      this.CorpsFirstAreaBattle = new int[2];
      this.CorpsTopRatio = new float[2];
      this.CorpsBottleneck = new int[2];
      this.CorpsOldDefend = new int[2];
      this.TempGroupHQ = new int[2];
      this.CorpsTempStrength = new int[2];
      this.FriendlySupply = new int[2];
      this.StartFriendlySupply = new int[2];
      this.EnemySupply = new int[2];
      this.AreaSteps = new int[2, 2];
      this.CorpsEntrench = new int[2];
      this.EnemySupplyGone = new int[2];
      this.StartEnemySupplyGone = new int[2];
      this.CorpsAirStrength = new int[2];
      this.CorpsTempAirStrength = new int[2];
      this.CorpsAirEffect = new int[2];
      this.corpsstartStrength = new int[2];
      this.CorpsLandStrength = new int[2];
      this.CorpsPowerLeft = new int[2];
      this.CorpsAttack = new int[2];
      this.CorpsDefend = new int[2];
      this.GroupType = new int[2];
      this.GroupHis = new int[2];
      this.GroupName = new string[2];
      this.GroupAttack = new int[2];
      this.GroupDefend = new int[2];
      this.GroupFallBack = new int[2];
      this.GroupFollowUp = new int[2];
      this.TempGroupTarget = new int[2];
      this.GroupHQNeed = new int[2];
      this.SeaBorder = new int[2, 2];
      this.SeaMatrix = new int[2, 2];
      this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE = 50;
      this.DIFFICULTY_LEVEL_STRATEGY_MOVES = 500;
      this.CONST_ARTMULTI = 2f;
      this.CONST_AIRMULTI = 1.5f;
      this.CONST_LANDDEFMULTI = 2f;
      this.StrTempCorps = new int[1];
      this.StrTempCorpsMod = new float[1];
      this.StrCurSides = new int[1];
      this.StrCounterAttack = new int[1, 1];
      this.StrLandEnemySupply = new int[1];
      this.StartStrLandEnemySupply = new int[1];
      this.StrOrigAreaOwner = new int[1];
      this.StrAreaEntrench = new int[1];
      this.StrAreaNegPow = new int[1];
      this.LogTxt = new string[1];
      this.LogTxt2 = new string[1];
      this.game = tgame;
      this.LastRegime = -1;
    }

    pub fn PlayCards(eventgroup: i32, bool alllog)
    {
      if (alllog)
        this.AddLog("PLAY HAND CARDS OF UNITS?");
      if (alllog)
        this.AddLog("");
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index1: i32 = 0; index1 <= unitCounter1; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].Historical > -1 & this.game.Data.UnitObj[index1].Regime == this.game.Data.Turn)
        {
          let mut historical: i32 = this.game.Data.UnitObj[index1].Historical;
          for (let mut handCardCounter: i32 = this.game.Data.HistoricalUnitObj[historical].HandCardCounter; handCardCounter >= 0; handCardCounter += -1)
          {
            let mut cardnr: i32 = this.game.Data.HistoricalUnitObj[historical].HandCard[handCardCounter];
            let mut num: i32 = 1;
            if (this.game.Data.ActionCardObj[cardnr].HisVarCostType > -1)
            {
              let mut hisVarCount: i32 = this.game.Data.HistoricalUnitObj[historical].HisVarCount;
              for (let mut index2: i32 = 0; index2 <= hisVarCount; index2 += 1)
              {
                if (this.game.Data.HistoricalUnitObj[historical].HisVarType[index2] == this.game.Data.ActionCardObj[cardnr].HisVarCostType && this.game.Data.HistoricalUnitObj[historical].HisVarValue[index2] < this.game.Data.ActionCardObj[cardnr].HisVarCostQty)
                  num = 0;
              }
            }
            if (this.game.Data.ActionCardObj[cardnr].PPCost > this.game.Data.RegimeObj[this.game.Data.Turn].ResPts)
              num = 0;
            if (num == 1)
            {
              if (this.game.Data.ActionCardObj[cardnr].PreExecuteEvent > -1)
              {
                if (alllog)
                  this.AddLog("");
                if (alllog)
                  this.AddLog(this.game.Data.UnitObj[index1].Name + " has card with pre-execute event: " + this.game.Data.ActionCardObj[cardnr].Title);
                this.game.EditObj.UnitSelected = index1;
                this.game.ProcessingObj.PlayCardPreEvent(cardnr);
              }
              else if (alllog)
                this.AddLog(this.game.Data.UnitObj[index1].Name + " has card: " + this.game.Data.ActionCardObj[cardnr].Title);
              if (this.game.Data.ActionCardObj[cardnr].AILabel > 0)
              {
                if (alllog)
                  this.AddLog("Calling event for advice on what to play: " + this.game.Data.EventObj[this.game.Data.ActionCardObj[cardnr].AILabel].Name + ". event either sets areax=unit# to play on or areax,areay=hex to play on.");
                this.game.EditObj.AreaX = -1;
                this.game.EditObj.AreaY = -1;
                this.game.EventRelatedObj.DoCheckSpecificEvent(this.game.Data.ActionCardObj[cardnr].AILabel, this.game.Data.ActionCardObj[cardnr].TempVar0, this.game.Data.ActionCardObj[cardnr].TempVar1, index1);
                if (this.game.EditObj.AreaX > -1 & this.game.EditObj.AreaY > -1 & this.game.Data.ActionCardObj[cardnr].AreaSlot > -1 & this.game.Data.ActionCardObj[cardnr].AreaValue > -1)
                {
                  if (alllog)
                    this.AddLog("PLAYED!!! target hex selected = " + this.game.EditObj.AreaX.ToString() + "," + this.game.EditObj.AreaY.ToString());
                  this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                }
                else if (this.game.EditObj.AreaX > -1 & this.game.Data.ActionCardObj[cardnr].UnitSelect)
                {
                  this.game.EditObj.UnitSelected = this.game.EditObj.AreaX;
                  if (alllog)
                    this.AddLog("PLAYED!!! unit target selected = " + this.game.Data.UnitObj[this.game.EditObj.UnitSelected].Name);
                  this.game.EditObj.AreaX = -1;
                  this.game.EditObj.AreaY = -1;
                  this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                }
                else if (alllog)
                  this.AddLog("event has returned AreaX=-1 indicating we should hold playing the card.");
              }
              else
              {
                if (alllog)
                  this.AddLog("card has no AIlabel set for instructions event.");
                if (this.game.Data.ActionCardObj[cardnr].UnitSelect)
                {
                  SimpleList simpleList = SimpleList::new();
                  let mut unitCounter2: i32 = this.game.Data.UnitCounter;
                  for (let mut index3: i32 = 0; index3 <= unitCounter2; index3 += 1)
                  {
                    if (this.game.Data.UnitObj[index3].TempUnitSelectable)
                      simpleList.Add(index3,  Math.Round( (VBMath.Rnd() *  this.GetDivisionalPower(index3, -1))));
                  }
                  if (simpleList.Counter > -1)
                  {
                    simpleList.Sort();
                    this.game.EditObj.UnitSelected = simpleList.Id[simpleList.Counter];
                    if (alllog)
                      this.AddLog("PLAYED!!! unit target selected = " + this.game.Data.UnitObj[this.game.EditObj.UnitSelected].Name);
                    this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                  }
                }
                else if (this.game.Data.ActionCardObj[cardnr].AreaSlot > -1 & this.game.Data.ActionCardObj[cardnr].AreaValue > -1)
                {
                  SimpleList simpleList = SimpleList::new();
                  let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
                  for (let mut tdata1: i32 = 0; tdata1 <= mapWidth; tdata1 += 1)
                  {
                    let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                    for (let mut tdata2: i32 = 0; tdata2 <= mapHeight; tdata2 += 1)
                    {
                      if (this.game.Data.MapObj[0].HexObj[tdata1, tdata2].AreaCode[this.game.Data.ActionCardObj[cardnr].AreaSlot] == this.game.Data.ActionCardObj[cardnr].AreaValue)
                        simpleList.Add(tdata1 * 1000 + tdata2,  Math.Round( (VBMath.Rnd() * 5000f)), tdata1, tdata2);
                    }
                  }
                  if (simpleList.Counter > -1)
                  {
                    simpleList.Sort();
                    this.game.EditObj.AreaX = simpleList.Data1[0];
                    this.game.EditObj.AreaY = simpleList.Data1[0];
                    if (alllog)
                      this.AddLog("PLAYED!!!  target hex selected = " + this.game.EditObj.AreaX.ToString() + "," + this.game.EditObj.AreaY.ToString());
                    this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                  }
                }
                else
                {
                  if (alllog)
                    this.AddLog("PLAYED!!! card played without any settings <not good>");
                  this.game.ProcessingObj.PlayCardByUnit(index1, cardnr);
                }
              }
            }
          }
        }
      }
    }

    pub fn ExecuteAI()
    {
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index: i32 = 0; index <= moveMatrixCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].Regime == this.game.Data.Turn)
          this.game.Data.UnitObj[index].AIBottleneck = 0;
      }
      if (this.GroupCounter < 0)
      {
        this.game.AIRunning = false;
      }
      else
      {
        this.game.EditObj.TempAIString = "Setting up Execution";
        this.game.EditObj.AIProgressNow = 0;
        this.game.EditObj.AIProgressMax = 100;
        this.LogCounter = -1;
        this.PlayCards(0, this.FullLog);
        if (this.FullLog)
          this.WriteLog("20_PlayCards");
        this.LogCounter = -1;
        this.MakeTempCategories(this.FullLog);
        if (this.FullLog)
          this.WriteLog("21_MakeTempCategories");
        this.LogCounter = -1;
        this.MakeFighterCoverage(this.FullLog);
        if (this.FullLog)
          this.WriteLog("22_MakeFighterCoverage");
        this.LogCounter = -1;
        this.TempGroupHQ = (int[]) Utils.CopyArray((Array) this.TempGroupHQ, (Array) new int[this.GroupCounter + 1]);
        let mut groupCounter1: i32 = this.GroupCounter;
        for (let mut grp: i32 = 0; grp <= groupCounter1; grp += 1)
          this.TempGroupHQ[grp] = this.GetGroupHQ(grp);
        SimpleList simpleList = SimpleList::new();
        this.CorpsLoc = (int[]) Utils.CopyArray((Array) this.CorpsLoc, (Array) new int[this.GroupCounter + 1]);
        let mut groupCounter2: i32 = this.GroupCounter;
        for (let mut tid: i32 = 0; tid <= groupCounter2; tid += 1)
        {
          let mut tweight: i32 = 0;
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
          {
            if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].AIGroup == tid)
            {
              tweight = tweight + this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr, true) + this.game.HandyFunctionsObj.GetPowerPtsAbsoluteForAirOnly(unr) * 20;
              if (this.CorpsLoc[tid] != this.game.Data.UnitObj[unr].AIDefend)
                tweight += 26000;
              else if (this.game.Data.UnitObj[unr].AIAttackStyle == 3 && this.game.Data.UnitObj[unr].AIAttack == this.game.Data.UnitObj[unr].AIFollowup | this.game.Data.UnitObj[unr].AIFollowup == -1)
                tweight += 9000;
            }
          }
          simpleList.Add(tid, tweight);
        }
        simpleList.ReverseSort();
        let mut counter: i32 = simpleList.Counter;
        for (let mut index1: i32 = 0; index1 <= counter; index1 += 1)
        {
          let mut num1: i32 = simpleList.Id[index1];
          let mut num2: i32 = 0;
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
          {
            if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].AIGroup == num1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.game.Data.UnitObj[unr].X > -1 && this.game.HandyFunctionsObj.GetLowestAp(unr) > 0)
            {
              num2 += 1;
              break;
            }
          }
          if (num2 > 0)
          {
            this.OpGroup = num1;
            this.AddLog("");
            this.AddLog("Move And Attack for Corps = " + this.GroupName[this.OpGroup]);
            let mut index2: i32 = this.GetGroupHQ(this.OpGroup);
            if ( this.game.Data.RuleVar[891] > 0.0 |  this.game.Data.RuleVar[892] > 0.0 |  this.game.Data.RuleVar[893] > 0.0 && index2 > -1)
            {
              let mut num3: i32 = 0;
              let mut hq: i32 = this.game.Data.UnitObj[index2].HQ;
              if (this.game.Data.UnitObj[index2].Historical > -1)
              {
                if ( this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].ID ==  this.game.Data.RuleVar[891])
                  num3 = 1;
                if ( this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].ID ==  this.game.Data.RuleVar[892])
                  num3 = 1;
                if ( this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].ID ==  this.game.Data.RuleVar[893])
                  num3 = 1;
              }
              if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1)
              {
                if ( this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].ID ==  this.game.Data.RuleVar[891])
                  num3 = 1;
                if ( this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].ID ==  this.game.Data.RuleVar[892])
                  num3 = 1;
                if ( this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].ID ==  this.game.Data.RuleVar[893])
                  num3 = 1;
              }
              if (num3 == 0)
                index2 = -1;
            }
            if (index2 > -1 &  this.game.Data.RuleVar[894] > 0.0 && this.game.Data.UnitObj[index2].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[index2].Historical].Type > 7)
              index2 = -1;
            if (index2 > -1)
            {
              this.AddLog("Fallback = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIFallback));
              this.AddLog("Defend = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIDefend));
              this.AddLog("Attack = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIAttack));
              this.AddLog("Followup = " + this.GetAreaName(this.game.Data.UnitObj[index2].AIFollowup));
              this.AddLog("AttackStyle = " + Conversion.Str( this.game.Data.UnitObj[index2].AIAttackStyle));
              this.AddLog("--*||*--");
              this.MoveAndAttackCorps();
            }
            else
              this.AddLog("EMPTY CORPS / disabled processing this corps");
          }
        }
        this.LogCounter = -1;
        if (this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime == -1)
          this.ExecuteStrategicTransfers(this.FullLog);
        if (this.FullLog)
          this.WriteLog("51_ExecuteStrategicTransfers");
        this.LogCounter = -1;
        this.SetBackTempGroups(this.FullLog);
        if (this.FullLog)
          this.WriteLog("52_SetBackTempGroups");
        this.LogCounter = -1;
        this.MakeSupplyMatrix(false, false);
        this.game.AIRunning = false;
      }
    }

    pub fn InitSetAirIntercept(bool alllog)
    {
      if ( this.game.Data.RuleVar[842] == 0.0)
        return;
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut unr: i32 = 0; unr <= unitCounter1; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1)
        {
          let mut absoluteForAirOnly: i32 = this.game.HandyFunctionsObj.GetPowerPtsAbsoluteForAirOnly(unr);
          if (absoluteForAirOnly > 0)
          {
            if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.game.Data.UnitObj[unr].Regime))
              num1 += absoluteForAirOnly;
            else
              num2 += absoluteForAirOnly;
          }
        }
      }
      let mut num3: i32 =  Math.Round( ( num1 * this.game.Data.RuleVar[842]));
      bool flag = (num3 < num2 ?   Math.Round( (100 * num3) /  num2) : 100.0) >  VBMath.Rnd() * 100.0;
      if (alllog)
        this.AddLog("friendly airpower = " + num3.ToString() + ", enemy airpower = " + num2.ToString() + " intercept = " + flag.ToString());
      let mut unitCounter2: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter2; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.HandyFunctionsObj.GetPowerPtsAbsoluteForAirOnly(unr) > 0 && this.game.Data.Turn == this.game.Data.UnitObj[unr].Regime)
        {
          this.game.Data.UnitObj[unr].SOInterceptRdnStop = !flag ? 100 : ( VBMath.Rnd() <= 0.5 ? 50 : 75);
          if (alllog)
            this.AddLog(this.game.Data.UnitObj[unr].Name + " => intercept stop at rdn <= " + this.game.Data.UnitObj[unr].SOInterceptRdnStop.ToString());
        }
      }
    }

    pub fn GetEnemyOnArea(area: i32) -> i32
    {
      let mut areaCount: i32 = this.AreaCount;
      enemyOnArea: i32;
      for (let mut index: i32 = 0; index <= areaCount; index += 1)
      {
        if (this.AreaBorder[index, area] > 0 & this.AreaBorder[index, area] < 99 && this.AreaStartEnemy[index] > 0)
          enemyOnArea += this.AreaStartEnemy[index];
      }
      return enemyOnArea;
    }

    pub float GetRatioOnArea(area: i32)
    {
      index: i32;
      if (this.game.Data.UnitObj[index].AIDefend > this.AreaCount)
        return 1f;
      let mut groupCounter: i32 = this.GroupCounter;
      num1: i32;
      for (let mut grp: i32 = 0; grp <= groupCounter; grp += 1)
      {
        let mut groupHq: i32 = this.GetGroupHQ(grp);
        if (groupHq > -1)
        {
          let mut num2: i32 = 0;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1 && this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIDefend, area] > 0 & this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIDefend, area] < 99)
          {
            num1 += this.CorpsStrength[grp];
            num2 = 1;
          }
          if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & num2 == 0 && this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIAttack, area] > 0 & this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIAttack, area] < 99)
          {
            num1 += this.CorpsStrength[grp];
            num2 = 1;
          }
          if (this.game.Data.UnitObj[groupHq].AIFallback > -1 & num2 == 0 && this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIFallback, area] > 0 & this.AreaNarrowBorder[this.game.Data.UnitObj[groupHq].AIFallback, area] < 99)
            num1 += this.CorpsStrength[grp];
        }
      }
      let mut num3: i32 = this.AreaStrength[area];
      if (num1 <= 0)
        return 0.0f;
      if (num3 == 0)
        return 999f;
      this.AddLog("Area = " + this.GetAreaName(area) + ", Ratio = " + Conversion.Str( ( num1 /  num3)));
      return  num1 /  num3;
    }

    pub HasThisHQNoSplit: bool(unr: i32) => unr != -1 && this.game.Data.UnitObj[unr].Historical != -1 && (this.game.Data.UnitObj[unr].AIGroup > -1 && this.GroupType[this.game.Data.UnitObj[unr].AIGroup] == 5 &  this.game.Data.RuleVar[888] == 1.0 || this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[unr].Historical].NoSplit);

    pub fn InitFreeRoads()
    {
      if ( this.game.Data.RuleVar[32] == -1.0)
        return;
      let mut locCounter: i32 = this.game.Data.LocCounter;
      for (let mut index1: i32 = 0; index1 <= locCounter; index1 += 1)
      {
        let mut x: i32 = this.game.Data.LocObj[index1].X;
        let mut y: i32 = this.game.Data.LocObj[index1].Y;
        if (this.game.Data.MapObj[0].HexObj[x, y].Regime == this.game.Data.Turn)
        {
          let mut index2: i32 = this.AreaMatrixNarrow[x, y];
          if (index2 > -1)
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.AreaCenter[index2].x, this.AreaCenter[index2].y, 0);
            index3: i32;
            index4: i32;
            if ( this.game.EditObj.TempValue[0].Value[x, y] >  this.game.Data.RuleVar[51] && this.game.EditObj.TempValue[0].Value[index3, index4] < 999)
            {
              let mut num: i32 = 1;
              while (num == 1)
              {
                num = 0;
                Coordinate coordinate = this.game.EditObj.TempCameFrom[0].Value[x, y];
                if (coordinate.onmap)
                {
                  let mut index5: i32 = this.game.HandyFunctionsObj.HexFacing(x, y, 0, coordinate.x, coordinate.y, 0) - 1;
                  this.game.Data.MapObj[0].HexObj[x, y].RoadType[index5] =  Math.Round( this.game.Data.RuleVar[32]);
                  let mut index6: i32 = index5 + 3;
                  if (index6 > 5)
                    index6 -= 6;
                  this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].RoadType[index6] =  Math.Round( this.game.Data.RuleVar[32]);
                  num = 1;
                  x = coordinate.x;
                  y = coordinate.y;
                }
              }
            }
          }
        }
      }
    }

    pub fn InitDecisions()
    {
      num1: i32;
      do
      {
        Number: i32;
        Number += 1;
        this.AddLog("INIT DECISION ROUND " + Conversion.Str( Number));
        num1 = 0;
        SimpleList simpleList = SimpleList::new();
        let mut locTypeCounter: i32 = this.game.Data.LocTypeCounter;
        for (let mut index1: i32 = 0; index1 <= locTypeCounter; index1 += 1)
        {
          if (this.game.Data.LocTypeObj[index1].AICanBuild)
          {
            let mut num2: i32 = 1;
            if (this.game.Data.RegimeObj[this.game.Data.Turn].ResPts < this.game.Data.LocTypeObj[index1].PPCost)
              num2 = 0;
            let mut index2: i32 = 0;
            do
            {
              if (this.game.Data.LocTypeObj[index1].VarType[index2] > -1 && this.game.Data.RegimeObj[this.game.Data.Turn].RegimeSlot[this.game.Data.LocTypeObj[index1].VarType[index2]] < this.game.Data.LocTypeObj[index1].VarQty[index2])
                num2 = 0;
              if (this.game.Data.LocTypeObj[index1].Research[index2] > -1 && !this.game.Data.RegimeObj[this.game.Data.Turn].ResField[this.game.Data.LocTypeObj[index1].Research[index2]])
                num2 = 0;
              index2 += 1;
            }
            while (index2 <= 4);
            if (num2 == 1)
            {
              this.game.EditObj.AreaX = -1;
              this.game.EditObj.AreaY = -1;
              Coordinate locationForLocType;
              if (this.game.Data.LocTypeObj[index1].AILocEvent > -1)
              {
                this.game.EventRelatedObj.DoCheckSpecificEvent(this.game.Data.LocTypeObj[index1].AILocEvent, index1);
                locationForLocType.x = this.game.EditObj.AreaX;
                locationForLocType.y = this.game.EditObj.AreaY;
              }
              else
                locationForLocType = this.AutoFindLocationForLocType(index1);
              if (locationForLocType.x > -1 && this.game.EditObj.TempValue[0].Value[locationForLocType.x, locationForLocType.y] == 1)
              {
                let mut aiPriority: i32 = this.game.Data.LocTypeObj[index1].AIPriority;
                if (this.game.Data.LocTypeObj[index1].AIEvent > -1)
                {
                  this.game.EventRelatedObj.DoCheckSpecificEvent(this.game.Data.LocTypeObj[index1].AIEvent, index1);
                  aiPriority += this.game.EditObj.AreaX;
                }
                if (aiPriority > 0)
                {
                  tid: i32;
                  tid += 1;
                  simpleList.Add(tid, aiPriority, 1, index1, locationForLocType.x, locationForLocType.y);
                  num1 = 1;
                }
              }
            }
          }
        }
        simpleList.Sort();
        let mut counter: i32 = simpleList.Counter;
        for (let mut index: i32 = 0; index <= counter; index += 1)
          this.AddLog(Conversion.Str( simpleList.Id[index]) + ", weight=" + Conversion.Str( simpleList.Weight[index]) + " data= " + Conversion.Str( simpleList.Data1[index]) + "," + Conversion.Str( simpleList.Data2[index]) + "," + Conversion.Str( simpleList.Data3[index]) + ",");
        if (simpleList.Counter > -1)
        {
          let mut num3: i32 = simpleList.Data1[simpleList.Counter];
          let mut loctype: i32 = simpleList.Data2[simpleList.Counter];
          let mut x: i32 = simpleList.Data3[simpleList.Counter];
          let mut y: i32 = simpleList.Data4[simpleList.Counter];
          if (num3 == 1)
            this.game.ProcessingObj.Build(-1, x, y, 0, loctype, this.game.Data.Turn);
        }
      }
      while (num1 == 1);
    }

    pub Coordinate AutoFindLocationForLocType(loctyp: i32)
    {
      let mut num1: i32 = -1;
      let mut num2: i32 = -9999;
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.game.HandyFunctionsObj.RedimTempValue(0);
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          if (this.game.Data.MapObj[0].HexObj[index1, index2].Regime > -1)
            numArray[index1, index2] = !this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index1, index2].Regime) ? (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index1, index2].Regime) ? 300 : (this.game.Data.Turn != this.game.Data.MapObj[0].HexObj[index1, index2].Regime ? 100 : 0)) : 1000;
          else if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index1, index2].LandscapeType].IsSea)
            numArray[index1, index2] = 100;
        }
      }
      let mut num3: i32 = 1;
      let mut num4: i32 = 0;
      Coordinate locationForLocType;
      while (num3 == 1 & num4 < 999)
      {
        num4 += 1;
        num3 = 0;
        let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            let mut tfacing: i32 = 1;
            do
            {
              locationForLocType = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (locationForLocType.onmap &&  numArray[locationForLocType.x, locationForLocType.y] < Conversion.Int( numArray[cx, cy] / 2.0))
              {
                numArray[locationForLocType.x, locationForLocType.y] =  Math.Round(Conversion.Int( numArray[cx, cy] / 2.0));
                num3 = 1;
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
          }
        }
      }
      let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
      index3: i32;
      num5: i32;
      for (index3 = 0; index3 <= mapWidth3; index3 += 1)
      {
        let mut mapHeight1: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index4: i32 = 0; index4 <= mapHeight1; index4 += 1)
        {
          let mut num6: i32 = 0;
          if (this.game.Data.MapObj[0].HexObj[index3, index4].Regime == this.game.Data.Turn && this.game.Data.MapObj[0].HexObj[index3, index4].Location == -1)
          {
            let mut buildGround: i32 = this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index3, index4].LandscapeType].BuildGround;
            if (this.game.Data.LocTypeObj[loctyp].BuildgroundType[buildGround] && this.game.HandyFunctionsObj.IsHexNextToSea(index3, index4, 0) | !this.game.Data.LocTypeObj[loctyp].IsPort)
            {
              bool flag = true;
              let mut mapWidth4: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut x2: i32 = 0; x2 <= mapWidth4; x2 += 1)
              {
                let mut mapHeight2: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut y2: i32 = 0; y2 <= mapHeight2; y2 += 1)
                {
                  let mut location: i32 = this.game.Data.MapObj[0].HexObj[x2, y2].Location;
                  if (location > -1)
                  {
                    let mut locTypeGroup: i32 = this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].LocTypeGroup;
                    let mut num7: i32 = this.game.HandyFunctionsObj.Distance(index3, index4, 0, x2, y2, 0);
                    if (this.game.Data.LocTypeObj[loctyp].MinDistance[locTypeGroup] > -1 && this.game.Data.LocTypeObj[loctyp].MinDistance[locTypeGroup] > num7)
                      flag = false;
                  }
                }
              }
              if (this.game.Data.LocTypeObj[loctyp].SlotType > -1 && this.game.Data.MapObj[0].HexObj[index3, index4].AreaCode[this.game.Data.LocTypeObj[loctyp].SlotType] != this.game.Data.LocTypeObj[loctyp].SlotValue)
                flag = false;
              if (flag)
              {
                num6 = 1;
                if (numArray[index3, index4] > num2)
                {
                  num2 = numArray[index3, index4];
                  num1 = index3;
                  num5 = index4;
                }
              }
            }
          }
          this.game.EditObj.TempValue[0].Value[index3, index4] = num6 != 1 ? 0 : 1;
        }
      }
      locationForLocType.x = num1;
      locationForLocType.y = num5;
      locationForLocType.map = 0;
      locationForLocType.onmap = true;
      if (index3 == -1)
      {
        locationForLocType.onmap = false;
        locationForLocType.y = -1;
      }
      return locationForLocType;
    }

    pub fn InitUnitHQs()
    {
      bool flag = true;
      if (flag)
        this.AddLog("----------------------");
      if (flag)
        this.AddLog("----------------------");
      if (flag)
        this.AddLog("INITUNITHQ");
      let mut groupCounter: i32 = this.GroupCounter;
      for (let mut grp: i32 = 0; grp <= groupCounter; grp += 1)
      {
        let mut index1: i32 = this.GetGroupHQ(grp);
        let mut realGroupHq: i32 = this.GetRealGroupHQ(grp);
        if (index1 > -1 && !this.game.Data.UnitObj[index1].IsHQ)
          index1 = -1;
        if (index1 > -1)
        {
          if (this.game.Data.UnitObj[index1].IsHQ)
          {
            let mut unitCounter: i32 = this.game.Data.UnitCounter;
            for (let mut index2: i32 = 0; index2 <= unitCounter; index2 += 1)
            {
              if (this.game.Data.UnitObj[index2].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index2].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index2].X > -1 & !this.game.Data.UnitObj[index2].IsHQ & this.game.Data.UnitObj[index2].AIGroup == grp && this.game.Data.UnitObj[index2].HQ != index1 | this.game.Data.UnitObj[index2].HQ == -1)
              {
                let mut num1: i32 = this.game.HandyFunctionsObj.Gethqpow(index2);
                let mut num2: i32 = this.game.HandyFunctionsObj.Gethqpowifhqis(index2, index1);
                if (num2 >= num1 & num2 > 0 | this.game.Data.UnitObj[index2].HQ == -1)
                {
                  this.game.ProcessingObj.SetUnitHq(index2, index1);
                  if (flag)
                    this.AddLog("Set unit " + this.game.Data.UnitObj[index2].Name + " to HQ " + this.game.Data.UnitObj[index1].Name);
                }
              }
            }
          }
        }
        else
        {
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut Unr: i32 = 0; Unr <= unitCounter; Unr += 1)
          {
            if (this.game.Data.UnitObj[Unr].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[Unr].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[Unr].X > -1 & !this.game.Data.UnitObj[Unr].IsHQ & this.game.Data.UnitObj[Unr].AIGroup == grp && this.game.Data.UnitObj[Unr].HQ != realGroupHq | this.game.Data.UnitObj[Unr].HQ == -1 && realGroupHq != -1)
            {
              this.game.ProcessingObj.SetUnitHq(Unr, realGroupHq);
              if (flag)
                this.AddLog("Set unit " + this.game.Data.UnitObj[Unr].Name + " to HQ " + this.game.Data.UnitObj[realGroupHq].Name);
            }
          }
        }
      }
    }

    pub fn GetPowerPointsUnderCommand(hq: i32) -> i32
    {
      let mut pointsUnderCommand: i32 = 0;
      bool[] flagArray = new bool[this.GroupCounter + 1];
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
      {
        if (this.game.Data.UnitObj[index].HQ == hq)
        {
          let mut aiGroup: i32 = this.game.Data.UnitObj[index].AIGroup;
          if (aiGroup <= this.GroupCounter && !flagArray[aiGroup])
          {
            flagArray[aiGroup] = true;
            let mut unitCounter2: i32 = this.game.Data.UnitCounter;
            for (let mut unr: i32 = 0; unr <= unitCounter2; unr += 1)
            {
              if (this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index].AIGroup == aiGroup)
                pointsUnderCommand += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
            }
          }
        }
      }
      return pointsUnderCommand;
    }

    pub fn GetGroup(his: i32) -> i32
    {
      let mut groupCounter: i32 = this.GroupCounter;
      for (let mut group: i32 = 0; group <= groupCounter; group += 1)
      {
        if (this.GroupHis[group] == his)
          return group;
      }
      return -1;
    }

    pub fn GetRealGroupHQ(grp: i32) -> i32
    {
      let mut realGroupHq: i32 = this.GetGroupHQ(grp);
      if (realGroupHq > -1 && !this.game.Data.UnitObj[realGroupHq].IsHQ)
        realGroupHq = !(!this.game.Data.UnitObj[realGroupHq].IsHQ & this.game.Data.UnitObj[realGroupHq].HQ > -1) ? -1 : this.game.Data.UnitObj[realGroupHq].HQ;
      return realGroupHq;
    }

    pub fn GetGroupHQ(grp: i32) -> i32
    {
      let mut groupHq1: i32 = -1;
      if (grp == -1)
        return -1;
      if (this.GroupHis[grp] > 0)
        groupHq1 = this.game.HandyFunctionsObj.GetUnitByHistorical(this.GroupHis[grp]);
      if (groupHq1 == -1)
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut groupHq2: i32 = 0; groupHq2 <= unitCounter; groupHq2 += 1)
        {
          if (this.game.Data.UnitObj[groupHq2].PreDef == -1 && this.game.Data.UnitObj[groupHq2].X > -1 & this.GetRegime(this.game.Data.UnitObj[groupHq2].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[groupHq2].IsHQ && this.game.Data.UnitObj[groupHq2].AIGroup == grp)
            return groupHq2;
        }
      }
      if (groupHq1 == -1)
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut groupHq3: i32 = 0; groupHq3 <= unitCounter; groupHq3 += 1)
        {
          if (this.game.Data.UnitObj[groupHq3].PreDef == -1 && this.game.Data.UnitObj[groupHq3].X > -1 & this.GetRegime(this.game.Data.UnitObj[groupHq3].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[groupHq3].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[groupHq3].Historical].TempAttack > -1 | this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[groupHq3].Historical].TempDefend > -1 && this.game.Data.UnitObj[groupHq3].AIGroup == grp)
            return groupHq3;
        }
      }
      if (groupHq1 == -1)
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut groupHq4: i32 = 0; groupHq4 <= unitCounter; groupHq4 += 1)
        {
          if (this.game.Data.UnitObj[groupHq4].PreDef == -1 && this.game.Data.UnitObj[groupHq4].X > -1 & this.GetRegime(this.game.Data.UnitObj[groupHq4].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[groupHq4].AIGroup == grp)
            return groupHq4;
        }
      }
      return groupHq1;
    }

    pub fn GetGroupUnits(grp: i32) -> i32
    {
      let mut groupUnits: i32 = 0;
      if (grp == -1)
        return 0;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X > -1 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].AIGroup == grp)
          groupUnits += 1;
      }
      return groupUnits;
    }

    pub fn GetLargestArmy() -> i32
    {
      int[] numArray1 = new int[this.game.Data.RegimeCounter + 1];
      float num1 = 0.8f +  new Random(this.game.Data.MapWidth * this.game.Data.MapHeight * this.GetGameDataTurn() * Strings.Len(this.game.Data.Name)).Next(0, 1000) / 2500f;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.GetRegime(this.game.Data.UnitObj[unr].Regime) > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.game.Data.UnitObj[unr].X > -1)
        {
          int[] numArray2 = numArray1;
          int[] numArray3 = numArray2;
          let mut regime1: i32 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          let mut index1: i32 = regime1;
          let mut num2: i32 = numArray2[regime1] +  Math.Round( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ( this.game.HandyFunctionsObj.GetAverageMor(unr) / 50.0) * 0.25);
          numArray3[index1] = num2;
          int[] numArray4 = numArray1;
          int[] numArray5 = numArray4;
          let mut regime2: i32 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          let mut index2: i32 = regime2;
          let mut num3: i32 = numArray4[regime2] +  Math.Round( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ( this.game.HandyFunctionsObj.GetAverageXp(unr) / 50.0) * 0.75);
          numArray5[index2] = num3;
        }
      }
      let mut nr: i32 = 0;
      let mut num4: i32 = -1;
      let mut regimeCounter: i32 = this.game.Data.RegimeCounter;
      num5: i32;
      for (let mut index: i32 = 0; index <= regimeCounter; index += 1)
      {
        if (this.GetRegime(index) == this.GetGameDataTurn())
          numArray1[index] =  Math.Round( ( numArray1[index] * num1));
        if (numArray1[index] > num4)
        {
          num4 = numArray1[index];
          nr = index;
        }
        if (this.GetRegime(index) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, index))
          num5 += numArray1[index];
      }
      if (this.GetRegime(nr) == this.GetGameDataTurn())
      {
        this.ATTACKERRATIO =  numArray1[this.GetGameDataTurn()] /  num5;
        if ( this.ATTACKERRATIO < 1.0)
          this.ATTACKERRATIO = 1f;
      }
      return nr;
    }

    pub fn GetLargestEnemy() -> i32
    {
      int[] numArray1 = new int[this.game.Data.RegimeCounter + 1];
      float num1 = 0.8f +  new Random(this.game.Data.MapWidth * this.game.Data.MapHeight * this.GetGameDataTurn() * Strings.Len(this.game.Data.Name)).Next(0, 1000) / 2500f;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.GetRegime(this.game.Data.UnitObj[unr].Regime) > -1 & this.game.Data.UnitObj[unr].PreDef == -1 & this.game.Data.UnitObj[unr].X > -1 && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.UnitObj[unr].Regime))
        {
          int[] numArray2 = numArray1;
          int[] numArray3 = numArray2;
          let mut regime1: i32 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          let mut index1: i32 = regime1;
          let mut num2: i32 = numArray2[regime1] +  Math.Round( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ( this.game.HandyFunctionsObj.GetAverageMor(unr) / 50.0) * 0.25);
          numArray3[index1] = num2;
          int[] numArray4 = numArray1;
          int[] numArray5 = numArray4;
          let mut regime2: i32 = this.GetRegime(this.game.Data.UnitObj[unr].Regime);
          let mut index2: i32 = regime2;
          let mut num3: i32 = numArray4[regime2] +  Math.Round( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) * ( this.game.HandyFunctionsObj.GetAverageXp(unr) / 50.0) * 0.75);
          numArray5[index2] = num3;
        }
      }
      let mut nr: i32 = 0;
      let mut num4: i32 = -1;
      let mut regimeCounter: i32 = this.game.Data.RegimeCounter;
      num5: i32;
      for (let mut index: i32 = 0; index <= regimeCounter; index += 1)
      {
        if (this.GetRegime(index) == this.GetGameDataTurn())
          numArray1[index] =  Math.Round( ( numArray1[index] * num1));
        if (numArray1[index] > num4)
        {
          num4 = numArray1[index];
          nr = index;
        }
        if (this.GetRegime(index) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, index))
          num5 += numArray1[index];
      }
      if (this.GetRegime(nr) == this.GetGameDataTurn())
      {
        this.ATTACKERRATIO =  numArray1[this.GetGameDataTurn()] /  num5;
        if ( this.ATTACKERRATIO < 1.0)
          this.ATTACKERRATIO = 1f;
      }
      return nr;
    }

    pub fn SetBackTempGroups(bool tlog)
    {
      if (tlog)
        this.AddLog("SET BACK TEMP GROUPS");
      if (tlog)
        this.AddLog("");
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].TempGroup > -1)
        {
          if (tlog)
            this.AddLog(this.game.Data.UnitObj[index].Name + " from tempgroup " + this.GroupName[this.game.Data.UnitObj[index].AIGroup] + " back to group: " + this.GroupName[this.game.Data.UnitObj[index].TempGroup]);
          this.game.Data.UnitObj[index].AIGroup = this.game.Data.UnitObj[index].TempGroup;
          this.game.Data.UnitObj[index].TempGroup = -1;
        }
      }
    }

    pub CanBeStrategiclyTransferred: bool(unr: i32) => true;

    pub fn GetBestCapHQ(regnr: i32) -> i32
    {
      SimpleList simpleList = SimpleList::new();
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut tid: i32 = 0; tid <= unitCounter; tid += 1)
      {
        if (this.game.Data.UnitObj[tid].Regime == regnr & this.game.Data.UnitObj[tid].SupplyIn > 0 & this.game.Data.UnitObj[tid].AirCap > 0 && this.game.Data.UnitObj[tid].IsHQ)
          simpleList.Add(tid, this.game.Data.UnitObj[tid].AirCap);
      }
      simpleList.Sort();
      return simpleList.Counter >= 0 ? simpleList.Id[simpleList.Counter] : -1;
    }

    pub SimpleList GetAreaToAreaPath(from: i32, too: i32)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      let mut num1: i32 = 0;
      numArray1[too] = 1;
      let mut num2: i32 = 1;
      while (num2 >= 0)
      {
        num1 += 1;
        --num2;
        let mut areaCount1: i32 = this.AreaCount;
        for (let mut index1: i32 = 1; index1 <= areaCount1; index1 += 1)
        {
          if (numArray1[index1] == num1)
          {
            let mut areaCount2: i32 = this.AreaCount;
            for (let mut index2: i32 = 1; index2 <= areaCount2; index2 += 1)
            {
              if (this.AreaNarrowBorder[index1, index2] > 0)
              {
                let mut num3: i32 = !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime, this.game.Data.Turn) ? (!this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime, this.game.Data.Turn) ? 99 : 1) : 0;
                if (numArray1[index2] == 0 | numArray1[index2] > num1 + 1 + num3)
                {
                  numArray1[index2] = num1 + 1 + num3;
                  numArray2[index2] = index1;
                  num2 = 1;
                }
              }
            }
          }
        }
      }
      SimpleList areaToAreaPath = SimpleList::new();
      if (numArray1[from] > 0)
      {
        let mut num4: i32 = 0;
        let mut num5: i32 = 1;
        while (num5 == 1)
        {
          num4 += 1;
          num5 = 0;
          if (numArray2[from] > 0)
          {
            if (num4 > 1)
              areaToAreaPath.Add(numArray2[from], 1);
            num5 = 1;
            from = numArray2[from];
          }
          if (from == 0)
            num5 = 0;
        }
      }
      return areaToAreaPath;
    }

    pub GetAreaName: String(nr: i32, bool withnumber = true)
    {
      if (nr == -1)
        return "-1";
      if (nr > this.AreaCount)
        return "OLD";
      if (!withnumber)
        return this.game.HandyFunctionsObj.GetHexName(this.AreaCenter[nr].x, this.AreaCenter[nr].y, 0);
      return Conversion.Str( nr) + ") " + this.game.HandyFunctionsObj.GetHexName(this.AreaCenter[nr].x, this.AreaCenter[nr].y, 0) + "(" + Conversion.Str( this.AreaCenter[nr].x) + "," + Conversion.Str( this.AreaCenter[nr].y) + ")";
    }

    pub Coordinate GetCloseFriendlyRoadHex(
      x: i32,
      y: i32,
      maxdistance: i32,
      let mut unitslot: i32 = -1)
    {
      this.ptemp = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.ptemp2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      SimpleList simpleList = SimpleList::new();
      this.ptemp[x, y] = 1;
      let mut num1: i32 = 0;
      let mut num2: i32 = 1;
      Coordinate closeFriendlyRoadHex;
      if (unitslot > -1)
      {
        closeFriendlyRoadHex = this.MarkerHasCoord(unitslot);
        if (!closeFriendlyRoadHex.onmap)
          return closeFriendlyRoadHex;
        let mut index: i32 = this.MoveMatrixUnit[unitslot];
        let mut num3: i32 = 1000;
        while (!(closeFriendlyRoadHex.x == this.game.Data.UnitObj[index].X & closeFriendlyRoadHex.y == this.game.Data.UnitObj[index].Y))
        {
          --num3;
          this.ptemp2[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] = num3;
          sCoordinate sCoordinate = this.MoveMatrixCameFrom[unitslot, closeFriendlyRoadHex.x, closeFriendlyRoadHex.y];
          closeFriendlyRoadHex.x =  sCoordinate.x;
          closeFriendlyRoadHex.y =  sCoordinate.y;
          closeFriendlyRoadHex.onmap = sCoordinate.onmap;
          if (!closeFriendlyRoadHex.onmap)
            break;
        }
      }
      let mut index1: i32 = 0;
      tid: i32;
      do
      {
        if (this.SupplyMatrixReal[x, y] < 9999 && this.game.Data.MapObj[0].HexObj[x, y].RoadType[index1] == 0)
        {
          tid += 1;
          if (unitslot == -1)
            simpleList.Add(tid, 50, x, y);
          else
            simpleList.Add(tid, this.ptemp2[x, y], x, y);
        }
        index1 += 1;
      }
      while (index1 <= 5);
      while (num2 == 1 & num1 <= maxdistance)
      {
        num1 += 1;
        num2 = 0;
        let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (this.ptemp[cx, cy] == num1)
            {
              let mut tfacing: i32 = 1;
              do
              {
                closeFriendlyRoadHex = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (closeFriendlyRoadHex.onmap & this.ptemp[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] == 0)
                {
                  let mut num4: i32 = 0;
                  if (unitslot == -1)
                    num4 = 1;
                  else if (this.MoveMatrix[unitslot, closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] <= this.game.HandyFunctionsObj.GetLowestAp(this.MoveMatrixUnit[unitslot]))
                    num4 = 1;
                  if (num4 == 1)
                  {
                    this.ptemp[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] = num1 + 1;
                    num2 = 1;
                    if (this.SupplyMatrixReal[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y] < 9999)
                    {
                      let mut index2: i32 = 0;
                      do
                      {
                        if (this.game.Data.MapObj[0].HexObj[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y].RoadType[index2] == 0)
                        {
                          tid += 1;
                          if (unitslot == -1)
                            simpleList.Add(tid, 50 - num1, closeFriendlyRoadHex.x, closeFriendlyRoadHex.y);
                          else
                            simpleList.Add(tid, this.ptemp2[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y], closeFriendlyRoadHex.x, closeFriendlyRoadHex.y);
                        }
                        index2 += 1;
                      }
                      while (index2 <= 5);
                    }
                  }
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      if (simpleList.Counter == -1)
      {
        closeFriendlyRoadHex.onmap = false;
        return closeFriendlyRoadHex;
      }
      simpleList.Sort();
      closeFriendlyRoadHex.x = simpleList.Data1[simpleList.Counter];
      closeFriendlyRoadHex.y = simpleList.Data2[simpleList.Counter];
      closeFriendlyRoadHex.onmap = true;
      return closeFriendlyRoadHex;
    }

    pub fn GetGameDataTurn() -> i32 => this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime > -1 ? this.game.Data.RegimeObj[this.game.Data.Turn].UberRegime : this.game.Data.Turn;

    pub fn GetRegime(nr: i32) -> i32
    {
      if (nr == -1)
        return -1;
      return this.game.Data.RegimeObj[nr].UberRegime > -1 ? this.game.Data.RegimeObj[nr].UberRegime : nr;
    }

    pub fn MakeTScoreMatrix()
    {
      this.TscoreMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.TscoreCounterMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut ix: i32 = 0; ix <= mapWidth1; ix += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut iy: i32 = 0; iy <= mapHeight; iy += 1)
        {
          this.TscoreMatrix[ix, iy] = this.GetTScore2(ix, iy);
          this.TscoreCounterMatrix[ix, iy] = this.GetTScore2(ix, iy, true);
          this.ptemp[ix, iy] = 0;
        }
      }
      let mut num1: i32 = 1;
      let mut num2: i32 = -1;
      Coordinate coordinate;
      while (num1 == 1)
      {
        num1 = 0;
        num2 += 1;
        let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (this.ptemp[cx, cy] == num2)
            {
              let mut num3: i32 =  Math.Round( this.TscoreCounterMatrix[cx, cy] * 0.5);
              if (num3 > 10)
              {
                let mut tfacing: i32 = 1;
                do
                {
                  coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                  if (coordinate.onmap && num3 > this.TscoreCounterMatrix[coordinate.x, coordinate.y])
                  {
                    this.TscoreCounterMatrix[coordinate.x, coordinate.y] = num3;
                    this.ptemp[coordinate.x, coordinate.y] = num2 + 1;
                    num1 = 1;
                  }
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth3; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          this.ptemp[index1, index2] = 0;
      }
      let mut num4: i32 = 1;
      let mut num5: i32 = -1;
      while (num4 == 1)
      {
        num4 = 0;
        num5 += 1;
        let mut mapWidth4: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth4; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (this.ptemp[cx, cy] == num5)
            {
              let mut num6: i32 =  Math.Round( this.TscoreMatrix[cx, cy] * 0.5);
              if (num6 > 10)
              {
                let mut tfacing: i32 = 1;
                do
                {
                  coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                  if (coordinate.onmap && num6 > this.TscoreMatrix[coordinate.x, coordinate.y])
                  {
                    this.TscoreMatrix[coordinate.x, coordinate.y] = num6;
                    this.ptemp[coordinate.x, coordinate.y] = num5 + 1;
                    num4 = 1;
                  }
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
    }

    pub fn GetRandomCorpsGroup() -> i32
    {
      let mut groupCounter1: i32 = this.GroupCounter;
      num1: i32;
      for (let mut index: i32 = 0; index <= groupCounter1; index += 1)
      {
        if (this.GroupType[index] <= 5)
          num1 += 1;
      }
      let mut num2: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  num1)) + 1;
      if (num2 > num1)
        num2 = num1;
      let mut num3: i32 = 0;
      let mut groupCounter2: i32 = this.GroupCounter;
      for (let mut randomCorpsGroup: i32 = 0; randomCorpsGroup <= groupCounter2; randomCorpsGroup += 1)
      {
        if (this.GroupType[randomCorpsGroup] <= 5)
          num3 += 1;
        if (num3 == num2)
          return randomCorpsGroup;
      }
      return -1;
    }

    pub fn GetHighestFuzzyVPGroup(forgroup: i32) -> i32
    {
      let mut highestFuzzyVpGroup: i32 = -1;
      let mut index1: i32 = this.TempGroupHQ[forgroup];
      let mut hq: i32 = index1;
      if (index1 > -1)
      {
        if (this.game.Data.UnitObj[hq].Historical > -1)
        {
          if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type == 8)
            return -1;
          if (this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type < 7)
          {
            hq = this.game.Data.UnitObj[index1].HQ;
            if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type < 7 && this.game.Data.UnitObj[hq].HQ > -1)
            {
              hq = this.game.Data.UnitObj[hq].HQ;
              if (hq > -1 && this.game.Data.UnitObj[hq].Historical > -1 && this.game.Data.HistoricalUnitObj[this.game.Data.UnitObj[hq].Historical].Type < 7 && this.game.Data.UnitObj[hq].HQ > -1)
                hq = this.game.Data.UnitObj[hq].HQ;
            }
          }
        }
      }
      else
        hq = -1;
      let mut num1: i32 = 0;
      let mut groupCounter: i32 = this.GroupCounter;
      for (let mut index2: i32 = 0; index2 <= groupCounter; index2 += 1)
      {
        if (this.GroupType[index2] <= 5)
        {
          let mut unr: i32 = this.TempGroupHQ[index2];
          if (unr > -1 && this.game.HandyFunctionsObj.IsUnitInHQChain(unr, hq) | hq == -1 | hq == this.game.Data.UnitObj[unr].HQ)
          {
            let mut index3: i32 = !this.Attacker ? this.CorpsLoc[index2] : this.TempGroupTarget[index2];
            if (index3 > -1)
            {
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime) != this.GetGameDataTurn())
              {
                let mut num2: i32 =  Math.Round( ((1 +  Math.Round(Math.Sqrt( this.AreaFuzzyVP[index3]))) *  Math.Round( this.AreaStrength[index3] / 10.0)) * Math.Sqrt( this.CorpsStrength[index2]));
                if (num2 > num1)
                {
                  highestFuzzyVpGroup = index2;
                  num1 = num2;
                }
              }
              else if (!this.Attacker)
              {
                let mut num3: i32 = (1 +  Math.Round(Math.Sqrt( this.AreaFuzzyVP[index3]))) * this.CorpsStrength[index2];
                if (num3 > num1)
                {
                  highestFuzzyVpGroup = index2;
                  num1 = num3;
                }
              }
            }
          }
        }
      }
      if (highestFuzzyVpGroup == -1)
        highestFuzzyVpGroup = forgroup;
      return highestFuzzyVpGroup;
    }

    pub fn GetAverageHexSpeedofCorpsUnit(grp: i32, bool friendlyter) -> i32
    {
      let mut num1: i32 = 0;
      let mut num2: i32 = 0;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup == grp && this.game.Data.UnitObj[index].TempTheater == 0 && !this.game.Data.UnitObj[index].IsHQ)
        {
          let mut moveType: i32 = this.game.Data.SFTypeObj[this.game.Data.UnitObj[index].TempType].MoveType;
          num1 += this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
          if (!friendlyter)
            num1 += 10;
          num2 += 1;
        }
      }
      return num2 == 0 ? 0 :  Math.Round(Conversion.Int(100.0 /   Math.Round( num1 /  num2)));
    }

    pub fn GetAverageMoveTypeCorpsUnit(grp: i32) -> i32
    {
      let mut num1: i32 = 0;
      int[] numArray1 = new int[100];
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == grp && this.game.Data.UnitObj[unr].TempTheater == 0 && !this.game.Data.UnitObj[unr].IsHQ)
        {
          let mut moveType: i32 = this.game.Data.SFTypeObj[this.game.Data.UnitObj[unr].TempType].MoveType;
          int[] numArray2 = numArray1;
          int[] numArray3 = numArray2;
          let mut index1: i32 = moveType;
          let mut index2: i32 = index1;
          let mut num2: i32 = numArray2[index1] + this.GetUnitPower(unr, true);
          numArray3[index2] = num2;
        }
      }
      let mut moveTypeCorpsUnit: i32 = -1;
      let mut index: i32 = 0;
      do
      {
        if (numArray1[index] > num1)
        {
          num1 = numArray1[index];
          moveTypeCorpsUnit = index;
        }
        index += 1;
      }
      while (index <= 99);
      if (moveTypeCorpsUnit == -1)
        moveTypeCorpsUnit = 3;
      return moveTypeCorpsUnit;
    }

    pub fn GetHexSpeedofUnit(i: i32, bool friendlyter) -> i32
    {
      let mut num1: i32 = 0;
      let mut num2: i32 = 0;
      if (this.game.Data.UnitObj[i].TempTheater == 0)
      {
        let mut tempType: i32 = this.game.Data.UnitObj[i].TempType;
        if (tempType > -1)
        {
          let mut moveType: i32 = this.game.Data.SFTypeObj[tempType].MoveType;
          num1 += this.game.Data.RoadTypeObj[0].MoveCostOverrule[moveType];
          if (!friendlyter)
            num1 += 10;
          num2 += 1;
        }
      }
      return num2 == 0 ? 0 :  Math.Round(Conversion.Int(100.0 /   Math.Round( num1 /  num2)));
    }

    pub AreaSeaConnect: bool(nr: i32, nr2: i32)
    {
      let mut seaCount: i32 = this.SeaCount;
      for (let mut index: i32 = 1; index <= seaCount; index += 1)
      {
        if (this.SeaBorder[index, nr] > 0 & this.SeaBorder[index, nr2] > 0)
          return true;
      }
      return false;
    }

    pub fn AreaSeaConnectSeaNumber(nr: i32, nr2: i32) -> i32
    {
      let mut seaCount: i32 = this.SeaCount;
      for (let mut index: i32 = 1; index <= seaCount; index += 1)
      {
        if (this.SeaBorder[index, nr] > 0 & this.SeaBorder[index, nr2] > 0)
          return index;
      }
      return -1;
    }

    pub fn GetStrategyScore_EnemySupply()
    {
      if (this.EnemySupply.GetUpperBound(0) <= this.AreaCount)
        this.EnemySupply = (int[]) Utils.CopyArray((Array) this.EnemySupply, (Array) new int[this.AreaCount + 1]);
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index: i32 = 0; index <= areaCount1; index += 1)
      {
        this.atemp[index] = 0;
        this.atemp2[index] = 0;
        this.StrLandEnemySupply[index] = 0;
        this.EnemySupply[index] = 0;
      }
      let mut regimeCounter1: i32 = this.game.Data.RegimeCounter;
      num1: i32;
      for (let mut index1: i32 = 0; index1 <= regimeCounter1; index1 += 1)
      {
        if (this.GetRegime(index1) != this.GetGameDataTurn())
        {
          this.OpGroup = -1;
          let mut regime: i32 = this.GetRegime(index1);
          num2: i32;
          if ( this.game.Data.RuleVar[335] > 0.0)
          {
            let mut num3: i32 = 0;
            do
            {
              if (this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num3 * 4)))] > 0 & this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num3 * 4)))] > -1)
              {
                let mut index2: i32 = this.AreaMatrixWide[this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num3 * 4)))], this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num3 * 4)))]];
                num1 = 0;
                if (index2 > 0 && this.GetRegime(this.AreaOwner[index2]) == regime)
                {
                  num1 = 1;
                  this.atemp2[index2] = 1;
                  this.StrLandEnemySupply[index2] = 9999;
                }
                num2 = 0;
              }
              num3 += 1;
            }
            while (num3 <= 3);
          }
          else
          {
            let mut areaCount2: i32 = this.AreaCount;
            for (let mut i: i32 = 0; i <= areaCount2; i += 1)
            {
              if (this.IsAreaSupplySource(i, index1))
              {
                num1 = 1;
                this.atemp2[i] = 1;
                this.StrLandEnemySupply[i] = 9999;
              }
            }
          }
          while (num1 == 1)
          {
            num1 = 0;
            num2 += 1;
            let mut areaCount3: i32 = this.AreaCount;
            for (let mut nr: i32 = 1; nr <= areaCount3; nr += 1)
            {
              if (this.atemp2[nr] == num2)
              {
                let mut num4: i32 = this.AreaSupplyBorderCount[nr];
                for (let mut index3: i32 = 0; index3 <= num4; index3 += 1)
                {
                  nr2: i32;
                  if (this.AreaSupplyBorder[nr, index3] > 0 & nr != this.AreaSupplyBorder[nr, index3])
                  {
                    nr2 = this.AreaSupplyBorder[nr, index3];
                    if (this.GetRegime(this.AreaOwner[nr2]) == regime & this.atemp2[nr2] == 0 | this.StrLandEnemySupply[nr2] < 9999 & this.StrLandEnemySupply[nr2] > 0 & this.StrLandEnemySupply[nr2] != this.StrLandEnemySupply[nr])
                    {
                      this.atemp2[nr2] = this.atemp2[nr] + 1;
                      num1 = 1;
                      this.StrLandEnemySupply[nr2] = this.StrLandEnemySupply[nr];
                    }
                  }
                  if (this.AreaSupplyBorder[nr, index3] == 0 & this.AreasupplyborderSea[nr, index3] > 0 & this.StrLandEnemySupply[nr] == 9999 & nr != nr2)
                  {
                    nr2 = this.AreasupplyborderSea[nr, index3];
                    if (this.GetRegime(this.AreaOwner[nr2]) == regime & this.atemp2[nr2] == 0)
                    {
                      this.atemp2[nr2] = this.atemp2[nr] + 1;
                      num1 = 1;
                      this.StrLandEnemySupply[nr2] = this.AreaSeaConnectSeaNumber(nr, nr2);
                    }
                  }
                }
              }
            }
          }
        }
      }
      let mut areaCount4: i32 = this.AreaCount;
      for (let mut index: i32 = 0; index <= areaCount4; index += 1)
      {
        this.atemp[index] = 0;
        this.atemp2[index] = 0;
        this.EnemySupply[index] = 0;
      }
      let mut regimeCounter2: i32 = this.game.Data.RegimeCounter;
      for (let mut index4: i32 = 0; index4 <= regimeCounter2; index4 += 1)
      {
        if (this.game.Data.Turn != index4)
        {
          this.OpGroup = -1;
          let mut regime: i32 = this.GetRegime(index4);
          if ( this.game.Data.RuleVar[335] > 0.0)
          {
            let mut num5: i32 = 0;
            do
            {
              if (this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num5 * 4)))] > 0 & this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num5 * 4)))] > -1)
              {
                let mut index5: i32 = this.AreaMatrixWide[this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num5 * 4)))], this.game.Data.RegimeObj[regime].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num5 * 4)))]];
                num1 = 0;
                if (index5 > 0 && this.GetRegime(this.AreaOwner[index5]) == regime)
                {
                  num1 = 1;
                  this.atemp2[index5] = 1;
                  this.EnemySupply[index5] = 1;
                }
              }
              num5 += 1;
            }
            while (num5 <= 3);
          }
          else if (this.game.Data.Turn != index4)
          {
            let mut areaCount5: i32 = this.AreaCount;
            for (let mut i: i32 = 0; i <= areaCount5; i += 1)
            {
              if (this.IsAreaSupplySource(i, index4))
              {
                num1 = 1;
                this.atemp2[i] = 1;
                this.EnemySupply[i] = 1;
              }
            }
          }
          let mut num6: i32 = 0;
          while (num1 == 1)
          {
            num1 = 0;
            num6 += 1;
            let mut areaCount6: i32 = this.AreaCount;
            for (let mut nr: i32 = 1; nr <= areaCount6; nr += 1)
            {
              if (this.atemp2[nr] == num6)
              {
                if (nr == 163)
                  nr = nr;
                let mut num7: i32 = this.AreaSupplyBorderCount[nr];
                for (let mut index6: i32 = 0; index6 <= num7; index6 += 1)
                {
                  let mut nr2: i32 = this.AreaSupplyBorderEither[nr, index6];
                  if ((this.AreaNarrowBorder[nr, nr2] > 0 | this.AreaSeaConnect(nr, nr2)) & nr != nr2 && this.GetRegime(this.AreaOwner[nr2]) == regime & this.atemp2[nr2] == 0)
                  {
                    this.atemp2[nr2] = this.atemp2[nr] + 1;
                    num1 = 1;
                    this.EnemySupply[nr2] = 1;
                  }
                }
              }
            }
          }
        }
      }
      let mut areaCount7: i32 = this.AreaCount;
      for (let mut index7: i32 = 0; index7 <= areaCount7; index7 += 1)
      {
        if (this.AreaEnemy[index7] > 0)
        {
          if (this.EnemySupply[index7] == 0)
          {
            int[] enemySupplyGone = this.EnemySupplyGone;
            int[] numArray = enemySupplyGone;
            let mut index8: i32 = index7;
            let mut index9: i32 = index8;
            let mut num8: i32 = enemySupplyGone[index8] + 1;
            numArray[index9] = num8;
            if (this.EnemySupplyGone[index7] > 1)
              this.AreaEnemy[index7] =  Math.Round(0.5 *  this.AreaEnemy[index7]);
          }
          else
            this.EnemySupplyGone[index7] = 0;
        }
      }
    }

    pub fn GetStrategyScore_FriendlySupply(bool tlog, tround: i32)
    {
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("FRIENDLY SUPPLY");
        this.AddLog("");
      }
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index: i32 = 0; index <= areaCount1; index += 1)
      {
        this.atemp[index] = 0;
        this.FriendlySupply[index] = 0;
      }
      this.atemp2 = new int[this.AreaCount + 1];
      num1: i32;
      num2: i32;
      if ( this.game.Data.RuleVar[335] > 0.0)
      {
        let mut num3: i32 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num3 * 4)))] > 0 && this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num3 * 4)))] > -1)
          {
            let mut index: i32 = this.AreaMatrixWide[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num3 * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num3 * 4)))]];
            num1 = 0;
            if (index > 0 && index > 0 & this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn())
            {
              num1 = 1;
              this.atemp2[index] = 1;
              this.FriendlySupply[index] = 1;
            }
            num2 = 0;
          }
          num3 += 1;
        }
        while (num3 <= 3);
      }
      else
      {
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut i: i32 = 0; i <= areaCount2; i += 1)
        {
          if (this.IsAreaSupplySource(i, this.game.Data.Turn))
          {
            num1 = 1;
            this.atemp2[i] = 1;
            this.FriendlySupply[i] = 1;
          }
        }
      }
      while (num1 == 1)
      {
        num1 = 0;
        num2 += 1;
        let mut areaCount3: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount3; nr += 1)
        {
          if (this.atemp2[nr] == num2)
          {
            let mut num4: i32 = this.AreaSupplyBorderCount[nr];
            for (let mut index: i32 = 0; index <= num4; index += 1)
            {
              let mut nr2: i32 = this.AreaSupplyBorderEither[nr, index];
              if (this.atemp2[nr2] == 0 && (this.AreaNarrowBorder[nr, nr2] > 0 | this.AreaSeaConnect(nr, nr2)) & nr != nr2 && this.GetRegime(this.AreaOwner[nr2]) == this.GetGameDataTurn())
              {
                this.atemp2[nr2] = this.atemp2[nr] + 1;
                num1 = 1;
                this.FriendlySupply[nr2] = 1;
              }
            }
          }
        }
      }
      if (tround > 0)
      {
        let mut groupCounter: i32 = this.GroupCounter;
        for (let mut index: i32 = 0; index <= groupCounter; index += 1)
        {
          let mut num5: i32 = 0;
          if (index == 1 & this.CorpsTarget[index] > 0 & tround == 1)
            index = index;
          if (this.FriendlySupply[this.CorpsLoc[index]] == 0 && this.CorpsTarget[index] > 0 && this.FriendlySupply[this.CorpsTarget[index]] == 1)
            num5 = 1;
          if (num5 == 0)
          {
            if (tround >= 2)
            {
              if (tround == 2)
              {
                if (this.FriendlySupply[this.CorpsLoc[index]] == 0)
                  this.CorpsTempStrength[index] =  Math.Round( this.CorpsTempStrength[index] * 0.66);
              }
              else if (tround == 3)
              {
                if (this.FriendlySupply[this.CorpsLoc[index]] == 0)
                  this.CorpsTempStrength[index] =  Math.Round( this.CorpsTempStrength[index] * 0.5);
              }
              else if (this.FriendlySupply[this.CorpsLoc[index]] == 0)
                this.CorpsTempStrength[index] =  Math.Round( this.CorpsTempStrength[index] * 0.33);
            }
          }
          else if (tround >= 3 && tround == 2 && this.FriendlySupply[this.CorpsLoc[index]] == 0)
            this.CorpsTempStrength[index] =  Math.Round( this.CorpsTempStrength[index] * 0.8);
        }
      }
      if (!tlog)
        return;
      let mut areaCount4: i32 = this.AreaCount;
      for (let mut nr: i32 = 1; nr <= areaCount4; nr += 1)
        this.AddLog(this.GetAreaName(nr) + " = " + this.FriendlySupply[nr].ToString());
    }

    pub fn GetStrategyScore_TroopsPlace(round: i32, bool makelog)
    {
      let mut areaCount: i32 = this.AreaCount;
      for (let mut index1: i32 = 1; index1 <= areaCount; index1 += 1)
      {
        this.StrAreaNegPow[index1] = 0;
        if (this.AreaEnemy[index1] > 0 & this.Attacker && this.EnemySupply[index1] > 0)
        {
          int[] strAreaEntrench = this.StrAreaEntrench;
          int[] numArray = strAreaEntrench;
          let mut index2: i32 = index1;
          let mut index3: i32 = index2;
          let mut num: i32 = strAreaEntrench[index2] + 40;
          numArray[index3] = num;
          if (this.StrAreaEntrench[index1] > 200)
            this.StrAreaEntrench[index1] = 200;
        }
      }
      let mut counter: i32 = this.TempTroops.Counter;
      for (let mut index4: i32 = 0; index4 <= counter; index4 += 1)
      {
        let mut index5: i32 = this.TempTroops.Data1[index4];
        let mut index6: i32 = this.TempTroops.Data2[index4];
        if (index5 > -1 & index6 > -1)
        {
          let mut nr: i32 = this.AreaMatrixWide[index5, index6];
          if (nr > -1 && this.AreaOwner[nr] > -1)
          {
            if (this.TempTroops.Data3[index4] == 1 & this.AreaOwner[nr] > -1 & this.GetRegime(this.AreaOwner[nr]) != this.GetGameDataTurn())
            {
              let mut Number: i32 = this.TempTroops.Data4[index4];
              if (Number > 0)
              {
                if (makelog)
                  this.AddLog(this.GetAreaName(nr) + " RECEIVES " + Conversion.Str( Number) + " REINFORCEMENTS (1PROJECTED)");
                this.StrAreaEntrench[nr] =  Math.Round( (this.AreaEnemy[nr] * this.StrAreaEntrench[nr] + Number) /  (this.AreaEnemy[nr] + Number));
                int[] areaEnemy = this.AreaEnemy;
                int[] numArray1 = areaEnemy;
                let mut index7: i32 = nr;
                let mut index8: i32 = index7;
                let mut num1: i32 = areaEnemy[index7] + Number;
                numArray1[index8] = num1;
                int[] areaStartEnemy = this.AreaStartEnemy;
                int[] numArray2 = areaStartEnemy;
                let mut index9: i32 = nr;
                let mut index10: i32 = index9;
                let mut num2: i32 = areaStartEnemy[index9] + Number;
                numArray2[index10] = num2;
              }
            }
            else if (this.TempTroops.Data3[index4] == 2 & this.AreaOwner[nr] > -1 & this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[nr])].AIPower[0].Value[index5, index6] > 0)
            {
              let mut num3: i32 = 999;
              let mut num4: i32 = -1;
              let mut groupCounter1: i32 = this.GroupCounter;
              for (let mut index11: i32 = 0; index11 <= groupCounter1; index11 += 1)
              {
                let mut num5: i32 = this.CorpsLoc[index11] != nr ? this.AreaSteps[this.CorpsLoc[index11], nr] : 0;
                if (this.GroupType[index11] > 5)
                  num5 += 9;
                if (this.CorpsTarget[index11] > -1 && this.AreaEnemy[this.CorpsTarget[index11]] <= 0)
                  num5 += 3;
                if (num5 < num3)
                {
                  num3 = num5;
                  num4 = index11;
                }
              }
              let mut num6: i32 = 0;
              let mut groupCounter2: i32 = this.GroupCounter;
              for (let mut index12: i32 = 0; index12 <= groupCounter2; index12 += 1)
              {
                let mut num7: i32 = this.CorpsLoc[index12] != nr ? this.AreaSteps[this.CorpsLoc[index12], nr] : 0;
                if (this.CorpsTarget[index12] > -1 && this.AreaEnemy[this.CorpsTarget[index12]] <= 0)
                  num7 += 3;
                if (this.GroupType[index12] > 5)
                  num7 += 9;
                if (num7 == num3)
                  num6 += 1;
              }
              let mut num8: i32 = num3;
              if (num4 > -1)
              {
                let mut num9: i32 = this.TempTroops.Data4[index4];
                if (num9 > 0)
                {
                  let mut groupCounter3: i32 = this.GroupCounter;
                  for (let mut index13: i32 = 0; index13 <= groupCounter3; index13 += 1)
                  {
                    if (this.CorpsPowerLeft[index13] > 0)
                    {
                      let mut num10: i32 = this.CorpsLoc[index13] != nr ? this.AreaSteps[this.CorpsLoc[index13], nr] : 0;
                      if (this.CorpsTarget[index13] > -1 && this.AreaEnemy[this.CorpsTarget[index13]] <= 0)
                        num10 += 3;
                      if (this.GroupType[index13] > 5)
                        num10 += 9;
                      if (num10 == num8)
                      {
                        let mut index14: i32 = index13;
                        if (makelog)
                          this.AddLog(this.GroupName[index14] + " RECEIVES " + Conversion.Str(  Math.Round( num9 /  num6)) + " REINFORCEMENTS (2PROJECTED)");
                        this.CorpsEntrench[index14] =  Math.Round( (this.CorpsTempStrength[index14] * this.CorpsEntrench[index14]) /  (this.CorpsTempStrength[index14] +  Math.Round( num9 /  num6)));
                        int[] corpsTempStrength = this.CorpsTempStrength;
                        int[] numArray3 = corpsTempStrength;
                        let mut index15: i32 = index14;
                        let mut index16: i32 = index15;
                        let mut num11: i32 = corpsTempStrength[index15] +  Math.Round( num9 /  num6);
                        numArray3[index16] = num11;
                        int[] corpsstartStrength = this.corpsstartStrength;
                        int[] numArray4 = corpsstartStrength;
                        let mut index17: i32 = index14;
                        let mut index18: i32 = index17;
                        let mut num12: i32 = corpsstartStrength[index17] +  Math.Round( num9 /  num6);
                        numArray4[index18] = num12;
                        int[] corpsPowerLeft = this.CorpsPowerLeft;
                        int[] numArray5 = corpsPowerLeft;
                        let mut index19: i32 = index14;
                        let mut index20: i32 = index19;
                        let mut num13: i32 = corpsPowerLeft[index19] -  Math.Round( num9 /  num6);
                        numArray5[index20] = num13;
                      }
                    }
                  }
                }
              }
            }
            else if (this.TempTroops.Data3[index4] == 3 & this.AreaOwner[nr] > -1 & this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[nr])].AIPower[0].Value[index5, index6] < 0)
            {
              let mut num: i32 = this.TempTroops.Data4[index4];
              if (round > 1)
                num = num;
              if (makelog)
                this.AddLog(this.GetAreaName(nr) + " GETS" + Conversion.Str( Math.Abs(num)) + " NEGATIVE POWER.");
              this.StrAreaNegPow[nr] = Math.Abs(num);
            }
          }
        }
      }
    }

    pub fn GetStrategyScore_Prepare_TroopsPlace()
    {
      this.TempTroops = SimpleList::new();
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut tdata1: i32 = 0; tdata1 <= mapWidth; tdata1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut tdata2: i32 = 0; tdata2 <= mapHeight; tdata2 += 1)
        {
          let mut index: i32 = this.AreaMatrixWide[tdata1, tdata2];
          tid: i32;
          if (index > -1 && this.AreaOwner[index] > -1)
          {
            if (this.AreaOwner[index] > -1 & this.GetRegime(this.AreaOwner[index]) != this.GetGameDataTurn())
            {
              let mut tdata4: i32 = this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2];
              if (tdata4 > 0)
              {
                tid += 1;
                this.TempTroops.Add(tid, 1, tdata1, tdata2, 1, tdata4);
              }
            }
            else if (this.AreaOwner[index] > -1 & this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2] > 0)
            {
              let mut tdata4: i32 = this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2];
              if (tdata4 > 0)
              {
                tid += 1;
                this.TempTroops.Add(tid, 1, tdata1, tdata2, 2, tdata4);
              }
            }
            else if (this.AreaOwner[index] > -1 & this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn() & this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2] < 0)
            {
              let mut num: i32 = this.game.Data.RegimeObj[this.GetRegime(this.AreaOwner[index])].AIPower[0].Value[tdata1, tdata2];
              tid += 1;
              this.TempTroops.Add(tid, 1, tdata1, tdata2, 3, Math.Abs(num));
            }
          }
        }
      }
    }

    pub fn GetStrategyScore_CorpsTarget( SimpleList straty, round: i32, bool makelog)
    {
      let mut groupCounter: i32 = this.GroupCounter;
      for (let mut index1: i32 = 0; index1 <= groupCounter; index1 += 1)
      {
        if (this.CurrentAreaGroup == this.AreaGroup[this.CorpsStartLoc[index1]])
        {
          this.CorpsTarget[index1] = 0;
          let mut nr1: i32 = straty.FindNr(index1);
          if (nr1 > -1)
          {
            let mut num1: i32 = 0;
            let mut num2: i32 = 0;
            let mut num3: i32 = 0;
            if (this.CorpsMove[index1] == 1)
            {
              num1 = straty.Data1[nr1];
              num2 = this.CorpsStartLoc[index1];
              num3 = -1;
            }
            if (this.CorpsMove[index1] == 2)
            {
              num1 = straty.Data2[nr1];
              num2 = straty.Data1[nr1];
              num3 = this.CorpsStartLoc[index1];
            }
            if (this.CorpsMove[index1] == 3)
            {
              num1 = straty.Data3[nr1];
              num2 = straty.Data2[nr1];
              num3 = straty.Data1[nr1];
            }
            if (this.CorpsMove[index1] == 4)
            {
              num1 = straty.Data4[nr1];
              num2 = straty.Data3[nr1];
              num3 = straty.Data2[nr1];
            }
            if (this.CorpsMove[index1] == 5)
            {
              num1 = straty.Data5[nr1];
              num2 = straty.Data4[nr1];
              num3 = straty.Data3[nr1];
            }
            if (num2 == num1)
              num1 = -1;
            if (num3 == num2)
              num1 = -1;
            this.CorpsTarget[index1] = num1;
            let mut index2: i32 = this.TempGroupHQ[index1];
            if (index2 > -1 & round == 1 && this.game.Data.UnitObj[index2].AIAttack > -1 | this.game.Data.UnitObj[index2].AIDefend > -1 && this.CorpsMove[index1] == 1 & this.game.Data.UnitObj[index2].AIAttack <= this.AreaCount & this.game.Data.UnitObj[index2].AIDefend <= this.AreaCount)
            {
              let mut num4: i32 = 0;
              if (this.game.Data.UnitObj[index2].AIAttack == this.CorpsTarget[index1])
                num4 = 1;
              else if (this.game.Data.UnitObj[index2].AIAttack == -1)
                num4 = 1;
              else if (this.game.Data.UnitObj[index2].AIFollowup == this.CorpsTarget[index1])
                num4 = 1;
              if (this.game.Data.UnitObj[index2].AIAttack > -1 && this.GetRegime(this.AreaOwner[this.game.Data.UnitObj[index2].AIAttack]) == this.GetGameDataTurn())
                num4 = 1;
              if (num4 == 1)
              {
                if (makelog)
                  this.AddLog(this.GroupName[index1] + " IS SAME");
                this += 1.StrConsistSame;
              }
              if (num4 == 0)
              {
                if (makelog)
                  this.AddLog(this.GroupName[index1] + " IS DIFFERENT");
                this += 1.StrConsistDifferent;
              }
            }
            if (this.CorpsTarget[index1] <= 0 & !this.Attacker)
            {
              int[] corpsEntrench = this.CorpsEntrench;
              int[] numArray = corpsEntrench;
              let mut index3: i32 = index1;
              let mut index4: i32 = index3;
              let mut num5: i32 = corpsEntrench[index3] + 15;
              numArray[index4] = num5;
              if (this.CorpsEntrench[index1] > 100)
                this.CorpsEntrench[index1] = 100;
            }
            if (this.CorpsMove[index1] > 0 & this.CorpsTarget[index1] > 0)
            {
              if (this.GetRegime(this.AreaOwner[this.CorpsTarget[index1]]) == this.GetGameDataTurn())
              {
                if (this.CorpsStance[index1] == 2)
                {
                  int[] corpsMoveProgress = this.CorpsMoveProgress;
                  int[] numArray = corpsMoveProgress;
                  let mut index5: i32 = index1;
                  let mut index6: i32 = index5;
                  let mut num6: i32 = corpsMoveProgress[index5] + Math.Max(2,  Math.Round( this.GetAverageHexSpeedofCorpsUnit(index1, true) * 0.33));
                  numArray[index6] = num6;
                }
                else
                {
                  int[] corpsMoveProgress1 = this.CorpsMoveProgress;
                  int[] numArray1 = corpsMoveProgress1;
                  let mut index7: i32 = index1;
                  let mut index8: i32 = index7;
                  let mut num7: i32 = corpsMoveProgress1[index7] + Math.Max(3, this.GetAverageHexSpeedofCorpsUnit(index1, true));
                  numArray1[index8] = num7;
                  let mut num8: i32 = 0;
                  let mut areaCount: i32 = this.AreaCount;
                  for (let mut nr2: i32 = 1; nr2 <= areaCount; nr2 += 1)
                  {
                    if (this.AreaBorder[nr2, this.CorpsTarget[index1]] > 0 && this.GetRegime(this.AreaOwner[nr2]) == this.GetGameDataTurn() && this.GetAreaEnemyNeighbourCount(nr2) > 0)
                      num8 += 1;
                  }
                  if (num8 == 0)
                  {
                    int[] corpsMoveProgress2 = this.CorpsMoveProgress;
                    int[] numArray2 = corpsMoveProgress2;
                    let mut index9: i32 = index1;
                    let mut index10: i32 = index9;
                    let mut num9: i32 = corpsMoveProgress2[index9] + Math.Min(2,  Math.Round( this.GetAverageHexSpeedofCorpsUnit(index1, true) / 3.0));
                    numArray2[index10] = num9;
                  }
                  if ( this.game.Data.RuleVar[811] > 0.0)
                  {
                    int[] corpsMoveProgress3 = this.CorpsMoveProgress;
                    int[] numArray3 = corpsMoveProgress3;
                    let mut index11: i32 = index1;
                    let mut index12: i32 = index11;
                    let mut num10: i32 = corpsMoveProgress3[index11] +  Math.Round( (this.game.Data.RuleVar[811] *  Math.Max(5, this.GetAverageHexSpeedofCorpsUnit(index1, true))));
                    numArray3[index12] = num10;
                  }
                  this.CorpsEntrench[index1] = 0;
                }
              }
              else
              {
                if (this.GetRegime(this.AreaOwner[this.CorpsTarget[index1]]) == -1)
                {
                  int[] corpsMoveProgress4 = this.CorpsMoveProgress;
                  int[] numArray4 = corpsMoveProgress4;
                  let mut index13: i32 = index1;
                  let mut index14: i32 = index13;
                  let mut num11: i32 = corpsMoveProgress4[index13] + Math.Max(5, this.GetAverageHexSpeedofCorpsUnit(index1, true));
                  numArray4[index14] = num11;
                  int[] corpsMoveProgress5 = this.CorpsMoveProgress;
                  int[] numArray5 = corpsMoveProgress5;
                  let mut index15: i32 = index1;
                  let mut index16: i32 = index15;
                  let mut num12: i32 = corpsMoveProgress5[index15] +  Math.Round( Math.Max(5, this.GetAverageHexSpeedofCorpsUnit(index1, true)) / 2.0);
                  numArray5[index16] = num12;
                }
                else
                {
                  int[] corpsMoveProgress = this.CorpsMoveProgress;
                  int[] numArray = corpsMoveProgress;
                  let mut index17: i32 = index1;
                  let mut index18: i32 = index17;
                  let mut num13: i32 = corpsMoveProgress[index17] + Math.Max(4, this.GetAverageHexSpeedofCorpsUnit(index1, false));
                  numArray[index18] = num13;
                }
                this.CorpsEntrench[index1] = 0;
              }
            }
            if (makelog)
              this.AddLog(this.GroupName[index1] + " ENTRENCH = " + Conversion.Str( this.CorpsEntrench[index1]));
          }
        }
      }
    }

    pub fn GetStrategyScore_MoveEnemy(round: i32, bool makelog)
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut nr: i32 = 1; nr <= areaCount1; nr += 1)
      {
        if (this.AreaGroup[nr] == this.CurrentAreaGroup && this.EnemySupply[nr] == 1)
        {
          numArray1[nr] =  Math.Round( this.AreaEnemy[nr] * 0.33);
          numArray2[nr] = this.GetAreaEnemyNeighbourCountFuzzyVP(nr);
          numArray3[nr] = this.GetAreaFriendlyNeighbourCount2(nr);
        }
      }
      if (!this.Attacker | round > 2)
      {
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut nr1: i32 = 1; nr1 <= areaCount2; nr1 += 1)
        {
          if (this.AreaGroup[nr1] == this.CurrentAreaGroup && this.GetRegime(this.AreaOwner[nr1]) != this.GetGameDataTurn() & this.EnemySupply[nr1] == 1 & this.AreaEnemy[nr1] > 0)
          {
            let mut num1: i32 = numArray2[nr1];
            if (num1 > 0)
            {
              let mut areaCount3: i32 = this.AreaCount;
              for (let mut nr2: i32 = 1; nr2 <= areaCount3; nr2 += 1)
              {
                if (this.AreaGroup[nr2] == this.CurrentAreaGroup && !this.Attacker | this.Meeting | this.AreaBroadBorder[nr1, nr2] > 0 & this.AreaBroadBorder[nr1, nr2] < 99 && this.GetRegime(this.AreaOwner[nr2]) != this.GetGameDataTurn() & this.AreaOwner[nr2] == this.AreaOwner[nr1] & this.EnemySupply[nr2] == 1 & this.StrLandEnemySupply[nr2] == this.StrLandEnemySupply[nr1] && numArray2[nr2] > numArray2[nr1])
                {
                  float num2 =  numArray2[nr2] /  num1;
                  if ( this.AreaEnemy[nr2] + 300.0 * (1.0 +  this.game.Data.RuleVar[828]) <   Math.Round( ( this.AreaEnemy[nr1] * num2)))
                  {
                    let mut Number: i32 =  Math.Round( numArray1[nr1] * 0.2);
                    if ( this.game.Data.RuleVar[828] > 0.0)
                      Number =  Math.Round( ( Number / this.game.Data.RuleVar[828]));
                    this.StrAreaEntrench[nr2] =  Math.Round( (this.AreaEnemy[nr2] * this.StrAreaEntrench[nr2] + Number) /  Math.Max(1, this.AreaEnemy[nr2] + Number));
                    int[] areaEnemy1 = this.AreaEnemy;
                    int[] numArray4 = areaEnemy1;
                    let mut index1: i32 = nr2;
                    let mut index2: i32 = index1;
                    let mut num3: i32 = areaEnemy1[index1] + Number;
                    numArray4[index2] = num3;
                    int[] numArray5 = numArray1;
                    int[] numArray6 = numArray5;
                    let mut index3: i32 = nr1;
                    let mut index4: i32 = index3;
                    let mut num4: i32 = numArray5[index3] - Number;
                    numArray6[index4] = num4;
                    int[] areaEnemy2 = this.AreaEnemy;
                    int[] numArray7 = areaEnemy2;
                    let mut index5: i32 = nr1;
                    let mut index6: i32 = index5;
                    let mut num5: i32 = areaEnemy2[index5] - Number;
                    numArray7[index6] = num5;
                    if (makelog)
                      this.AddLog("ENEMY AREA " + this.GetAreaName(nr1) + " TRANSFER TO " + this.GetAreaName(nr2) + " " + Conversion.Str( Number) + " pts");
                  }
                }
              }
            }
          }
        }
      }
      let mut areaCount4: i32 = this.AreaCount;
      for (let mut index7: i32 = 1; index7 <= areaCount4; index7 += 1)
      {
        if (this.AreaGroup[index7] == this.CurrentAreaGroup & this.EnemySupply[index7] == 1 && this.GetRegime(this.AreaOwner[index7]) != this.GetGameDataTurn() && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.AreaOwner[index7], this.GetGameDataTurn()) && numArray3[index7] == 0 & this.AreaEnemy[index7] > 0)
        {
          if (index7 == 19)
            index7 = index7;
          let mut num6: i32 = 0;
          let mut areaCount5: i32 = this.AreaCount;
          for (let mut index8: i32 = 1; index8 <= areaCount5; index8 += 1)
          {
            if (this.AreaGroup[index8] == this.CurrentAreaGroup & index7 != index8 && this.AreaSteps[index7, index8] > 0 & this.AreaSteps[index7, index8] < 99 & (!this.Attacker | this.Meeting |  this.game.Data.RuleVar[830] == 1.0 | this.AreaFuzzyVP[index8] > this.AreaFuzzyVP[index7]) && this.EnemySupply[index8] == 1 & this.StrLandEnemySupply[index8] == this.StrLandEnemySupply[index7] && numArray3[index8] > 0)
              num6 += this.AreaFuzzyVP[index8];
          }
          if (num6 > 0)
          {
            let mut areaCount6: i32 = this.AreaCount;
            for (let mut index9: i32 = 1; index9 <= areaCount6; index9 += 1)
            {
              if (this.AreaGroup[index9] == this.CurrentAreaGroup & index7 != index9 & this.EnemySupply[index9] == 1 && this.AreaSteps[index7, index9] > 0 & this.AreaSteps[index7, index9] < 99 & (!this.Attacker | this.Meeting |  this.game.Data.RuleVar[830] == 1.0 | this.AreaFuzzyVP[index9] > this.AreaFuzzyVP[index7]))
              {
                if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.AreaOwner[index9], this.AreaOwner[index7]) & this.StrLandEnemySupply[index9] == this.StrLandEnemySupply[index7] && numArray3[index9] > 0)
                {
                  if (this.Attacker)
                  {
                    if (round > 2)
                    {
                      let mut num7: i32 =  Math.Round(Conversion.Int( this.AreaEnemy[index7] * 0.2) * ( this.AreaFuzzyVP[index9] /  num6));
                      if ( this.game.Data.RuleVar[828] > 0.0)
                        num7 =  Math.Round( ( num7 / this.game.Data.RuleVar[828]));
                      if (num7 > 0 & num7 <= this.AreaEnemy[index7])
                      {
                        this.StrAreaEntrench[index9] =  Math.Round( (this.AreaEnemy[index9] * this.StrAreaEntrench[index9] + num7) /  (this.AreaEnemy[index9] + num7));
                        int[] areaEnemy3 = this.AreaEnemy;
                        int[] numArray8 = areaEnemy3;
                        let mut index10: i32 = index9;
                        let mut index11: i32 = index10;
                        let mut num8: i32 = areaEnemy3[index10] + num7;
                        numArray8[index11] = num8;
                        int[] areaEnemy4 = this.AreaEnemy;
                        int[] numArray9 = areaEnemy4;
                        let mut index12: i32 = index7;
                        let mut index13: i32 = index12;
                        let mut num9: i32 = areaEnemy4[index12] - num7;
                        numArray9[index13] = num9;
                      }
                    }
                  }
                  else if (round <= 2)
                  {
                    let mut num10: i32 =  Math.Round(Conversion.Int( this.AreaEnemy[index7] * 0.66) * ( this.AreaFuzzyVP[index9] /  num6));
                    if ( this.game.Data.RuleVar[828] > 0.0)
                      num10 =  Math.Round( ( num10 / this.game.Data.RuleVar[828]));
                    if (num10 > 0)
                    {
                      this.StrAreaEntrench[index9] =  Math.Round( (this.AreaEnemy[index9] * this.StrAreaEntrench[index9] + num10) /  (this.AreaEnemy[index9] + num10));
                      int[] areaEnemy5 = this.AreaEnemy;
                      int[] numArray10 = areaEnemy5;
                      let mut index14: i32 = index9;
                      let mut index15: i32 = index14;
                      let mut num11: i32 = areaEnemy5[index14] + num10;
                      numArray10[index15] = num11;
                      int[] areaEnemy6 = this.AreaEnemy;
                      int[] numArray11 = areaEnemy6;
                      let mut index16: i32 = index7;
                      let mut index17: i32 = index16;
                      let mut num12: i32 = areaEnemy6[index16] - num10;
                      numArray11[index17] = num12;
                    }
                  }
                  else
                  {
                    let mut num13: i32 =  Math.Round( Conversion.Int(this.AreaEnemy[index7] * 1) * ( this.AreaFuzzyVP[index9] /  num6));
                    if ( this.game.Data.RuleVar[828] > 0.0)
                      num13 =  Math.Round( ( num13 / this.game.Data.RuleVar[828]));
                    if (num13 > 0)
                    {
                      this.StrAreaEntrench[index9] =  Math.Round( (this.AreaEnemy[index9] * this.StrAreaEntrench[index9] + num13) /  (this.AreaEnemy[index9] + num13));
                      int[] areaEnemy7 = this.AreaEnemy;
                      int[] numArray12 = areaEnemy7;
                      let mut index18: i32 = index9;
                      let mut index19: i32 = index18;
                      let mut num14: i32 = areaEnemy7[index18] + num13;
                      numArray12[index19] = num14;
                      int[] areaEnemy8 = this.AreaEnemy;
                      int[] numArray13 = areaEnemy8;
                      let mut index20: i32 = index7;
                      let mut index21: i32 = index20;
                      let mut num15: i32 = areaEnemy8[index20] - num13;
                      numArray13[index21] = num15;
                    }
                  }
                }
                if (0 > this.AreaEnemy[index7])
                  this.AreaEnemy[index7] = 0;
              }
            }
          }
        }
      }
    }

    pub fn GetStrategyScore_Attacks( SimpleList straty, round: i32, bool makelog)
    {
      bool[] flagArray = new bool[this.AreaCount + 1];
      let mut num1: i32 = num1;
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut nr1: i32 = 1; nr1 <= areaCount1; nr1 += 1)
      {
        if (this.AreaGroup[nr1] == this.CurrentAreaGroup)
        {
          let mut num2: i32 = 0;
          let mut index1: i32 = 0;
          let mut areaNeighbourCount: i32 = this.GetAreaNeighbourCount(nr1);
          let mut val1: i32 = 0;
          this.StrTempCorpsCounter = -1;
          let mut groupCounter1: i32 = this.GroupCounter;
          for (let mut index2: i32 = 0; index2 <= groupCounter1; index2 += 1)
          {
            if (this.CorpsTarget[index2] == nr1 & this.game.HandyFunctionsObj.IsAlliedOrSelf(this.AreaOwner[this.CorpsLoc[index2]], this.GetGameDataTurn()) & this.CorpsTempStrength[index2] > 0)
            {
              let mut num3: i32 = 0;
              let mut Number: i32 = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0 | Number > 99)
                Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0 | Number > 99)
                Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0 | Number > 98)
                Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
              if (Number == 0)
              {
                Number = Number;
                num3 = 1;
              }
              if (this.CorpsMove[index2] == 1)
              {
                if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.CorpsTarget[index2]].x, this.AreaCenter[this.CorpsTarget[index2]].y].Regime), this.GetGameDataTurn()))
                {
                  if (this.HisAreaDistanceFriendly.GetUpperBound(0) >= index2)
                  {
                    if (this.HisAreaDistanceFriendly[index2, this.CorpsTarget[index2]] < 9999)
                      Number =  Math.Round( this.HisAreaDistanceFriendly[index2, this.CorpsTarget[index2]] / 20.0);
                    else if (!this.AreaIsExtra[this.CorpsLoc[index2]])
                    {
                      Number = 99;
                    }
                    else
                    {
                      Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                      if (Number == 0 | Number > 99)
                        Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                      if (Number == 0 | Number > 99)
                        Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                      if (Number == 0 | Number > 98)
                        Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    }
                  }
                  else
                  {
                    Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 98)
                      Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  }
                }
                else if (this.HisAreaDistance.GetUpperBound(0) >= index2)
                {
                  if (this.HisAreaDistance[index2, this.CorpsTarget[index2]] < 9999)
                    Number =  Math.Round( this.HisAreaDistance[index2, this.CorpsTarget[index2]] / 20.0);
                  else if (!this.AreaIsExtra[this.CorpsLoc[index2]])
                  {
                    Number = 99;
                  }
                  else
                  {
                    Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 99)
                      Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                    if (Number == 0 | Number > 98)
                      Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  }
                }
                else
                {
                  Number = this.AreaNarrowBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  if (Number == 0 | Number > 99)
                    Number = this.AreaBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  if (Number == 0 | Number > 99)
                    Number = this.AreaWideBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                  if (Number == 0 | Number > 98)
                    Number = this.AreaBroadBorder[this.CorpsLoc[index2], this.CorpsTarget[index2]];
                }
              }
              if (index2 == 7)
                index2 = index2;
              if (round > 1 & this.CorpsStrategic[index2] & this.FriendlySupply[nr1] == 1)
              {
                if (makelog)
                  this.AddLog(this.GroupName[index2] + " HAS STRATEGIC SPEED");
                Number = 1;
              }
              else
              {
                let mut num4: i32 = this.CorpsStrategic[index2] & this.FriendlySupply[nr1] == 0 ? 1 : 0;
              }
              if (makelog)
                this.AddLog(this.GroupName[index2] + ". FROM: " + this.GetAreaName(this.CorpsLoc[index2]) + ". TOO: " + this.GetAreaName(nr1) + ". Move progress is " + Conversion.Str( this.CorpsMoveProgress[index2]) + " of " + Conversion.Str( Number));
              if ( this.CorpsMoveProgress[index2] >=  Number * 0.66 | Number - this.CorpsMoveProgress[index2] < 5 && this.FriendlySupply[this.CorpsLoc[index2]] > 0)
              {
                if (num3 == 1)
                  ;
                let mut num5: i32 = this.CorpsTempStrength[index2];
                val1 +=  Math.Round( this.CorpsAirEffect[index2] / 100.0 *  this.CorpsTempAirStrength[index2]);
                if (this.CorpsStance[index2] == 1)
                  num5 =  Math.Round( num5 * 0.5);
                if (this.CorpsStance[index2] == 2)
                  num5 =  Math.Round( num5 * 0.5);
                if (this.CorpsBottleneck[index2] > 0 & this.CorpsOldDefend[index2] == this.CorpsLoc[index2] & round < 4)
                {
                  num5 =  Math.Round( num5 * ( this.CorpsBottleneck[index2] / 100.0));
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK .. PERCENTAGE LEFT = " + this.CorpsBottleneck[index2].ToString());
                }
                this += 1.StrTempCorpsCounter;
                this.StrTempCorps = (int[]) Utils.CopyArray((Array) this.StrTempCorps, (Array) new int[this.StrTempCorpsCounter + 1]);
                this.StrTempCorpsMod = (float[]) Utils.CopyArray((Array) this.StrTempCorpsMod, (Array) new float[this.StrTempCorpsCounter + 1]);
                if ( this.CorpsMoveProgress[index2] >=  Number * 1.33)
                {
                  num5 *= 1;
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 1f;
                }
                else if (this.CorpsMoveProgress[index2] >= Number * 1)
                {
                  num5 =  Math.Round( num5 * 0.75);
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 0.75f;
                }
                else if ( this.CorpsMoveProgress[index2] >=  Number * 0.82)
                {
                  num5 =  Math.Round( num5 * 0.5);
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 0.5f;
                }
                else if ( this.CorpsMoveProgress[index2] >=  Number * 0.66 | Number - this.CorpsMoveProgress[index2] < 5)
                {
                  num5 =  Math.Round( num5 * 0.25);
                  this.StrTempCorpsMod[this.StrTempCorpsCounter] = 0.25f;
                }
                num2 += num5;
                this.StrTempCorps[this.StrTempCorpsCounter] = index2;
                let mut num6: i32 = 0;
                let mut num7: i32 = index1;
                for (let mut index3: i32 = 1; index3 <= num7; index3 += 1)
                {
                  if (this.StrCurSides[index3] == this.CorpsLoc[index2])
                    num6 = 1;
                }
                if (num6 == 0)
                {
                  index1 += 1;
                  this.StrCurSides[index1] = this.CorpsLoc[index2];
                }
              }
            }
          }
          num8: i32;
          if (num2 > 0)
          {
            if (this.GetRegime(this.AreaOwner[nr1]) == this.GetGameDataTurn())
            {
              let mut num9: i32 = this.AreaOwner[nr1];
            }
            else
            {
              if (makelog)
                this.AddLog("GOT " + Conversion.Str( num2) + " : " + Conversion.Str( this.AreaEnemy[nr1]) + " ON " + this.GetAreaName(nr1));
              if (makelog)
                this.AddLog("Enemy strength before battle: " + Conversion.Str( this.AreaEnemy[nr1]));
              let mut num10: i32 = num2;
              if (areaNeighbourCount > 4 & index1 > 4)
                num2 =  Math.Round( num2 * (1.0 + 1.0 * ( index1 /  areaNeighbourCount)));
              else if (areaNeighbourCount > 3 & index1 > 3)
                num2 =  Math.Round( num2 * (1.0 + 0.75 * ( index1 /  areaNeighbourCount)));
              else if (areaNeighbourCount > 2 & index1 > 2)
                num2 =  Math.Round( num2 * (1.0 + 0.5 * ( index1 /  areaNeighbourCount)));
              else if (areaNeighbourCount > 1 & index1 > 1)
                num2 =  Math.Round( num2 * (1.0 + 0.25 * ( index1 /  areaNeighbourCount)));
              let mut Number1: i32 = this.AreaEnemy[nr1];
              float num11 = this.AreaEnemy[nr1] != 0 ?  num2 /  Number1 : 10f;
              let mut tempCorpsCounter1: i32 = this.StrTempCorpsCounter;
              for (let mut index4: i32 = 0; index4 <= tempCorpsCounter1; index4 += 1)
              {
                if ( num11 >  this.CorpsTopRatio[this.StrTempCorps[index4]] & (round <= 1 & this.Attacker | round <= 2 & !this.Attacker))
                  this.CorpsTopRatio[this.StrTempCorps[index4]] = num11;
              }
              if (this.AreaDefensive[nr1] > 0)
              {
                Number1 =  Math.Round( Number1 * ( (100 + this.AreaDefensive[nr1]) / 100.0));
                if (makelog)
                  this.AddLog("Enemy after AreaDefensive = " + Conversion.Str( Number1));
              }
              if (this.StrAreaEntrench[nr1] > 0)
              {
                Number1 =  Math.Round( Number1 / 2.0) +  Math.Round( (Number1 + Number1 *  Math.Round( this.StrAreaEntrench[nr1] / 100.0)) / 2.0);
                if (makelog)
                  this.AddLog("Enemy after Entrench = " + Conversion.Str( Number1));
              }
              if (this.EnemySupply[nr1] < 1)
              {
                Number1 =  Math.Round( Number1 * 0.2);
                if (makelog)
                  this.AddLog("Enemy after No-supply = " + Conversion.Str( Number1));
              }
              num8 = 0;
              float num12 = this.AreaEnemy[nr1] != 0 ?  num2 /  Number1 : 10f;
              if ( num12 > 10.0)
                num12 = 10f;
              if (val1 > 0 & round <= 2)
              {
                num12 +=  (val1 * 2) /  Math.Max(val1, num2);
                if (makelog)
                  this.AddLog("Ratio after Air = " + Conversion.Str( num12));
              }
              Number2: i32;
              Number3: i32;
              if ( num12 > 1.0)
              {
                float Number4 =  (6.0 / Math.Sqrt( Math.Min(9f, num12)));
                if (makelog)
                  this.AddLog("TSng For defender casualties = " + Conversion.Str( Number4));
                if (this.StrAreaEntrench[nr1] > 150)
                {
                  Number4 *= 1.66f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after entrench= " + Conversion.Str( Number4));
                }
                else if (this.StrAreaEntrench[nr1] > 100)
                {
                  Number4 *= 1.44f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after entrench= " + Conversion.Str( Number4));
                }
                else if (this.StrAreaEntrench[nr1] > 50)
                {
                  Number4 *= 1.22f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after entrench= " + Conversion.Str( Number4));
                }
                if (this.AreaDefensive[nr1] > 150)
                {
                  Number4 *= 1.66f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after areadef= " + Conversion.Str( Number4));
                }
                else if (this.AreaDefensive[nr1] > 100)
                {
                  Number4 *= 1.44f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after areadef= " + Conversion.Str( Number4));
                }
                else if (this.AreaDefensive[nr1] > 50)
                {
                  Number4 *= 1.22f;
                  if (makelog)
                    this.AddLog("TSng For defender casualties after areadef= " + Conversion.Str( Number4));
                }
                if ( this.game.Data.RuleVar[394] > 0.0)
                {
                  Number4 *= this.game.Data.RuleVar[394];
                  if (makelog)
                    this.AddLog("TSng For defender casualties after rulevar394= " + Conversion.Str( Number4));
                }
                float Number5 = Number4 * 0.66f;
                if (makelog)
                  this.AddLog("TSng For defender casualties after *0.66 = " + Conversion.Str( Number5));
                Number2 =  Math.Round( ( num10 / Number5));
                float num13 =  (6.0 / Math.Sqrt( Math.Min(9f, num12)));
                if (this.StrAreaEntrench[nr1] > 150)
                  num13 *= 1.66f;
                else if (this.StrAreaEntrench[nr1] > 100)
                  num13 *= 1.44f;
                else if (this.StrAreaEntrench[nr1] > 50)
                  num13 *= 1.22f;
                if (this.AreaDefensive[nr1] > 150)
                  num13 *= 1.66f;
                else if (this.AreaDefensive[nr1] > 100)
                  num13 *= 1.44f;
                else if (this.AreaDefensive[nr1] > 50)
                  num13 *= 1.22f;
                if ( this.game.Data.RuleVar[394] > 0.0)
                  num13 *= this.game.Data.RuleVar[394];
                float Number6 = num13 * 0.66f;
                if (makelog)
                  this.AddLog("TSng For defender casualties after *0.66 = " + Conversion.Str( Number6));
                Number3 =  Math.Round( ( num10 / Number6));
              }
              else
              {
                Number2 = 0;
                Number3 = 0;
              }
              if (Number2 > this.AreaEnemy[nr1])
              {
                Number3 =  Math.Round( ( Number3 * ( this.AreaEnemy[nr1] /  Number2)));
                Number2 = this.AreaEnemy[nr1];
              }
              int[] areaEnemy = this.AreaEnemy;
              int[] numArray1 = areaEnemy;
              let mut index5: i32 = nr1;
              let mut index6: i32 = index5;
              let mut num14: i32 = areaEnemy[index5] - Number2;
              numArray1[index6] = num14;
              if (Number3 > num10)
                Number3 = num10;
              if (makelog)
                this.AddLog("ratio: " + Conversion.Str( num12) + " totdam = " + Conversion.Str( Number3) + ", totdam2 = " + Conversion.Str( Number2));
              if (makelog)
                this.AddLog("Enemy strength after: " + Conversion.Str( this.AreaEnemy[nr1]));
              if (makelog)
                this.AddLog("Friendly strength after: " + Conversion.Str( (num10 - Number3)));
              let mut tempCorpsCounter2: i32 = this.StrTempCorpsCounter;
              for (let mut index7: i32 = 0; index7 <= tempCorpsCounter2; index7 += 1)
              {
                let mut index8: i32 = this.StrTempCorps[index7];
                if (makelog)
                  this.AddLog(this.GroupName[index8] + " LOSES " + Conversion.Str(  Math.Round( ( Number3 * ( this.CorpsTempStrength[index8] * this.StrTempCorpsMod[index7] /  num2)))));
                let mut num15: i32 = 0;
                if (num2 > 0)
                  num15 =  Math.Round( ( Number3 * ( this.CorpsTempStrength[index8] * this.StrTempCorpsMod[index7] /  num2)));
                if (num15 > this.CorpsTempStrength[index8])
                  num15 = this.CorpsTempStrength[index8];
                if (num2 > 0)
                {
                  int[] corpsTempStrength = this.CorpsTempStrength;
                  int[] numArray2 = corpsTempStrength;
                  let mut index9: i32 = index8;
                  let mut index10: i32 = index9;
                  let mut num16: i32 = corpsTempStrength[index9] -  Math.Round( ( Number3 * ( this.CorpsTempStrength[index8] * this.StrTempCorpsMod[index7] /  num2)));
                  numArray2[index10] = num16;
                }
                if (num2 > 0)
                {
                  int[] corpsPowerLeft = this.CorpsPowerLeft;
                  int[] numArray3 = corpsPowerLeft;
                  let mut index11: i32 = index8;
                  let mut index12: i32 = index11;
                  let mut num17: i32 = corpsPowerLeft[index11] + num15;
                  numArray3[index12] = num17;
                }
                if (this.CorpsFirstAreaBattle[index8] == 0)
                  this.CorpsFirstAreaBattle[index8] = nr1;
                if (0 > this.CorpsTempStrength[index8])
                  this.CorpsTempStrength[index8] = 0;
              }
              if (0 >= this.AreaEnemy[nr1])
                this.AreaEnemy[nr1] = 0;
            }
            let mut groupCounter2: i32 = this.GroupCounter;
            for (let mut tid: i32 = 0; tid <= groupCounter2; tid += 1)
            {
              if (this.CorpsTarget[tid] == nr1 & this.AreaEnemy[nr1] <= 0)
              {
                let mut num18: i32 = this.AreaNarrowBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0 | num18 > 99)
                  num18 = this.AreaBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0 | num18 > 99)
                  num18 = this.AreaWideBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0 | num18 > 98)
                  num18 = this.AreaBroadBorder[this.CorpsLoc[tid], nr1];
                if (num18 == 0)
                  num18 = num18;
                if (this.CorpsMove[tid] == 1)
                {
                  if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr1].x, this.AreaCenter[nr1].y].Regime), this.GetGameDataTurn()))
                  {
                    if (this.HisAreaDistanceFriendly.GetUpperBound(0) >= tid)
                    {
                      if (this.HisAreaDistanceFriendly[tid, nr1] < 9999)
                        num18 =  Math.Round( this.HisAreaDistanceFriendly[tid, nr1] / 20.0);
                      else if (!this.AreaIsExtra[this.CorpsLoc[tid]])
                      {
                        num18 = 99;
                      }
                      else
                      {
                        num18 = this.AreaNarrowBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                        if (num18 == 0 | num18 > 99)
                          num18 = this.AreaBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                        if (num18 == 0 | num18 > 99)
                          num18 = this.AreaWideBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                        if (num18 == 0 | num18 > 98)
                          num18 = this.AreaBroadBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      }
                    }
                    else
                    {
                      num18 = this.AreaBorder[this.CorpsLoc[tid], nr1];
                      if (num18 == 0)
                        num18 = this.AreaWideBorder[this.CorpsLoc[tid], nr1];
                      if (num18 == 0 | num18 > 98)
                        num18 = this.AreaBroadBorder[this.CorpsLoc[tid], nr1];
                    }
                  }
                  else if (this.HisAreaDistance.GetUpperBound(0) >= tid)
                  {
                    if (this.HisAreaDistance[tid, nr1] < 9999)
                      num18 =  Math.Round( this.HisAreaDistance[tid, nr1] / 20.0);
                    else if (!this.AreaIsExtra[this.CorpsLoc[tid]])
                    {
                      num18 = 99;
                    }
                    else
                    {
                      num18 = this.AreaNarrowBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      if (num18 == 0 | num18 > 99)
                        num18 = this.AreaBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      if (num18 == 0 | num18 > 99)
                        num18 = this.AreaWideBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                      if (num18 == 0 | num18 > 98)
                        num18 = this.AreaBroadBorder[this.CorpsLoc[tid], this.CorpsTarget[tid]];
                    }
                  }
                  else
                  {
                    num18 = this.AreaBorder[this.CorpsLoc[tid], nr1];
                    if (num18 == 0)
                      num18 = this.AreaWideBorder[this.CorpsLoc[tid], nr1];
                    if (num18 == 0 | num18 > 98)
                      num18 = this.AreaBroadBorder[this.CorpsLoc[tid], nr1];
                  }
                }
                if (round > 1 & this.CorpsStrategic[tid] & this.FriendlySupply[nr1] == 1)
                {
                  if (makelog)
                    this.AddLog(this.GroupName[tid] + " HAS STRATEGIC SPEED");
                  num18 = 1;
                }
                else
                {
                  let mut num19: i32 = this.CorpsStrategic[tid] & this.FriendlySupply[nr1] == 0 ? 1 : 0;
                }
                if (this.CorpsMoveProgress[tid] >= num18)
                {
                  this.CorpsLoc[tid] = nr1;
                  int[] corpsMoveProgress = this.CorpsMoveProgress;
                  int[] numArray4 = corpsMoveProgress;
                  let mut index13: i32 = tid;
                  let mut index14: i32 = index13;
                  let mut num20: i32 = corpsMoveProgress[index13] - num18;
                  numArray4[index14] = num20;
                  let mut nr2: i32 = this.AreaOwner[nr1];
                  if (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.AreaOwner[nr1]), this.GetGameDataTurn()))
                  {
                    this.AreaOwner[nr1] = this.GetRegime(this.game.Data.Turn);
                    if (makelog)
                      this.AddLog("CONQUERED AREA!!");
                  }
                  if (this.GetRegime(nr2) != this.GetGameDataTurn())
                  {
                    int[] corpsMove = this.CorpsMove;
                    int[] numArray5 = corpsMove;
                    let mut index15: i32 = tid;
                    let mut index16: i32 = index15;
                    let mut num21: i32 = corpsMove[index15] + 1;
                    numArray5[index16] = num21;
                    if (this.CorpsMoveProgress[tid] > 4)
                      this.CorpsMoveProgress[tid] = 4;
                  }
                  else
                  {
                    index17: i32;
                    do
                    {
                      index17 = -1;
                      int[] corpsMove = this.CorpsMove;
                      int[] numArray6 = corpsMove;
                      let mut index18: i32 = tid;
                      let mut index19: i32 = index18;
                      let mut num22: i32 = corpsMove[index18] + 1;
                      numArray6[index19] = num22;
                      let mut nr3: i32 = straty.FindNr(tid);
                      if (this.CorpsMove[tid] == 1)
                        index17 = straty.Data1[nr3];
                      if (this.CorpsMove[tid] == 2)
                        index17 = straty.Data2[nr3];
                      if (this.CorpsMove[tid] == 3)
                        index17 = straty.Data3[nr3];
                      if (this.CorpsMove[tid] == 4)
                        index17 = straty.Data4[nr3];
                      if (this.CorpsMove[tid] == 5)
                        index17 = straty.Data5[nr3];
                      if (index17 > 0 & index17 != this.CorpsLoc[tid])
                      {
                        if (this.GetRegime(this.AreaOwner[index17]) == this.GetGameDataTurn())
                        {
                          let mut num23: i32 = this.AreaBorder[this.CorpsLoc[tid], index17];
                          if (num23 == 0)
                            num23 = this.AreaWideBorder[this.CorpsLoc[tid], index17];
                          if (num23 == 0)
                            num23 = this.AreaBroadBorder[this.CorpsLoc[tid], index17];
                          if (round > 1 & this.CorpsStrategic[tid] & this.FriendlySupply[index17] == 1)
                          {
                            num23 = 0;
                          }
                          else
                          {
                            let mut num24: i32 = this.CorpsStrategic[tid] & this.FriendlySupply[index17] == 0 ? 1 : 0;
                          }
                          if (this.CorpsMoveProgress[tid] >= num23)
                          {
                            this.CorpsLoc[tid] = index17;
                            this.CorpsMoveProgress[tid] = 0;
                            if (0 > this.CorpsMoveProgress[tid])
                              this.CorpsMoveProgress[tid] = 0;
                          }
                          else
                            index17 = -1;
                        }
                        else
                          index17 = -1;
                      }
                      else
                      {
                        index17 = -1;
                        this.CorpsMoveProgress[tid] = 0;
                      }
                    }
                    while (index17 > 0);
                  }
                }
              }
            }
          }
          if ((round < 5 | this.Meeting | !this.Attacker |  this.game.Data.RuleVar[386] == 1.0 | round == 1 | round % 2 == 0) & this.GetGameDataTurn() == this.GetRegime(this.AreaOwner[nr1]))
          {
            let mut Number7: i32 = 0;
            let mut Number8: i32 = 0;
            let mut Number9: i32 = 0;
            let mut Number10: i32 = 0;
            let mut num25: i32 = 0;
            let mut index20: i32 = 0;
            let mut num26: i32 = 9999;
            let mut areaCount2: i32 = this.AreaCount;
            for (let mut nr4: i32 = 1; nr4 <= areaCount2; nr4 += 1)
            {
              if (this.AreaGroup[nr4] == this.CurrentAreaGroup && nr4 != nr1 & this.AreaNarrowBorder[nr1, nr4] > 0 && this.GetRegime(this.AreaOwner[nr4]) != this.GetGameDataTurn() & this.EnemySupplyGone[nr4] < 2 && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[nr4])) && this.AreaEnemy[nr4] > 0)
              {
                strCounterAttack: Vec<i32> = this.StrCounterAttack;
                numArray: Vec<i32> = strCounterAttack;
                let mut index21: i32 = nr4;
                let mut index22: i32 = index21;
                let mut index23: i32 = nr1;
                let mut index24: i32 = index23;
                let mut num27: i32 = strCounterAttack[index21, index23] + 4;
                numArray[index22, index24] = num27;
                if (this.GetAreaEnemyNeighbourCountFuzzyVP(nr4) > 0)
                {
                  index20 += 1;
                  if (!(this.AreaCounterStep[nr1] > 0 & this.AreaCounterDirections[nr1, 1] == 0))
                  {
                    if (index20 < 9)
                      this.AreaCounterDirections[nr1, index20] = nr4;
                    if (index20 < 9)
                      this.AreaCounterRegime[nr1, index20] = this.AreaOwner[nr4];
                  }
                  if (this.AreaNarrowBorder[nr1, nr4] > 0 & this.AreaBorderNoBridge[nr1, nr4] < 1)
                  {
                    if ( this.StrCounterAttack[nr4, nr1] -  this.game.Data.RuleVar[831] >=  (10 + this.AreaBorder[nr1, nr4]))
                      Number7 +=  Math.Round( (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) /  this.GetAreaEnemyNeighbourCountFuzzyVP(nr4));
                    else if ( this.StrCounterAttack[nr4, nr1] -  this.game.Data.RuleVar[831] >=  (0 + this.AreaBorder[nr1, nr4]))
                      Number7 +=  Math.Round(0.2 *   Math.Round( (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) /  this.GetAreaEnemyNeighbourCountFuzzyVP(nr4)));
                    else if ( this.game.Data.RuleVar[826] == 0.0 &  this.StrCounterAttack[nr4, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr4] / 2.0)
                      Number7 +=  Math.Round(0.1 *   Math.Round( (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) /  this.GetAreaEnemyNeighbourCountFuzzyVP(nr4)));
                    else
                      Number7 = 0;
                  }
                  else if ( this.StrCounterAttack[nr4, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr4])
                    Number7 +=  Math.Round( (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) /  this.GetAreaEnemyNeighbourCountFuzzyVP(nr4));
                  else if ( this.game.Data.RuleVar[826] == 0.0 & !this.Attacker &  this.StrCounterAttack[nr4, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr4] / 2.0)
                    Number7 +=  Math.Round(0.1 *   Math.Round( (this.AreaEnemy[nr4] * this.AreaFuzzyVP[nr1]) /  this.GetAreaEnemyNeighbourCountFuzzyVP(nr4)));
                }
              }
            }
            if (!this.Attacker)
              Number7 =  Math.Round( Number7 * 1.4);
            if (this.StrAreaNegPow[nr1] != 0)
            {
              Number7 += Math.Abs(this.StrAreaNegPow[nr1]);
              if (index20 == 0)
                index20 = 1;
            }
            if (Number7 > this.AreaCounterPower[nr1] & round + 1 > this.AreaCounterStep[nr1])
            {
              this.AreaCounterPower[nr1] = Number7;
              if (this.AreaCounterStep[nr1] == 0)
                this.AreaCounterStep[nr1] = round;
            }
            let mut groupCounter3: i32 = this.GroupCounter;
            num28: i32;
            for (let mut index25: i32 = 0; index25 <= groupCounter3; index25 += 1)
            {
              if (this.CorpsLoc[index25] == nr1)
              {
                let mut num29: i32 = this.CorpsTempStrength[index25];
                if (this.CorpsLoc[index25] > -1 & this.CorpsTarget[index25] > -1 && this.CorpsTarget[index25] != this.CorpsLoc[index25] & this.GetRegime(this.AreaOwner[this.CorpsTarget[index25]]) == this.GetGameDataTurn())
                {
                  if (this.GroupType[index25] == 5 & Number7 > 0)
                    num29 = num29;
                  let mut num30: i32 = 0;
                  let mut areaCount3: i32 = this.AreaCount;
                  for (let mut index26: i32 = 1; index26 <= areaCount3; index26 += 1)
                  {
                    if (this.AreaNarrowBorder[index26, this.CorpsTarget[index25]] > 0 && this.GetRegime(this.AreaOwner[index26]) != this.GetGameDataTurn())
                      num30 += 1;
                  }
                  if (this.CorpsStance[index25] != 2)
                  {
                    if (makelog)
                      this.AddLog("NO POWER FOR GROUP MOVING THROUGH AREA..: " + this.GroupName[index25]);
                    num29 = 0;
                  }
                  else if (this.CorpsMove[index25] == 1 & num30 == 0)
                  {
                    if (makelog)
                      this.AddLog("3 * POWER FOR RETREAT MODE DEFENDER IF TARGET OF RETREAT IS NOT BORDERING ENEMY..: " + this.GroupName[index25]);
                    num29 *= 4;
                  }
                  else if (this.CorpsMove[index25] == 1)
                  {
                    if (makelog)
                      this.AddLog("3 * POWER FOR RETREAT MODE DEFENDER IF TARGET OF RETREAT IS NOT BORDERING ENEMY..: " + this.GroupName[index25]);
                    num29 *= 2;
                  }
                  else if (this.CorpsMove[index25] <= 2)
                  {
                    if (makelog)
                      this.AddLog("SECOND RETREAT OR RETREAT TO COMBATED AREA IS JUST NORMAL SCORE.: " + this.GroupName[index25]);
                    num29 *= 1;
                  }
                  else
                  {
                    if (makelog)
                      this.AddLog("OTHER.: " + this.GroupName[index25]);
                    num29 *= 1;
                  }
                }
                num28 = 0;
                Number9 += num29;
                if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] && this.CorpsBottleneck[index25] < num26)
                  num26 = this.CorpsBottleneck[index25];
                if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] & round >= 3)
                {
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK FOR OUR DEFENDERS.." + this.CorpsBottleneck[index25].ToString());
                  num28 = 1;
                }
                else if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] & round >= 2)
                {
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK FOR OUR DEFENDERS.." + this.CorpsBottleneck[index25].ToString());
                  num28 = 1;
                }
                else if (this.CorpsBottleneck[index25] > 0 & this.CorpsOldDefend[index25] == this.CorpsLoc[index25] & round >= 1)
                {
                  if (makelog)
                    this.AddLog("CORPS BOTTLENECK FOR OUR DEFENDERS.." + this.CorpsBottleneck[index25].ToString());
                  num28 = 1;
                }
                else
                  num29 =  Math.Round( ( num29 * ( (100 + this.CorpsEntrench[index25]) / 100f)));
                if (this.CorpsStance[index25] == 3)
                  num29 =  Math.Round( num29 * 0.66);
                if (this.FriendlySupply[nr1] < 1)
                  num29 =  Math.Round( num29 * 0.2);
                Number8 += num29;
              }
              else if (this.AreaBorder[nr1, this.CorpsLoc[index25]] <= 0)
                ;
            }
            if (this.AreaDefensive[nr1] > 0)
              Number8 =  Math.Round( Number8 * ( (100 + this.AreaDefensive[nr1]) / 100.0));
            if (Number7 > 0 & makelog)
              this.AddLog("ENEMY POWER on " + this.GetAreaName(nr1) + ". powon= " + Conversion.Str( Number7) + ", powdef=" + Conversion.Str( Number8) + " (core=" + Conversion.Str( Number9) + ", neighbours=" + Conversion.Str( Number10));
            float num31 = !(Number8 == 0 & Number7 > 0) ? (!(Number7 > 0 & Number8 > 0) ? 0.0f :  Number7 /  Number8) : 10f;
            num8 = 0;
            if ( num31 > 9.0)
              num31 = 9f;
            if ( num31 > 5.0 &  num31 < 8.0)
              num31 = num31;
            Number11: i32;
            Number12: i32;
            if ( num31 > 1.0)
            {
              if (this.Attacker)
              {
                float num32 =  (6.0 / Math.Sqrt( Math.Min(9f, num31)));
                if ( this.game.Data.RuleVar[395] > 0.0)
                  num32 *= this.game.Data.RuleVar[395];
                Number11 =  Math.Round( ( Number7 / num32));
                float num33 =  (6.0 / Math.Sqrt( Math.Min(2f, num31)));
                if ( this.game.Data.RuleVar[395] > 0.0)
                  num33 *= this.game.Data.RuleVar[395];
                Number12 =  Math.Round( ( Number7 / num33));
              }
              else
              {
                float num34 =  (13.0 / Math.Sqrt(Math.Pow( Math.Min(9f, num31), 1.8)));
                if ( this.game.Data.RuleVar[395] > 0.0)
                  num34 *= this.game.Data.RuleVar[395];
                Number11 =  Math.Round( ( Number7 / num34));
                float num35 =  (13.0 / Math.Sqrt(Math.Pow( Math.Min(2f, num31), 1.8)));
                if ( this.game.Data.RuleVar[395] > 0.0)
                  num35 *= this.game.Data.RuleVar[395];
                Number12 =  Math.Round( ( Number7 / num35));
              }
            }
            else if ( num31 > 0.5 | this.StrAreaNegPow[nr1] > 0)
            {
              float num36 = 6f;
              if ( this.game.Data.RuleVar[395] > 0.0)
                num36 *= this.game.Data.RuleVar[395];
              Number11 =  Math.Round( ( Number7 / num36));
              float num37 = 6f * num31;
              if ( this.game.Data.RuleVar[395] > 0.0)
                num37 *= this.game.Data.RuleVar[395];
              Number12 =  Math.Round( ( Number7 / num37));
            }
            else
            {
              Number11 = 0;
              Number12 = 0;
            }
            if ( this.game.Data.RuleVar[829] > 0.0)
            {
              Number11 =  Math.Round( ( Number11 / this.game.Data.RuleVar[829]));
              Number12 =  Math.Round( ( Number12 / this.game.Data.RuleVar[829]));
            }
            if (num26 > 0 & num26 < 100)
              Number12 =  Math.Round( Number12 * ( num26 / 100.0));
            if (Number8 == 0)
              Number12 = 0;
            if (Number11 > 0 & makelog)
              this.AddLog("COUNTERATTACK on " + this.GetAreaName(nr1) + ". powon= " + Conversion.Str( Number7) + ", powdef=" + Conversion.Str( Number8) + " (core=" + Conversion.Str( Number9) + ", neighbours=" + Conversion.Str( Number10) + ". CAUSES " + Conversion.Str( Number11) + " dammage on defender.  And " + Conversion.Str( Number12) + " dammage on attacker. (ratio is " + Conversion.Str( num31) + ")");
            if (nr1 == 31 & this.AreaGroupCount == 1 & Number7 > 0 & Number8 == 0)
              nr1 = nr1;
            if (Number11 > 0)
            {
              let mut num38: i32 = 0;
              let mut num39: i32 = -1;
              let mut num40: i32 = 0;
              num25 = 0;
              let mut num41: i32 = 0;
              let mut num42: i32 = Number7;
              let mut num43: i32 = 0;
              let mut groupCounter4: i32 = this.GroupCounter;
              for (let mut index27: i32 = 0; index27 <= groupCounter4; index27 += 1)
              {
                if (this.CorpsLoc[index27] == nr1 & Number9 > 0)
                {
                  let mut num44: i32 = 1;
                  if (this.CorpsLoc[index27] > -1 & this.CorpsTarget[index27] > -1 && this.CorpsTarget[index27] != this.CorpsLoc[index27] & this.GetRegime(this.AreaOwner[this.CorpsTarget[index27]]) == this.GetGameDataTurn())
                    num44 = 0;
                  if (num44 == 1)
                  {
                    let mut num45: i32 =  Math.Round( Number11 * ( this.CorpsTempStrength[index27] /  (Number9 + Number10)));
                    num41 += num45;
                    let mut num46: i32 = num45;
                    if (num46 > this.CorpsTempStrength[index27])
                      num46 = this.CorpsTempStrength[index27];
                    int[] corpsTempStrength = this.CorpsTempStrength;
                    int[] numArray7 = corpsTempStrength;
                    let mut index28: i32 = index27;
                    let mut index29: i32 = index28;
                    let mut num47: i32 = corpsTempStrength[index28] - num45;
                    numArray7[index29] = num47;
                    int[] corpsPowerLeft = this.CorpsPowerLeft;
                    int[] numArray8 = corpsPowerLeft;
                    let mut index30: i32 = index27;
                    let mut index31: i32 = index30;
                    let mut num48: i32 = corpsPowerLeft[index30] + num46;
                    numArray8[index31] = num48;
                    if (this.CorpsFirstAreaBattle[index27] == 0)
                      this.CorpsFirstAreaBattle[index27] = nr1;
                    if (this.CorpsTempStrength[index27] < 0)
                      num41 += this.CorpsTempStrength[index27];
                    if (0 > this.CorpsTempStrength[index27])
                      this.CorpsTempStrength[index27] = 0;
                    num38 += this.CorpsTempStrength[index27];
                  }
                }
                else
                {
                  let mut num49: i32 = this.AreaBorder[nr1, this.CorpsLoc[index27]] > 0 & Number9 + Number10 > 0 ? 1 : 0;
                }
              }
              if (Number12 > 0 & index20 == 1)
                Number12 = Number12;
              let mut num50: i32 = 0;
              let mut areaCount4: i32 = this.AreaCount;
              for (let mut nr5: i32 = 1; nr5 <= areaCount4; nr5 += 1)
              {
                if (nr5 != nr1 & this.AreaBorder[nr1, nr5] > 0 & num42 > 0 && this.GetRegime(this.AreaOwner[nr5]) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[nr5])))
                {
                  if (this.AreaOwner[nr5] > -1)
                    num39 = this.AreaOwner[nr5];
                  let mut Number13: i32 = 0;
                  if (this.AreaNarrowBorder[nr1, nr5] > 0 & this.AreaBorderNoBridge[nr1, nr5] < 1)
                  {
                    if ( this.StrCounterAttack[nr5, nr1] -  this.game.Data.RuleVar[831] >=  (this.AreaBorder[nr1, nr5] + 10))
                      Number13 =  Math.Round( Number12 * ( (this.AreaEnemy[nr5] * this.AreaFuzzyVP[nr1]) /  Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) /  num42));
                    else if ( this.StrCounterAttack[nr5, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr5])
                      Number13 =  Math.Round( Number12 * ( this.AreaEnemy[nr5] * 0.2 *  this.AreaFuzzyVP[nr1] /  Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) /  num42));
                    else if ( this.game.Data.RuleVar[826] == 0.0 &  this.StrCounterAttack[nr5, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr5] / 2.0)
                      Number13 =  Math.Round( Number12 * ( this.AreaEnemy[nr5] * 0.1 *  this.AreaFuzzyVP[nr1] /  Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) /  num42));
                  }
                  else if ( this.StrCounterAttack[nr5, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr5])
                    Number13 =  Math.Round( Number12 * ( (this.AreaEnemy[nr5] * this.AreaFuzzyVP[nr1]) /  Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) /  num42));
                  else if ( this.game.Data.RuleVar[826] == 0.0 &  this.StrCounterAttack[nr5, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr5] / 2.0)
                    Number13 =  Math.Round( Number12 * ( this.AreaEnemy[nr5] * 0.1 *  this.AreaFuzzyVP[nr1] /  Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)) /  num42));
                  if ( this.StrCounterAttack[nr5, nr1] -  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr5] / 2.0 |  this.StrCounterAttack[nr5, nr1] +  this.game.Data.RuleVar[831] >=  this.AreaBorder[nr1, nr5])
                  {
                    int[] areaEnemy = this.AreaEnemy;
                    int[] numArray = areaEnemy;
                    let mut index32: i32 = nr5;
                    let mut index33: i32 = index32;
                    let mut num51: i32 = areaEnemy[index32] - Number13;
                    numArray[index33] = num51;
                    if (makelog)
                      this.AddLog(this.GetAreaName(nr5) + " LOSES " + Conversion.Str( Number13));
                    if (this.AreaEnemy[nr5] < 0)
                      this.AreaEnemy[nr5] = 0;
                    num43 +=  Math.Round( (this.AreaEnemy[nr5] * this.AreaFuzzyVP[nr1]) /  Math.Max(1, this.GetAreaEnemyNeighbourCountFuzzyVP(nr5)));
                    num50 += 1;
                  }
                }
              }
              if (num39 == -1)
              {
                let mut regimeCounter: i32 = this.game.Data.RegimeCounter;
                for (let mut reg1: i32 = 0; reg1 <= regimeCounter; reg1 += 1)
                {
                  if (!this.game.Data.RegimeObj[reg1].Sleep && !this.game.HandyFunctionsObj.IsAlliedOrSelf(reg1, this.GetGameDataTurn()))
                  {
                    num39 = reg1;
                    num40 = num42;
                    num43 = num42;
                    if (num40 > 0)
                      num50 = 1;
                  }
                }
              }
              if (num38 == 0 & num39 > -1 & num43 > 0 & num50 > 0)
              {
                if (makelog)
                  this.AddLog("COUNTERATTACK ON " + this.GetAreaName(nr1) + " SUCCEEDS!!! ENEMY TROOPS MOVE IN. " + Conversion.Str( ( num43 /  num50)) + " points move in.");
                let mut groupCounter5: i32 = this.GroupCounter;
                for (let mut tid: i32 = 0; tid <= groupCounter5; tid += 1)
                {
                  if (this.CorpsLoc[tid] == nr1 & Number9 > 0)
                  {
                    let mut num52: i32 = 1;
                    if (this.CorpsLoc[tid] > -1 & this.CorpsTarget[tid] > -1 && this.CorpsTarget[tid] != this.CorpsLoc[tid] & this.GetRegime(this.AreaOwner[this.CorpsTarget[tid]]) == this.GetGameDataTurn())
                      num52 = 0;
                    if (num52 == 0)
                    {
                      if (tid == 7)
                        tid = tid;
                      let mut nr6: i32 = straty.FindNr(tid);
                      this.CorpsLoc[tid] = this.CorpsTarget[tid];
                      int[] corpsMove = this.CorpsMove;
                      int[] numArray = corpsMove;
                      let mut index34: i32 = tid;
                      let mut index35: i32 = index34;
                      let mut num53: i32 = corpsMove[index34] + 1;
                      numArray[index35] = num53;
                      if (this.CorpsMove[tid] == 1)
                        num28 = straty.Data1[nr6];
                      if (this.CorpsMove[tid] == 2)
                        num28 = straty.Data2[nr6];
                      if (this.CorpsMove[tid] == 3)
                        num28 = straty.Data3[nr6];
                      if (this.CorpsMove[tid] == 4)
                        num28 = straty.Data4[nr6];
                      if (this.CorpsMove[tid] == 5)
                        num28 = straty.Data5[nr6];
                      this.CorpsTarget[tid] = num28;
                      this.CorpsMoveProgress[tid] = 0;
                      if (makelog)
                        this.AddLog("MOVED FRIENDLY " + this.GroupName[tid] + " TO " + this.GetAreaName(this.CorpsLoc[tid]) + ", NEW TARGET: " + this.GetAreaName(this.CorpsTarget[tid]));
                    }
                  }
                }
                let mut areaCount5: i32 = this.AreaCount;
                for (let mut nr7: i32 = 1; nr7 <= areaCount5; nr7 += 1)
                {
                  if (nr7 != nr1 & this.AreaBorder[nr1, nr7] > 0 && this.GetRegime(this.AreaOwner[nr7]) != this.GetGameDataTurn() && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[nr7])))
                  {
                    let mut Number14: i32 =  Math.Round( num43 / 2.0 /  num50 * (  Math.Round( (this.AreaEnemy[nr7] * this.AreaFuzzyVP[nr1]) /  Math.Max(this.GetAreaEnemyNeighbourCountFuzzyVP(nr7), 1)) /  num43));
                    if (Number14 > this.AreaEnemy[nr7])
                      Number14 = this.AreaEnemy[nr7];
                    int[] areaEnemy = this.AreaEnemy;
                    int[] numArray = areaEnemy;
                    let mut index36: i32 = nr7;
                    let mut index37: i32 = index36;
                    let mut num54: i32 = areaEnemy[index36] - Number14;
                    numArray[index37] = num54;
                    if (makelog & Number14 > 0)
                      this.AddLog("FROM " + this.GetAreaName(nr7) + " : " + Conversion.Str( Number14));
                    num40 += Number14;
                    if (this.AreaEnemy[nr7] < 0)
                      this.AreaEnemy[nr7] = 0;
                    if (this.GetAreaEnemyNeighbourCount(nr7) == 0)
                    {
                      if (!this.Attacker)
                      {
                        num40 += this.AreaEnemy[nr7];
                        this.AreaEnemy[nr7] = 0;
                      }
                      if (this.Attacker)
                      {
                        num40 +=  Math.Round( this.AreaEnemy[nr7] / 2.0);
                        this.AreaEnemy[nr7] =  Math.Round( this.AreaEnemy[nr7] / 2.0);
                      }
                      if (makelog & Number14 > 0)
                        this.AddLog("ALL FROM " + this.GetAreaName(nr7) + " : " + Conversion.Str( this.AreaEnemy[nr7]));
                      this.AreaEnemy[nr7] = 0;
                    }
                  }
                }
                this.AreaOwner[nr1] = num39;
                this.AreaEnemy[nr1] = num40;
                let mut areaCount6: i32 = this.AreaCount;
                for (let mut index38: i32 = 1; index38 <= areaCount6; index38 += 1)
                {
                  if (index38 != nr1 & this.AreaBorder[nr1, index38] > 0 && this.GetRegime(this.AreaOwner[index38]) == this.GetGameDataTurn())
                    this.StrCounterAttack[nr1, index38] = -8;
                }
                let mut num55: i32 = 0;
                let mut areaCount7: i32 = this.AreaCount;
                for (let mut nr8: i32 = 1; nr8 <= areaCount7; nr8 += 1)
                {
                  if (nr8 != nr1 & this.AreaBorder[nr1, nr8] > 0 && this.GetRegime(this.AreaOwner[nr8]) != this.GetGameDataTurn() && this.GetAreaEnemyNeighbourCount(nr8) == 0)
                  {
                    num55 += this.AreaEnemy[nr8];
                    this.AreaEnemy[nr8] = 0;
                  }
                }
                if (num55 > 0)
                {
                  int[] areaEnemy = this.AreaEnemy;
                  int[] numArray = areaEnemy;
                  let mut index39: i32 = nr1;
                  let mut index40: i32 = index39;
                  let mut num56: i32 = areaEnemy[index39] + num55;
                  numArray[index40] = num56;
                }
              }
            }
          }
        }
      }
    }

    pub fn GetStrategyScore( SimpleList Straty, bool makelog, float Progress) -> i32
    {
      int[] numArray1 = new int[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      if (makelog)
      {
        let mut num1: i32 = num1;
      }
      this.EnemySupplyGone = new int[this.AreaCount + 1];
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index: i32 = 0; index <= areaCount1; index += 1)
        this.EnemySupplyGone[index] = this.StartEnemySupplyGone[index];
      if (this.StrCurSides.GetUpperBound(0) < this.AreaCount)
      {
        this.StrCurSides = new int[this.AreaCount + 1];
        this.StrCounterAttack = new int[this.AreaCount + 1, this.AreaCount + 1];
        this.StrLandEnemySupply = new int[this.AreaCount + 1];
        this.StrOrigAreaOwner = new int[this.AreaCount + 1];
        this.StrAreaEntrench = new int[this.AreaCount + 1];
        this.StrAreaNegPow = new int[this.AreaCount + 1];
      }
      else
      {
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut index1: i32 = 0; index1 <= areaCount2; index1 += 1)
        {
          this.StrCurSides[index1] = 0;
          let mut areaCount3: i32 = this.AreaCount;
          for (let mut index2: i32 = 0; index2 <= areaCount3; index2 += 1)
            this.StrCounterAttack[index1, index2] = 0;
          this.StrLandEnemySupply[index1] = 0;
          this.StrOrigAreaOwner[index1] = 0;
          this.StrAreaEntrench[index1] = 0;
          this.StrAreaNegPow[index1] = 0;
        }
      }
      this.StrTempCorpsCounter = 0;
      if (this.FriendlySupply.GetUpperBound(0) < this.AreaCount | this.AreaCounterPower.GetUpperBound(0) < this.AreaCount)
      {
        this.AreaOwner = new int[this.AreaCount + 1];
        this.AreaCounterPower = new int[this.AreaCount + 1];
        this.AreaCounterDirections = new int[this.AreaCount + 1, 10];
        this.AreaCounterRegime = new int[this.AreaCount + 1, 10];
        this.AreaCounterStep = new int[this.AreaCount + 1];
        this.AreaEnemy = new int[this.AreaCount + 1];
        this.FriendlySupply = new int[this.AreaCount + 1];
        this.EnemySupply = new int[this.AreaCount + 1];
        this.AreaStartEnemy = new int[this.AreaCount + 1];
      }
      else
      {
        let mut areaCount4: i32 = this.AreaCount;
        for (let mut index3: i32 = 0; index3 <= areaCount4; index3 += 1)
        {
          this.AreaCounterPower[index3] = 0;
          let mut index4: i32 = 0;
          do
          {
            this.AreaCounterDirections[index3, index4] = 0;
            this.AreaCounterRegime[index3, index4] = 0;
            index4 += 1;
          }
          while (index4 <= 9);
          this.AreaCounterStep[index3] = 0;
          this.AreaEnemy[index3] = 0;
          this.AreaStartEnemy[index3] = 0;
        }
      }
      if (this.CorpsTempAirStrength.GetUpperBound(0) < this.GroupCounter | this.CorpsTopRatio.GetUpperBound(0) < this.GroupCounter | this.CorpsLoc.GetUpperBound(0) < this.GroupCounter | this.CorpsTarget.GetUpperBound(0) < this.GroupCounter | this.CorpsAirEffect.GetUpperBound(0) < this.GroupCounter)
      {
        this.CorpsAirEffect = new int[this.GroupCounter + 1];
        this.CorpsEntrench = new int[this.GroupCounter + 1];
        this.CorpsLoc = new int[this.GroupCounter + 1];
        this.CorpsTarget = new int[this.GroupCounter + 1];
        this.CorpsMove = new int[this.GroupCounter + 1];
        this.CorpsMoveProgress = new int[this.GroupCounter + 1];
        this.CorpsStance = new int[this.GroupCounter + 1];
        this.CorpsTempStrength = new int[this.GroupCounter + 1];
        this.corpsstartStrength = new int[this.GroupCounter + 1];
        this.CorpsTempAirStrength = new int[this.GroupCounter + 1];
        this.CorpsFirstAreaBattle = new int[this.GroupCounter + 1];
        this.CorpsTopRatio = new float[this.GroupCounter + 1];
      }
      else
      {
        let mut groupCounter: i32 = this.GroupCounter;
        for (let mut index: i32 = 0; index <= groupCounter; index += 1)
        {
          this.CorpsAirEffect[index] = 0;
          this.CorpsTarget[index] = 0;
          this.CorpsMoveProgress[index] = 0;
          this.CorpsTempAirStrength[index] = 0;
          this.CorpsFirstAreaBattle[index] = 0;
          this.CorpsTopRatio[index] = 0.0f;
        }
      }
      if (this.CorpsStance.GetUpperBound(0) < this.GroupCounter)
        this.CorpsStance = new int[this.GroupCounter + 1];
      if (this.CorpsAirStrength.GetUpperBound(0) < this.GroupCounter)
        this.CorpsAirStrength = (int[]) Utils.CopyArray((Array) this.CorpsAirStrength, (Array) new int[this.GroupCounter + 1]);
      if (Information.IsNothing( Straty))
        return -99999;
      let mut num2: i32 = !(this.AreaGroupRound == 1 & this.AreaGroupCount > 1) ? (this.AreaGroupCount > 1 ? (this.AreaGroupCount > 3 ? 7 : 7) : 10) : 4;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].ProdBonus >= 100 &  Progress > 0.4)
        Progress = 1f;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].ProdBonus >= 250)
        Progress = 1f;
      let mut areaCount5: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount5; index += 1)
      {
        this.AreaOwner[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime;
        this.StrOrigAreaOwner[index] = this.AreaOwner[index];
        this.AreaEnemy[index] = this.AreaStrength[index];
        this.AreaStartEnemy[index] = this.AreaStrength[index];
        this.StrAreaEntrench[index] = this.AverageAreaEntrench[index];
      }
      let mut groupCounter1: i32 = this.GroupCounter;
      for (let mut grp: i32 = 0; grp <= groupCounter1; grp += 1)
      {
        this.CorpsLoc[grp] = this.CorpsStartLoc[grp];
        this.CorpsMove[grp] = 1;
        this.CorpsMoveProgress[grp] = 0;
        this.CorpsAirEffect[grp] = 100;
        this.CorpsEntrench[grp] = this.GetAverageCorpsEntrench(grp, 1);
        let mut nr: i32 = Straty.FindNr(grp + 99000);
        this.CorpsStance[grp] = nr <= -1 ? 2 : Straty.Data1[nr];
        this.CorpsTempStrength[grp] = this.CorpsStrength[grp];
        this.corpsstartStrength[grp] = this.CorpsStrength[grp];
      }
      let mut groupCounter2: i32 = this.GroupCounter;
      for (let mut index5: i32 = 0; index5 <= groupCounter2; index5 += 1)
      {
        let mut nr: i32 = Straty.FindNr(index5 + 199000);
        if (nr > -1 && Straty.Data1[nr] > -1)
        {
          let mut num3: i32 = 100 - this.game.HandyFunctionsObj.Distance(this.AreaCenter[this.CorpsLoc[index5]].x, this.AreaCenter[this.CorpsLoc[index5]].y, 0, this.AreaCenter[this.CorpsLoc[Straty.Data1[nr]]].x, this.AreaCenter[this.CorpsLoc[Straty.Data1[nr]]].y, 0) * 5;
          if (0 > num3)
            num3 = 0;
          if (this.CorpsAirStrength[index5] > 0)
          {
            this.CorpsAirEffect[Straty.Data1[nr]] =  Math.Round( (this.CorpsAirEffect[Straty.Data1[nr]] * this.CorpsTempAirStrength[Straty.Data1[nr]] + num3 * this.CorpsAirStrength[index5]) /  (this.CorpsTempAirStrength[Straty.Data1[nr]] + this.CorpsAirStrength[index5]));
            int[] corpsTempAirStrength = this.CorpsTempAirStrength;
            int[] numArray3 = corpsTempAirStrength;
            int[] data1 = Straty.Data1;
            int[] numArray4 = data1;
            let mut index6: i32 = nr;
            let mut index7: i32 = index6;
            let mut index8: i32 = numArray4[index7];
            let mut num4: i32 = corpsTempAirStrength[data1[index6]] + this.CorpsAirStrength[index5];
            numArray3[index8] = num4;
          }
        }
      }
      let mut Number1: i32 = 0;
      if (makelog)
        this.AddLog("STRATEGY SCORE");
      if (makelog)
        this.AddLog("Is attacker = " + Conversion.Str( this.Attacker));
      this.StrConsistSame = 0;
      this.StrConsistDifferent = 0;
      if (makelog)
      {
        if (makelog)
        {
          Number2: i32;
          this.AddLog("INITIAL SETUP****" + Conversion.Str( Number2) + "****");
        }
        let mut Number3: i32 = 0;
        let mut areaCount6: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount6; nr += 1)
        {
          if (makelog & this.AreaEnemy[nr] > 0)
          {
            this.AddLog(this.GetAreaName(nr) + ", Owner = " + Conversion.Str( this.AreaOwner[nr]) + ", AreaEnemy = " + Conversion.Str( this.AreaEnemy[nr]) + ", AreaSupply = " + Conversion.Str( this.EnemySupply[nr]));
            Number3 += this.AreaEnemy[nr];
          }
        }
        if (makelog)
          this.AddLog("TOTAL AreaEnemy = " + Conversion.Str( Number3));
        if (makelog)
          this.AddLog("***");
      }
      num5: i32;
      while (num5 < num2)
      {
        num5 += 1;
        if (makelog)
          this.AddLog("ROUND " + Conversion.Str( num5));
        this.GetStrategyScore_CorpsTarget( Straty, num5, makelog);
        this.GetStrategyScore_FriendlySupply(false, num5);
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].ProdBonus < 100)
        {
          if (num5 == 1 | num5 % 3 == 0 | !this.Attacker)
            this.GetStrategyScore_EnemySupply();
          this.GetStrategyScore_TroopsPlace(num5, makelog);
          if (num5 <= 2 | num5 % 3 == 0 | this.Meeting | !this.Attacker)
            this.GetStrategyScore_MoveEnemy(num5, makelog);
        }
        else
        {
          this.GetStrategyScore_EnemySupply();
          this.GetStrategyScore_TroopsPlace(num5, makelog);
          this.GetStrategyScore_MoveEnemy(num5, makelog);
        }
        if (makelog)
        {
          if (makelog)
            this.AddLog("****" + Conversion.Str( num5) + "****");
          let mut Number4: i32 = 0;
          let mut areaCount7: i32 = this.AreaCount;
          for (let mut nr: i32 = 1; nr <= areaCount7; nr += 1)
          {
            if (makelog & this.AreaEnemy[nr] > 0)
            {
              this.AddLog(this.GetAreaName(nr) + ", Owner = " + Conversion.Str( this.AreaOwner[nr]) + ", AreaEnemy = " + Conversion.Str( this.AreaEnemy[nr]) + ", AreaSupply = " + Conversion.Str( this.EnemySupply[nr]));
              Number4 += this.AreaEnemy[nr];
            }
          }
          if (makelog)
            this.AddLog("TOTAL AreaEnemy = " + Conversion.Str( Number4));
          if (makelog)
            this.AddLog("***");
          let mut Number5: i32 = 0;
          let mut groupCounter3: i32 = this.GroupCounter;
          for (let mut index: i32 = 0; index <= groupCounter3; index += 1)
          {
            if (makelog & this.CorpsTempStrength[index] > 0)
              this.AddLog(this.GroupName[index] + ", TempStr = " + Conversion.Str( this.CorpsTempStrength[index]) + ", Str = " + Conversion.Str( this.CorpsStrength[index]) + ", Area = " + this.GetAreaName(this.CorpsLoc[index]) + ", Target = " + this.GetAreaName(this.CorpsTarget[index]) + " Stance = " + Conversion.Str( this.CorpsStance[index]) + ", Supply=" + Conversion.Str( this.FriendlySupply[this.CorpsLoc[index]]));
            Number5 += this.CorpsTempStrength[index];
          }
          if (makelog)
            this.AddLog("TOTAL TempStr = " + Conversion.Str( Number5));
        }
        this.GetStrategyScore_Attacks( Straty, num5, makelog);
        let mut Number6: i32 = this.GetStrategyScoreForVP(makelog, num5);
        if (makelog)
          this.AddLog(Conversion.Str( num5) + ") SCORE FOR VP= " + Conversion.Str( Number6));
        if (this.Attacker)
        {
          if (num5 == 1)
            Number6 *= 5;
          if (num5 == 2)
            Number6 *= 3;
          if (num5 == 3)
            Number6 *= 2;
          if (num5 == 4)
            Number6 *= 1;
          if (num5 == 5)
            Number6 *= 1;
          if (num5 == 6)
            Number6 *= 1;
        }
        if (makelog)
          this.AddLog(Conversion.Str( num5) + ") SCORE AFTER ADJUSTMENT ROUND NR = " + Conversion.Str( Number6));
        if (this.Attacker)
          Number6 =  Math.Round( Number6 * 0.5 +  Number6 * 0.5 *  this.GetStrategyScoreForEnemyLeft());
        if (makelog & this.Attacker)
          this.AddLog(Conversion.Str( num5) + ") SCORE AFTER ADJUSTMENT ENEMY RATIO (" + Conversion.Str( this.GetStrategyScoreForEnemyLeft()) + ") = " + Conversion.Str( Number6));
        if (Number6 > 0)
          Number6 =  Math.Round( Number6 * 0.9 +  Number6 * 0.1 *  this.GetStrategyScoreForKillRatio());
        else if (Number6 > -1000)
          Number6 =  Math.Round( Number6 * 0.9 +  Number6 * 0.1 * (1.0 /  this.GetStrategyScoreForKillRatio()));
        if (makelog)
          this.AddLog(Conversion.Str( num5) + ") SCORE AFTER ADJUSTMENT 0.1 (" + Conversion.Str( this.GetStrategyScoreForKillRatio()) + ") KILL RATIO = " + Conversion.Str( Number6));
        Number1 += Number6;
        if (this.Attacker)
        {
          let mut Number7: i32 = Number6 <= 0 ?  Math.Round( Number6 * 0.2 +  Number6 * 0.8 * (1.0 /  this.GetStrategyScoreForUnusedCorps(makelog))) :  Math.Round( Number6 * 0.2 +  Number6 * 0.8 *  this.GetStrategyScoreForUnusedCorps(makelog));
          if (makelog)
            this.AddLog(Conversion.Str( num5) + ") SCORE AFTER ADJUSTMENT (" + Conversion.Str( this.GetStrategyScoreForUnusedCorps(false)) + ") UNUSED RATIO = " + Conversion.Str( Number7));
          Number1 += Number7;
        }
        let mut counter: i32 = this.TempPowerAbove.Counter;
        for (let mut index9: i32 = 0; index9 <= counter; index9 += 1)
        {
          let mut num6: i32 = 0;
          let mut groupCounter4: i32 = this.GroupCounter;
          for (let mut index10: i32 = 0; index10 <= groupCounter4; index10 += 1)
          {
            if (this.CorpsLoc[index10] == this.TempPowerAbove.Id[index9])
              num6 += this.CorpsTempStrength[index10];
          }
          if (num6 > this.TempPowerAbove.Data1[index9])
          {
            let mut Number8: i32 =  Math.Round( ((num6 - this.TempPowerAbove.Data1[index9]) * this.TempPowerAbove.Data2[index9]) /  (1 + (num2 - num5)));
            Number1 += Number8;
            if (makelog)
              this.AddLog(Conversion.Str( Number8) + " points for PowerAbove Points in area " + this.GetAreaName(this.TempPowerAbove.Id[index9]));
          }
        }
        if (makelog)
          this.AddLog("***=> END OF ROUND SCORE = " + Conversion.Str( Number1));
      }
      if (this.StrConsistSame + this.StrConsistDifferent > 0 & this.game.Data.Round > 1)
      {
        float Number9 =  this.StrConsistSame /  (this.StrConsistSame + this.StrConsistDifferent);
        if (makelog)
          this.AddLog("CONSISTENCY MODIFIER (FOR 1/2 OF SCORE) = " + Conversion.Str( Number9));
        Number1 = Number1 <= 0 ? ( Number9 != 0.0 ?  Math.Round( Number1 * 0.5 +  Number1 * 0.5 * (1.0 /  Number9)) :  Math.Round( Number1 * 0.5)) :  Math.Round( Number1 * 0.5 +  Number1 * 0.5 *  Number9);
      }
      let mut Number10: i32 = Number1 - this.ClosenessToFrontScore(makelog);
      if (makelog)
        this.AddLog("***=> SCORE AFTER ADDING CLOSENESS TO PROGNOSED ENEMY POSITION = " + Conversion.Str( Number10));
      let mut Number11: i32 = Number10 - this.ClosenessToCurrentFrontScore(makelog);
      if (makelog)
        this.AddLog("***=> SCORE AFTER ADDING CLOSENESS TO CURRENT ENEMY POSITION= " + Conversion.Str( Number11));
      let mut groupCounter5: i32 = this.GroupCounter;
      for (let mut index: i32 = 0; index <= groupCounter5; index += 1)
      {
        if (this.StartFriendlySupply[this.CorpsStartLoc[index]] == 0 && this.FriendlySupply[this.CorpsLoc[index]] == 1)
        {
          let mut Number12: i32 = this.CorpsTempStrength[index];
          Number11 += Number12;
          if (makelog)
            this.AddLog(Conversion.Str( Number12) + " points for surving power points from encirclement ");
        }
      }
      let mut groupCounter6: i32 = this.GroupCounter;
      for (let mut tid1: i32 = 0; tid1 <= groupCounter6; tid1 += 1)
      {
        let mut nr1: i32 = Straty.FindNr(tid1);
        if (nr1 > -1 & this.GroupType[tid1] <= 5 && Straty.Data1[nr1] > 0)
        {
          let mut groupCounter7: i32 = this.GroupCounter;
          for (let mut tid2: i32 = 0; tid2 <= groupCounter7; tid2 += 1)
          {
            if (this.CorpsStartLoc[tid2] == this.CorpsStartLoc[tid1])
            {
              let mut nr2: i32 = Straty.FindNr(tid2);
              if (nr2 > -1 & this.GroupType[tid2] <= 5 && Straty.Data1[nr2] != Straty.Data1[nr1] && this.HisAreaDistance[tid1, Straty.Data1[nr1]] > this.HisAreaDistance[tid2, Straty.Data1[nr1]])
              {
                let mut Number13: i32 =  Math.Round(Math.Sqrt(  Math.Round( Math.Min(this.corpsstartStrength[tid2], this.corpsstartStrength[tid1]) * ( (this.HisAreaDistance[tid1, Straty.Data1[nr1]] - this.HisAreaDistance[tid2, Straty.Data1[nr1]]) / 500.0))));
                Number11 -= Number13;
                if (makelog)
                  this.AddLog(Conversion.Str( Number13) + " points for having group " + this.GroupName[tid1] + " moving while " + this.GroupName[tid2] + " would have been quicker. = " + Conversion.Str( Number13) + " penalty.");
              }
            }
          }
        }
      }
      if (makelog)
        this.AddLog("***=> FINAL SCORE AFTER ALL ROUNDS = " + Conversion.Str( Number11));
      let mut d: i32 = 0;
      let mut groupCounter8: i32 = this.GroupCounter;
      for (let mut index: i32 = 0; index <= groupCounter8; index += 1)
        d += this.CorpsTempStrength[index];
      let mut Number14: i32 = Number11 +  Math.Round(Math.Sqrt( d));
      if (makelog)
        this.AddLog("***=> FINAL SCORE AFTER SQRT(TOTALTROOPS) added = " + Conversion.Str( Number14));
      return Number14;
    }

    pub fn ClosenessToFrontScore(bool makelog) -> i32
    {
      let mut groupCounter: i32 = this.GroupCounter;
      frontScore: i32;
      for (let mut index1: i32 = 0; index1 <= groupCounter; index1 += 1)
      {
        let mut Number1: i32 = 999999;
        let mut Number2: i32 = 0;
        if (this.GroupType[index1] <= 5 & this.CorpsLoc[index1] > 0 && this.AreaGroup[this.CorpsLoc[index1]] == this.CurrentAreaGroup)
        {
          if (this.CorpsStrength[index1] <= this.CorpsTempStrength[index1])
          {
            let mut areaCount: i32 = this.AreaCount;
            for (let mut index2: i32 = 1; index2 <= areaCount; index2 += 1)
            {
              if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.AreaOwner[index2]) && this.game.Data.RegimeObj[this.game.Data.Turn].AIVP[0].Value[this.AreaCenter[index2].x, this.AreaCenter[index2].y] > 0 | this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].VP > 0)
              {
                let mut areaStep: i32 = this.AreaSteps[index2, this.CorpsLoc[index1]];
                let mut num: i32 = this.AreaSteps[index2, this.CorpsLoc[index1]] > 1 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 2 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 3 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 4 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 5 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 6 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 7 ? 14 : 12) : 10) : 8) : 6) : 4) : 2) : 0;
                if (areaStep > 0 && areaStep < Number1)
                {
                  Number1 = areaStep;
                  Number2 = num;
                }
              }
            }
          }
          if (Number1 <= 99999)
          {
            if (makelog)
              this.AddLog(Conversion.Str( Number2) + " pomultiplier: i32 for " + this.GroupName[index1] + ". Closest enemy dist =" + Conversion.Str( Number1));
            let mut Number3: i32 =  Math.Round(Math.Sqrt(Math.Sqrt( this.corpsstartStrength[index1]))) * Number2;
            frontScore += Number3;
            if (makelog)
              this.AddLog("Removes -" + Conversion.Str( Number3));
          }
        }
      }
      return frontScore;
    }

    pub fn ClosenessToCurrentFrontScore(bool makelog) -> i32
    {
      let mut groupCounter: i32 = this.GroupCounter;
      currentFrontScore: i32;
      for (let mut index1: i32 = 0; index1 <= groupCounter; index1 += 1)
      {
        let mut Number1: i32 = 999999;
        let mut Number2: i32 = 0;
        if (this.GroupType[index1] <= 5 & this.CorpsLoc[index1] > 0 && this.AreaGroup[this.CorpsLoc[index1]] == this.CurrentAreaGroup)
        {
          if (this.CorpsStrength[index1] <= this.CorpsTempStrength[index1])
          {
            let mut areaCount: i32 = this.AreaCount;
            for (let mut index2: i32 = 1; index2 <= areaCount; index2 += 1)
            {
              if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime) && this.game.Data.RegimeObj[this.game.Data.Turn].AIVP[0].Value[this.AreaCenter[index2].x, this.AreaCenter[index2].y] > 0 | this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].VP > 0)
              {
                let mut areaStep: i32 = this.AreaSteps[index2, this.CorpsLoc[index1]];
                let mut num: i32 = this.AreaSteps[index2, this.CorpsLoc[index1]] > 1 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 2 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 3 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 4 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 5 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 6 ? (this.AreaSteps[index2, this.CorpsLoc[index1]] > 7 ? 14 : 12) : 10) : 8) : 6) : 4) : 2) : 0;
                if (areaStep > 0 && areaStep < Number1)
                {
                  Number1 = areaStep;
                  Number2 = num;
                }
              }
            }
          }
          if (Number1 <= 99999)
          {
            if (makelog)
              this.AddLog(Conversion.Str( Number2) + " pomultiplier: i32 for " + this.GroupName[index1] + ". Closest CURRENT FRONT enemy dist =" + Conversion.Str( Number1));
            let mut Number3: i32 =  Math.Round( ( Math.Round(Math.Sqrt(Math.Sqrt( this.corpsstartStrength[index1]))) * Number2) / 2.0);
            currentFrontScore += Number3;
            if (makelog)
              this.AddLog("Removes -" + Conversion.Str( Number3));
          }
        }
      }
      return currentFrontScore;
    }

    pub fn GetAreaBorderSteps(from: i32, too: i32, maxstep: i32) -> i32
    {
      int[] numArray = new int[this.AreaCount + 1];
      numArray[from] = 1;
      let mut num1: i32 = 1;
      let mut areaBorderSteps: i32 = 0;
      while (num1 == 1)
      {
        num1 = 0;
        areaBorderSteps += 1;
        if (areaBorderSteps > maxstep)
          return 9999;
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index1: i32 = 1; index1 <= areaCount; index1 += 1)
        {
          if (numArray[index1] == areaBorderSteps)
          {
            let mut num2: i32 = this.AreaSupplyBorderCount[index1];
            for (let mut index2: i32 = 1; index2 <= num2; index2 += 1)
            {
              let mut index3: i32 = this.AreaSupplyBorder[index1, index2];
              if (numArray[index3] == 0)
              {
                numArray[index3] = areaBorderSteps + 1;
                if (too == index3)
                  return areaBorderSteps;
                num1 = 1;
              }
            }
          }
        }
      }
      return 9999;
    }

    pub fn GetAreaNarrowBorderSteps(from: i32, too: i32, maxstep: i32) -> i32
    {
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index: i32 = 0; index <= areaCount1; index += 1)
        this.stemp[index] = 0;
      this.stemp[from] = 1;
      let mut num: i32 = 1;
      let mut narrowBorderSteps: i32 = 0;
      while (num == 1)
      {
        num = 0;
        narrowBorderSteps += 1;
        if (narrowBorderSteps > maxstep)
          return 9999;
        let mut areaCount2: i32 = this.AreaCount;
        for (let mut index1: i32 = 1; index1 <= areaCount2; index1 += 1)
        {
          if (this.stemp[index1] == narrowBorderSteps)
          {
            let mut areaCount3: i32 = this.AreaCount;
            for (let mut index2: i32 = 1; index2 <= areaCount3; index2 += 1)
            {
              if (this.AreaNarrowBorder[index1, index2] > 0 & this.AreaNarrowBorder[index1, index2] < 99 & index1 != index2 && this.stemp[index2] == 0)
              {
                this.stemp[index2] = narrowBorderSteps + 1;
                if (too == index2)
                  return narrowBorderSteps;
                num = 1;
              }
            }
          }
        }
      }
      return 9999;
    }

    pub fn GetAverageCorpsEntrench(grp: i32, let mut CatOnly: i32 = -1) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut index1: i32 = 0; index1 <= unitCounter; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].PreDef == -1 && this.game.Data.UnitObj[index1].AIGroup == grp & this.game.Data.UnitObj[index1].X > -1 && this.game.Data.UnitObj[index1].TempCategory == CatOnly | CatOnly == -1)
        {
          let mut sfCount: i32 = this.game.Data.UnitObj[index1].SFCount;
          for (let mut index2: i32 = 0; index2 <= sfCount; index2 += 1)
          {
            let mut sf: i32 = this.game.Data.UnitObj[index1].SFList[index2];
            let mut num3: i32 = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Qty;
            num1 += num3 * this.game.Data.SFObj[sf].CurrentEntrench;
            num2 += num3;
          }
        }
      }
      return num2 == 0 ? 0 :  Math.Round( num1 /  num2);
    }

    pub fn GetAverageAreaEntrench(Area: i32, let mut CatOnly: i32 = -1) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut index1: i32 = 0; index1 <= unitCounter; index1 += 1)
      {
        if (this.game.Data.UnitObj[index1].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index1].Regime) != this.GetGameDataTurn() & this.game.Data.UnitObj[index1].X > -1 && this.AreaMatrixNarrow[this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y] == Area && this.game.Data.UnitObj[index1].TempCategory == CatOnly | CatOnly == -1)
        {
          let mut sfCount: i32 = this.game.Data.UnitObj[index1].SFCount;
          for (let mut index2: i32 = 0; index2 <= sfCount; index2 += 1)
          {
            let mut sf: i32 = this.game.Data.UnitObj[index1].SFList[index2];
            let mut num3: i32 = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts * this.game.Data.SFObj[sf].Qty;
            num1 += num3 * this.game.Data.SFObj[sf].CurrentEntrench;
            num2 += num3;
          }
        }
      }
      return num2 == 0 ? 0 :  Math.Round( num1 /  num2);
    }

    pub Coordinate GetAverageCorpsUnitCoord(grp: i32, let mut CatOnly: i32 = -1, bool ReturnRoadHex = false)
    {
      SimpleList simpleList1 = SimpleList::new();
      let mut num1: i32 = 0;
      let mut num2: i32 = 0;
      let mut num3: i32 = 0;
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter1; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[unr].AIGroup == grp & this.game.Data.UnitObj[unr].X > -1 && this.game.Data.UnitObj[unr].TempCategory == CatOnly | CatOnly == -1)
        {
          let mut num4: i32 = this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          if (this.game.Data.UnitObj[unr].IsHQ)
            num4 =  Math.Round( num4 / 5.0);
          num2 += this.game.Data.UnitObj[unr].X * num4;
          num3 += this.game.Data.UnitObj[unr].Y * num4;
          tid: i32;
          tid += 1;
          simpleList1.Add(tid, 0, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y);
          num1 += num4;
        }
      }
      Coordinate averageCorpsUnitCoord;
      averageCorpsUnitCoord.onmap = false;
      if (num1 == 0 || simpleList1.Counter == -1)
        return averageCorpsUnitCoord;
      averageCorpsUnitCoord.x =  Math.Round( num2 /  num1);
      averageCorpsUnitCoord.y =  Math.Round( num3 /  num1);
      let mut counter: i32 = simpleList1.Counter;
      for (let mut index: i32 = 0; index <= counter; index += 1)
        simpleList1.Weight[index] = this.game.HandyFunctionsObj.Distance(simpleList1.Data1[index], simpleList1.Data2[index], 0, averageCorpsUnitCoord.x, averageCorpsUnitCoord.y, 0);
      simpleList1.Sort();
      averageCorpsUnitCoord.x = simpleList1.Data1[0];
      averageCorpsUnitCoord.y = simpleList1.Data2[0];
      if (ReturnRoadHex)
      {
        SimpleList simpleList2 = SimpleList::new();
        let mut tid: i32 = 0;
        let mut unitCounter2: i32 = this.game.Data.UnitCounter;
        for (let mut index1: i32 = 0; index1 <= unitCounter2; index1 += 1)
        {
          if (this.game.Data.UnitObj[index1].PreDef == -1 && this.game.Data.UnitObj[index1].AIGroup == grp & this.game.Data.UnitObj[index1].X > -1 && this.GetRegime(this.game.Data.UnitObj[index1].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index1].TempCategory == CatOnly | CatOnly == -1)
          {
            let mut num5: i32 = 0;
            tid += 1;
            let mut index2: i32 = 0;
            do
            {
              if (this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y].RoadType[index2] > -1)
                num5 = 1;
              index2 += 1;
            }
            while (index2 <= 5);
            if (num5 == 1)
              simpleList2.Add(tid, this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0, averageCorpsUnitCoord.x, averageCorpsUnitCoord.y, 0), this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y);
          }
        }
        if (simpleList2.Counter > -1)
        {
          simpleList2.Sort();
          averageCorpsUnitCoord.x = simpleList2.Data1[0];
          averageCorpsUnitCoord.y = simpleList2.Data2[0];
          averageCorpsUnitCoord.onmap = true;
          return averageCorpsUnitCoord;
        }
      }
      return averageCorpsUnitCoord;
    }

    pub float GetStrategyScoreForKillRatio()
    {
      let mut num1: i32 = 0;
      let mut num2: i32 = 0;
      let mut num3: i32 = 0;
      let mut num4: i32 = 0;
      let mut areaCount: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount; index += 1)
      {
        num1 += this.AreaStartEnemy[index];
        num2 += this.AreaEnemy[index];
      }
      let mut groupCounter: i32 = this.GroupCounter;
      for (let mut index: i32 = 0; index <= groupCounter; index += 1)
      {
        if (this.GroupType[index] <= 5)
          ;
        num3 += this.corpsstartStrength[index];
        num4 += this.CorpsTempStrength[index];
      }
      if (num4 > num3)
        num4 = num3;
      if (num2 > num1)
        num2 = num1;
      float scoreForKillRatio =  (num1 - num2) /  Math.Max(1, num3 - num4);
      if ( scoreForKillRatio == 0.0)
        scoreForKillRatio = 1f;
      if ( scoreForKillRatio < 0.25)
        scoreForKillRatio = scoreForKillRatio;
      if ( scoreForKillRatio > 4.0)
        scoreForKillRatio = 4f;
      return scoreForKillRatio;
    }

    pub float GetStrategyScoreForEnemyLeft()
    {
      let mut num1: i32 = 0;
      let mut num2: i32 = 0;
      let mut areaCount: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount; index += 1)
      {
        num1 += this.AreaStartEnemy[index];
        num2 += this.AreaEnemy[index];
      }
      if (num1 == 0)
        return 1f;
      return num2 > num1 ? 0.0f : 1f -  num2 /  num1;
    }

    pub float GetStrategyScoreForUnusedCorps(bool makelog)
    {
      let mut groupCounter: i32 = this.GroupCounter;
      num1: i32;
      num2: i32;
      for (let mut index: i32 = 0; index <= groupCounter; index += 1)
      {
        if (this.AreaGroup[this.CorpsLoc[index]] == this.CurrentAreaGroup)
        {
          let mut num3: i32 = 0;
          let mut num4: i32 = this.CorpsStrength[index] > this.CorpsTempStrength[index] | this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.CorpsLoc[index]].x, this.AreaCenter[this.CorpsLoc[index]].y].Regime) != this.GetGameDataTurn() ? 1 : 0;
          if (this.CorpsLoc[index] <= 0 || this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.CorpsLoc[index]].x, this.AreaCenter[this.CorpsLoc[index]].y].Regime) == this.GetGameDataTurn())
            ;
          if (this.CorpsTarget[index] <= 0 || this.GetRegime(this.AreaOwner[this.CorpsTarget[index]]) == this.GetGameDataTurn())
            ;
          if (this.GroupType[index] > 5 & this.CorpsTempAirStrength[index] <= 0)
            num3 = 1;
          if (this.CorpsStrength[index] > this.CorpsTempStrength[index])
            num3 = 1;
          if (this.StartFriendlySupply[this.CorpsStartLoc[index]] == 0)
            num3 = 1;
          if (num3 == 1)
          {
            num1 += this.CorpsStrength[index];
          }
          else
          {
            num2 += 1 * this.CorpsStrength[index] + this.CorpsTempAirStrength[index] * 10;
            if (makelog)
              this.AddLog(this.GroupName[index] + " IS NOT USED");
          }
        }
      }
      float scoreForUnusedCorps =  num1 /  Math.Max(1, num1 + num2);
      if ( scoreForUnusedCorps == 0.0)
        scoreForUnusedCorps = 1f;
      return scoreForUnusedCorps;
    }

    pub fn GetStrategyScoreForVP(bool makelog, round: i32) -> i32
    {
      let mut tempTotVp: i32 = this.TempTotVP;
      let mut tempCurVp: i32 = this.TempCurVP;
      let mut num1: i32 = 0;
      let mut strategyScoreForVp: i32 = 0;
      let mut num2: i32 = 0;
      if (tempTotVp <= 0)
        return 0;
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut nr: i32 = 1; nr <= areaCount1; nr += 1)
      {
        if (this.AreaGroup[nr] == this.CurrentAreaGroup)
        {
          let mut x: i32 = this.AreaCenter[nr].x;
          let mut y: i32 = this.AreaCenter[nr].y;
          if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
            num2 = num2 + this.game.Data.RegimeObj[this.game.Data.Turn].AIVP[0].Value[x, y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].VP + this.AreaExtraVP[nr];
          if (this.GetRegime(this.AreaOwner[nr]) == this.GetGameDataTurn())
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
            {
              let mut Number: i32 =  Math.Round(1000.0 * ( (this.AreaExtraVP[nr] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].VP) /  tempTotVp));
              strategyScoreForVp += Number;
              if (makelog)
                this.AddLog(this.GetAreaName(nr) + " = + " + Conversion.Str( Number) + " pts. (VP) ( Extra VP= " + Conversion.Str( this.AreaExtraVP[nr]) + ")");
            }
          }
          else if (this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) == this.GetGameDataTurn() && this.GetRegime(this.AreaOwner[nr]) != this.GetGameDataTurn())
          {
            let mut Number: i32 =  Math.Round(1000.0 * ( (this.AreaExtraVP[nr] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[x, y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].VP) /  tempTotVp));
            strategyScoreForVp -= Number;
            if (makelog)
              this.AddLog(this.GetAreaName(nr) + " = - " + Conversion.Str( Number) + " pts. (VP) ( Extra VP= " + Conversion.Str( this.AreaExtraVP[nr]) + ")");
          }
        }
      }
      let mut areaCount2: i32 = this.AreaCount;
      num3: i32;
      num4: i32;
      for (let mut index: i32 = 1; index <= areaCount2; index += 1)
      {
        if (this.AreaGroup[index] == this.CurrentAreaGroup)
        {
          num3 += this.AreaStrength[index];
          num4 += this.AreaEnemy[index];
        }
      }
      float num5 = num3 <= 0 ? 0.0f : 1f -  num4 /  num3;
      if ( num5 > 1.0)
        num5 = 1f;
      if ( num5 < 0.0)
        num5 = 0.0f;
      num1 =  Math.Round( (350f * ( num2 /  Math.Max(1, tempTotVp - tempCurVp)) * num5));
      let mut Number1: i32 = 0;
      let mut areaCount3: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount3; index += 1)
      {
        if (this.AreaGroup[index] == this.CurrentAreaGroup)
        {
          let mut x: i32 = this.AreaCenter[index].x;
          let mut y: i32 = this.AreaCenter[index].y;
          if (this.GetRegime(this.AreaOwner[index]) == this.GetGameDataTurn())
            Number1 += this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].VP;
        }
      }
      if (makelog)
        this.AddLog("Our AI has " + Conversion.Str( Number1) + " VP prognosed.");
      bool flag;
      if (this.Attacker &&  this.game.Data.RuleVar[266] > 0.0 &  Number1 >=  this.game.Data.RuleVar[266])
      {
        strategyScoreForVp *= 20;
        flag = true;
        if (makelog)
          this.AddLog("CONSIDERED VICTORY *20");
      }
      if (!this.Attacker &&  this.game.Data.RuleVar[265] > 0.0 &  Number1 <=  this.game.Data.RuleVar[265] & this.AreaGroupCount == 1)
      {
        strategyScoreForVp -= 2000;
        flag = true;
        if (makelog)
          this.AddLog("CONSIDER LOST. subtracted -2000. ");
      }
      if ( (this.game.Data.Round + round) >  this.game.Data.RuleVar[844] &  this.game.Data.RuleVar[844] > 0.0)
      {
        if (this.Attacker & !flag)
        {
          strategyScoreForVp -= 2000;
          if (makelog)
            this.AddLog("CONSIDER LOST DUE TO PAST END OF SCENARIO DURATION. subtracted -2000. ");
        }
        else if (!this.Attacker & !flag)
          return 2000;
      }
      let mut num6: i32 = 0;
      let mut num7: i32 = 0;
      let mut areaCount4: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount4; index += 1)
      {
        if (!this.AreaIsExtra[index])
        {
          if (this.AreaOwner[index] == this.GetGameDataTurn() & this.StrOrigAreaOwner[index] != this.GetGameDataTurn())
            num6 += 1;
          if (this.AreaOwner[index] != this.GetGameDataTurn() & this.StrOrigAreaOwner[index] == this.GetGameDataTurn())
            num7 += 1;
        }
      }
      if (num6 > 0 | num7 > 0)
      {
        let mut Number2: i32 = num6 +  Math.Round( num6 * ( this.AverageVP / 2.0));
        let mut Number3: i32 = num7 +  Math.Round( num7 * ( this.AverageVP / 2.0));
        strategyScoreForVp = strategyScoreForVp + Number2 - Number3;
        if (makelog)
          this.AddLog("Score for Areas Added " + Conversion.Str( Number2) + " Score for Areas Lost -" + Conversion.Str( Number3));
      }
      return strategyScoreForVp;
    }

    pub fn GetClosestAreaThroughSupply(grp: i32) -> i32
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[] numArray3 = new int[this.AreaCount + 1];
      let mut areaThroughSupply: i32 = -1;
      let mut index1: i32 = -1;
      if (this.SupplyMatrix.GetUpperBound(0) < 2)
        return 0;
      if (this.GroupHis[grp] > -1)
      {
        index1 = this.game.HandyFunctionsObj.GetUnitByHistorical(this.GroupHis[grp]);
      }
      else
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut index2: i32 = 0; index2 <= unitCounter; index2 += 1)
        {
          if (this.game.Data.UnitObj[index2].PreDef == -1 && this.game.Data.UnitObj[index2].AIGroup == grp)
          {
            index1 = index2;
            break;
          }
        }
      }
      if (index1 == -1)
        return 0;
      let mut hq: i32 = this.game.Data.UnitObj[index1].HQ;
      if (hq == -1)
        return 0;
      if (hq > -1)
      {
        areaThroughSupply = -1;
        Coordinate coordinate;
        coordinate.onmap = true;
        coordinate.x = this.game.Data.UnitObj[index1].X;
        coordinate.y = this.game.Data.UnitObj[index1].Y;
        for (; areaThroughSupply == -1 & coordinate.onmap; coordinate = this.SupplyMatrixRealCameFrom[coordinate.x, coordinate.y])
        {
          let mut index3: i32 = this.AreaMatrixWide[coordinate.x, coordinate.y];
          if (index3 > 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime) == this.GetGameDataTurn())
            areaThroughSupply = index3;
        }
        if (areaThroughSupply == -1)
        {
          coordinate.onmap = true;
          coordinate.x = this.game.Data.UnitObj[index1].X;
          coordinate.y = this.game.Data.UnitObj[index1].Y;
          for (; areaThroughSupply == -1 & coordinate.onmap; coordinate = this.SupplyMatrixPrognosisCameFrom[coordinate.x, coordinate.y])
          {
            let mut index4: i32 = this.AreaMatrixWide[coordinate.x, coordinate.y];
            if (index4 > 0 && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index4].x, this.AreaCenter[index4].y].Regime) == this.GetGameDataTurn())
              areaThroughSupply = index4;
          }
        }
      }
      if (areaThroughSupply == -1)
        areaThroughSupply = 0;
      return areaThroughSupply;
    }

    pub fn GetStartArea(grp: i32) -> i32
    {
      Coordinate averageCorpsUnitCoord = this.GetAverageCorpsUnitCoord(grp, ReturnRoadHex: true);
      if (this.game.Data.Round == 1)
      {
        let mut groupHq: i32 = this.GetGroupHQ(grp);
        if (groupHq > -1)
        {
          let mut num: i32 = this.AreaMatrixNarrow[this.game.Data.UnitObj[groupHq].X, this.game.Data.UnitObj[groupHq].Y];
        }
      }
      let mut startArea: i32 = 0;
      if (startArea == 0 & this.AreaMatrixNarrow[averageCorpsUnitCoord.x, averageCorpsUnitCoord.y] > 0)
        startArea = this.AreaMatrixNarrow[averageCorpsUnitCoord.x, averageCorpsUnitCoord.y];
      if (startArea == 0)
        startArea = this.GetClosestAreaThroughSupply(grp);
      if (startArea == 0)
        startArea = this.AreaMatrixWide[averageCorpsUnitCoord.x, averageCorpsUnitCoord.y];
      return startArea;
    }

    pub fn GetHisAreaAsAIArea(hisarea: i32) -> i32
    {
      let mut areaCount: i32 = this.AreaCount;
      for (let mut hisAreaAsAiArea: i32 = 1; hisAreaAsAiArea <= areaCount; hisAreaAsAiArea += 1)
      {
        if (this.AreaIsHistoricalArea[hisAreaAsAiArea] == hisarea)
          return hisAreaAsAiArea;
      }
      return -1;
    }

    pub fn GetTotalVPonMap(bool OnlyVP = false) -> i32
    {
      totalVponMap: i32;
      if (this.Attacker | OnlyVP)
      {
        let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          {
            if (this.CurrentAreaGroup > 0)
            {
              if (this.AreaMatrixWide[index1, index2] > 0 && this.AreaGroup[this.AreaMatrixWide[index1, index2]] == this.CurrentAreaGroup)
              {
                totalVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
                if (!OnlyVP)
                  totalVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
              }
            }
            else
            {
              totalVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
              if (!OnlyVP)
                totalVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
            }
          }
        }
      }
      else if (this.CurrentAreaGroup > 0)
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount; index += 1)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup)
            totalVponMap += this.AreaFuzzyVP[index];
        }
      }
      else
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount; index += 1)
          totalVponMap += this.AreaFuzzyVP[index];
      }
      if (this.AreaExtraVP.GetUpperBound(0) < this.AreaCount)
        this.AreaExtraVP = new int[this.AreaCount + 1];
      if (!OnlyVP)
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount; index += 1)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup)
            totalVponMap += this.AreaExtraVP[index];
        }
      }
      return totalVponMap;
    }

    pub fn GetStartVPonMap(bool OnlyVP = false) -> i32
    {
      startVponMap: i32;
      if (this.Attacker | OnlyVP)
      {
        let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index1, index2].Regime) == this.GetGameDataTurn())
            {
              if (this.CurrentAreaGroup > 0)
              {
                if (this.AreaMatrixWide[index1, index2] > 0 && this.AreaGroup[this.AreaMatrixWide[index1, index2]] == this.CurrentAreaGroup)
                {
                  startVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
                  if (!OnlyVP)
                    startVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
                }
              }
              else
              {
                startVponMap += this.game.Data.MapObj[0].HexObj[index1, index2].VP;
                if (!OnlyVP)
                  startVponMap += this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[index1, index2];
              }
            }
          }
        }
      }
      else if (this.CurrentAreaGroup > 0)
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount; index += 1)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn())
            startVponMap += this.AreaFuzzyVP[index];
        }
      }
      else
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount; index += 1)
        {
          if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn())
            startVponMap += this.AreaFuzzyVP[index];
        }
      }
      if (!OnlyVP)
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 0; index <= areaCount; index += 1)
        {
          if (this.AreaGroup[index] == this.CurrentAreaGroup && this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn())
            startVponMap += this.AreaExtraVP[index];
        }
      }
      return startVponMap;
    }

    pub GetRandomFriendlyArea: i32(
      nr: i32,
      let mut not1: i32 = -1,
      let mut not2: i32 = -1,
      let mut not3: i32 = -1,
      let mut not4: i32 = -1,
      let mut not5: i32 = -1,
      let mut grp: i32 = -1,
      bool allowsame = false,
      let mut tAreaGroup: i32 = -1)
    {
      let mut num1: i32 = 0;
      let mut upperBound1: i32 = this.AreaCenter.GetUpperBound(0);
      for (let mut index: i32 = 1; index <= upperBound1; index += 1)
      {
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime) == this.GetGameDataTurn() && tAreaGroup == -1 | tAreaGroup == this.AreaGroup[index] && this.AreaSteps[nr, index] < 4 | nr == index & allowsame && !(!allowsame & nr == index))
        {
          let mut num2: i32 = 1;
          if (not1 == index | not2 == index | not3 == index | not4 == index | not5 == index)
            num2 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance[grp, index] >= 999)
              num2 = 0;
            if (nr == index)
              num2 = 1;
          }
          if (num2 == 1)
            num1 += 1;
        }
      }
      if (num1 <= 0)
        return 0;
      let mut num3: i32 =  Math.Round( (Conversion.Int( num1 * VBMath.Rnd()) + 1f));
      let mut num4: i32 = 0;
      let mut upperBound2: i32 = this.AreaCenter.GetUpperBound(0);
      for (let mut randomFriendlyArea: i32 = 1; randomFriendlyArea <= upperBound2; randomFriendlyArea += 1)
      {
        if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomFriendlyArea].x, this.AreaCenter[randomFriendlyArea].y].Regime) == this.GetGameDataTurn() && tAreaGroup == -1 | tAreaGroup == this.AreaGroup[randomFriendlyArea] && this.AreaSteps[nr, randomFriendlyArea] < 4 | nr == randomFriendlyArea & allowsame && !(!allowsame & nr == randomFriendlyArea))
        {
          let mut num5: i32 = 1;
          if (not1 == randomFriendlyArea | not2 == randomFriendlyArea | not3 == randomFriendlyArea | not4 == randomFriendlyArea | not5 == randomFriendlyArea)
            num5 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance[grp, randomFriendlyArea] >= 999)
              num5 = 0;
            if (nr == randomFriendlyArea)
              num5 = 1;
          }
          if (num5 == 1)
          {
            num4 += 1;
            if (num4 == num3)
              return randomFriendlyArea;
          }
        }
      }
      return 0;
    }

    pub fn SetRandomAreaNeighbour_new(tareagroup: i32)
    {
      this.RandomAreaNeighbourCount = new int[this.AreaCount + 1];
      this.RandomAreaNeighbour = new int[this.AreaCount + 1, this.AreaCount + 1];
      let mut areaCount: i32 = this.AreaCount;
      for (let mut index1: i32 = 1; index1 <= areaCount; index1 += 1)
      {
        this.RandomAreaNeighbourCount[index1] = -1;
        let mut num1: i32 = this.AreaSupplyBorderCount[index1];
        for (let mut index2: i32 = 0; index2 <= num1; index2 += 1)
        {
          let mut index3: i32 = index2 != -1 ? this.AreaSupplyBorder[index1, index2] : index1;
          if (index3 > 0 && tareagroup == -1 | tareagroup == this.AreaGroup[index3] && !(this.game.Data.RegimeObj[this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime].Sleep & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index1].x, this.AreaCenter[index1].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime)))
          {
            int[] areaNeighbourCount = this.RandomAreaNeighbourCount;
            int[] numArray = areaNeighbourCount;
            let mut index4: i32 = index1;
            let mut index5: i32 = index4;
            let mut num2: i32 = areaNeighbourCount[index4] + 1;
            numArray[index5] = num2;
            this.RandomAreaNeighbour[index1, this.RandomAreaNeighbourCount[index1]] = index3;
          }
        }
      }
    }

    pub GetRandomAreaNeighbourFromPreSet_new: i32(
      nr: i32,
      let mut not1: i32 = -1,
      let mut not2: i32 = -1,
      let mut not3: i32 = -1,
      let mut not4: i32 = -1,
      let mut not5: i32 = -1,
      let mut grp: i32 = -1,
      bool allowsame = false,
      let mut tAreaGroup: i32 = -1)
    {
      if (this.RandomAreaNeighbourCount[nr] <= -1)
        return 0;
      let mut num1: i32 =  Math.Round( Conversion.Int( (this.RandomAreaNeighbourCount[nr] + 1) * VBMath.Rnd()));
      let mut num2: i32 = 0;
      let mut num3: i32 = this.RandomAreaNeighbourCount[nr];
      for (let mut index: i32 = 0; index <= num3; index += 1)
      {
        let mut neighbourFromPreSetNew: i32 = this.RandomAreaNeighbour[nr, index];
        if (neighbourFromPreSetNew > 0)
        {
          let mut num4: i32 = 1;
          if (not1 == neighbourFromPreSetNew | not2 == neighbourFromPreSetNew | not3 == neighbourFromPreSetNew | not4 == neighbourFromPreSetNew | not5 == neighbourFromPreSetNew)
            num4 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance[grp, neighbourFromPreSetNew] >= 999)
              num4 = 0;
            if (!this.CorpsEngineer[grp] && this.AreaBorderNoBridge[nr, neighbourFromPreSetNew] == 0)
              num4 = 0;
            if (nr == neighbourFromPreSetNew)
              num4 = 1;
          }
          if (num4 == 1)
          {
            num2 += 1;
            if (num2 == num1)
              return neighbourFromPreSetNew;
          }
        }
      }
      return 0;
    }

    pub GetRandomAreaNeighbour_broad: i32(
      nr: i32,
      let mut not1: i32 = -1,
      let mut not2: i32 = -1,
      let mut not3: i32 = -1,
      let mut not4: i32 = -1,
      let mut not5: i32 = -1,
      let mut grp: i32 = -1,
      bool allowsame = false,
      let mut tAreaGroup: i32 = -1)
    {
      let mut num1: i32 = 0;
      let mut upperBound1: i32 = this.AreaCenter.GetUpperBound(0);
      for (let mut index: i32 = 1; index <= upperBound1; index += 1)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[index] && this.AreaBroadBorder[nr, index] > 0 & this.AreaBroadBorder[nr, index] < 99 | nr == index & allowsame && !(!allowsame & nr == index) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime)))
        {
          let mut num2: i32 = 1;
          if (not1 == index | not2 == index | not3 == index | not4 == index | not5 == index)
            num2 = 0;
          if (num2 == 1)
            num1 += 1;
        }
      }
      if (num1 <= 0)
        return 0;
      let mut num3: i32 =  Math.Round( (Conversion.Int( num1 * VBMath.Rnd()) + 1f));
      let mut num4: i32 = 0;
      let mut upperBound2: i32 = this.AreaCenter.GetUpperBound(0);
      for (let mut areaNeighbourBroad: i32 = 1; areaNeighbourBroad <= upperBound2; areaNeighbourBroad += 1)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[areaNeighbourBroad] && this.AreaBroadBorder[nr, areaNeighbourBroad] > 0 & this.AreaBroadBorder[nr, areaNeighbourBroad] < 99 | nr == areaNeighbourBroad & allowsame && !(!allowsame & nr == areaNeighbourBroad) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[areaNeighbourBroad].x, this.AreaCenter[areaNeighbourBroad].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[areaNeighbourBroad].x, this.AreaCenter[areaNeighbourBroad].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[areaNeighbourBroad].x, this.AreaCenter[areaNeighbourBroad].y].Regime)))
        {
          let mut num5: i32 = 1;
          if (not1 == areaNeighbourBroad | not2 == areaNeighbourBroad | not3 == areaNeighbourBroad | not4 == areaNeighbourBroad | not5 == areaNeighbourBroad)
            num5 = 0;
          if (num5 == 1)
          {
            num4 += 1;
            if (num4 == num3)
              return areaNeighbourBroad;
          }
        }
      }
      return 0;
    }

    pub GetRandomAreaNeighbour: i32(
      nr: i32,
      let mut not1: i32 = -1,
      let mut not2: i32 = -1,
      let mut not3: i32 = -1,
      let mut not4: i32 = -1,
      let mut not5: i32 = -1,
      let mut grp: i32 = -1,
      bool allowsame = false,
      let mut tAreaGroup: i32 = -1)
    {
      let mut num1: i32 = 0;
      if (grp > -1 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.AreaOwner[nr]) && this.FriendlySupply[nr] == 0)
        return this.GetRandomAreaNeighbour_broad(nr, not1, not2, not3, not4, not5, grp, true, tAreaGroup);
      let mut upperBound1: i32 = this.AreaCenter.GetUpperBound(0);
      for (let mut index: i32 = 1; index <= upperBound1; index += 1)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[index] && this.AreaBorder[nr, index] > 0 & this.AreaBorder[nr, index] < 99 | nr == index & allowsame && !(!allowsame & nr == index) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime)))
        {
          let mut num2: i32 = 1;
          if (not1 == index | not2 == index | not3 == index | not4 == index | not5 == index)
            num2 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance.GetUpperBound(0) >= grp && this.HisAreaDistance[grp, index] >= 999)
              num2 = 0;
            if (!this.CorpsEngineer[grp] && this.AreaBorderNoBridge[nr, index] == 0)
              num2 = 0;
            if (nr == index)
              num2 = 1;
          }
          if (num2 == 1)
            num1 += 1;
        }
      }
      if (num1 <= 0)
        return 0;
      let mut num3: i32 =  Math.Round( (Conversion.Int( num1 * VBMath.Rnd()) + 1f));
      let mut num4: i32 = 0;
      let mut upperBound2: i32 = this.AreaCenter.GetUpperBound(0);
      for (let mut randomAreaNeighbour: i32 = 1; randomAreaNeighbour <= upperBound2; randomAreaNeighbour += 1)
      {
        if (tAreaGroup == -1 | tAreaGroup == this.AreaGroup[randomAreaNeighbour] && this.AreaBorder[nr, randomAreaNeighbour] > 0 & this.AreaBorder[nr, randomAreaNeighbour] < 99 | nr == randomAreaNeighbour & allowsame && !(!allowsame & nr == randomAreaNeighbour) && !(this.game.HandyFunctionsObj.IsASleep(this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomAreaNeighbour].x, this.AreaCenter[randomAreaNeighbour].y].Regime) & !this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomAreaNeighbour].x, this.AreaCenter[randomAreaNeighbour].y].Regime)) && !this.game.HandyFunctionsObj.IsNeutral(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr].x, this.AreaCenter[nr].y].Regime), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[randomAreaNeighbour].x, this.AreaCenter[randomAreaNeighbour].y].Regime)))
        {
          let mut num5: i32 = 1;
          if (not1 == randomAreaNeighbour | not2 == randomAreaNeighbour | not3 == randomAreaNeighbour | not4 == randomAreaNeighbour | not5 == randomAreaNeighbour)
            num5 = 0;
          if (grp > -1)
          {
            if (this.HisAreaDistance.GetUpperBound(0) >= grp && this.HisAreaDistance[grp, randomAreaNeighbour] >= 999)
              num5 = 0;
            if (!this.CorpsEngineer[grp] && this.AreaBorderNoBridge[nr, randomAreaNeighbour] == 0)
              num5 = 0;
            if (nr == randomAreaNeighbour)
              num5 = 1;
          }
          if (num5 == 1)
          {
            num4 += 1;
            if (num4 == num3)
              return randomAreaNeighbour;
          }
        }
      }
      return 0;
    }

    pub fn GetAreaNeighbourCount(nr: i32) -> i32
    {
      let mut areaNeighbourCount: i32 = 0;
      let mut upperBound: i32 = this.AreaCenter.GetUpperBound(0);
      for (let mut index: i32 = 1; index <= upperBound; index += 1)
      {
        if (this.AreaBorder[nr, index] > 0)
          areaNeighbourCount += 1;
      }
      return areaNeighbourCount;
    }

    pub fn GetAreaEnemyNeighbourCount(nr: i32) -> i32
    {
      let mut enemyNeighbourCount: i32 = 0;
      let mut num: i32 = this.AreaSupplyBorderCount[nr];
      for (let mut index1: i32 = 0; index1 <= num; index1 += 1)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index1]] > 0)
        {
          let mut index2: i32 = this.AreaSupplyBorder[nr, index1];
          if (this.AreaOwner[nr] != this.AreaOwner[index2] & this.game.HandyFunctionsObj.IsHostileNotSelf2(this.AreaOwner[nr], this.AreaOwner[index2]))
          {
            if (!(this.GetGameDataTurn() != this.AreaOwner[nr] & this.GetGameDataTurn() != this.AreaOwner[index2]))
              enemyNeighbourCount += 1;
            else
              enemyNeighbourCount = enemyNeighbourCount;
          }
        }
      }
      return enemyNeighbourCount;
    }

    pub fn GetAreaEnemyNeighbourCountFuzzyVP(nr: i32) -> i32
    {
      let mut neighbourCountFuzzyVp: i32 = 0;
      let mut num: i32 = this.AreaSupplyBorderCount[nr];
      for (let mut index1: i32 = 0; index1 <= num; index1 += 1)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index1]] > 0)
        {
          let mut index2: i32 = this.AreaSupplyBorder[nr, index1];
          if (this.game.HandyFunctionsObj.IsHostileNotSelf2(this.AreaOwner[nr], this.AreaOwner[index2]))
            neighbourCountFuzzyVp += this.AreaFuzzyVP[index2];
        }
      }
      return neighbourCountFuzzyVp;
    }

    pub fn GetAreaFriendlyNeighbourCount(nr: i32) -> i32
    {
      let mut friendlyNeighbourCount: i32 = 0;
      let mut num: i32 = this.AreaSupplyBorderCount[nr];
      for (let mut index: i32 = 0; index <= num; index += 1)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index]] > 0 & this.GetGameDataTurn() == this.GetRegime(this.AreaOwner[this.AreaSupplyBorder[nr, index]]))
          friendlyNeighbourCount += 1;
      }
      return friendlyNeighbourCount;
    }

    pub fn GetAreaFriendlyNeighbourCount2(nr: i32) -> i32
    {
      let mut friendlyNeighbourCount2: i32 = 0;
      let mut num: i32 = this.AreaSupplyBorderCount[nr];
      for (let mut index: i32 = 0; index <= num; index += 1)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index]] > 0 & this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetGameDataTurn(), this.GetRegime(this.AreaOwner[this.AreaSupplyBorder[nr, index]])))
          friendlyNeighbourCount2 += 1;
      }
      return friendlyNeighbourCount2;
    }

    pub fn GetAreaFriendlyNeighbourFuzzyVPCount(nr: i32) -> i32
    {
      let mut neighbourFuzzyVpCount: i32 = 0;
      let mut num: i32 = this.AreaSupplyBorderCount[nr];
      for (let mut index: i32 = 0; index <= num; index += 1)
      {
        if (this.AreaBorder[nr, this.AreaSupplyBorder[nr, index]] > 0 & this.GetGameDataTurn() == this.GetRegime(this.AreaOwner[this.AreaSupplyBorder[nr, index]]))
          neighbourFuzzyVpCount += this.AreaFuzzyVP[index];
      }
      return neighbourFuzzyVpCount;
    }

    pub IsAreaSupplySource: bool(i: i32, regnr: i32)
    {
      let mut location: i32 = this.game.Data.MapObj[0].HexObj[this.AreaCenter[i].x, this.AreaCenter[i].y].Location;
      return this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[i].x, this.AreaCenter[i].y].Regime) == this.GetRegime(regnr) && location > -1 && this.game.Data.LocTypeObj[this.game.Data.LocObj[location].Type].MaxProd > 0;
    }

    pub fn GetScoreForReconquestOfImportance() -> i32
    {
      let mut reconquestOfImportance: i32 = 0;
      if ( this.game.Data.RuleVar[335] > 0.0)
      {
        let mut num: i32 = 0;
        do
        {
          if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num * 4)))] > 0)
          {
            let mut regime: i32 = this.game.Data.MapObj[0].HexObj[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))]].Regime;
            let mut nr: i32 = this.TempCounterOwner[this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))]];
            if (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(regime), this.GetGameDataTurn()) && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(nr), this.GetGameDataTurn()))
              reconquestOfImportance += 2000;
            if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(regime), this.GetGameDataTurn()) && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(nr), this.GetGameDataTurn()))
              reconquestOfImportance -= 2000;
          }
          num += 1;
        }
        while (num <= 3);
      }
      return reconquestOfImportance;
    }

    pub fn MakeSupplyCounterOwnerMatrix()
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyCounterMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.SupplyCounterMatrix[index1, index2] = 9999;
          numArray1[index1, index2] = 0;
        }
      }
      if ( this.game.Data.RuleVar[335] <= 0.0)
        return;
      let mut num: i32 = 0;
      do
      {
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num * 4)))] > 0)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))], 0, DontCountEnemyRoads: true, UseCounterOwner: true);
          let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
            {
              if (this.SupplyCounterMatrix[index3, index4] > this.game.EditObj.TempValue[0].Value[index3, index4])
                this.SupplyCounterMatrix[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
            }
          }
        }
        num += 1;
      }
      while (num <= 3);
    }

    pub fn MakeSupplyTempOwnerMatrix()
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.SupplyTempOwnerMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.SupplyCounterMatrix[index1, index2] = 9999;
          numArray1[index1, index2] = 0;
        }
      }
      if ( this.game.Data.RuleVar[335] <= 0.0)
        return;
      let mut num: i32 = 0;
      do
      {
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 3f +  (num * 4)))] > 0)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.GetGameDataTurn(),  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 0.0f +  (num * 4)))], this.game.Data.RegimeObj[this.GetGameDataTurn()].RegimeSlot[ Math.Round( (this.game.Data.RuleVar[335] + 1f +  (num * 4)))], 0, DontCountEnemyRoads: true, UseCounterOwner: true, UseTempOwner: true);
          let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
            {
              if (this.SupplyTempOwnerMatrix[index3, index4] > this.game.EditObj.TempValue[0].Value[index3, index4])
                this.SupplyTempOwnerMatrix[index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
            }
          }
        }
        num += 1;
      }
      while (num <= 3);
    }

    pub Coordinate GetDefindedAreaCapitol(areanr: i32)
    {
      SimpleList simpleList = SimpleList::new();
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut tdata1: i32 = 0; tdata1 <= mapWidth; tdata1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut tdata2: i32 = 0; tdata2 <= mapHeight; tdata2 += 1)
        {
          if (this.game.Data.AreaObj[areanr].Code == this.game.Data.MapObj[0].HexObj[tdata1, tdata2].AreaCode[this.game.Data.AreaObj[areanr].Slot])
          {
            let mut tweight: i32 = 0;
            tid: i32;
            tid += 1;
            if (this.game.Data.MapObj[0].HexObj[tdata1, tdata2].Location > -1)
              tweight = 10;
            if (this.game.Data.MapObj[0].HexObj[tdata1, tdata2].VP > 0)
              tweight += this.game.Data.MapObj[0].HexObj[tdata1, tdata2].VP * 10;
            simpleList.Add(tid, tweight, tdata1, tdata2);
          }
        }
      }
      simpleList.Sort();
      Coordinate defindedAreaCapitol;
      defindedAreaCapitol.onmap = false;
      if (simpleList.Counter > -1)
      {
        defindedAreaCapitol.onmap = true;
        defindedAreaCapitol.x = simpleList.Data1[0];
        defindedAreaCapitol.y = simpleList.Data2[0];
      }
      return defindedAreaCapitol;
    }

    pub fn MakeAdvanceAxisMatrix()
    {
      this.AdvanceAxisMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.FullAdvanceMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.ptemp = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.ptemp2 = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      Coordinate coordinate1;
      coordinate1.x = -1;
      Coordinate coordinate2;
      coordinate2.x = -1;
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      Coordinate coordinate3;
      coordinate3.onmap = false;
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.AdvanceAxisMatrix[index1, index2] = -1;
          this.FullAdvanceMatrix[index1, index2] = 0;
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIDefend > this.AreaCount || this.game.Data.UnitObj[groupHq].AIFallback > this.AreaCount || this.game.Data.UnitObj[groupHq].AIAttack > this.AreaCount || this.game.Data.UnitObj[groupHq].AIFollowup > this.AreaCount)
        return;
      Coordinate coordinate4;
      if (this.game.Data.UnitObj[groupHq].AIFallback > -1 & this.game.Data.UnitObj[groupHq].AIDefend > -1)
      {
        coordinate1 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback];
        coordinate2 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
        if (coordinate1.onmap & coordinate2.onmap)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
          coordinate4 = coordinate2;
          coordinate3 = coordinate2;
          this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
          for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIDefend > -1 & this.game.Data.UnitObj[groupHq].AIAttack > -1)
      {
        coordinate1 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
        coordinate2 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack];
        if (coordinate1.onmap & coordinate2.onmap)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
          coordinate4 = coordinate2;
          coordinate3 = coordinate2;
          this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
          for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & this.game.Data.UnitObj[groupHq].AIFollowup > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].y].Regime != -1)
      {
        coordinate1 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack];
        coordinate2 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFollowup];
        if (coordinate1.onmap & coordinate2.onmap)
        {
          this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
          coordinate4 = coordinate2;
          coordinate3 = coordinate2;
          this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
          for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            this.AdvanceAxisMatrix[coordinate4.x, coordinate4.y] = 0;
        }
      }
      num1: i32;
      if (coordinate1.x > -1 & coordinate2.x > -1)
      {
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), coordinate2.x, coordinate2.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate1.x, TarY: coordinate1.y, TarMap: 0);
        coordinate4 = coordinate1;
        this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
        num2: i32;
        num1 = num2 + 1;
        for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate2.x & coordinate4.y == coordinate2.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
        {
          this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
          num1 += 1;
        }
        if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & this.game.Data.UnitObj[groupHq].AIFollowup > -1 && this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIAttack].y].Regime != -1)
        {
          coordinate4.x = -1;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
            coordinate4 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
          else if (this.CorpsLoc[this.OpGroup] > -1)
            coordinate4 = this.AreaCenter[this.CorpsLoc[this.OpGroup]];
          if (coordinate4.x > -1)
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate4.x, TarY: coordinate4.y, TarMap: 0);
            this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
            num1 += 1;
            for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            {
              this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = 0;
              num1 += 1;
            }
          }
        }
      }
      if (coordinate1.x > -1 & coordinate2.x > -1)
      {
        let mut num3: i32 = num1 + 3;
        this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), coordinate1.x, coordinate1.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate2.x, TarY: coordinate2.y, TarMap: 0);
        coordinate4 = coordinate2;
        this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num3;
        let mut num4: i32 = num3 - 1;
        for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate4.x == coordinate1.x & coordinate4.y == coordinate1.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
        {
          this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num4;
          --num4;
        }
        if (this.game.Data.UnitObj[groupHq].AIAttack > -1 & this.game.Data.UnitObj[groupHq].AIFollowup > -1)
        {
          coordinate4.x = -1;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
            coordinate4 = this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend];
          else if (this.CorpsLoc[this.OpGroup] > -1)
            coordinate4 = this.AreaCenter[this.CorpsLoc[this.OpGroup]];
          if (coordinate4.x > -1)
          {
            this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[99]), 99,  Math.Round( this.game.Data.RuleVar[3]), coordinate4.x, coordinate4.y, 0, dontenterenemy: false, NoAPPenalties: true, SeaBlock: true, NoBridgePenalty: true, TarX: coordinate1.x, TarY: coordinate1.y, TarMap: 0);
            Coordinate coordinate5 = coordinate4;
            coordinate4 = coordinate1;
            this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num4;
            let mut num5: i32 = num4 - 1;
            for (coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y]; coordinate4.onmap & !(coordinate5.x == coordinate4.x & coordinate5.y == coordinate4.y); coordinate4 = this.game.EditObj.TempCameFrom[0].Value[coordinate4.x, coordinate4.y])
            {
              this.FullAdvanceMatrix[coordinate4.x, coordinate4.y] = num5;
              --num5;
            }
          }
        }
      }
      let mut num6: i32 = 1;
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      while (num6 == 1)
      {
        num6 = 0;
        let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray[cx, cy] == 0 && this.FullAdvanceMatrix[cx, cy] > 0)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap && numArray[coordinate1.x, coordinate1.y] == 0 & this.FullAdvanceMatrix[coordinate1.x, coordinate1.y] <= 0 &&  Math.Round( this.FullAdvanceMatrix[cx, cy] * 0.75) > this.FullAdvanceMatrix[coordinate1.x, coordinate1.y])
                {
                  this.FullAdvanceMatrix[coordinate1.x, coordinate1.y] =  Math.Round( this.FullAdvanceMatrix[cx, cy] * 0.75);
                  num6 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
              numArray[cx, cy] = 1;
            }
          }
        }
      }
      let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index3: i32 = 0; index3 <= mapWidth3; index3 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
        {
          this.ptemp[index3, index4] = 0;
          if (this.AdvanceAxisMatrix[index3, index4] > -1)
          {
            if ( this.SupplyMatrixReal[index3, index4] <  this.game.Data.RuleVar[53])
            {
              this.ptemp[index3, index4] = 1;
              this.ptemp2[index3, index4] = 1;
            }
            else
            {
              this.AdvanceAxisMatrix[index3, index4] = -1;
              this.ptemp2[index3, index4] = 1;
            }
          }
        }
      }
      let mut num7: i32 = 0;
      num8: i32;
      do
      {
        num8 = 0;
        num7 += 1;
        let mut mapWidth4: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth4; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (this.ptemp[cx, cy] == num7)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate1.onmap & this.ptemp[coordinate1.x, coordinate1.y] == 0 & this.ptemp2[coordinate1.x, coordinate1.y] == 1)
                {
                  this.ptemp[coordinate1.x, coordinate1.y] = num7 + 1;
                  this.AdvanceAxisMatrix[cx, cy] = num7;
                  num8 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      while (num8 == 1 & num7 < 4);
    }

    pub fn AddVirtualUnits(area: i32, power: i32, bool tlog)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          numArray[index1, index2] = -1;
      }
      if (tlog)
        this.AddLog("");
      if (tlog)
        this.AddLog("VIRTUAL UNITS:");
      Coordinate coordinate;
      if (this.AreaCounterDirections[area, 1] == 0)
      {
        let mut num1: i32 = -1;
        let mut regimeCounter: i32 = this.game.Data.RegimeCounter;
        for (let mut reg2: i32 = 0; reg2 <= regimeCounter; reg2 += 1)
        {
          if (!this.game.Data.RegimeObj[reg2].Sleep & !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetGameDataTurn(), reg2))
          {
            num2: i32;
            num1 = num2;
            break;
          }
        }
        if (num1 > -1)
        {
          let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
            {
              if (this.AreaMatrixNarrow[cx, cy] == area & this.game.Data.MapObj[0].HexObj[cx, cy].Location > -1)
              {
                let mut tfacing: i32 = 1;
                do
                {
                  coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                  if (coordinate.onmap && this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                  {
                    numArray[coordinate.x, coordinate.y] = num1;
                    break;
                  }
                  tfacing += 1;
                }
                while (tfacing <= 6);
              }
            }
          }
        }
      }
      else
      {
        let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth3; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (this.AreaMatrixNarrow[cx, cy] == area)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap)
                {
                  let mut num3: i32 = 0;
                  let mut num4: i32 = this.AreaMatrixNarrow[coordinate.x, coordinate.y];
                  let mut index: i32 = 1;
                  while (this.AreaCounterDirections[area, index] != num4)
                  {
                    index += 1;
                    if (index > 9)
                      goto label_38;
                  }
                  num3 = 1;
                  let mut num5: i32 = this.AreaCounterRegime[area, index];
label_38:
                  if (num3 == 1)
                    numArray[coordinate.x, coordinate.y] = num5;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      CoordList coordList = CoordList::new();
      let mut mapWidth4: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x: i32 = 0; x <= mapWidth4; x += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y: i32 = 0; y <= mapHeight; y += 1)
        {
          if (numArray[x, y] > -1)
            coordList.AddCoord(x, y, 0);
        }
      }
      let mut num: i32 = 0;
      if (coordList.counter <= -1)
        return;
      while (num < 50 & power > 0 & num <= this.MoveMatrixCounter * 3)
      {
        num += 1;
        let mut index3: i32 =  Math.Round( ( coordList.counter * VBMath.Rnd()));
        coordinate = coordList.coord[index3];
        if (coordinate.onmap)
        {
          let mut randomUnit: i32 = this.GetRandomUnit(numArray[coordinate.x, coordinate.y]);
          if (randomUnit > -1)
          {
            this.game.Data.AddUnit(coordinate.x, coordinate.y, 0);
            this.game.HandyFunctionsObj.CopyUnit(this.game.Data.UnitCounter, randomUnit);
            this.game.Data.UnitObj[this.game.Data.UnitCounter].IsVirtual = true;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Regime = numArray[coordinate.x, coordinate.y];
            this.game.Data.UnitObj[this.game.Data.UnitCounter].X = coordinate.x;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Y = coordinate.y;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].TempType = this.game.Data.UnitObj[this.game.Data.UnitCounter].TempType;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].TempCategory = this.game.Data.UnitObj[this.game.Data.UnitCounter].TempCategory;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].TempTypeRoad = this.game.Data.UnitObj[this.game.Data.UnitCounter].TempTypeRoad;
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Map = 0;
            power -= this.game.HandyFunctionsObj.GetPowerPtsAbsolute(randomUnit);
            this.game.Data.UnitObj[this.game.Data.UnitCounter].Name = "VIRTUAL " + this.game.Data.UnitObj[this.game.Data.UnitCounter].Name;
            if (tlog)
              this.AddLog("Copy of " + this.game.Data.UnitObj[randomUnit].Name + " added on " + coordinate.x.ToString() + "," + coordinate.y.ToString());
            this.MakeTempMovementType(this.game.Data.UnitCounter);
            let mut sfCount: i32 = this.game.Data.UnitObj[this.game.Data.UnitCounter].SFCount;
            for (let mut index4: i32 = 0; index4 <= sfCount; index4 += 1)
            {
              let mut sf: i32 = this.game.Data.UnitObj[this.game.Data.UnitCounter].SFList[index4];
              this.game.Data.SFObj[sf].Rdn = 100;
              this.game.Data.SFObj[sf].Ap = 100;
            }
          }
        }
      }
    }

    pub fn removevirtualUnits()
    {
      for (let mut unitCounter: i32 = this.game.Data.UnitCounter; unitCounter >= 0; unitCounter += -1)
      {
        if (this.game.Data.UnitObj[unitCounter].IsVirtual)
        {
          data: DataClass = this.game.Data;
          let mut nr: i32 = unitCounter;
          let mut gameClass: GameClass = (GameClass) null;
           let mut local: GameClass =  gameClass;
          data.RemoveUnit(nr,  local);
        }
      }
    }

    pub fn GetRandomUnit(regnr: i32) -> i32
    {
      num: i32;
      for (; num < 100; num += 1)
      {
        let mut unr: i32 =  Math.Round( (VBMath.Rnd() *  this.game.Data.UnitCounter));
        if (this.game.Data.UnitObj[unr].Regime == regnr & !this.game.Data.UnitObj[unr].IsHQ & this.game.Data.UnitObj[unr].PreDef == -1 & !this.game.Data.UnitObj[unr].IsVirtual && !this.game.HandyFunctionsObj.HasUnitAirSF(unr) & !this.game.HandyFunctionsObj.HasUnitNavySF(unr))
          return unr;
      }
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].Regime == regnr & !this.game.Data.UnitObj[unr].IsHQ && !this.game.HandyFunctionsObj.HasUnitAirSF(unr) & !this.game.HandyFunctionsObj.HasUnitNavySF(unr) && this.game.Data.UnitObj[unr].PreDef > -1 & this.game.Data.UnitObj[unr].Regime == regnr)
          return unr;
      }
      return -1;
    }

    pub MaybeeExecuteAttackMarkers: bool()
    {
      bool flag = false;
      let mut counter1: i32 = this.AirMarkerList.Counter;
      Coordinate Target;
      for (let mut index1: i32 = 0; index1 <= counter1; index1 += 1)
      {
        if (this.AirMarkerList.Weight[index1] == 1 & this.AirMarkerList.Data3[index1] > -1)
        {
          let mut scoreForAirAttack: i32 = this.GetScoreForAirAttack(this.AirMarkerList.Data3[index1], this.AirMarkerList.Data4[index1], false, true);
          if (scoreForAirAttack > 0)
          {
            this.game.TempCombat = new CombatClass(this.game);
            Target.x = this.AirMarkerList.Data3[index1];
            Target.y = this.AirMarkerList.Data4[index1];
            this.game.EditObj.TempUnitList = UnitList::new();
            this.JoinUnitsAirAttack(Target.x, Target.y,  this.game.EditObj.TempUnitList);
            this.AddLog("AIR ATTACK ON " + Conversion.Str( Target.x) + "," + Conversion.Str( Target.y) + " with points score = " + Conversion.Str( scoreForAirAttack));
            s: String = "PARTICIPANTS: ";
            let mut counter2: i32 = this.game.EditObj.TempUnitList.counter;
            for (let mut index2: i32 = 0; index2 <= counter2; index2 += 1)
            {
              if (index2 > 0)
                s += ", ";
              s += this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index2]].Name;
            }
            this.AddLog(s);
            this.game.TempCombat.Init(Target, 1, this.game.EditObj.TempUnitList, 14);
            this.game.TempCombat.DoBattle();
            this.game.TempCombat.EndBattle();
            flag = true;
            this.game.TempCombat = (CombatClass) null;
            this.MakeTempMovementTypes(false);
            let mut num: i32 = index1;
            let mut counter3: i32 = this.AirMarkerList.Counter;
            for (let mut index3: i32 = num; index3 <= counter3; index3 += 1)
            {
              if (this.AirMarkerList.Data3[index3] == this.AirMarkerList.Data3[index1] & this.AirMarkerList.Data4[index3] == this.AirMarkerList.Data4[index1])
                this.AirMarkerList.Weight[index3] = 0;
            }
          }
        }
      }
      let mut counter4: i32 = this.ArtMarkerList.Counter;
      for (let mut index4: i32 = 0; index4 <= counter4; index4 += 1)
      {
        if (this.ArtMarkerList.Weight[index4] == 1)
        {
          let mut scoreForArtAttack: i32 = this.GetScoreForArtAttack(this.ArtMarkerList.Data3[index4], this.ArtMarkerList.Data4[index4], false, true);
          if (scoreForArtAttack > 0)
          {
            this.game.TempCombat = new CombatClass(this.game);
            Target.x = this.ArtMarkerList.Data3[index4];
            Target.y = this.ArtMarkerList.Data4[index4];
            this.game.EditObj.TempUnitList = UnitList::new();
            this.JoinUnitsArtilleryAttack(Target.x, Target.y,  this.game.EditObj.TempUnitList);
            this.AddLog("ARTILLERY ATTACK ON " + Conversion.Str( Target.x) + "," + Conversion.Str( Target.y) + " with points score = " + Conversion.Str( scoreForArtAttack));
            s: String = "PARTICIPANTS: ";
            let mut counter5: i32 = this.game.EditObj.TempUnitList.counter;
            for (let mut index5: i32 = 0; index5 <= counter5; index5 += 1)
            {
              if (index5 > 0)
                s += ", ";
              s += this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index5]].Name;
            }
            this.AddLog(s);
            this.game.TempCombat.Init(Target, 1, this.game.EditObj.TempUnitList, 11);
            this.game.TempCombat.DoBattle();
            this.game.TempCombat.EndBattle();
            flag = true;
            this.game.TempCombat = (CombatClass) null;
            this.MakeTempMovementTypes(false);
            let mut num: i32 = index4;
            let mut counter6: i32 = this.ArtMarkerList.Counter;
            for (let mut index6: i32 = num; index6 <= counter6; index6 += 1)
            {
              if (this.ArtMarkerList.Data3[index6] == this.ArtMarkerList.Data3[index4] & this.ArtMarkerList.Data4[index6] == this.ArtMarkerList.Data4[index4])
                this.ArtMarkerList.Weight[index6] = 0;
            }
          }
        }
      }
      let mut counter7: i32 = this.MarkerList.Counter;
      for (let mut index7: i32 = 0; index7 <= counter7; index7 += 1)
      {
        if (this.MarkerList.Weight[index7] == 1)
        {
          this.AddLog("CHECK");
          let mut scoreForAttack: i32 = this.GetScoreForAttack(this.MarkerList.Data3[index7], this.MarkerList.Data4[index7], false, true);
          if (scoreForAttack > 0)
          {
            this.AddLog("REAL TRY");
            let mut num1: i32 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
            let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
              num1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
              num1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
            if (Operators.CompareString(this.game.Data.UnitObj[groupHq].Name, "X Corps", false) == 0)
              ;
            if (this.Attacker)
            {
              if ( this.CorpsTopRatio[this.OpGroup] > 1.0)
                num1 =  Math.Round( num1 / Math.Sqrt( Math.Min(9f, this.CorpsTopRatio[this.OpGroup])));
              num1 =  Math.Round( num1 * 0.9);
            }
            if (scoreForAttack >= num1)
            {
              this.game.TempCombat = new CombatClass(this.game);
              Target.x = this.MarkerList.Data3[index7];
              Target.y = this.MarkerList.Data4[index7];
              this.game.EditObj.OrderType = 2;
              this.game.EditObj.TempUnitList = UnitList::new();
              this.JoinUnitsInLandAttack(Target.x, Target.y,  this.game.EditObj.TempUnitList);
              if (this.game.EditObj.TempUnitList.counter > -1)
              {
                this.AddLog("ATTACK ON " + Conversion.Str( Target.x) + "," + Conversion.Str( Target.y) + " with points score = " + Conversion.Str( scoreForAttack));
                s: String = "PARTICIPANTS: ";
                let mut counter8: i32 = this.game.EditObj.TempUnitList.counter;
                for (let mut index8: i32 = 0; index8 <= counter8; index8 += 1)
                {
                  if (index8 > 0)
                    s += ", ";
                  s += this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index8]].Name;
                }
                this.AddLog(s);
                this.game.TempCombat.Init(Target, 1, this.game.EditObj.TempUnitList, 2);
                this.game.TempCombat.DoBattle();
                this.game.TempCombat.EndBattle();
                flag = true;
                this.game.TempCombat = (CombatClass) null;
                this.MakeTempMovementTypes(false);
                let mut num2: i32 = index7;
                let mut counter9: i32 = this.MarkerList.Counter;
                for (let mut index9: i32 = num2; index9 <= counter9; index9 += 1)
                {
                  if (this.MarkerList.Data3[index9] == this.MarkerList.Data3[index7] & this.MarkerList.Data4[index9] == this.MarkerList.Data4[index7])
                    this.MarkerList.Weight[index9] = 0;
                }
              }
            }
          }
        }
      }
      return flag;
    }

    pub fn ExecuteBestMove( SimpleList TempMove, bool IsSimulation)
    {
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
      {
        this.game.Data.UnitObj[index].TempX = -1;
        this.game.Data.UnitObj[index].TempY = -1;
      }
      let mut counter1: i32 = TempMove.Counter;
      for (let mut index1: i32 = 0; index1 <= counter1; index1 += 1)
      {
        if (TempMove.Weight[index1] >= 1)
        {
          let mut unitslot: i32 = TempMove.Data1[index1];
          if (unitslot > -1)
          {
            let mut unr: i32 = this.MoveMatrixUnit[unitslot];
            let mut num1: i32 = 0;
            do
            {
              let mut num2: i32 = 0;
              if (num1 == 0 & this.game.Data.UnitObj[unr].IsHQ)
                num2 = 1;
              if (num1 == 1 & this.game.Data.UnitObj[unr].TempCategory == 3)
                num2 = 1;
              if (num1 == 1 & this.game.Data.UnitObj[unr].TempCategory == 2)
                num2 = 1;
              if (num1 == 1 & this.game.Data.UnitObj[unr].TempCategory == 5)
                num2 = 1;
              if (num1 == 2 & this.game.Data.UnitObj[unr].TempCategory == 1)
                num2 = 1;
              if (num1 == 2 & this.game.Data.UnitObj[unr].TempCategory == 4)
                num2 = 1;
              if (num1 == 2 & this.game.Data.UnitObj[unr].TempCategory <= 0)
                num2 = 1;
              if (num1 > 0 & this.game.Data.UnitObj[unr].IsHQ)
                num2 = 0;
              if (num2 == 1)
              {
                let mut x1: i32 = this.game.Data.UnitObj[unr].X;
                let mut y1: i32 = this.game.Data.UnitObj[unr].Y;
                let mut x2: i32 = TempMove.Data3[index1];
                let mut y2: i32 = TempMove.Data4[index1];
                if (this.game.Data.UnitObj[unr].TempStrategic && this.game.Data.UnitObj[unr].TempCategory != 3 && !this.game.Data.UnitObj[unr].IsHQ && this.CanBeStrategiclyTransferred(unr))
                {
                  Coordinate closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 4, unitslot);
                  if (closeFriendlyRoadHex.onmap)
                  {
                    x2 = closeFriendlyRoadHex.x;
                    y2 = closeFriendlyRoadHex.y;
                  }
                }
                if (this.game.Data.UnitObj[unr].IsHQ)
                  unr = unr;
                if (this.game.Data.UnitObj[unr].TempCategory == 3)
                {
                  let mut index2: i32 = this.AirMarkerList.Data1[TempMove.Data2[index1]];
                  let mut index3: i32 = this.AirMarkerList.Data2[TempMove.Data2[index1]];
                  if (!(x1 == index2 & y1 == index3))
                  {
                    this.game.HandyFunctionsObj.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, ismove: true);
                    if (this.game.EditObj.TempValue[0].Value[index2, index3] < 9999)
                    {
                      this.AddLog("AIR MOVING " + this.game.Data.UnitObj[unr].Name + " TO <" + Conversion.Str( index2) + "," + Conversion.Str( index3) + ">");
                      this.game.ProcessingObj.ExecuteMovement(unr, x1, y1, 0, index2, index3, 0);
                    }
                  }
                }
                else
                {
                  let mut num3: i32 = 0;
                  if (this.MoveMatrix[unitslot, x2, y2] < 9999)
                  {
                    this.game.HandyFunctionsObj.MakeMovePrediction(unr, this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, ismove: true);
                    if (!(x1 == x2 & y1 == y2))
                    {
                      while (!this.game.EditObj.TempCameFrom[0].Value[x2, y2].onmap & !(x1 == x2 & y1 == y2))
                      {
                        num3 += 1;
                        sCoordinate sCoordinate = this.MoveMatrixCameFrom[unitslot, x2, y2];
                        Coordinate coordinate;
                        coordinate.x =  sCoordinate.x;
                        coordinate.y =  sCoordinate.y;
                        coordinate.onmap = sCoordinate.onmap;
                        if (!(x2 == 0 & y2 == 0 & coordinate.x == 0 & coordinate.y == 0))
                        {
                          x2 = coordinate.x;
                          y2 = coordinate.y;
                          if (num3 > 199)
                            break;
                        }
                        else
                          break;
                      }
                      if (!(x1 == x2 & y1 == y2))
                      {
                        if (this.game.EditObj.TempValue[0].Value[x2, y2] < 9999)
                        {
                          this.AddLog("MOVING " + this.game.Data.UnitObj[unr].Name + " TO <" + Conversion.Str( x2) + "," + Conversion.Str( y2) + ">");
                          this.game.ProcessingObj.ExecuteMovement(unr, x1, y1, 0, x2, y2, 0);
                          if (this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter <= 15)
                            ;
                        }
                        if (this.game.Data.UnitObj[unr].X == x2 & this.game.Data.UnitObj[unr].Y == y2 && this.game.Data.UnitObj[unr].TempCategory == 4 & this.EngineerMarkerList.Counter > -1)
                        {
                          this.game.HandyFunctionsObj.InfraHexHighlight(x2, y2, 0, unr);
                          let mut index4: i32 = this.EngineerMarkerList.Data3[TempMove.Data2[index1]];
                          let mut index5: i32 = this.EngineerMarkerList.Data4[TempMove.Data2[index1]];
                          if (index4 > -1)
                          {
                            let mut facing: i32 = this.game.HandyFunctionsObj.HexFacing(x2, y2, 0, index4, index5, 0) - 1;
                            if (this.game.EditObj.TempValue[0].Value[index4, index5] == 0 & facing >= 0)
                            {
                              this.game.ProcessingObj.BuildInfra(unr, x2, y2, 0, facing);
                              this.AddLog("ENGINEER " + this.game.Data.UnitObj[unr].Name + " BUILD BRIDGE FROM <" + Conversion.Str( x2) + "," + Conversion.Str( y2) + "> to <" + Conversion.Str( index4) + "," + Conversion.Str( index5));
                            }
                          }
                        }
                      }
                    }
                  }
                  else
                    this.AddLog(this.game.Data.UnitObj[unr].Name + " DID NOT MOVE. Because move prognosis thinks it can never reach that point. ");
                }
              }
              num1 += 1;
            }
            while (num1 <= 2);
          }
        }
      }
      if (this.Attacker)
        return;
      let mut unitCounter2: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter2; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].AIGroup == this.OpGroup && this.game.Data.UnitObj[unr].AIAttackStyle == 1 & (this.game.Data.UnitObj[unr].TempCategory == 1 | this.game.Data.UnitObj[unr].TempCategory == 4))
        {
          let mut index6: i32 = this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y];
          if (index6 > 0 & this.game.Data.UnitObj[unr].AIAttack == -1 && this.AreaBridges[index6].Counter > -1)
          {
            let mut counter2: i32 = this.AreaBridges[index6].Counter;
            for (let mut index7: i32 = 0; index7 <= counter2; index7 += 1)
            {
              let mut index8: i32 = this.AreaBridges[index6].Id[index7];
              if (index8 > 0 && this.AreaBridges[index6].Data1[index7] == this.game.Data.UnitObj[unr].X & this.AreaBridges[index6].Data2[index7] == this.game.Data.UnitObj[unr].Y | this.AreaBridges[index6].Data3[index7] == this.game.Data.UnitObj[unr].X & this.AreaBridges[index6].Data4[index7] == this.game.Data.UnitObj[unr].Y && this.game.HandyFunctionsObj.IsHostileNotSelf2(this.GetGameDataTurn(), this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index8].x, this.AreaCenter[index8].y].Regime)))
              {
                this.game.EditObj.OrderX = this.game.Data.UnitObj[unr].X;
                this.game.EditObj.OrderY = this.game.Data.UnitObj[unr].Y;
                num4: i32;
                num5: i32;
                if (this.AreaBridges[index6].Data1[index7] == this.game.Data.UnitObj[unr].X & this.AreaBridges[index6].Data2[index7] == this.game.Data.UnitObj[unr].Y)
                {
                  num4 = this.AreaBridges[index6].Data3[index7];
                  num5 = this.AreaBridges[index6].Data4[index7];
                }
                else
                {
                  num4 = this.AreaBridges[index6].Data1[index7];
                  num5 = this.AreaBridges[index6].Data2[index7];
                }
                let mut facing: i32 = this.game.HandyFunctionsObj.HexFacing(this.game.EditObj.OrderX, this.game.EditObj.OrderY, 0, num4, num5, 0) - 1;
                if (facing >= 0 && this.game.Data.MapObj[0].HexObj[this.game.EditObj.OrderX, this.game.EditObj.OrderY].Bridge[facing] &&  this.game.Data.RuleVar[505] == 0.0 &  this.game.Data.RuleVar[809] == 0.0)
                {
                  this.AddLog("BLOW BRIDGE ATTEMPT TOWARDS " + Conversion.Str( num4) + "," + Conversion.Str( num5));
                  this.game.ProcessingObj.BlowBridge(unr, this.game.EditObj.OrderX, this.game.EditObj.OrderY, 0, facing);
                }
                this.game.EditObj.OrderX = -1;
                this.game.EditObj.OrderY = -1;
              }
            }
          }
        }
      }
    }

    pub fn GetSameCoordinateMarker(unr: i32, SimpleList tlist) -> i32
    {
      let mut counter: i32 = tlist.Counter;
      for (let mut coordinateMarker: i32 = 0; coordinateMarker <= counter; coordinateMarker += 1)
      {
        if ((tlist.Weight[coordinateMarker] == 5 | tlist.Data3[coordinateMarker] == -1) & tlist.Data1[coordinateMarker] == this.game.Data.UnitObj[unr].X & tlist.Data2[coordinateMarker] == this.game.Data.UnitObj[unr].Y || tlist.Data1[coordinateMarker] == this.game.Data.UnitObj[unr].X & tlist.Data2[coordinateMarker] == this.game.Data.UnitObj[unr].Y)
          return coordinateMarker;
      }
      return -1;
    }

    pub SimpleList GetRandomAttackMarkers(
      movematrixnr: i32,
      SimpleList tlist,
      AverageSupplyPercentage: i32)
    {
      let mut num1: i32 = this.MoveMatrixUnit[movematrixnr];
      SimpleList randomAttackMarkers1 = SimpleList::new();
      SimpleList randomAttackMarkers2 = SimpleList::new();
      if (num1 == -1)
        return randomAttackMarkers1;
      let mut counter: i32 = tlist.Counter;
      for (let mut tid: i32 = 0; tid <= counter; tid += 1)
      {
        if (tlist.Weight[tid] == 1 & tlist.Data3[tid] > -1)
        {
          if (AverageSupplyPercentage < 20 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 1)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 20 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 2)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 20 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 3)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 35 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 1)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 35 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 2)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (AverageSupplyPercentage < 50 & this.DistanceFromSuppliedHex[tlist.Data3[tid], tlist.Data4[tid]] <= 1)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 35)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 20)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else if (this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 5)
          {
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
          }
          else
            randomAttackMarkers1.Add(tid, this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]], tlist.Data1[tid], tlist.Data2[tid], tlist.Data3[tid], tlist.Data4[tid]);
        }
      }
      if (randomAttackMarkers1.Counter > -1)
      {
        randomAttackMarkers1.Sort();
        let mut index1: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (Math.Min(10, randomAttackMarkers1.Counter) + 1)));
        let mut num2: i32 = Math.Min(10, randomAttackMarkers1.Counter);
        for (let mut index2: i32 = 0; index2 <= num2; index2 += 1)
        {
          if (randomAttackMarkers1.Data3[index2] == randomAttackMarkers1.Data3[index1] & randomAttackMarkers1.Data4[index2] == randomAttackMarkers1.Data4[index1])
            randomAttackMarkers2.Add(randomAttackMarkers1.Id[index2], 1);
        }
      }
      return randomAttackMarkers2;
    }

    pub SimpleList GetRandomBottleneckMarkers(movematrixnr: i32, SimpleList tlist)
    {
      let mut num: i32 = this.MoveMatrixUnit[movematrixnr];
      SimpleList bottleneckMarkers = SimpleList::new();
      SimpleList simpleList = SimpleList::new();
      if (num == -1)
        return bottleneckMarkers;
      let mut counter: i32 = tlist.Counter;
      for (let mut tid: i32 = 0; tid <= counter; tid += 1)
      {
        if ( this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]] > 5.0 +  VBMath.Rnd() * 20.0)
          bottleneckMarkers.Add(tid,  Math.Round( this.MoveMatrix[movematrixnr, tlist.Data1[tid], tlist.Data2[tid]] /  this.BottleNeckMatrix[tlist.Data1[tid], tlist.Data2[tid]]), tlist.Data1[tid], tlist.Data2[tid], tlist.Data1[tid], tlist.Data2[tid]);
      }
      bottleneckMarkers.Sort();
      return bottleneckMarkers;
    }

    pub fn ReturnShockAndAweMarker(SimpleList tMarkerlist, float trnd, UnitSlot: i32, unr: i32) -> i32
    {
      let mut num1: i32 = 0;
      let mut counter1: i32 = this.MarkerList.Counter;
      for (let mut index1: i32 = 0; index1 <= counter1; index1 += 1)
      {
        if (this.MarkerList.Weight[index1] == 1)
        {
          let mut num2: i32 = 0;
          let mut num3: i32 = 0;
          let mut counter2: i32 = this.ArtMarkerList.Counter;
          for (let mut index2: i32 = 0; index2 <= counter2; index2 += 1)
          {
            if (this.ArtMarkerList.Weight[index2] == 1 & this.ArtMarkerList.Data3[index2] == this.MarkerList.Data3[index1] & this.ArtMarkerList.Data4[index2] == this.MarkerList.Data4[index1])
              num2 = 1;
          }
          if (this.ArtMarkerList.Counter < 1)
            num2 = 1;
          let mut counter3: i32 = this.AirMarkerList.Counter;
          for (let mut index3: i32 = 0; index3 <= counter3; index3 += 1)
          {
            if (this.AirMarkerList.Weight[index3] == 1 & this.AirMarkerList.Data3[index3] == this.MarkerList.Data3[index1] & this.AirMarkerList.Data4[index3] == this.MarkerList.Data4[index1])
              num3 = 1;
          }
          if (this.AirMarkerList.Counter < 1)
            num3 = 1;
          if (num2 == 1 & num3 == 1)
            num1 += 1;
        }
      }
      if (num1 == 0)
        return -1;
      let mut counter4: i32 = this.MarkerList.Counter;
      for (let mut index4: i32 = 0; index4 <= counter4; index4 += 1)
      {
        if (this.MarkerList.Weight[index4] == 1)
        {
          let mut num4: i32 = 0;
          let mut num5: i32 = 0;
          let mut counter5: i32 = this.ArtMarkerList.Counter;
          for (let mut index5: i32 = 0; index5 <= counter5; index5 += 1)
          {
            if (this.ArtMarkerList.Weight[index5] == 1 & this.ArtMarkerList.Data3[index5] == this.MarkerList.Data3[index4] & this.ArtMarkerList.Data4[index5] == this.MarkerList.Data4[index4])
              num4 = 1;
          }
          if (this.ArtMarkerList.Counter < 1)
            num4 = 1;
          let mut counter6: i32 = this.AirMarkerList.Counter;
          for (let mut index6: i32 = 0; index6 <= counter6; index6 += 1)
          {
            if (this.AirMarkerList.Weight[index6] == 1 & this.AirMarkerList.Data3[index6] == this.MarkerList.Data3[index4] & this.AirMarkerList.Data4[index6] == this.MarkerList.Data4[index4])
              num5 = 1;
          }
          if (this.AirMarkerList.Counter < 1)
            num5 = 1;
          if (num4 == 1 & num5 == 1)
          {
            num6: i32;
            num6 += 1;
            if (num6 ==  Math.Round( Conversion.Int(trnd *  num1)) + 1)
            {
              let mut counter7: i32 = tMarkerlist.Counter;
              num7: i32;
              for (let mut index7: i32 = 0; index7 <= counter7; index7 += 1)
              {
                if (this.MoveMatrix[UnitSlot, tMarkerlist.Data1[index7], tMarkerlist.Data2[index7]] < 9999 | this.game.Data.UnitObj[unr].X == tMarkerlist.Data1[index7] & this.game.Data.UnitObj[unr].Y == tMarkerlist.Data2[index7] && tMarkerlist.Data3[index7] == this.MarkerList.Data3[index4] & tMarkerlist.Data4[index7] == this.MarkerList.Data4[index4])
                  num7 += 1;
              }
              let mut num8: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  num7)) + 1;
              if (num7 > 0)
              {
                let mut counter8: i32 = tMarkerlist.Counter;
                for (let mut index8: i32 = 0; index8 <= counter8; index8 += 1)
                {
                  num9: i32;
                  if (this.MoveMatrix[UnitSlot, tMarkerlist.Data1[index8], tMarkerlist.Data2[index8]] < 9999 | this.game.Data.UnitObj[unr].X == tMarkerlist.Data1[index8] & this.game.Data.UnitObj[unr].Y == tMarkerlist.Data2[index8] && tMarkerlist.Data3[index8] == this.MarkerList.Data3[index4] & tMarkerlist.Data4[index8] == this.MarkerList.Data4[index4])
                    num9 += 1;
                  if (num9 == num8)
                    return index8;
                }
              }
              return -1;
            }
          }
        }
      }
      return -1;
    }

    pub fn FindBestMove()
    {
      this.LogCounter2 = -1;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].X > -1 & this.game.Data.UnitObj[unr].PreDef == -1)
        {
          this.game.Data.UnitObj[unr].TempUnitPower = this.GetUnitPower(unr, false);
          this.game.Data.UnitObj[unr].TempCombatImprovePercent = this.game.HandyFunctionsObj.GetCombatImprovePercent(unr);
          if (this.OpGroup == 1)
            this.AddLog2(this.game.Data.UnitObj[unr].Name + " TEMPUNITPOWER = " + Conversion.Str( this.game.Data.UnitObj[unr].TempUnitPower) + " , COMBATIMPRPERCENT=" + Conversion.Str( this.game.Data.UnitObj[unr].TempCombatImprovePercent));
        }
      }
      this.AAM1.x = this.game.Data.MapObj[0].MapWidth;
      this.AAM1.y = this.game.Data.MapObj[0].MapHeight;
      this.AAM2.x = -1;
      this.AAM2.y = -1;
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      index1: i32;
      for (index1 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          if (this.FullAdvanceMatrix[index1, index2] > 0)
          {
            if (index1 < this.AAM1.x)
              this.AAM1.x = index1;
            if (index2 < this.AAM1.y)
              this.AAM1.y = index2;
            if (index1 > this.AAM2.x)
              this.AAM2.x = index1;
            if (index2 > this.AAM2.y)
              this.AAM2.y = index2;
          }
        }
      }
      this.CMS1.x = this.game.Data.MapObj[0].MapWidth;
      this.CMS2.y = this.game.Data.MapObj[0].MapHeight;
      this.CMS2.x = -1;
      this.CMS2.y = -1;
      let mut enemyMatrixCounter: i32 = this.EnemyMatrixCounter;
      for (let mut index3: i32 = 1; index3 <= enemyMatrixCounter; index3 += 1)
      {
        let mut index4: i32 = this.EnemyMatrixUnit[index3];
        index1 = this.game.Data.UnitObj[index4].X;
        let mut y: i32 = this.game.Data.UnitObj[index4].Y;
        if (Math.Max(0, index1 - 10) < this.CMS1.x)
          this.CMS1.x = Math.Max(0, index1 - 10);
        if (Math.Max(0, y - 10) < this.CMS1.y)
          this.CMS1.y = Math.Max(0, y - 10);
        if (Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10) > this.CMS2.x)
          this.CMS2.x = Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10);
        if (Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10) > this.CMS2.y)
          this.CMS2.y = Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10);
      }
      let mut num1: i32 = 0;
      let mut num2: i32 = 0;
      let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
      for (let mut index5: i32 = 0; index5 <= moveMatrixCounter1; index5 += 1)
      {
        let mut index6: i32 = this.MoveMatrixUnit[index5];
        num1 += this.game.Data.UnitObj[index6].SupplyIn;
        num2 += this.game.Data.UnitObj[index6].SupplyInReq;
        index1 = this.game.Data.UnitObj[index6].X;
        let mut y: i32 = this.game.Data.UnitObj[index6].Y;
        if (Math.Max(0, index1 - 10) < this.CMS1.x)
          this.CMS1.x = Math.Max(0, index1 - 10);
        if (Math.Max(0, y - 10) < this.CMS1.y)
          this.CMS1.y = Math.Max(0, y - 10);
        if (Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10) > this.CMS2.x)
          this.CMS2.x = Math.Min(this.game.Data.MapObj[0].MapWidth, index1 + 10);
        if (Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10) > this.CMS2.y)
          this.CMS2.y = Math.Min(this.game.Data.MapObj[0].MapHeight, y + 10);
      }
      let mut num3: i32 = num2 + 1;
      this.AverageSupplyPercentage =  Math.Round(100.0 * ( num1 /  num3));
      let mut num4: i32 = 0;
      SimpleList simpleList1 = SimpleList::new();
      let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
      SimpleList simpleList2;
      for (let mut tdata1: i32 = 0; tdata1 <= moveMatrixCounter2; tdata1 += 1)
      {
        let mut index7: i32 = this.MoveMatrixUnit[tdata1];
        if (this.game.Data.UnitObj[index7].Historical > -1)
        {
          let mut historical: i32 = this.game.Data.UnitObj[index7].Historical;
          if (this.game.Data.HistoricalUnitObj[historical].TempTargetX > -1)
          {
            if (this.game.Data.UnitObj[index7].TempCategory == 1)
              simpleList2 = this.MarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 2)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 5)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 3)
              simpleList2 = this.AirMarkerList;
            if (this.game.Data.UnitObj[index7].TempCategory == 4)
              simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
            let mut counter: i32 = simpleList2.Counter;
            tid: i32;
            for (let mut tdata2: i32 = 0; tdata2 <= counter; tdata2 += 1)
            {
              if (this.game.Data.HistoricalUnitObj[historical].TempTargetAttackX > -1)
              {
                if (simpleList2.Data1[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetX & simpleList2.Data2[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetY & simpleList2.Data3[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetAttackX & simpleList2.Data4[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetAttackY)
                {
                  tid += 1;
                  simpleList1.Add(tid, 1, tdata1, tdata2, simpleList2.Data1[tdata2], simpleList2.Data2[tdata2], CheckExistence: false);
                  this.MoveMatrixUnitMarker[tdata1] = tdata2;
                  num4 = 1;
                }
              }
              else if (simpleList2.Data1[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetX & simpleList2.Data2[tdata2] == this.game.Data.HistoricalUnitObj[historical].TempTargetY)
              {
                tid += 1;
                simpleList1.Add(tid, 1, tdata1, tdata2, simpleList2.Data1[tdata2], simpleList2.Data2[tdata2], CheckExistence: false);
                this.MoveMatrixUnitMarker[tdata1] = tdata2;
                num4 = 1;
              }
            }
          }
        }
      }
      if (num4 == 1)
      {
        this.BestMove = simpleList1;
      }
      else
      {
        bool flag1 = true;
        GC.Collect();
        VBMath.Randomize( (this.game.Data.Turn + this.game.Data.Round + this.game.Data.MapObj[0].MapWidth));
        let mut Number1: i32 = -9999;
        let mut Number2: i32 = 0;
        this.Meeting = false;
        bool flag2 = this.GetLargestArmy() == this.GetGameDataTurn();
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 1)
          this.Attacker = true;
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 2)
          this.Attacker = false;
        if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 3)
          this.Meeting = true;
        this.HistoryScoreList = SimpleList::new();
        this.HistoryMoveCounter = 0;
        this.BestMove = (SimpleList) null;
        if (this.MarkerList.Counter == -1)
          return;
        let mut tid: i32 = 0;
        let mut Number3: i32 = this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE;
        if (this.MoveMatrixCounter > 15)
          Number3 =  Math.Round( Number3 * Math.Sqrt( this.MoveMatrixCounter / 15.0));
        if (this.MoveAndAttackRound > 1)
          Number3 =  Math.Round( Number3 /  this.MoveAndAttackRound);
        if (this.MoveMatrixCounter <= 1)
        {
          Number3 =  Math.Round( Number3 / 4.0);
          if (this.GroupType[this.OpGroup] >= 5)
            Number3 =  Math.Round( Number3 / 4.0);
        }
        else if (this.MoveMatrixCounter <= 2)
          Number3 =  Math.Round( Number3 / 3.0);
        else if (this.MoveMatrixCounter <= 3)
          Number3 =  Math.Round( Number3 / 2.5);
        else if (this.MoveMatrixCounter <= 4)
          Number3 =  Math.Round( Number3 / 2.0);
        else if (this.MoveMatrixCounter <= 5)
          Number3 =  Math.Round( Number3 / 1.5);
        if (Number3 < 10)
          Number3 = 10;
        let mut num5: i32 = 99999;
        let mut num6: i32 = 9999;
        let mut num7: i32 = 9999;
        let mut num8: i32 = 9999;
        let mut index8: i32 = 1;
        do
        {
          this.MoveMatrixUnitMarker[index8] = -1;
          this.TempMoveMatrixUnitMarker[index8] = -1;
          index8 += 1;
        }
        while (index8 <= 90);
        if (flag1)
          this.AddLog2("MAXMOVE = " + Conversion.Str( Number3));
        bool quicktest = false;
        let mut num9: i32 = this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus <= 100 & this.CorpsStance[this.OpGroup] == 3 ? 1 : 0;
        num10: i32;
        while (Number2 < Number3)
        {
          SimpleList TempMove = SimpleList::new();
          Number2 += 1;
          if (flag1)
          {
            this.AddLog2("");
            this.AddLog2("******** " + Number2.ToString());
          }
          num11: i32;
          if (Number2 > num11)
            quicktest = false;
          if (Number2 == 1 | Number2 % 20 == 0)
          {
            this.game.EditObj.AIProgressMax = Number3;
            this.game.EditObj.AIProgressNow = Number2;
            this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + ". Round " + Conversion.Str( this.MoveAndAttackRound) + ". " + Strings.Trim(Conversion.Str(  Math.Round( Number2 /  Number3 * 100.0))) + "% completed.";
          }
          bool flag3 = false;
          if (Number2 + 10 < Number3)
          {
            if ( VBMath.Rnd() < 0.02)
            {
              num6 = 9999;
              flag3 = true;
            }
            else if ( VBMath.Rnd() < 0.02)
            {
              num7 = 9999;
              flag3 = true;
            }
          }
          let mut index9: i32 = 1;
          do
          {
            this.MoveMatrixUnitMarker[index9] = -1;
            index9 += 1;
          }
          while (index9 <= 90);
          SimpleList simpleList3 = SimpleList::new();
          float num12 = VBMath.Rnd();
          float trnd = VBMath.Rnd();
          VBMath.Rnd();
          VBMath.Rnd();
          let mut moveMatrixCounter3: i32 = this.MoveMatrixCounter;
          num13: i32;
          num14: i32;
          num15: i32;
          num16: i32;
          for (let mut index10: i32 = 1; index10 <= moveMatrixCounter3; index10 += 1)
          {
            let mut index11: i32 = this.MoveMatrixUnit[index10];
            if (index11 > -1)
            {
              if (this.game.Data.UnitObj[index11].TempCategory == 1)
                simpleList2 = this.MarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 2)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 5)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 3)
                simpleList2 = this.AirMarkerList;
              if (this.game.Data.UnitObj[index11].TempCategory == 4)
                simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
              tdata2_1: i32;
              num17: i32;
              if (this.game.Data.UnitObj[index11].TempStrategic)
              {
                if (flag1)
                  this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Strategic Move");
                let mut index12: i32 = this.game.Data.UnitObj[index11].AIAttackStyle != 3 ? this.game.Data.UnitObj[index11].AIDefend : this.game.Data.UnitObj[index11].AIAttack;
                if (index12 > -1)
                {
                  let mut x: i32 = this.AreaCenter[index12].x;
                  let mut y: i32 = this.AreaCenter[index12].y;
                  let mut num18: i32 = -1;
                  if (this.game.Data.MapObj[0].HexObj[x, y].UnitCounter > -1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
                  {
                    let mut counter: i32 = simpleList2.Counter;
                    for (let mut index13: i32 = 0; index13 <= counter; index13 += 1)
                    {
                      if (this.GetTscore(simpleList2.Data1[index13], simpleList2.Data2[index13]) > num18)
                      {
                        x = simpleList2.Data1[index13];
                        y = simpleList2.Data2[index13];
                        num18 = this.GetTscore(x, y);
                      }
                    }
                  }
                  tdata2_1 = -1;
                  let mut counter1: i32 = simpleList2.Counter;
                  for (let mut index14: i32 = 0; index14 <= counter1; index14 += 1)
                  {
                    if (simpleList2.Data1[index14] == x & simpleList2.Data2[index14] == y)
                      tdata2_1 = index14;
                  }
                  if (tdata2_1 == -1)
                  {
                    simpleList2.Add(50000 + tid, 2, x, y, -1, -1);
                    tdata2_1 = simpleList2.Counter;
                  }
                  TempMove.Add(tid, 1, index10, tdata2_1, x, y, CheckExistence: false, CheckData1Existence: true);
                  num17 = 0;
                  this.MoveMatrixUnitMarker[index10] = tdata2_1;
                }
              }
              else if (!Information.IsNothing( simpleList2))
              {
                if (flag3 |  Number2 <=  Number3 / 8.0)
                {
                  if (flag1)
                    this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Random OR Doctrines");
                  tid += 1;
                  let mut num19: i32 = 1;
                  let mut num20: i32 = 0;
                  if ((this.Attacker &  num12 < 0.1 | !this.Attacker &  num12 < 0.05) & !this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => ShockAwe Doctrine");
                    tdata2_1 = this.ReturnShockAndAweMarker(simpleList2, trnd, index10, index11);
                    if (tdata2_1 > -1)
                    {
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                      if (tdata3 == 13)
                        tdata3 = tdata3;
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if ((this.Attacker &  num12 < 0.1 | !this.Attacker &  num12 < 0.05) & this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => HQ in focus Doctrine");
                    tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                    if (tdata2_1 > -1)
                    {
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num5 >= Number2)
                  {
                    num13 += 1;
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Do not move doctrine");
                    tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                    num5 = Number2;
                    if (tdata2_1 > -1)
                    {
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num6 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & !this.game.Data.UnitObj[index11].IsHQ)
                  {
                    num14 += 1;
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Center Target Doctrine");
                    tdata2_1 = this.game.Data.UnitObj[index11].AIAttack <= -1 ? this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y) : this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].y);
                    num6 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num6 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Central Target Doctrine (HQ behind)");
                    if (this.game.Data.UnitObj[index11].AIFallback > -1)
                      tdata2_1 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].y);
                    else if (this.game.Data.UnitObj[index11].AIDefend > -1)
                      tdata2_1 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y);
                    num6 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num7 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & !this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Closest Target");
                    num15 += 1;
                    tdata2_1 = this.GetMarkerForClosestEnemy(index11, this.AverageSupplyPercentage);
                    num7 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  else if (num7 >= Number2 & (this.game.Data.UnitObj[index11].AIAttack > -1 | this.game.Data.UnitObj[index11].AIDefend > -1) & this.game.Data.UnitObj[index11].IsHQ)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => Closest Target (HQ)");
                    let mut tdata2_2: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                    let mut tdata3: i32 = simpleList2.Data1[tdata2_2];
                    let mut tdata4: i32 = simpleList2.Data2[tdata2_2];
                    TempMove.Add(tid, 1, index10, tdata2_2, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                    num19 = 0;
                    this.MoveMatrixUnitMarker[index10] = tdata2_2;
                  }
                  else if (num8 >= Number2 & this.game.Data.UnitObj[index11].AIDefend > -1)
                  {
                    if (flag1)
                      this.AddLog2(this.game.Data.UnitObj[index11].Name + " => To Defend Area!");
                    num16 += 1;
                    tdata2_1 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y);
                    num8 = Number2;
                    if (tdata2_1 > -1 && tdata2_1 > -1)
                    {
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                      TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_1;
                    }
                  }
                  while (num19 == 1 & num20 < 100)
                  {
                    num20 += 1;
                    let mut tdata2_3: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                    if (this.MoveMatrix[index10, simpleList2.Data1[tdata2_3], simpleList2.Data2[tdata2_3]] < 9999 | this.game.Data.UnitObj[index11].X == simpleList2.Data1[tdata2_3] & this.game.Data.UnitObj[index11].Y == simpleList2.Data2[tdata2_3])
                    {
                      tdata3: i32;
                      tdata4: i32;
                      if ( VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index11].TempCategory == 1)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM : MUTATED MARKER");
                        tdata3 =  Math.Round( ( simpleList2.Data1[tdata2_3] + Conversion.Int( ( VBMath.Rnd() * 4.0 - 2.0))));
                        tdata4 =  Math.Round( ( simpleList2.Data2[tdata2_3] + Conversion.Int( ( VBMath.Rnd() * 4.0 - 2.0))));
                        if (tdata3 < 0 | tdata4 < 0 | tdata3 > this.game.Data.MapObj[0].MapWidth | tdata4 > this.game.Data.MapObj[0].MapHeight)
                        {
                          tdata3 = simpleList2.Data1[tdata2_3];
                          tdata4 = simpleList2.Data2[tdata2_3];
                        }
                        if (this.MoveMatrix[index10, tdata3, tdata4] >= 9999)
                        {
                          tdata3 = simpleList2.Data1[tdata2_3];
                          tdata4 = simpleList2.Data2[tdata2_3];
                        }
                      }
                      else if ( VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index11].TempCategory != 3 & this.CorpsStance[this.OpGroup] == 1)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM AIR : Own Coordinate");
                        tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                        if (tdata2_1 > -1)
                          tdata2_3 = tdata2_1;
                        tdata3 = simpleList2.Data1[tdata2_3];
                        tdata4 = simpleList2.Data2[tdata2_3];
                      }
                      else if ( VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index11].IsHQ)
                      {
                        tdata2_1 = this.GetSameCoordinateMarker(index11, simpleList2);
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM HQ : Different Coordinate");
                        if (tdata2_1 > -1)
                          tdata2_3 = tdata2_1;
                        tdata3 = simpleList2.Data1[tdata2_3];
                        tdata4 = simpleList2.Data2[tdata2_3];
                      }
                      else
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => RANDOM : RANDOM MARKER");
                        tdata3 = simpleList2.Data1[tdata2_3];
                        tdata4 = simpleList2.Data2[tdata2_3];
                      }
                      tid += 1;
                      TempMove.Add(tid, 1, index10, tdata2_3, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                      num19 = 0;
                      this.MoveMatrixUnitMarker[index10] = tdata2_3;
                    }
                  }
                }
                else
                {
                  Random random = new Random(Number2 + this.game.Data.Round * 4002);
                  float num21 =  Math.Sqrt(Math.Sqrt( ( random.Next(0, 100000) / 100000f)));
                  let mut num22: i32 = 0;
                  if (Number2 >= Number3 - 2)
                  {
                    num21 = 1f;
                    num22 = 1;
                    if (flag1)
                      this.AddLog2("MODE: Mutate top record. Special for HQ positioning");
                  }
                  else if (random.Next(0, 100) > 30)
                  {
                    num21 = 1f;
                    num22 = 1;
                    if (flag1)
                      this.AddLog2("MODE: Mutate top record");
                  }
                  else if (random.Next(0, 100) < 50)
                  {
                    if ( VBMath.Rnd() > 0.5)
                      num21 = 1f;
                    if (flag1)
                      this.AddLog2("MODE: Mix old record with top record OR Doctrine");
                  }
                  else
                  {
                    if ( VBMath.Rnd() > 0.5)
                      num21 =  Math.Sqrt(Math.Sqrt( VBMath.Rnd()));
                    if (flag1)
                      this.AddLog2("MODE: Mix old record with other old record OR Doctrine");
                  }
                  float num23 =  VBMath.Rnd() >= 0.33 ? ( VBMath.Rnd() >= 0.5 ?  Math.Min(0.6,  (8f /  (1 + this.MoveMatrixCounter))) :  Math.Min(0.45,  (4f /  (1 + this.MoveMatrixCounter)))) :  Math.Min(0.3,  (2f /  (1 + this.MoveMatrixCounter)));
                  for (let mut tdata2_4: i32 = this.HistoryScoreList.Counter; tdata2_4 >= 0; tdata2_4 += -1)
                  {
                    let mut num24: i32 = this.HistoryScoreList.Weight[this.HistoryScoreList.Counter] - this.HistoryScoreList.Weight[0];
                    if ( ( (this.HistoryScoreList.Weight[tdata2_4] - this.HistoryScoreList.Weight[0]) /  num24) <=  num21)
                    {
                      let mut index15: i32 = this.HistoryScoreList.Id[tdata2_4];
                      tid += 1;
                      if (Number2 == Number3 - 2)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM SELF + GIVE DEFENSIVE LOC TO HQ");
                        let mut nr: i32 = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          let mut unr: i32 = this.MoveMatrixUnit[this.HistoryMove[index15].Data1[nr]];
                          tdata2_1 = -1;
                          if (this.game.Data.UnitObj[unr].IsHQ)
                          {
                            tdata2_1 = this.GetNormalDefensiveCenterMarker(unr, this.HistoryMove[index15].Data1[nr]);
                            if (tdata2_1 > -1)
                            {
                              TempMove.Add(tid, 1, index10, tdata2_1, this.MarkerList.Data1[tdata2_1], this.MarkerList.Data2[tdata2_1], CheckExistence: false, CheckData1Existence: true);
                              this.MoveMatrixUnitMarker[index10] = tdata2_1;
                            }
                          }
                          if (tdata2_1 == -1)
                          {
                            TempMove.Add(tid, 1, index10, this.HistoryMove[index15].Data2[nr], this.HistoryMove[index15].Data3[nr], this.HistoryMove[index15].Data4[nr], this.HistoryMove[index15].Data5[nr], false, true);
                            this.MoveMatrixUnitMarker[index10] = this.HistoryMove[index15].Data2[nr];
                            break;
                          }
                          break;
                        }
                        break;
                      }
                      if (Number2 == Number3 - 1)
                      {
                        if (flag1)
                          this.AddLog(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM SELF + GIVE FALLBACK LOC TO HQ");
                        let mut nr: i32 = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          let mut unr: i32 = this.MoveMatrixUnit[this.HistoryMove[index15].Data1[nr]];
                          tdata2_1 = -1;
                          if (this.game.Data.UnitObj[unr].IsHQ)
                          {
                            tdata2_1 = this.GetNormalFallbackCenterMarker(unr, this.HistoryMove[index15].Data1[nr]);
                            if (tdata2_1 > -1)
                            {
                              TempMove.Add(tid, 1, index10, tdata2_1, this.MarkerList.Data1[tdata2_1], this.MarkerList.Data2[tdata2_1], CheckExistence: false, CheckData1Existence: true);
                              this.MoveMatrixUnitMarker[index10] = tdata2_1;
                            }
                          }
                          if (tdata2_1 == -1)
                          {
                            TempMove.Add(tid, 1, index10, this.HistoryMove[index15].Data2[nr], this.HistoryMove[index15].Data3[nr], this.HistoryMove[index15].Data4[nr], this.HistoryMove[index15].Data5[nr], false, true);
                            this.MoveMatrixUnitMarker[index10] = this.HistoryMove[index15].Data2[nr];
                            break;
                          }
                          break;
                        }
                        break;
                      }
                      if ( VBMath.Rnd() >  num23)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM SELF");
                        let mut nr: i32 = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          TempMove.Add(tid, 1, index10, this.HistoryMove[index15].Data2[nr], this.HistoryMove[index15].Data3[nr], this.HistoryMove[index15].Data4[nr], this.HistoryMove[index15].Data5[nr], false, true);
                          this.MoveMatrixUnitMarker[index10] = this.HistoryMove[index15].Data2[nr];
                          break;
                        }
                        break;
                      }
                      num25: i32;
                      if ( VBMath.Rnd() < 0.25 & num22 == 0)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => COPY MARKER FROM OTHER STRAT.");
                        let mut nr: i32 = this.HistoryMove[index15].FindNr(-1, index10);
                        if (nr > -1)
                        {
                          tid += 1;
                          tdata2_4 = this.HistoryMove[index15].Data2[nr];
                          let mut tdata3: i32 = this.HistoryMove[index15].Data3[nr];
                          let mut tdata4: i32 = this.HistoryMove[index15].Data4[nr];
                          TempMove.Add(tid, 1, index10, tdata2_4, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                          break;
                        }
                        tdata2_4 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                        let mut tdata3_1: i32 = simpleList2.Data1[tdata2_4];
                        let mut tdata4_1: i32 = simpleList2.Data2[tdata2_4];
                        tid += 1;
                        TempMove.Add(tid, 1, index10, tdata2_4, tdata3_1, tdata4_1, CheckExistence: false, CheckData1Existence: true);
                        num17 = 0;
                        this.MoveMatrixUnitMarker[index10] = tdata2_4;
                        num25 = -1;
                        break;
                      }
                      if (num22 == 0)
                      {
                        let mut num26: i32 =  Math.Round( (VBMath.Rnd() * 100f));
                        num27: i32;
                        num28: i32;
                        num29: i32;
                        if ( Math.Round( (VBMath.Rnd() * 100f)) < 50)
                        {
                          num27 = index10;
                          num28 = index10;
                          num29 = 0;
                          if (flag1)
                            this.AddLog2(this.game.Data.UnitObj[index11].Name + " => DOCTRINE. JUST THIS UNIT.");
                        }
                        else
                        {
                          num27 = 1;
                          num28 = this.MoveMatrixCounter;
                          num29 = 1;
                          if (flag1)
                            this.AddLog2(this.game.Data.UnitObj[index11].Name + " => DOCTRINE. FULL HISTORICAL.");
                        }
                        let mut num30: i32 = num27;
                        let mut num31: i32 = num28;
                        for (let mut tdata1: i32 = num30; tdata1 <= num31; tdata1 += 1)
                        {
                          let mut num32: i32 = 0;
                          if ( this.game.Data.RuleVar[356] == 0.0)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical == this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Historical & this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Historical > -1 | num29 == 0 && this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].TempCategory)
                              num32 = 1;
                          }
                          else if (index10 == tdata1 |  VBMath.Rnd() > 2.0 /  this.MoveMatrixCounter && this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].TempCategory)
                            num32 = 1;
                          if (num32 == 1)
                          {
                            num10 = -1;
                            if (num26 < 25)
                            {
                              tdata2_1 = this.ReturnShockAndAweMarker(simpleList2, trnd, index10, index11);
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => SHOCK&AWE");
                            }
                            else if (num26 < 50)
                            {
                              tdata2_1 = this.GetSameCoordinateMarker(this.MoveMatrixUnit[tdata1], simpleList2);
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => STAY PUT");
                            }
                            else if (num26 < 75)
                            {
                              if (this.game.Data.UnitObj[index11].AIAttack > -1)
                              {
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => ATTACK CENTER");
                                tdata2_1 = this.GetMarkerForCoordinate(this.MoveMatrixUnit[tdata1], this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIAttack].y);
                              }
                              else
                              {
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => Random MArker");
                                tdata2_1 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                              }
                            }
                            else
                            {
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Name + " => CLOSEST ENEMY");
                              tdata2_1 =  VBMath.Rnd() <= 0.5 ? this.GetMarkerForClosestEnemy(index11, this.AverageSupplyPercentage) : this.GetMarkerForClosestEnemy(this.MoveMatrixUnit[tdata1], this.AverageSupplyPercentage);
                            }
                            if (tdata2_1 > -1 && this.MoveMatrix[tdata1, simpleList2.Data1[tdata2_1], simpleList2.Data2[tdata2_1]] < 9999 | this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].X == simpleList2.Data1[tdata2_1] & this.game.Data.UnitObj[this.MoveMatrixUnit[tdata1]].Y == simpleList2.Data2[tdata2_1])
                            {
                              let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                              let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                              tid += 1;
                              TempMove.Add(tid, 1, tdata1, tdata2_1, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                              this.MoveMatrixUnitMarker[tdata1] = tdata2_1;
                            }
                          }
                        }
                        break;
                      }
                      let mut num33: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() * 7f));
                      if (num33 == 0 | num33 == 3 & this.CorpsStance[this.OpGroup] == 1)
                      {
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : TAKE RANDOM MARKER");
                      }
                      else if (num33 == 1 | (num33 == 2 | num33 == 3) & this.CorpsStance[this.OpGroup] == 3)
                      {
                        num33 = 1;
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : RANDOM SIDES OF ATTACK ON SAME ATTACK MARKER (div only)");
                      }
                      else if (num33 == 4 | num33 == 2 & this.CorpsStance[this.OpGroup] == 1)
                      {
                        num33 = 2;
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : MOVE ON DEFEND / FALLBACK / SELF");
                      }
                      else if (num33 == 5 | num33 == 6)
                      {
                        num33 = 3;
                        if (flag1)
                          this.AddLog2(this.game.Data.UnitObj[index11].Name + " => NOT COPY : RANDOM BOTTLENECK");
                      }
                      SimpleList simpleList4 = SimpleList::new();
                      num34: i32;
                      num35: i32;
                      if ( VBMath.Rnd() > 0.5 & (num33 == 0 | num33 == 2))
                      {
                        num34 = index10;
                        num35 = index10;
                      }
                      else
                      {
                        num34 = 0;
                        num35 = this.MoveMatrixCounter;
                      }
                      num36: i32;
                      num37: i32;
                      switch (num33)
                      {
                        case 1:
                          simpleList4 = this.GetRandomAttackMarkers(index10, simpleList2, this.AverageSupplyPercentage);
                          num34 = 0;
                          num35 = this.MoveMatrixCounter;
                          num36 =  Math.Round( (VBMath.Rnd() * 100f));
                          num37 =  Math.Round( (VBMath.Rnd() * 100f));
                          if (simpleList4.Counter < 0)
                          {
                            if (flag1)
                              this.AddLog2(this.game.Data.UnitObj[index11].Name + "!*could not find randomattackmarkers*");
                            num33 = 0;
                            break;
                          }
                          break;
                        case 3:
                          simpleList4 = this.GetRandomBottleneckMarkers(index10, simpleList2);
                          if (simpleList4.Counter < 0)
                          {
                            if (flag1)
                              this.AddLog2(this.game.Data.UnitObj[index11].Name + "!*could not find random bottlenecks*");
                            num33 = 0;
                            break;
                          }
                          break;
                      }
                      let mut num38: i32 = num34;
                      let mut num39: i32 = num35;
                      for (let mut index16: i32 = num38; index16 <= num39; index16 += 1)
                      {
                        let mut num40: i32 = 0;
                        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical == this.game.Data.UnitObj[this.MoveMatrixUnit[index16]].Historical & this.game.Data.UnitObj[this.MoveMatrixUnit[index16]].Historical > -1 && this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == this.game.Data.UnitObj[this.MoveMatrixUnit[index16]].TempCategory)
                          num40 += 1;
                        if (num40 > 0)
                        {
                          switch (num33)
                          {
                            case 0:
                              tdata2_4 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                              let mut num41: i32 = simpleList2.Data1[tdata2_4];
                              let mut num42: i32 = simpleList2.Data2[tdata2_4];
                              if ( VBMath.Rnd() < 0.2 /  num40 & this.game.Data.UnitObj[index11].TempCategory == 1)
                              {
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! MUTATED MARKER(type0)");
                                let mut index17: i32 =  Math.Round( ( simpleList2.Data1[tdata2_4] + Conversion.Int( ( VBMath.Rnd() * 4.0 - 2.0))));
                                let mut index18: i32 =  Math.Round( ( simpleList2.Data2[tdata2_4] + Conversion.Int( ( VBMath.Rnd() * 4.0 - 2.0))));
                                if (index17 < 0 | index18 < 0 | index17 > this.game.Data.MapObj[0].MapWidth | index18 > this.game.Data.MapObj[0].MapHeight)
                                {
                                  index17 = simpleList2.Data1[tdata2_4];
                                  index18 = simpleList2.Data2[tdata2_4];
                                }
                                if (this.MoveMatrix[index10, index17, index18] >= 9999)
                                {
                                  num41 = simpleList2.Data1[tdata2_4];
                                  num42 = simpleList2.Data2[tdata2_4];
                                  continue;
                                }
                                continue;
                              }
                              if (flag1)
                              {
                                this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! RANDOM MARKER(type0)");
                                continue;
                              }
                              continue;
                            case 1:
                              let mut index19: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList4.Counter + 1)));
                              tdata2_4 = simpleList4.Id[index19];
                              let mut tdata3_2: i32 = simpleList2.Data1[tdata2_4];
                              let mut tdata4_2: i32 = simpleList2.Data2[tdata2_4];
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! SAME TARGET RANDOM DIRECTON MARKER (type1) : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                              tid += 1;
                              TempMove.Add(tid, 1, index10, tdata2_4, tdata3_2, tdata4_2, CheckExistence: false, CheckData1Existence: true);
                              num17 = 0;
                              this.MoveMatrixUnitMarker[index10] = tdata2_4;
                              num25 = -1;
                              continue;
                            case 2:
                              let mut num43: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() * 3f));
                              if (num43 == 0 & this.game.Data.UnitObj[index11].AIDefend > -1)
                              {
                                let mut markerForCoordinate: i32 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIDefend].y);
                                if (markerForCoordinate > -1)
                                {
                                  tdata2_4 = markerForCoordinate;
                                  let mut tdata3_3: i32 = simpleList2.Data1[tdata2_4];
                                  let mut tdata4_3: i32 = simpleList2.Data2[tdata2_4];
                                  if (flag1)
                                    this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! TO DEFEND AREA : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                                  tid += 1;
                                  TempMove.Add(tid, 1, index10, tdata2_4, tdata3_3, tdata4_3, CheckExistence: false, CheckData1Existence: true);
                                  num17 = 0;
                                  this.MoveMatrixUnitMarker[index10] = tdata2_4;
                                  num25 = -1;
                                  continue;
                                }
                                continue;
                              }
                              if (num43 == 1 & this.game.Data.UnitObj[index11].AIFallback > -1)
                              {
                                let mut markerForCoordinate: i32 = this.GetMarkerForCoordinate(index11, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].x, this.AreaCenter[this.game.Data.UnitObj[index11].AIFallback].y);
                                if (markerForCoordinate > -1)
                                {
                                  tdata2_4 = markerForCoordinate;
                                  let mut tdata3_4: i32 = simpleList2.Data1[tdata2_4];
                                  let mut tdata4_4: i32 = simpleList2.Data2[tdata2_4];
                                  if (flag1)
                                    this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! TO FALLBACK AREA : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                                  tid += 1;
                                  TempMove.Add(tid, 1, index10, tdata2_4, tdata3_4, tdata4_4, CheckExistence: false, CheckData1Existence: true);
                                  num17 = 0;
                                  this.MoveMatrixUnitMarker[index10] = tdata2_4;
                                  num25 = -1;
                                  continue;
                                }
                                continue;
                              }
                              let mut markerForCoordinate1: i32 = this.GetMarkerForCoordinate(index11, this.game.Data.UnitObj[index11].X, this.game.Data.UnitObj[index11].Y);
                              if (markerForCoordinate1 > -1)
                              {
                                tdata2_4 = markerForCoordinate1;
                                let mut tdata3_5: i32 = simpleList2.Data1[tdata2_4];
                                let mut tdata4_5: i32 = simpleList2.Data2[tdata2_4];
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! TO DO-NOT-MOVE : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                                tid += 1;
                                TempMove.Add(tid, 1, index10, tdata2_4, tdata3_5, tdata4_5, CheckExistence: false, CheckData1Existence: true);
                                num17 = 0;
                                this.MoveMatrixUnitMarker[index10] = tdata2_4;
                                num25 = -1;
                                continue;
                              }
                              continue;
                            case 3:
                              let mut index20: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList4.Counter + 1)));
                              tdata2_4 = simpleList4.Id[index20];
                              let mut tdata3_6: i32 = simpleList2.Data1[tdata2_4];
                              let mut tdata4_6: i32 = simpleList2.Data2[tdata2_4];
                              if (flag1)
                                this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! RANDOM Bottlenec(type1) : " + simpleList2.Data1[tdata2_4].ToString() + "," + simpleList2.Data2[tdata2_4].ToString() + "=>" + simpleList2.Data3[tdata2_4].ToString() + "," + simpleList2.Data4[tdata2_4].ToString());
                              tid += 1;
                              TempMove.Add(tid, 1, index10, tdata2_4, tdata3_6, tdata4_6, CheckExistence: false, CheckData1Existence: true);
                              num17 = 0;
                              this.MoveMatrixUnitMarker[index10] = tdata2_4;
                              num25 = -1;
                              continue;
                            default:
                              continue;
                          }
                        }
                      }
                      if (num33 == 1)
                      {
                        if (num36 > 0)
                        {
                          let mut moveMatrixCounter4: i32 = this.MoveMatrixCounter;
                          for (let mut index21: i32 = 0; index21 <= moveMatrixCounter4; index21 += 1)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index21]].TempCategory == 2 &&  Math.Round( (VBMath.Rnd() * 100f)) < num36)
                            {
                              let mut coordinateTarget: i32 = this.GetClosestMarkerForCoordinateTarget(index21, simpleList2.Data3[tdata2_4], simpleList2.Data4[tdata2_4]);
                              if (coordinateTarget > -1)
                              {
                                let mut tdata3: i32 = this.ArtMarkerList.Data1[coordinateTarget];
                                let mut tdata4: i32 = this.ArtMarkerList.Data2[coordinateTarget];
                                tid += 1;
                                TempMove.Add(tid, 1, index21, coordinateTarget, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                                num17 = 0;
                                this.MoveMatrixUnitMarker[index21] = coordinateTarget;
                                num25 = -1;
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! ARTILLERY SUPPORT ASSIGNED (type1) : " + this.ArtMarkerList.Data1[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data2[coordinateTarget].ToString() + "=>" + this.ArtMarkerList.Data3[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data4[coordinateTarget].ToString());
                              }
                            }
                          }
                        }
                        if (num37 > 0)
                        {
                          let mut moveMatrixCounter5: i32 = this.MoveMatrixCounter;
                          for (let mut index22: i32 = 0; index22 <= moveMatrixCounter5; index22 += 1)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index22]].TempCategory == 3 &&  Math.Round( (VBMath.Rnd() * 100f)) < num37)
                            {
                              let mut coordinateTarget: i32 = this.GetClosestMarkerForCoordinateTarget(index22, simpleList2.Data3[tdata2_4], simpleList2.Data4[tdata2_4]);
                              if (coordinateTarget > -1)
                              {
                                let mut tdata3: i32 = this.ArtMarkerList.Data1[coordinateTarget];
                                let mut tdata4: i32 = this.ArtMarkerList.Data2[coordinateTarget];
                                tid += 1;
                                TempMove.Add(tid, 1, index22, coordinateTarget, tdata3, tdata4, CheckExistence: false, CheckData1Existence: true);
                                num17 = 0;
                                this.MoveMatrixUnitMarker[index22] = coordinateTarget;
                                num25 = -1;
                                if (flag1)
                                  this.AddLog2(this.game.Data.UnitObj[index11].Name + "!!! AIR SUPPORT ASSIGNED (type1) : " + this.ArtMarkerList.Data1[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data2[coordinateTarget].ToString() + "=>" + this.ArtMarkerList.Data3[coordinateTarget].ToString() + "," + this.ArtMarkerList.Data4[coordinateTarget].ToString());
                              }
                            }
                          }
                          break;
                        }
                        break;
                      }
                      break;
                    }
                  }
                }
              }
            }
          }
          moveScore: i32;
          if (this.FullLog)
          {
            if (num13 > 0 & num13 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("DO NOT MOVE DOCTRINE I");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineI_" + this.MoveAndAttackRound.ToString());
              num13 += 1000;
            }
            else if (num14 > 0 & num14 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("CENTER TARGET DOCTRINE II");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineII_" + this.MoveAndAttackRound.ToString());
              num14 += 1000;
            }
            else if (num15 > 0 & num15 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("CLOSEST TARGET DOCTRINE III");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineIII_" + this.MoveAndAttackRound.ToString());
              num15 += 1000;
            }
            else if (num16 > 0 & num16 < 999)
            {
              this.LogCounter = -1;
              this.AddLog("DEFEND_AREA_DOCTRINE IV");
              moveScore = this.GetMoveScore(TempMove, true, quicktest);
              this.WriteLog("_30_" + this.GroupName[this.OpGroup] + "_DoctrineIV_" + this.MoveAndAttackRound.ToString());
              num15 += 1000;
            }
            else
              moveScore = this.GetMoveScore(TempMove, false, quicktest);
          }
          else
            moveScore = this.GetMoveScore(TempMove, false, quicktest);
          if (flag1)
            this.AddLog2(Conversion.Str( Number2) + ") CurrentScore = " + Conversion.Str( moveScore) + ", BestScore=" + Conversion.Str( Number1));
          if (moveScore != Number1)
          {
            this.HistoryMove[this.HistoryMoveCounter] = TempMove;
            this.HistoryScoreList.Add(this.HistoryMoveCounter, moveScore, CheckExistence: false);
            this.HistoryScoreList.Sort();
            this += 1.HistoryMoveCounter;
            Number2 = Number2;
            if (this.HistoryScoreList.Counter > 450)
              this.HistoryScoreList.Remove(this.HistoryScoreList.Id[ Math.Round( VBMath.Rnd() *  this.HistoryScoreList.Counter * 0.5)]);
            if (moveScore > Number1 | Information.IsNothing( this.BestMove))
            {
              let mut moveMatrixCounter6: i32 = this.MoveMatrixCounter;
              for (let mut index23: i32 = 1; index23 <= moveMatrixCounter6; index23 += 1)
                this.TempMoveMatrixUnitMarker[index23] = this.MoveMatrixUnitMarker[index23];
              this.BestMove = TempMove;
              Number1 = moveScore;
              if (flag1)
                this.AddLog2("NEW BEST SCORE = " + Conversion.Str( moveScore));
            }
            else if (flag1)
              this.AddLog2("OLD BEST SCORE = " + Conversion.Str( Number1));
          }
        }
        if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100 & this.MoveMatrixCounter > 3)
        {
          bool[] flagArray1 = new bool[2];
          float num44 = 1.1f;
          if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
            num44 = 0.9f;
          if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 250)
            num44 = 0.0f;
          this.AddLog2("START SYSTEMATICAL CORTEX");
          this.AddExtraMarkers();
          let mut moveMatrixCounter7: i32 = this.MoveMatrixCounter;
          index24: i32;
          for (let mut index25: i32 = 1; index25 <= moveMatrixCounter7; index25 += 1)
          {
            num10 = this.BestMove.FindNr(-1, index25);
            let mut unr: i32 = this.MoveMatrixUnit[index25];
            if (unr > -1 &  num44 < 1.0 && !this.game.Data.UnitObj[unr].TempStrategic)
            {
              if (this.game.Data.UnitObj[unr].TempCategory == 1)
                simpleList2 = this.MarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 2)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 5)
                simpleList2 = this.ArtMarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 3)
                simpleList2 = this.AirMarkerList;
              if (this.game.Data.UnitObj[unr].TempCategory == 4)
                simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
              bool[] flagArray2 = new bool[simpleList2.Counter + 1];
              for (let mut counter: i32 = simpleList2.Counter; counter >= 0; counter += -1)
              {
                flagArray2[counter] = true;
                if ( VBMath.Rnd() >  num44 | simpleList2.Id[counter] < 9999)
                {
                  if (simpleList2.Data3[counter] > -1)
                  {
                    if (this.game.HandyFunctionsObj.MoveApCostPreview(unr, simpleList2.Data1[counter], simpleList2.Data2[counter], simpleList2.Data1[counter], simpleList2.Data2[counter], 0, simpleList2.Data3[counter], simpleList2.Data4[counter], 0, true).x + this.MoveMatrix[index25, simpleList2.Data1[counter], simpleList2.Data2[counter]] > this.game.HandyFunctionsObj.GetLowestAp(unr))
                      flagArray2[counter] = false;
                  }
                  else if (this.MoveMatrix[index25, simpleList2.Data1[counter], simpleList2.Data2[counter]] > this.game.HandyFunctionsObj.GetLowestAp(unr))
                    flagArray2[counter] = false;
                }
                else
                  flagArray2[counter] = false;
              }
              let mut counter2: i32 = simpleList2.Counter;
              for (index24 = 0; index24 <= counter2; index24 += 1)
              {
                if (flagArray2[index24])
                {
                  SimpleList TempMove = SimpleList::new();
                  let mut counter3: i32 = this.BestMove.Counter;
                  for (let mut index26: i32 = 0; index26 <= counter3; index26 += 1)
                    TempMove.Add(this.BestMove.Id[index26], this.BestMove.Weight[index26], this.BestMove.Data1[index26], this.BestMove.Data2[index26], this.BestMove.Data3[index26], this.BestMove.Data4[index26], this.BestMove.Data5[index26], false, true);
                  let mut moveMatrixCounter8: i32 = this.MoveMatrixCounter;
                  for (let mut index27: i32 = 1; index27 <= moveMatrixCounter8; index27 += 1)
                    this.MoveMatrixUnitMarker[index27] = this.TempMoveMatrixUnitMarker[index27];
                  this.MoveMatrixUnitMarker[index25] = index24;
                  let mut nr: i32 = TempMove.FindNr(-1, index25);
                  if (nr > -1)
                  {
                    TempMove.Weight[nr] = 1;
                    TempMove.Data1[nr] = index25;
                    TempMove.Data2[nr] = index24;
                    TempMove.Data3[nr] = simpleList2.Data1[index24];
                    TempMove.Data4[nr] = simpleList2.Data2[index24];
                  }
                  else
                  {
                    tid += 1;
                    TempMove.Add(tid, 1, index25, index24, simpleList2.Data1[index24], simpleList2.Data2[index24], CheckExistence: false, CheckData1Existence: true);
                  }
                  let mut moveScore: i32 = this.GetMoveScore(TempMove, false, quicktest);
                  if (moveScore > Number1)
                  {
                    let mut moveMatrixCounter9: i32 = this.MoveMatrixCounter;
                    for (let mut index28: i32 = 1; index28 <= moveMatrixCounter9; index28 += 1)
                      this.TempMoveMatrixUnitMarker[index28] = this.MoveMatrixUnitMarker[index28];
                    this.AddLog2(Conversion.Str( index24) + ") New sys Bestscore=" + Conversion.Str( Number1) + ", CurrentScore = " + Conversion.Str( moveScore));
                    this.BestMove = TempMove;
                    Number1 = moveScore;
                  }
                  if (index24 % 20 == 0)
                  {
                    this.game.EditObj.AIProgressMax = this.MoveMatrixCounter;
                    this.game.EditObj.AIProgressNow = index25;
                    this.game.EditObj.TempAIString = "Systematical finetuning. Round " + Conversion.Str( index25) + "/" + Conversion.Str( this.MoveMatrixCounter);
                  }
                }
              }
            }
          }
          this.AddLog2("START SYSTEMATICAL ATTACK PERMUTATIONS");
          bool[] flagArray3 = new bool[this.MarkerList.Counter + 1];
          bool[] flagArray4 = new bool[this.MoveMatrixCounter + 1];
          let mut counter4: i32 = this.MarkerList.Counter;
          for (let mut index29: i32 = 0; index29 <= counter4; index29 += 1)
          {
            let mut num45: i32 = 0;
            if (!flagArray3[index29])
            {
              SimpleList TempMove = SimpleList::new();
              let mut counter5: i32 = this.BestMove.Counter;
              for (let mut index30: i32 = 0; index30 <= counter5; index30 += 1)
                TempMove.Add(this.BestMove.Id[index30], this.BestMove.Weight[index30], this.BestMove.Data1[index30], this.BestMove.Data2[index30], this.BestMove.Data3[index30], this.BestMove.Data4[index30], this.BestMove.Data5[index30], false, true);
              let mut moveMatrixCounter10: i32 = this.MoveMatrixCounter;
              for (let mut index31: i32 = 1; index31 <= moveMatrixCounter10; index31 += 1)
                this.MoveMatrixUnitMarker[index31] = this.TempMoveMatrixUnitMarker[index31];
              bool[] flagArray5 = new bool[this.MoveMatrixCounter + 1];
              if (this.MarkerList.Weight[index29] == 1 & !flagArray3[index29])
              {
                let mut moveMatrixCounter11: i32 = this.MoveMatrixCounter;
                for (let mut tdata1: i32 = 1; tdata1 <= moveMatrixCounter11; tdata1 += 1)
                {
                  if (!flagArray5[tdata1])
                  {
                    let mut unr: i32 = this.MoveMatrixUnit[tdata1];
                    if (this.game.Data.UnitObj[unr].TempCategory == 1)
                    {
                      let mut num46: i32 = 9999;
                      let mut num47: i32 = -1;
                      let mut counter6: i32 = this.MarkerList.Counter;
                      for (let mut index32: i32 = 0; index32 <= counter6; index32 += 1)
                      {
                        if (this.MarkerList.Data3[index29] == this.MarkerList.Data3[index32] && this.MarkerList.Data4[index29] == this.MarkerList.Data4[index32])
                        {
                          flagArray3[index32] = true;
                          if (this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] <= this.game.HandyFunctionsObj.GetLowestAp(unr))
                          {
                            let mut x: i32 = this.game.HandyFunctionsObj.MoveApCostPreview(unr, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32], this.MarkerList.Data1[index32], this.MarkerList.Data2[index32], 0, this.MarkerList.Data3[index32], this.MarkerList.Data4[index32], 0, true).x;
                            if (this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] + x <= this.game.HandyFunctionsObj.GetLowestAp(unr) && x + this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] < num46)
                            {
                              num46 = this.MoveMatrix[tdata1, this.MarkerList.Data1[index32], this.MarkerList.Data2[index32]] + x;
                              num47 = index32;
                            }
                          }
                        }
                      }
                      if (num47 > -1)
                      {
                        let mut tdata2: i32 = num47;
                        let mut nr: i32 = this.BestMove.FindNr(-1, tdata1);
                        flagArray5[tdata1] = true;
                        let mut num48: i32 = this.MoveMatrixUnit[tdata1];
                        num45 += 1;
                        if (nr > -1)
                        {
                          TempMove.Weight[nr] = 1;
                          TempMove.Data1[nr] = tdata1;
                          TempMove.Data2[nr] = tdata2;
                          TempMove.Data3[nr] = this.MarkerList.Data1[tdata2];
                          TempMove.Data4[nr] = this.MarkerList.Data2[tdata2];
                        }
                        else
                        {
                          tid += 1;
                          TempMove.Add(tid, 1, tdata1, tdata2, this.MarkerList.Data1[tdata2], this.MarkerList.Data2[tdata2], CheckExistence: false, CheckData1Existence: true);
                        }
                        this.MoveMatrixUnitMarker[tdata1] = tdata2;
                      }
                    }
                  }
                }
              }
              if (num45 > 0)
              {
                let mut moveScore: i32 = this.GetMoveScore(TempMove, false, quicktest);
                if (moveScore > Number1)
                {
                  let mut moveMatrixCounter12: i32 = this.MoveMatrixCounter;
                  for (let mut index33: i32 = 1; index33 <= moveMatrixCounter12; index33 += 1)
                    this.TempMoveMatrixUnitMarker[index33] = this.MoveMatrixUnitMarker[index33];
                  this.AddLog2(Conversion.Str( index24) + ") Attack permutations Bestscore=" + Conversion.Str( Number1) + ", CurrentScore = " + Conversion.Str( moveScore));
                  this.BestMove = TempMove;
                  Number1 = moveScore;
                }
                this.game.EditObj.AIProgressMax = simpleList2.Counter;
                this.game.EditObj.AIProgressNow = index29;
                this.game.EditObj.TempAIString = "Systematical attack permutations.";
              }
            }
          }
          if (!Information.IsNothing( this.BestMove))
          {
            let mut moveMatrixCounter13: i32 = this.MoveMatrixCounter;
            for (let mut index34: i32 = 1; index34 <= moveMatrixCounter13; index34 += 1)
              this.MoveMatrixUnitMarker[index34] = this.TempMoveMatrixUnitMarker[index34];
          }
        }
        if (this.LogCounter2 <= -1)
          return;
        this.LogTxt = new string[this.LogCounter2 + 1];
        this.LogCounter = this.LogCounter2;
        let mut logCounter2: i32 = this.LogCounter2;
        for (let mut index35: i32 = 0; index35 <= logCounter2; index35 += 1)
          this.LogTxt[index35] = this.LogTxt2[index35];
        this.WriteLog("FullAILog_1_30_" + this.GroupName[this.OpGroup] + "_40_scoring_round" + this.MoveAndAttackRound.ToString());
        this.LogCounter = -1;
        this.LogCounter2 = -1;
      }
    }

    pub fn GetSameTargetAsOtherUnit(unitslot: i32, unr: i32) -> i32
    {
      let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
      num1: i32;
      for (let mut index: i32 = 1; index <= moveMatrixCounter1; index += 1)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == this.game.Data.UnitObj[unr].TempCategory && this.MoveMatrixUnit[index] != unr)
          num1 += 1;
      }
      if (num1 == 0)
        return -1;
      let mut num2: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  num1)) + 1;
      let mut num3: i32 = 0;
      let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
      for (let mut index: i32 = 1; index <= moveMatrixCounter2; index += 1)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == this.game.Data.UnitObj[unr].TempCategory && this.MoveMatrixUnit[index] != unr)
        {
          num3 += 1;
          if (num2 == num3)
            return this.MoveMatrixUnitMarker[index];
        }
      }
      return -1;
    }

    pub fn GetNormalDefensiveCenterMarker(unr: i32, unitslot: i32) -> i32
    {
      SimpleList markerList = this.MarkerList;
      let mut aiDefend: i32 = this.game.Data.UnitObj[unr].AIDefend;
      if (aiDefend > -1)
      {
        let mut counter: i32 = markerList.Counter;
        for (let mut defensiveCenterMarker: i32 = 0; defensiveCenterMarker <= counter; defensiveCenterMarker += 1)
        {
          if (markerList.Data1[defensiveCenterMarker] == this.AreaCenter[aiDefend].x & markerList.Data2[defensiveCenterMarker] == this.AreaCenter[aiDefend].y && this.MoveMatrix[unitslot, markerList.Data1[defensiveCenterMarker], markerList.Data2[defensiveCenterMarker]] < 9999)
            return defensiveCenterMarker;
        }
      }
      return -1;
    }

    pub fn GetNormalFallbackCenterMarker(unr: i32, unitslot: i32) -> i32
    {
      SimpleList markerList = this.MarkerList;
      let mut aiFallback: i32 = this.game.Data.UnitObj[unr].AIFallback;
      if (aiFallback > -1)
      {
        let mut counter: i32 = markerList.Counter;
        for (let mut fallbackCenterMarker: i32 = 0; fallbackCenterMarker <= counter; fallbackCenterMarker += 1)
        {
          if (markerList.Data1[fallbackCenterMarker] == this.AreaCenter[aiFallback].x & markerList.Data2[fallbackCenterMarker] == this.AreaCenter[aiFallback].y && this.MoveMatrix[unitslot, markerList.Data1[fallbackCenterMarker], markerList.Data2[fallbackCenterMarker]] < 9999)
            return fallbackCenterMarker;
        }
      }
      return -1;
    }

    pub fn GetRandomSameTarget(SimpleList TempMove, TempMarker: i32, UnitSlot: i32, Unr: i32) -> i32
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList.Counter != -1 ? this.EngineerMarkerList : this.MarkerList;
      if (Information.IsNothing( Expression) || Expression.Weight[TempMarker] != 1)
        return TempMarker;
      let mut num1: i32 = -1;
      let mut counter1: i32 = Expression.Counter;
      for (let mut index: i32 = 0; index <= counter1; index += 1)
      {
        if (TempMarker != index && Expression.Data3[index] == Expression.Data3[TempMarker] & Expression.Data4[index] == Expression.Data4[TempMarker] && this.MoveMatrix[UnitSlot, Expression.Data1[index], Expression.Data2[index]] < 9999 | this.game.Data.UnitObj[Unr].X == Expression.Data1[index] & this.game.Data.UnitObj[Unr].Y == Expression.Data2[index])
          num1 += 1;
      }
      if (num1 > -1)
      {
        let mut num2: i32 =  Math.Round( (VBMath.Rnd() *  (num1 + 1)));
        let mut num3: i32 = -1;
        let mut counter2: i32 = Expression.Counter;
        for (let mut randomSameTarget: i32 = 0; randomSameTarget <= counter2; randomSameTarget += 1)
        {
          if (TempMarker != randomSameTarget && Expression.Data3[randomSameTarget] == Expression.Data3[TempMarker] & Expression.Data4[randomSameTarget] == Expression.Data4[TempMarker] && this.MoveMatrix[UnitSlot, Expression.Data1[randomSameTarget], Expression.Data2[randomSameTarget]] < 9999 | this.game.Data.UnitObj[Unr].X == Expression.Data1[randomSameTarget] & this.game.Data.UnitObj[Unr].Y == Expression.Data2[randomSameTarget])
          {
            num3 += 1;
            if (num2 == num3)
              return randomSameTarget;
          }
        }
      }
      return TempMarker;
    }

    pub fn Backup_FindBestMove()
    {
      let mut Number: i32 = -9999;
      let mut num1: i32 = 0;
      bool flag1 = this.GetLargestArmy() == this.GetGameDataTurn();
      this.HistoryScoreList = SimpleList::new();
      this.HistoryMoveCounter = 0;
      this.BestMove = (SimpleList) null;
      if (this.MarkerList.Counter == -1)
        return;
      let mut tid: i32 = 0;
      let mut num2: i32 = this.DIFFICULTY_LEVEL_MOVES_FOR_BEST_MOVE;
      if (this.MoveMatrixCounter > 12)
        num2 =  Math.Round( num2 * Math.Sqrt( this.MoveMatrixCounter / 12.0));
      if (this.MoveMatrixCounter < 8)
        num2 =  Math.Round( num2 * ( this.MoveMatrixCounter / 8.0));
      let mut num3: i32 = 99999;
      let mut num4: i32 = 9999;
      let mut num5: i32 = 9999;
      let mut index1: i32 = 1;
      do
      {
        this.MoveMatrixUnitMarker[index1] = -1;
        this.TempMoveMatrixUnitMarker[index1] = -1;
        index1 += 1;
      }
      while (index1 <= 90);
      while (num1 < num2)
      {
        SimpleList TempMove = SimpleList::new();
        num1 += 1;
        if (num1 == 1)
          this.game.EditObj.TempAIString = this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].Name + " is moving. Round = " + Conversion.Str( this.MoveAndAttackRound);
        bool flag2 = false;
        if ( VBMath.Rnd() < 0.05)
        {
          num4 = 9999;
          flag2 = true;
        }
        else if ( VBMath.Rnd() < 0.05)
        {
          num5 = 9999;
          flag2 = true;
        }
        let mut index2: i32 = 1;
        do
        {
          this.MoveMatrixUnitMarker[index2] = -1;
          index2 += 1;
        }
        while (index2 <= 90);
        SimpleList simpleList1 = SimpleList::new();
        float num6 = VBMath.Rnd();
        float trnd = VBMath.Rnd();
        VBMath.Rnd();
        VBMath.Rnd();
        let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
        SimpleList simpleList2;
        tdata2_1: i32;
        for (let mut index3: i32 = 1; index3 <= moveMatrixCounter1; index3 += 1)
        {
          let mut index4: i32 = this.MoveMatrixUnit[index3];
          if (index4 > -1)
          {
            if (this.game.Data.UnitObj[index4].TempCategory == 1)
              simpleList2 = this.MarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 2)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 5)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 3)
              simpleList2 = this.AirMarkerList;
            if (this.game.Data.UnitObj[index4].TempCategory == 4)
              simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
            num7: i32;
            if (this.game.Data.UnitObj[index4].TempStrategic)
            {
              let mut index5: i32 = this.game.Data.UnitObj[index4].AIAttackStyle != 3 ? this.game.Data.UnitObj[index4].AIDefend : this.game.Data.UnitObj[index4].AIAttack;
              if (index5 > -1)
              {
                let mut x: i32 = this.AreaCenter[index5].x;
                let mut y: i32 = this.AreaCenter[index5].y;
                let mut num8: i32 = -1;
                if (this.game.Data.MapObj[0].HexObj[x, y].UnitCounter > -1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[x, y].Regime) != this.GetGameDataTurn())
                {
                  let mut counter: i32 = simpleList2.Counter;
                  for (let mut index6: i32 = 0; index6 <= counter; index6 += 1)
                  {
                    if (this.GetTscore(simpleList2.Data1[index6], simpleList2.Data2[index6]) > num8)
                    {
                      x = simpleList2.Data1[index6];
                      y = simpleList2.Data2[index6];
                      num8 = this.GetTscore(x, y);
                    }
                  }
                }
                tdata2_1 = -1;
                let mut counter1: i32 = simpleList2.Counter;
                for (let mut index7: i32 = 0; index7 <= counter1; index7 += 1)
                {
                  if (simpleList2.Data1[index7] == x & simpleList2.Data2[index7] == y)
                    tdata2_1 = index7;
                }
                if (tdata2_1 == -1)
                {
                  simpleList2.Add(50000 + tid, 2, x, y, -1, -1);
                  tdata2_1 = simpleList2.Counter;
                }
                TempMove.Add(tid, 1, index3, tdata2_1, x, y, CheckExistence: false);
                num7 = 0;
                this.MoveMatrixUnitMarker[index3] = tdata2_1;
              }
            }
            else if (!Information.IsNothing( simpleList2))
            {
              if (flag2 | num1 <= 10 |  VBMath.Rnd() <= 1.0 /  Math.Min(10, this.MoveMatrixCounter))
              {
                tid += 1;
                let mut num9: i32 = 1;
                let mut num10: i32 = 0;
                if ((this.Attacker &  num6 < 0.1 | !this.Attacker &  num6 < 0.05) & !this.game.Data.UnitObj[index4].IsHQ)
                {
                  this.AddLog("SHOCKAWE DOCTRINE");
                  tdata2_1 = this.ReturnShockAndAweMarker(simpleList2, trnd, index3, index4);
                  if (tdata2_1 > -1)
                  {
                    let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                    let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                    if (tdata3 == 13)
                      tdata3 = tdata3;
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if ((this.Attacker &  num6 < 0.1 | !this.Attacker &  num6 < 0.05) & this.game.Data.UnitObj[index4].IsHQ)
                {
                  tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                  if (tdata2_1 > -1)
                  {
                    let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                    let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num3 >= num1)
                {
                  this.AddLog("DONT MOVE DOCTRINE 1");
                  tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                  num3 = num1;
                  if (tdata2_1 > -1)
                  {
                    let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                    let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num4 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & !this.game.Data.UnitObj[index4].IsHQ)
                {
                  this.AddLog("DOCTRINE2");
                  tdata2_1 = this.game.Data.UnitObj[index4].AIAttack <= -1 ? this.GetMarkerForCoordinate(index4, this.AreaCenter[this.game.Data.UnitObj[index4].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[index4].AIDefend].y) : this.GetMarkerForCoordinate(index4, this.AreaCenter[this.game.Data.UnitObj[index4].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index4].AIAttack].y);
                  num4 = num1;
                  if (tdata2_1 > -1 && tdata2_1 > -1)
                  {
                    let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                    let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num4 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & this.game.Data.UnitObj[index4].IsHQ)
                {
                  let mut tdata2_2: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                  let mut tdata3: i32 = simpleList2.Data1[tdata2_2];
                  let mut tdata4: i32 = simpleList2.Data2[tdata2_2];
                  TempMove.Add(tid, 1, index3, tdata2_2, tdata3, tdata4, CheckExistence: false);
                  num9 = 0;
                  this.MoveMatrixUnitMarker[index3] = tdata2_2;
                }
                else if (num5 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & !this.game.Data.UnitObj[index4].IsHQ)
                {
                  this.AddLog("DOCTRINE3");
                  num5 = num1;
                  if (tdata2_1 > -1 && tdata2_1 > -1)
                  {
                    let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                    let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                    TempMove.Add(tid, 1, index3, tdata2_1, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_1;
                  }
                }
                else if (num5 >= num1 & (this.game.Data.UnitObj[index4].AIAttack > -1 | this.game.Data.UnitObj[index4].AIDefend > -1) & this.game.Data.UnitObj[index4].IsHQ)
                {
                  let mut tdata2_3: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                  let mut tdata3: i32 = simpleList2.Data1[tdata2_3];
                  let mut tdata4: i32 = simpleList2.Data2[tdata2_3];
                  TempMove.Add(tid, 1, index3, tdata2_3, tdata3, tdata4, CheckExistence: false);
                  num9 = 0;
                  this.MoveMatrixUnitMarker[index3] = tdata2_3;
                }
                while (num9 == 1 & num10 < 100)
                {
                  num10 += 1;
                  let mut tdata2_4: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                  if (this.MoveMatrix[index3, simpleList2.Data1[tdata2_4], simpleList2.Data2[tdata2_4]] < 9999 | this.game.Data.UnitObj[index4].X == simpleList2.Data1[tdata2_4] & this.game.Data.UnitObj[index4].Y == simpleList2.Data2[tdata2_4])
                  {
                    tdata3: i32;
                    tdata4: i32;
                    if ( VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index4].TempCategory == 1)
                    {
                      tdata3 =  Math.Round( ( simpleList2.Data1[tdata2_4] + Conversion.Int( ( VBMath.Rnd() * 4.0 - 2.0))));
                      tdata4 =  Math.Round( ( simpleList2.Data2[tdata2_4] + Conversion.Int( ( VBMath.Rnd() * 4.0 - 2.0))));
                      if (tdata3 < 0 | tdata4 < 0 | tdata3 > this.game.Data.MapObj[0].MapWidth | tdata4 > this.game.Data.MapObj[0].MapHeight)
                      {
                        tdata3 = simpleList2.Data1[tdata2_4];
                        tdata4 = simpleList2.Data2[tdata2_4];
                      }
                      if (this.MoveMatrix[index3, tdata3, tdata4] >= 9999)
                      {
                        tdata3 = simpleList2.Data1[tdata2_4];
                        tdata4 = simpleList2.Data2[tdata2_4];
                      }
                    }
                    else if ( VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index4].TempCategory != 3 & this.CorpsStance[this.OpGroup] == 1)
                    {
                      tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                      if (tdata2_1 > -1)
                        tdata2_4 = tdata2_1;
                      tdata3 = simpleList2.Data1[tdata2_4];
                      tdata4 = simpleList2.Data2[tdata2_4];
                    }
                    else if ( VBMath.Rnd() < 0.25 & this.game.Data.UnitObj[index4].IsHQ)
                    {
                      tdata2_1 = this.GetSameCoordinateMarker(index4, simpleList2);
                      if (tdata2_1 > -1)
                        tdata2_4 = tdata2_1;
                      tdata3 = simpleList2.Data1[tdata2_4];
                      tdata4 = simpleList2.Data2[tdata2_4];
                    }
                    else
                    {
                      tdata3 = simpleList2.Data1[tdata2_4];
                      tdata4 = simpleList2.Data2[tdata2_4];
                    }
                    tid += 1;
                    TempMove.Add(tid, 1, index3, tdata2_4, tdata3, tdata4, CheckExistence: false);
                    num9 = 0;
                    this.MoveMatrixUnitMarker[index3] = tdata2_4;
                  }
                }
              }
              else
              {
                if (this.game.Data.UnitObj[index4].IsHQ)
                  index4 = index4;
                float num11 =  Math.Sqrt(Math.Sqrt( ( new Random(num1 + this.game.Data.Round * 4002).Next(0, 100000) / 100000f)));
                if ( VBMath.Rnd() > 0.5)
                  num11 = 1f;
                float num12 = 1f /  (1 + this.MoveMatrixCounter);
                if ( VBMath.Rnd() < 0.5)
                  num12 =  (( num12 + 1.0) / 2.0);
                else if ( VBMath.Rnd() < 0.5)
                  num12 = VBMath.Rnd();
                for (let mut tdata2_5: i32 = this.HistoryScoreList.Counter; tdata2_5 >= 0; tdata2_5 += -1)
                {
                  let mut num13: i32 = this.HistoryScoreList.Weight[this.HistoryScoreList.Counter] - this.HistoryScoreList.Weight[0];
                  if ( ( (this.HistoryScoreList.Weight[tdata2_5] - this.HistoryScoreList.Weight[0]) /  num13) <=  num11)
                  {
                    let mut index8: i32 = this.HistoryScoreList.Id[tdata2_5];
                    tid += 1;
                    index9: i32;
                    if ( VBMath.Rnd() <  num12)
                    {
                      index9 = this.HistoryMove[index8].FindNr(-1, index3);
                      this.AddLog("COPY SELF EXISTING");
                    }
                    else if ( VBMath.Rnd() < 0.7)
                    {
                      index9 =  Math.Round( Conversion.Int( (this.HistoryMove[index8].Counter + 1) * VBMath.Rnd()));
                      if (this.game.Data.UnitObj[this.MoveMatrixUnit[this.HistoryMove[index8].Data1[index9]]].TempCategory == this.game.Data.UnitObj[index4].TempCategory)
                      {
                        if ( VBMath.Rnd() < 0.5 & this.game.Data.UnitObj[index4].TempCategory == 1)
                        {
                          let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
                          for (let mut index10: i32 = 1; index10 <= moveMatrixCounter2; index10 += 1)
                          {
                            if (this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].TempCategory == 1 && this.game.Data.UnitObj[this.MoveMatrixUnit[index3]].Historical == this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical & this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Historical > -1)
                            {
                              tdata2_1 = this.GetRandomSameTarget(this.HistoryMove[index8], this.HistoryMove[index8].Data2[index9], index10, this.MoveMatrixUnit[index10]);
                              if (tdata2_1 > -1 && this.MoveMatrix[index10, simpleList2.Data1[tdata2_1], simpleList2.Data2[tdata2_1]] < 9999 | this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].X == simpleList2.Data1[tdata2_1] & this.game.Data.UnitObj[this.MoveMatrixUnit[index10]].Y == simpleList2.Data2[tdata2_1])
                              {
                                let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                                let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                                TempMove.Add(tid, 1, index10, tdata2_1, tdata3, tdata4, CheckExistence: false);
                                this.MoveMatrixUnitMarker[index10] = tdata2_1;
                                this.AddLog("WHOLE HIS UNIT TAKE MARKER FROM OTHER");
                              }
                            }
                          }
                        }
                        else
                        {
                          let mut index11: i32 = index3;
                          tdata2_1 = this.GetRandomSameTarget(this.HistoryMove[index8], this.HistoryMove[index8].Data2[index9], index11, this.MoveMatrixUnit[index11]);
                          if (tdata2_1 > -1)
                          {
                            if (this.MoveMatrix[index11, simpleList2.Data1[tdata2_1], simpleList2.Data2[tdata2_1]] < 9999 | this.game.Data.UnitObj[this.MoveMatrixUnit[index11]].X == simpleList2.Data1[tdata2_1] & this.game.Data.UnitObj[this.MoveMatrixUnit[index11]].Y == simpleList2.Data2[tdata2_1])
                            {
                              let mut tdata3: i32 = simpleList2.Data1[tdata2_1];
                              let mut tdata4: i32 = simpleList2.Data2[tdata2_1];
                              TempMove.Add(tid, 1, index11, tdata2_1, tdata3, tdata4, CheckExistence: false);
                              this.MoveMatrixUnitMarker[index11] = tdata2_1;
                              this.AddLog("SINGLE UNIT COPY MARKER");
                              break;
                            }
                            index9 = this.HistoryMove[index8].FindNr(-1, index3);
                          }
                        }
                      }
                      else
                        index9 = this.HistoryMove[index8].FindNr(-1, index3);
                    }
                    else
                    {
                      tdata2_5 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (simpleList2.Counter + 1)));
                      let mut tdata3: i32 = simpleList2.Data1[tdata2_5];
                      let mut tdata4: i32 = simpleList2.Data2[tdata2_5];
                      tid += 1;
                      TempMove.Add(tid, 1, index3, tdata2_5, tdata3, tdata4, CheckExistence: false);
                      num7 = 0;
                      this.MoveMatrixUnitMarker[index3] = tdata2_5;
                      index9 = -1;
                    }
                    if (index9 > -1)
                    {
                      TempMove.Add(tid, 1, index3, this.HistoryMove[index8].Data2[index9], this.HistoryMove[index8].Data3[index9], this.HistoryMove[index8].Data4[index9], this.HistoryMove[index8].Data5[index9], false);
                      this.MoveMatrixUnitMarker[index3] = this.HistoryMove[index8].Data2[index9];
                      break;
                    }
                    break;
                  }
                }
              }
            }
          }
        }
        let mut moveMatrixCounter3: i32 = this.MoveMatrixCounter;
        for (let mut unitslot: i32 = 1; unitslot <= moveMatrixCounter3; unitslot += 1)
        {
          let mut unr: i32 = this.MoveMatrixUnit[unitslot];
          if (unr > -1 &  VBMath.Rnd() > 0.9)
          {
            if (this.game.Data.UnitObj[unr].TempCategory == 3)
              ;
            tdata2_1 = this.GetSameTargetAsOtherUnit(unitslot, unr);
            if (tdata2_1 > -1)
              this.MoveMatrixUnitMarker[unitslot] = tdata2_1;
          }
          if (unr > -1)
          {
            simpleList2 = (SimpleList) null;
            if (this.game.Data.UnitObj[unr].TempCategory == 1)
              simpleList2 = this.MarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 2)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 5)
              simpleList2 = this.ArtMarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 3)
              simpleList2 = this.AirMarkerList;
            if (this.game.Data.UnitObj[unr].TempCategory == 4)
              simpleList2 = this.EngineerMarkerList.Counter <= -1 ? this.MarkerList : this.EngineerMarkerList;
            if (!Information.IsNothing( simpleList2) &&  VBMath.Rnd() < 0.15 & this.game.Data.UnitObj[unr].TempCategory != 3 & this.CorpsStance[this.OpGroup] == 1)
            {
              tdata2_1 = this.GetSameCoordinateMarker(unr, simpleList2);
              if (tdata2_1 > -1)
                this.MoveMatrixUnitMarker[unitslot] = tdata2_1;
            }
          }
        }
        let mut moveScore: i32 = this.GetMoveScore(TempMove, false);
        this.AddLog("CurrentScore = " + Conversion.Str( moveScore) + ", BestScore = " + Conversion.Str( Number));
        if (moveScore != Number)
        {
          this.HistoryMove[this.HistoryMoveCounter] = TempMove;
          this.HistoryScoreList.Add(this.HistoryMoveCounter, moveScore, CheckExistence: false);
          this.HistoryScoreList.Sort();
          this += 1.HistoryMoveCounter;
          num1 = num1;
          if (this.HistoryScoreList.Counter > 50)
            this.HistoryScoreList.Remove(this.HistoryScoreList.Id[ Math.Round( VBMath.Rnd() *  this.HistoryScoreList.Counter * 0.5)]);
          if (moveScore > Number)
          {
            let mut moveMatrixCounter4: i32 = this.MoveMatrixCounter;
            for (let mut index12: i32 = 1; index12 <= moveMatrixCounter4; index12 += 1)
              this.TempMoveMatrixUnitMarker[index12] = this.MoveMatrixUnitMarker[index12];
            this.BestMove = TempMove;
            Number = moveScore;
          }
        }
      }
      if (Information.IsNothing( this.BestMove))
        return;
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index13: i32 = 1; index13 <= moveMatrixCounter; index13 += 1)
        this.MoveMatrixUnitMarker[index13] = this.TempMoveMatrixUnitMarker[index13];
    }

    pub fn GetMarkerForSelfTarget(SimpleList TempMove, TempMarker: i32, UnitSlot: i32, Unr: i32) -> i32
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing( Expression))
        return TempMarker;
      let mut counter: i32 = Expression.Counter;
      for (let mut markerForSelfTarget: i32 = 0; markerForSelfTarget <= counter; markerForSelfTarget += 1)
      {
        if (Expression.Data1[markerForSelfTarget] == this.game.Data.UnitObj[Unr].X & Expression.Data2[markerForSelfTarget] == this.game.Data.UnitObj[Unr].Y)
          return markerForSelfTarget;
      }
      return TempMarker;
    }

    pub fn GetMarkerForCoordinate(Unr: i32, X: i32, y: i32) -> i32
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing( Expression))
        return -1;
      SimpleList simpleList = SimpleList::new();
      let mut counter: i32 = Expression.Counter;
      for (let mut tid: i32 = 0; tid <= counter; tid += 1)
      {
        if (Expression.Data1[tid] == X & Expression.Data2[tid] == y)
          simpleList.Add(tid,  Math.Round( (VBMath.Rnd() * 1000f)));
      }
      simpleList.Sort();
      return simpleList.Counter > -1 ? simpleList.Id[0] : -1;
    }

    pub fn GetClosestMarkerForCoordinateTarget(movematrixnr: i32, X: i32, y: i32) -> i32
    {
      let mut unr: i32 = this.MoveMatrixUnit[movematrixnr];
      SimpleList Expression;
      if (this.game.Data.UnitObj[unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing( Expression))
        return -1;
      SimpleList simpleList = SimpleList::new();
      let mut counter: i32 = Expression.Counter;
      for (let mut tid: i32 = 0; tid <= counter; tid += 1)
      {
        if (Expression.Data3[tid] == X & Expression.Data4[tid] == y &  this.MoveMatrix[movematrixnr, Expression.Data1[tid], Expression.Data2[tid]] <  this.game.HandyFunctionsObj.GetLowestAp(unr) * 0.66)
        {
          let mut num: i32 = this.MoveMatrix[movematrixnr, Expression.Data1[tid], Expression.Data2[tid]];
          let mut tweight: i32 =  Math.Round( num * 0.8 +  num *  VBMath.Rnd() * 0.2);
          simpleList.Add(tid, tweight);
        }
      }
      simpleList.Sort();
      return simpleList.Counter > -1 ? simpleList.Id[0] : -1;
    }

    pub fn GetMarkerForClosestEnemy(Unr: i32, AverageSupplyPercentage: i32) -> i32
    {
      SimpleList Expression;
      if (this.game.Data.UnitObj[Unr].TempCategory == 1)
        Expression = this.MarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 2)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 5)
        Expression = this.ArtMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 3)
        Expression = this.AirMarkerList;
      if (this.game.Data.UnitObj[Unr].TempCategory == 4)
        Expression = this.EngineerMarkerList;
      if (Information.IsNothing( Expression))
        return -1;
      SimpleList simpleList = SimpleList::new();
      let mut counter: i32 = Expression.Counter;
      for (let mut tid: i32 = 0; tid <= counter; tid += 1)
      {
        if (Expression.Weight[tid] == 1)
        {
          let mut num: i32 = this.game.HandyFunctionsObj.Distance(Expression.Data1[tid], Expression.Data2[tid], 0, this.game.Data.UnitObj[Unr].X, this.game.Data.UnitObj[Unr].Y, 0, 99);
          if (AverageSupplyPercentage < 40 & Expression.Data3[tid] > -1)
          {
            if (this.DistanceFromSuppliedHex[Expression.Data3[tid], Expression.Data4[tid]] <= 1)
              simpleList.Add(tid, num * 10 +  Math.Round( (VBMath.Rnd() * 10f)));
            else if (this.DistanceFromSuppliedHex[Expression.Data3[tid], Expression.Data4[tid]] <= 2)
              simpleList.Add(tid, num * 20 +  Math.Round( (VBMath.Rnd() * 10f)));
            else
              simpleList.Add(tid, num * 50 +  Math.Round( (VBMath.Rnd() * 10f)));
          }
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 35)
            simpleList.Add(tid, num * 10 +  Math.Round( (VBMath.Rnd() * 10f)));
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 20)
            simpleList.Add(tid, num * 15 +  Math.Round( (VBMath.Rnd() * 10f)));
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 10)
            simpleList.Add(tid, num * 20 +  Math.Round( (VBMath.Rnd() * 10f)));
          else if (this.BottleNeckMatrix[Expression.Data1[tid], Expression.Data2[tid]] > 5)
            simpleList.Add(tid, num * 25 +  Math.Round( (VBMath.Rnd() * 10f)));
          else
            simpleList.Add(tid, num * 50 +  Math.Round( (VBMath.Rnd() * 10f)));
        }
      }
      simpleList.Sort();
      return simpleList.Counter > -1 ? simpleList.Id[0] : -1;
    }

    pub fn GetMoveScore(SimpleList TempMove, bool MakeLog, bool quicktest = false) -> i32
    {
      if (this.OpGroup <= this.CorpsTopRatio.GetUpperBound(0))
      {
        if (quicktest)
        {
          if (MakeLog)
          {
            this.AddLog("***QUICK TEST SCORING MOVE***");
            this.AddLog("CORPSRATIO = " + Conversion.Str( this.CorpsTopRatio[this.OpGroup]));
          }
        }
        else if (MakeLog)
        {
          this.AddLog("***SCORING MOVE***");
          this.AddLog("CORPSRATIO = " + Conversion.Str( this.CorpsTopRatio[this.OpGroup]));
        }
      }
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        this.game.Data.UnitObj[index].TempX = -1;
        this.game.Data.UnitObj[index].TempY = -1;
        this.game.Data.UnitObj[index].FinalX = -1;
        this.game.Data.UnitObj[index].FinalY = -1;
      }
      let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
      for (let mut index: i32 = 1; index <= moveMatrixCounter1; index += 1)
        this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempSlot = index;
      let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
      for (let mut tdata1: i32 = 1; tdata1 <= moveMatrixCounter2; tdata1 += 1)
      {
        let mut num: i32 = -1;
        let mut counter: i32 = TempMove.Counter;
        for (let mut index: i32 = 0; index <= counter; index += 1)
        {
          if (TempMove.Weight[index] >= 1 && tdata1 == TempMove.Data1[index])
          {
            num = index;
            break;
          }
        }
        let mut index1: i32 = num;
        let mut unr: i32 = this.MoveMatrixUnit[tdata1];
        this.game.Data.UnitObj[unr].TempSlot = tdata1;
        let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(unr);
        let mut x: i32 = this.game.Data.UnitObj[unr].X;
        let mut y: i32 = this.game.Data.UnitObj[unr].Y;
        index2: i32;
        index3: i32;
        if (index1 == -1)
        {
          index2 = x;
          index3 = y;
        }
        else
        {
          index2 = TempMove.Data3[index1];
          index3 = TempMove.Data4[index1];
        }
        if (this.game.Data.UnitObj[unr].FinalX == -1)
        {
          this.game.Data.UnitObj[unr].FinalX = index2;
          this.game.Data.UnitObj[unr].FinalY = index3;
        }
        Coordinate coordinate1;
        if (this.game.Data.UnitObj[unr].TempCategory == 3)
        {
          if (lowestAp < this.MoveMatrix[tdata1, index2, index3])
          {
            index2 = x;
            index3 = y;
          }
        }
        else if (this.MoveMatrix[tdata1, index2, index3] == 9999)
        {
          index2 = x;
          index3 = y;
        }
        else
        {
          for (; lowestAp < this.MoveMatrix[tdata1, index2, index3] & !(x == index2 & y == index3); index3 = coordinate1.y)
          {
            sCoordinate sCoordinate = this.MoveMatrixCameFrom[tdata1, index2, index3];
            coordinate1.x =  sCoordinate.x;
            coordinate1.y =  sCoordinate.y;
            coordinate1.onmap = sCoordinate.onmap;
            if (!coordinate1.onmap)
            {
              index2 = x;
              index3 = y;
              break;
            }
            index2 = coordinate1.x;
          }
        }
        if (!this.game.HandyFunctionsObj.HasHexRoad(index2, index3, 0) && this.game.Data.UnitObj[unr].TempStrategic && !this.game.Data.UnitObj[unr].IsHQ && this.CanBeStrategiclyTransferred(unr))
        {
          Coordinate coordinate2 = this.MoveMatrixCloseRoad[tdata1];
          if (coordinate2.onmap)
          {
            index2 = coordinate2.x;
            index3 = coordinate2.y;
            if (MakeLog)
              this.AddLog("OVERRULE TO " + Conversion.Str( coordinate2.x) + "," + Conversion.Str( coordinate2.y));
          }
          else if (MakeLog)
            this.AddLog("CANT FIND OVERRULE");
        }
        this.game.Data.UnitObj[unr].TempX = index2;
        this.game.Data.UnitObj[unr].TempY = index3;
        if (MakeLog)
          this.AddLog(this.game.Data.UnitObj[unr].Name + " PROJECTED TO REACH " + Conversion.Str( index2) + "," + Conversion.Str( index3));
        if (!(this.game.Data.UnitObj[unr].TempX == this.game.Data.UnitObj[unr].X & this.game.Data.UnitObj[unr].TempY == this.game.Data.UnitObj[unr].Y))
        {
          if (TempMove.FindNr(-1, tdata1) == -1)
            ;
        }
      }
      let mut Number1: i32 = 5000 + this.GetScoreForHexOccupationAndHQ2( TempMove, MakeLog);
      if (MakeLog)
        this.AddLog("***Score after Hex Occupation scores added = " + Conversion.Str( Number1));
      let mut scoreForAttacks: i32 = this.GetScoreForAttacks(true, MakeLog);
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      Number2: i32;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
      {
        float num = 1.25f;
        if ( this.game.Data.RuleVar[367] > 0.0)
          num *= this.game.Data.RuleVar[367] / 100f;
        Number2 =  Math.Round( ( scoreForAttacks * num));
      }
      else
      {
        float num = 1.25f;
        if ( this.game.Data.RuleVar[368] > 0.0)
          num *= this.game.Data.RuleVar[368] / 100f;
        Number2 =  Math.Round( ( scoreForAttacks * num));
      }
      if (Number2 > 0)
      {
        if (MakeLog)
          this.AddLog("Attack score = " + Conversion.Str( Number2));
        Number2 = this.MoveAndAttackRound != 1 ? (this.MoveAndAttackRound != 2 ? Number2 :  Math.Round( Number2 * 0.75 + 0.25 *  Number2 * ( Math.Min(100, this.GetFreeAP(true)) / 100.0))) :  Math.Round( Number2 * 0.5 + 0.5 *  Number2 * ( Math.Min(100, this.GetFreeAP(true)) / 100.0));
        if (MakeLog)
          this.AddLog("***AttackScore Modified for free Ap = " + Conversion.Str( Number2));
      }
      let mut Number3: i32 = Number1 + Number2;
      if (MakeLog)
        this.AddLog("***Score after Attack scores added = " + Conversion.Str( Number3));
      let mut scoreForMovingIn: i32 = this.GetScoreForMovingIn( TempMove, MakeLog);
      num1: i32;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle != 3)
      {
        float num2 = 0.1f;
        if ( this.game.Data.RuleVar[369] > 0.0)
          num2 =  ( num2 *  this.game.Data.RuleVar[369] / 100.0);
        num1 =  Math.Round( ( scoreForMovingIn * num2));
      }
      else
      {
        float num3 = 0.2f;
        if ( this.game.Data.RuleVar[370] > 0.0)
          num3 =  ( num3 *  this.game.Data.RuleVar[370] / 100.0);
        num1 =  Math.Round( ( scoreForMovingIn * num3));
      }
      let mut Number4: i32 = Number3 + num1;
      if (MakeLog)
        this.AddLog("***Score after for [moving in] scores added = " + Conversion.Str( Number4));
      this.CounterAttackPossible = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      if (!quicktest)
      {
        let mut counterAttackScore: i32 = this.GetCounterAttackScore( TempMove, MakeLog);
        let mut num4: i32 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ( this.game.Data.RuleVar[372] != 0.0 ?  Math.Round( counterAttackScore *  this.game.Data.RuleVar[372] / 100.0) : counterAttackScore) : ( this.game.Data.RuleVar[371] != 0.0 ?  Math.Round( counterAttackScore *  this.game.Data.RuleVar[371] / 100.0) :  Math.Round( counterAttackScore * 1.25));
        if (this.GroupCounter > this.CorpsTopRatio.GetUpperBound(0))
          this.CorpsTopRatio = (float[]) Utils.CopyArray((Array) this.CorpsTopRatio, (Array) new float[this.GroupCounter + 1]);
        if ( this.CorpsTopRatio[this.OpGroup] > 1.0)
          num4 =  Math.Round( num4 / Math.Sqrt( this.CorpsTopRatio[this.OpGroup]));
        Number4 -= num4;
        if (MakeLog)
          this.AddLog("***Score after [counter attack score] subtracted = " + Conversion.Str( Number4));
      }
      if (!quicktest)
      {
        let mut num5: i32 =  Math.Round( this.GetCounterMoveScore( TempMove, MakeLog) / Math.Max(1.0, Math.Sqrt(2.0 *  this.CorpsTopRatio[this.OpGroup])));
        let mut num6: i32 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ( this.game.Data.RuleVar[374] != 0.0 ?  Math.Round( num5 *  this.game.Data.RuleVar[374] / 100.0) : num5) : ( this.game.Data.RuleVar[373] != 0.0 ?  Math.Round( num5 *  this.game.Data.RuleVar[373] / 100.0) :  Math.Round( num5 / 2.0));
        Number4 -= num6;
        if (MakeLog)
          this.AddLog("***Score after [counter move score] subtracted = " + Conversion.Str( Number4));
      }
      if (!quicktest)
      {
        let mut num7: i32 = this.GetOurSelvesEncircledScore( TempMove, MakeLog);
        if (num7 > 0)
          num7 = num7;
        let mut num8: i32 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ( this.game.Data.RuleVar[376] != 0.0 ?  Math.Round( num7 *  this.game.Data.RuleVar[376] / 100.0) : num7) : ( this.game.Data.RuleVar[375] != 0.0 ?  Math.Round( num7 *  this.game.Data.RuleVar[375] / 100.0) : num7);
        Number4 -= num8;
        if (MakeLog)
          this.AddLog("***Score after [GetOurselvesEncircled] subtracted = " + Conversion.Str( Number4));
      }
      if (!this.MovingIn)
      {
        let mut scoreForEntrench: i32 = this.GetScoreForEntrench( TempMove, MakeLog);
        Number4 += scoreForEntrench;
        if (MakeLog)
          this.AddLog("***Score after Entrench added = " + Conversion.Str( Number4));
      }
      if (!quicktest)
      {
        let mut enemyEncircledScore: i32 = this.GetEnemyEncircledScore( TempMove, MakeLog);
        let mut Number5: i32 = this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 ? ( this.game.Data.RuleVar[381] != 0.0 ?  Math.Round( enemyEncircledScore *  this.game.Data.RuleVar[381] / 100.0) :  Math.Round( enemyEncircledScore / 4.0)) : ( this.game.Data.RuleVar[380] != 0.0 ?  Math.Round( enemyEncircledScore *  this.game.Data.RuleVar[380] / 100.0) :  Math.Round( enemyEncircledScore / 4.0));
        if (MakeLog)
          this.AddLog(" encircle enemy /4 = " + Conversion.Str( Number5));
        Number4 += Number5;
        if (MakeLog)
          this.AddLog("***Score after [GetEnemyEncircled] added = " + Conversion.Str( Number4));
      }
      let mut Number6: i32 = 0;
      let mut Number7: i32 = 0;
      let mut Number8: i32 = 0;
      let mut num9: i32 = 0;
      let mut num10: i32 = 0;
      if (!quicktest && this.game.Data.UnitObj[groupHq].AIAttackStyle == 3 & this.game.Data.RegimeObj[this.GetRegime(this.game.Data.Turn)].ProdBonus >= 100)
      {
        if (this.AAM1.x == 0 & this.AAM2.x == 0)
        {
          this.AAM2.x = this.game.Data.MapObj[0].MapWidth;
          this.AAM2.y = this.game.Data.MapObj[0].MapHeight;
        }
        let mut x1: i32 = this.AAM1.x;
        let mut x2: i32 = this.AAM2.x;
        for (let mut index4: i32 = x1; index4 <= x2; index4 += 1)
        {
          let mut y1: i32 = this.AAM1.y;
          let mut y2: i32 = this.AAM2.y;
          for (let mut index5: i32 = y1; index5 <= y2; index5 += 1)
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index4, index5].Regime) == this.GetGameDataTurn())
              Number6 += this.FullAdvanceMatrix[index4, index5];
            if (this.GetRegime(this.TempOwner[index4, index5]) == this.GetGameDataTurn() & this.TempCounterOwner[index4, index5] == this.GetGameDataTurn())
              Number7 += this.FullAdvanceMatrix[index4, index5];
            Number8 += this.FullAdvanceMatrix[index4, index5];
            if (this.FullAdvanceMatrix[index4, index5] > num9)
              num9 = this.FullAdvanceMatrix[index4, index5];
          }
        }
        let mut num11: i32 = this.game.HandyFunctionsObj.GetGroupPowerPoints(groupHq) * 13;
        if (num11 > Number4)
          num11 = Number4;
        if (MakeLog)
          this.AddLog("Full Matrix score. Hexes. Started with " + Conversion.Str( Number6) + ", Ended with " + Conversion.Str( Number7) + " of total " + Conversion.Str( Number8));
        if ( this.game.Data.RuleVar[383] == 0.0 & Number8 > 0)
        {
          if (Number6 > Number7)
            Number4 +=  Math.Round(0.0 -  num11 * 0.15 * ( (Number6 - Number7) /  Number8));
          else if (Number7 > Number6)
            Number4 +=  Math.Round(0.0 +  num11 * 0.15 * ( (Number7 - Number6) /  Number8));
        }
        else if (Number8 > 0)
        {
          if (Number6 > Number7)
            Number4 +=  Math.Round(0.0 -  num11 * ( this.game.Data.RuleVar[383] / 100.0) * ( (Number6 - Number7) /  Number8));
          else if (Number7 > Number6)
            Number4 +=  Math.Round(0.0 +  num11 * ( this.game.Data.RuleVar[383] / 100.0) * ( (Number7 - Number6) /  Number8));
        }
        if (MakeLog)
          this.AddLog("***Score after [FullAdvanceMatrix Pts for Hexes] added = " + Conversion.Str( Number4));
        if ( this.CorpsTopRatio[this.OpGroup] > 2.0)
        {
          let mut Number9: i32 = 0;
          let mut Number10: i32 = 0;
          let mut moveMatrixCounter3: i32 = this.MoveMatrixCounter;
          for (let mut index6: i32 = 1; index6 <= moveMatrixCounter3; index6 += 1)
          {
            let mut index7: i32 = this.MoveMatrixUnit[index6];
            if (this.game.Data.UnitObj[index7].TempCategory == 1)
            {
              let mut x3: i32 = this.game.Data.UnitObj[index7].X;
              let mut y: i32 = this.game.Data.UnitObj[index7].Y;
              Number9 += this.FullAdvanceMatrix[x3, y];
              let mut index8: i32 = this.game.Data.UnitObj[index7].TempX;
              let mut index9: i32 = this.game.Data.UnitObj[index7].TempY;
              if (index8 == -1)
              {
                index8 = this.game.Data.UnitObj[index7].X;
                index9 = this.game.Data.UnitObj[index7].Y;
              }
              if (this.GetRegime(this.TempOwner[index8, index9]) == this.GetGameDataTurn() & this.TempCounterOwner[index8, index9] == this.GetGameDataTurn())
                Number10 += this.FullAdvanceMatrix[index8, index9];
              num10 += 1;
            }
          }
          let mut Number11: i32 = num9 * num10;
          if (MakeLog)
            this.AddLog("Full Matrix score. Units Hex Values. Started with " + Conversion.Str( Number9) + ", Ended with " + Conversion.Str( Number10) + " of a total " + Conversion.Str( Number11));
          if ( this.game.Data.RuleVar[382] == 0.0 & Number11 > 0)
          {
            if (Number9 > Number10)
              Number4 +=  Math.Round(0.0 -  num11 * 0.4 * ( (Number9 - Number10) /  Number11));
            else if (Number10 > Number9 & Number11 > 0)
              Number4 +=  Math.Round(0.0 +  num11 * 0.4 * ( (Number10 - Number9) /  Number11));
          }
          else if (Number11 > 0)
          {
            if (Number9 > Number10)
              Number4 +=  Math.Round(0.0 -  num11 * ( this.game.Data.RuleVar[382] / 100.0) * ( (Number9 - Number10) /  Number11));
            else if (Number10 > Number9 & Number11 > 0)
              Number4 +=  Math.Round(0.0 +  num11 * ( this.game.Data.RuleVar[382] / 100.0) * ( (Number10 - Number9) /  Number11));
          }
          if (MakeLog)
            this.AddLog("***Score after [FullAdvanceMatrix Pts for Units] added = " + Conversion.Str( Number4));
        }
        else if (MakeLog)
          this.AddLog("No Full Matrix score calculated because group not strong enough to warrant it.");
      }
      let mut reconquestOfImportance: i32 = this.GetScoreForReconquestOfImportance();
      if (reconquestOfImportance != 0)
      {
        Number4 += reconquestOfImportance;
        if (MakeLog)
          this.AddLog("GOT " + Conversion.Str( reconquestOfImportance) + " FOR RECONQUESTS OR LOSSES OF IMPORTANCE! (such as supply bases)");
      }
      return Number4;
    }

    pub fn GetPercentTempUnits() -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
        {
          num1 += 1;
          if (this.game.Data.UnitObj[index].TempGroup > -1)
            num2 += 1;
        }
      }
      return num1 == 0 ? 0 :  Math.Round(100.0 * ( num2 /  num1));
    }

    pub fn GetAbsoluteTempUnits(grp: i32) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      absoluteTempUnits: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1)
        {
          if (this.game.Data.UnitObj[index].AIGroup == grp)
          {
            if (this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
            {
              num: i32;
              num += 1;
              if (this.game.Data.UnitObj[index].TempGroup > -1)
                absoluteTempUnits += 1;
            }
          }
          else if (this.game.Data.UnitObj[index].TempGroup == grp)
            absoluteTempUnits += 1;
        }
      }
      return absoluteTempUnits;
    }

    pub fn GetAverageUnitPowerPointsAbsolute() -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn())
        {
          num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          num2 += 1;
        }
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetAverageEnemyUnitPowerPointsAbsolute() -> i32
    {
      num1: i32;
      num2: i32;
      if (this.EnemyMatrixCounter <= 1)
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut index: i32 = 1; index <= unitCounter; index += 1)
        {
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.UnitObj[index].Regime))
          {
            let mut unr: i32 = index;
            if (unr > -1 & unr <= this.game.Data.UnitCounter)
              num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
            num2 += 1;
          }
        }
      }
      else
      {
        let mut enemyMatrixCounter: i32 = this.EnemyMatrixCounter;
        for (let mut index: i32 = 1; index <= enemyMatrixCounter; index += 1)
        {
          let mut unr: i32 = this.EnemyMatrixUnit[index];
          if (unr > -1 & unr <= this.game.Data.UnitCounter)
            num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          num2 += 1;
        }
      }
      if (num2 == 0)
        num2 = 1;
      return  Math.Round(Conversion.Int( num1 /  num2));
    }

    pub fn GetEnemyEncircledScore( SimpleList tempMove, bool makelog) -> i32
    {
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
        }
      }
      if (makelog)
        this.AddLog("Get Enemy Encircled Score");
      let mut powerPointsAbsolute: i32 = this.GetAverageEnemyUnitPowerPointsAbsolute();
      let mut enemyMatrixCounter1: i32 = this.EnemyMatrixCounter;
      Coordinate coordinate1;
      Coordinate coordinate2;
      enemyEncircledScore: i32;
      for (let mut index: i32 = 1; index <= enemyMatrixCounter1; index += 1)
      {
        let mut unr: i32 = this.EnemyMatrixUnit[index];
        if (!this.game.Data.UnitObj[unr].IsVirtual)
        {
          let mut regime: i32 = this.game.Data.UnitObj[unr].Regime;
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.GetGameDataTurn(), this.GetRegime(regime)))
          {
            let mut num1: i32 = 1;
            coordinate1.x = this.game.Data.UnitObj[unr].X;
            coordinate1.y = this.game.Data.UnitObj[unr].Y;
            coordinate1.onmap = false;
            if (coordinate1.x > -1 & coordinate1.y > -1)
              coordinate1.onmap = true;
            while (coordinate1.onmap & num1 == 1 & this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] != 0)
            {
              num1 = 0;
              if (regime == this.TempOwner[coordinate1.x, coordinate1.y] | this.game.Data.UnitObj[unr].X == coordinate1.x & this.game.Data.UnitObj[unr].Y == coordinate1.y)
              {
                num2: i32;
                if ( this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
                {
                  num2 = 1;
                  break;
                }
                if ( this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixEnemyRealCameFrom[coordinate1.x, coordinate1.y];
                  if (regime == this.TempOwner[coordinate2.x, coordinate2.y])
                  {
                    coordinate1 = coordinate2;
                    num2 = 1;
                    break;
                  }
                }
                if (num1 == 0 &  this.SupplyMatrixEnemyPrognosis[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixEnemyPrognosisCameFrom[coordinate1.x, coordinate1.y];
                  if (regime == this.TempOwner[coordinate2.x, coordinate2.y])
                  {
                    coordinate1 = coordinate2;
                    num1 = 1;
                  }
                }
              }
              if (num1 == 0)
              {
                let mut Number: i32 =  Math.Round(100.0 * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  Math.Max(1, powerPointsAbsolute)) * 0.15 * ( this.GetTscore(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y) / 100.0));
                if (makelog)
                  this.AddLog("ENEMY SOFT encircled: " + this.game.Data.UnitObj[unr].Name + ". Bonus pts =" + Conversion.Str( Number));
                enemyEncircledScore += Number;
              }
            }
          }
        }
      }
      let mut enemyMatrixCounter2: i32 = this.EnemyMatrixCounter;
      for (let mut index3: i32 = 1; index3 <= enemyMatrixCounter2; index3 += 1)
      {
        let mut unr: i32 = this.EnemyMatrixUnit[index3];
        if (!this.game.Data.UnitObj[unr].IsVirtual)
        {
          let mut regime: i32 = this.game.Data.UnitObj[unr].Regime;
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.GetGameDataTurn(), this.GetRegime(regime)))
          {
            let mut num3: i32 = 1;
            coordinate1.x = this.game.Data.UnitObj[unr].X;
            coordinate1.y = this.game.Data.UnitObj[unr].Y;
            coordinate1.onmap = false;
            let mut num4: i32 = 0;
            let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index4: i32 = 0; index4 <= mapWidth2; index4 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index5: i32 = 0; index5 <= mapHeight; index5 += 1)
                this.ptemp3[index4, index5] = 0;
            }
            if (coordinate1.x > -1 & coordinate1.y > -1)
              coordinate1.onmap = true;
            while (coordinate1.onmap & num3 == 1 & this.SupplyMatrixEnemyPrognosis[coordinate1.x, coordinate1.y] != 0)
            {
              num3 = 0;
              if ( this.SupplyMatrixEnemyReal[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
              {
                coordinate2 = this.SupplyMatrixEnemyRealCameFrom[coordinate1.x, coordinate1.y];
                if (regime == this.TempCounterOwner[coordinate2.x, coordinate2.y] | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && this.ptemp3[coordinate2.x, coordinate2.y] == 0)
                {
                  coordinate1 = coordinate2;
                  num3 = 1;
                  num4 += 1;
                  if (num4 == 10)
                    break;
                }
              }
              if (num3 == 0 &  this.SupplyMatrixEnemyPrognosis[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
              {
                coordinate2 = this.SupplyMatrixEnemyPrognosisCameFrom[coordinate1.x, coordinate1.y];
                if (regime == this.TempCounterOwner[coordinate2.x, coordinate2.y] | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && this.ptemp3[coordinate2.x, coordinate2.y] == 0)
                {
                  coordinate1 = coordinate2;
                  num3 = 1;
                }
              }
              if (num3 == 0)
              {
                coordinate2.onmap = false;
                let mut tfacing: i32 = 1;
                do
                {
                  Coordinate coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing);
                  if (coordinate3.onmap && regime == this.TempCounterOwner[coordinate3.x, coordinate3.y] | this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea &&  this.SupplyMatrixEnemyPrognosis[coordinate3.x, coordinate3.y] <  this.game.Data.RuleVar[53] && this.ptemp3[coordinate3.x, coordinate3.y] == 0)
                  {
                    if (!coordinate2.onmap)
                      coordinate2 = coordinate3;
                    else if (this.SupplyMatrixEnemyPrognosis[coordinate3.x, coordinate3.y] < this.SupplyMatrixEnemyPrognosis[coordinate2.x, coordinate2.y])
                      coordinate2 = coordinate3;
                  }
                  tfacing += 1;
                }
                while (tfacing <= 6);
                if (coordinate2.onmap)
                {
                  coordinate1 = coordinate2;
                  num3 = 1;
                  this.ptemp3[coordinate1.x, coordinate1.y] = 1;
                }
              }
              if (num3 == 0)
              {
                let mut Number: i32 =  Math.Round(45.0 * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  Math.Max(1, powerPointsAbsolute)) * ( this.GetTscore(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y) / 100.0));
                if (makelog)
                  this.AddLog("ENEMY HARD encircled: " + this.game.Data.UnitObj[unr].Name + ". Bonus pts =" + Conversion.Str( Number));
                enemyEncircledScore += Number;
              }
            }
          }
        }
      }
      return enemyEncircledScore;
    }

    pub fn GetOurSelvesEncircledScore( SimpleList tempMove, bool makelog, bool IsTest = false) -> i32
    {
      if (makelog)
        this.AddLog("Get Ourselves Encircled Score");
      this.GetGroupHQ(this.OpGroup);
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
          this.ptemp3[index1, index2] = 0;
        }
      }
      let mut powerPointsAbsolute: i32 = this.GetAverageUnitPowerPointsAbsolute();
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
        this.game.Data.UnitObj[index].TempEncircled = 0;
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      bool flag = true;
      let mut num1: i32 = 0;
      num2: i32;
      do
      {
        if (num1 == 0 & !this.game.Data.UnitObj[groupHq].IsHQ)
        {
          flag = true;
          num1 = 2;
        }
        Coordinate coordinate1;
        Coordinate coordinate2;
        Coordinate coordinate3;
        if (num1 == 0 | num1 == 2)
        {
          let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
          for (let mut index: i32 = 1; index <= moveMatrixCounter1; index += 1)
          {
            let mut unr: i32 = this.MoveMatrixUnit[index];
            if (unr == groupHq | num1 == 2)
            {
              let mut num3: i32 = 1;
              let mut num4: i32 =  Math.Round( this.game.Data.RuleVar[52]);
              let mut num5: i32 = Math.Max(0,  Math.Round( ( this.SupplyMatrixReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] - this.game.Data.RuleVar[51])));
              if (num4 > num5)
                num4 = num5;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              coordinate1.onmap = false;
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num3 == 1)
              {
                num3 = 0;
                if (this.SupplyMatrixReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] <= num4)
                {
                  num3 = 1;
                  break;
                }
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn() | this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate1.x, coordinate1.y]))
                {
                  if ( this.SupplyMatrixReal[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[52])
                  {
                    coordinate2 = this.SupplyMatrixRealCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate1.x, coordinate1.y]) | this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == -1)
                    {
                      coordinate1 = coordinate2;
                      num3 = 1;
                    }
                  }
                  if (num3 == 0 &  this.SupplyMatrixPrognosis[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[52])
                  {
                    coordinate2 = this.SupplyMatrixPrognosisCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == -1)
                    {
                      coordinate1 = coordinate2;
                      num3 = 1;
                    }
                  }
                }
                if (this.SupplyMatrixReal[coordinate1.x, coordinate1.y] > num4)
                {
                  if (num3 == 0)
                  {
                    let mut Number: i32 = !(this.game.Data.UnitObj[unr].IsHQ & powerPointsAbsolute > 0) ? 150 :  Math.Round(100.0 * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  powerPointsAbsolute) * 0.75);
                    if ( this.game.Data.UnitObj[unr].SupplyIn <  this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                      Number =  Math.Round( Number * 2.5);
                    if ( this.game.Data.UnitObj[unr].Supply <  this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                      Number =  Math.Round( Number * 1.5);
                    if (this.game.Data.UnitObj[unr].IsHQ)
                      Number *= 3;
                    if (!IsTest)
                      this.game.Data.UnitObj[unr].TempEncircled = 1;
                    if (makelog)
                      this.AddLog("NO EASY SUPPLY ROUTE TO HIGH HQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str( Number));
                    if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                      ;
                    num2 += Number;
                  }
                }
                else
                  break;
              }
              if (num3 == 0 & num1 == 0)
                flag = false;
            }
          }
          let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
          for (let mut index3: i32 = 1; index3 <= moveMatrixCounter2; index3 += 1)
          {
            let mut unr: i32 = this.MoveMatrixUnit[index3];
            if (groupHq == unr)
            {
              let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut index4: i32 = 0; index4 <= mapWidth2; index4 += 1)
              {
                let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut index5: i32 = 0; index5 <= mapHeight; index5 += 1)
                  this.ptemp3[index4, index5] = 0;
              }
              let mut num6: i32 = 1;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              coordinate1.onmap = false;
              let mut num7: i32 = 0;
              let mut num8: i32 =  Math.Round( this.game.Data.RuleVar[52]);
              let mut num9: i32 = Math.Max(0,  Math.Round( ( this.SupplyMatrixReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] - this.game.Data.RuleVar[51])));
              if (num8 > num9)
                num8 = num9;
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num6 == 1 & this.SupplyMatrixReal[coordinate1.x, coordinate1.y] != 0)
              {
                num6 = 0;
                if ( this.SupplyMatrixReal[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[52])
                {
                  coordinate2 = this.SupplyMatrixRealCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num6 = 1;
                    num7 += 1;
                    if (num7 >= 25)
                      break;
                  }
                }
                if (num6 == 0 &  this.SupplyMatrixPrognosis[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[52])
                {
                  coordinate2 = this.SupplyMatrixPrognosisCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num6 = 1;
                  }
                }
                if (num6 == 0)
                {
                  coordinate2.onmap = false;
                  let mut tfacing: i32 = 1;
                  do
                  {
                    coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing);
                    if (coordinate3.onmap && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate3.x, coordinate3.y]) && this.ptemp3[coordinate3.x, coordinate3.y] == 0 && this.SupplyMatrixPrognosis[coordinate3.x, coordinate3.y] < num8)
                    {
                      if (!coordinate2.onmap)
                        coordinate2 = coordinate3;
                      else if (this.SupplyMatrixPrognosis[coordinate3.x, coordinate3.y] < this.SupplyMatrixPrognosis[coordinate2.x, coordinate2.y])
                        coordinate2 = coordinate3;
                    }
                    tfacing += 1;
                  }
                  while (tfacing <= 6);
                  if (coordinate2.onmap)
                  {
                    coordinate1 = coordinate2;
                    num6 = 1;
                    this.ptemp3[coordinate2.x, coordinate2.y] = 1;
                  }
                }
                if (this.SupplyMatrixReal[coordinate1.x, coordinate1.y] > num8)
                {
                  if (num6 == 0)
                  {
                    let mut Number: i32 = !(this.game.Data.UnitObj[unr].IsHQ & powerPointsAbsolute > 0) ? 50 :  Math.Round(100.0 * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  powerPointsAbsolute) * 0.25);
                    if ( this.game.Data.UnitObj[unr].SupplyIn <  this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                      Number =  Math.Round( Number * 2.5);
                    if ( this.game.Data.UnitObj[unr].Supply <  this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                      Number *= 3;
                    if (this.game.Data.UnitObj[unr].IsHQ)
                      Number *= 3;
                    if (!IsTest)
                      this.game.Data.UnitObj[unr].TempEncircled = 2;
                    if (makelog)
                      this.AddLog("NO HARD SUPPLY ROUTE TO HIGH HQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str( Number));
                    if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                      ;
                    num2 += Number;
                  }
                }
                else
                  break;
              }
              if (num6 == 0 & num1 == 0)
                flag = false;
            }
          }
        }
        if (num1 == 1)
        {
          let mut moveMatrixCounter3: i32 = this.MoveMatrixCounter;
          for (let mut index: i32 = 1; index <= moveMatrixCounter3; index += 1)
          {
            let mut unr: i32 = this.MoveMatrixUnit[index];
            if (unr != groupHq)
            {
              let mut num10: i32 = 1;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              if (coordinate1.x == -1)
              {
                coordinate1.x = this.game.Data.UnitObj[unr].X;
                coordinate1.y = this.game.Data.UnitObj[unr].Y;
              }
              coordinate1.onmap = false;
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num10 == 1 & this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] != 0)
              {
                num10 = 0;
                num11: i32;
                if ( this.SupplyMatrixOpHQReal[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] <=  this.game.Data.RuleVar[52])
                {
                  num11 = 1;
                  break;
                }
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn() | this.game.Data.Turn == this.TempOwner[coordinate1.x, coordinate1.y] | this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime == -1)
                {
                  if ( this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
                  {
                    coordinate2 = this.SupplyMatrixOpHQRealCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate1.x, coordinate1.y]))
                    {
                      coordinate1 = coordinate2;
                      num11 = 1;
                      break;
                    }
                  }
                  if (num10 == 0 &  this.SupplyMatrixOpHQPrognosis[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
                  {
                    coordinate2 = this.SupplyMatrixOpHQPrognosisCameFrom[coordinate1.x, coordinate1.y];
                    if (this.GetGameDataTurn() == this.GetRegime(this.TempOwner[coordinate2.x, coordinate2.y]))
                    {
                      coordinate1 = coordinate2;
                      num10 = 1;
                    }
                  }
                }
                if (!flag)
                  num10 = 0;
                if (num10 == 0)
                {
                  let mut Number: i32 = !this.game.Data.UnitObj[unr].IsHQ ? 150 :  Math.Round(100.0 * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  powerPointsAbsolute) * 0.75);
                  if (!flag)
                    Number =  Math.Round( Number / 2.0);
                  if ( this.game.Data.UnitObj[unr].SupplyIn <  this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                    Number =  Math.Round( Number * 2.5);
                  if ( this.game.Data.UnitObj[unr].Supply <  this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                    Number =  Math.Round( Number * 1.5);
                  if (this.game.Data.UnitObj[unr].IsHQ)
                    Number *= 3;
                  if (!IsTest)
                    this.game.Data.UnitObj[unr].TempEncircled = 1;
                  if (makelog)
                    this.AddLog("NO EASY SUPPLY ROUTE TO OPHQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str( Number));
                  if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                    ;
                  num2 += Number;
                }
              }
            }
          }
          let mut moveMatrixCounter4: i32 = this.MoveMatrixCounter;
          for (let mut index6: i32 = 1; index6 <= moveMatrixCounter4; index6 += 1)
          {
            let mut unr: i32 = this.MoveMatrixUnit[index6];
            if (unr != groupHq)
            {
              let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut index7: i32 = 0; index7 <= mapWidth3; index7 += 1)
              {
                let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut index8: i32 = 0; index8 <= mapHeight; index8 += 1)
                  this.ptemp3[index7, index8] = 0;
              }
              let mut num12: i32 = 1;
              coordinate1.x = this.game.Data.UnitObj[unr].TempX;
              coordinate1.y = this.game.Data.UnitObj[unr].TempY;
              coordinate1.onmap = false;
              let mut num13: i32 = 0;
              if (coordinate1.x == -1)
              {
                coordinate1.x = this.game.Data.UnitObj[unr].X;
                coordinate1.y = this.game.Data.UnitObj[unr].Y;
              }
              if (coordinate1.x > -1 & coordinate1.y > -1)
                coordinate1.onmap = true;
              while (coordinate1.onmap & num12 == 1 & this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] != 0)
              {
                num12 = 0;
                if ( this.SupplyMatrixOpHQReal[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixOpHQRealCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num12 = 1;
                    num13 += 1;
                    if (num13 >= 10)
                      break;
                  }
                }
                if (num12 == 0 &  this.SupplyMatrixOpHQPrognosis[coordinate1.x, coordinate1.y] <=  this.game.Data.RuleVar[53])
                {
                  coordinate2 = this.SupplyMatrixOpHQPrognosisCameFrom[coordinate1.x, coordinate1.y];
                  if (this.ptemp3[coordinate2.x, coordinate2.y] == 0 && this.GetGameDataTurn() == this.GetRegime(this.TempCounterOwner[coordinate2.x, coordinate2.y]) | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime == -1)
                  {
                    coordinate1 = coordinate2;
                    num12 = 1;
                  }
                }
                if (num12 == 0)
                {
                  coordinate2.onmap = false;
                  let mut tfacing: i32 = 1;
                  do
                  {
                    coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing);
                    if (coordinate3.onmap && this.GetRegime(this.game.Data.Turn) == this.GetRegime(this.TempCounterOwner[coordinate3.x, coordinate3.y]) && this.ptemp3[coordinate3.x, coordinate3.y] == 0 &&  this.SupplyMatrixOpHQPrognosis[coordinate3.x, coordinate3.y] <  this.game.Data.RuleVar[53])
                    {
                      if (!coordinate2.onmap)
                        coordinate2 = coordinate3;
                      else if (this.SupplyMatrixOpHQPrognosis[coordinate3.x, coordinate3.y] < this.SupplyMatrixOpHQPrognosis[coordinate2.x, coordinate2.y])
                        coordinate2 = coordinate3;
                    }
                    tfacing += 1;
                  }
                  while (tfacing <= 6);
                  if (coordinate2.onmap)
                  {
                    coordinate1 = coordinate2;
                    num12 = 1;
                    this.ptemp3[coordinate2.x, coordinate2.y] = 1;
                  }
                }
                if (!flag)
                  num12 = 0;
                if (num12 == 0)
                {
                  let mut Number: i32 = !this.game.Data.UnitObj[unr].IsHQ ? 50 :  Math.Round(100.0 * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  powerPointsAbsolute) * 0.25);
                  if (!flag)
                    Number =  Math.Round( Number / 2.0);
                  if ( this.game.Data.UnitObj[unr].SupplyIn <  this.game.Data.UnitObj[unr].SupplyInReq * 0.25)
                    Number =  Math.Round( Number * 2.5);
                  if ( this.game.Data.UnitObj[unr].Supply <  this.game.Data.UnitObj[unr].SupplyInReq * 0.1)
                    Number *= 3;
                  if (this.game.Data.UnitObj[unr].IsHQ)
                    Number *= 3;
                  if (!IsTest)
                    this.game.Data.UnitObj[unr].TempEncircled = 2;
                  if (makelog)
                    this.AddLog("NO HARD SUPPLY ROUTE TO OPHQ for " + this.game.Data.UnitObj[unr].Name + ". Penalty pts =" + Conversion.Str( Number));
                  if (this.game.Data.UnitObj[groupHq].AIFallback <= -1 || this.game.Data.UnitObj[unr].FinalX != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x || this.game.Data.UnitObj[unr].FinalY != this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
                    ;
                  num2 += Number;
                }
              }
            }
          }
        }
        num1 += 1;
      }
      while (num1 <= 1);
      return num2 * 8;
    }

    pub fn MakeEnemyPowerDispersed()
    {
      this.EnemyPowerDispersed = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x1: i32 = 0; x1 <= mapWidth; x1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y1: i32 = 0; y1 <= mapHeight; y1 += 1)
        {
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[x1, y1].Regime, this.game.Data.Turn) && this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter > -1)
          {
            let mut num1: i32 = 0;
            let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter;
            for (let mut index: i32 = 0; index <= unitCounter; index += 1)
            {
              let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x1, y1].UnitList[index];
              num1 += this.game.Data.UnitObj[unit].TempUnitPower;
            }
            if (num1 > 0)
            {
              let mut num2: i32 = Math.Max(0, x1 - 5);
              let mut num3: i32 = Math.Min(x1 + 5, this.game.Data.MapObj[0].MapWidth);
              for (let mut x2: i32 = num2; x2 <= num3; x2 += 1)
              {
                let mut num4: i32 = Math.Max(0, y1 - 5);
                let mut num5: i32 = Math.Min(y1 + 5, this.game.Data.MapObj[0].MapHeight);
                for (let mut y2: i32 = num4; y2 <= num5; y2 += 1)
                {
                  let mut num6: i32 = this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0, 6) + 1;
                  let mut num7: i32 = num6 * num6;
                  let mut num8: i32 = 0;
                  if (num7 <= 36)
                    num8 =  Math.Round( num1 /  num7);
                  enemyPowerDispersed: Vec<i32> = this.EnemyPowerDispersed;
                  numArray: Vec<i32> = enemyPowerDispersed;
                  let mut index1: i32 = x2;
                  let mut index2: i32 = index1;
                  let mut index3: i32 = y2;
                  let mut index4: i32 = index3;
                  let mut num9: i32 = enemyPowerDispersed[index1, index3] + num8;
                  numArray[index2, index4] = num9;
                }
              }
            }
          }
        }
      }
    }

    pub fn MakeFriendlyPowerDispersed()
    {
      this.FriendlyPowerDispersed = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut x1: i32 = 0; x1 <= mapWidth; x1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut y1: i32 = 0; y1 <= mapHeight; y1 += 1)
        {
          if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.MapObj[0].HexObj[x1, y1].Regime, this.game.Data.Turn) && this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter > -1)
          {
            let mut num1: i32 = 0;
            let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x1, y1].UnitCounter;
            for (let mut index: i32 = 0; index <= unitCounter; index += 1)
            {
              let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x1, y1].UnitList[index];
              if (this.game.Data.UnitObj[unit].AIGroup != this.OpGroup)
                num1 += this.game.Data.UnitObj[unit].TempUnitPower;
            }
            if (num1 > 0)
            {
              let mut num2: i32 = Math.Max(0, x1 - 5);
              let mut num3: i32 = Math.Min(x1 + 5, this.game.Data.MapObj[0].MapWidth);
              for (let mut x2: i32 = num2; x2 <= num3; x2 += 1)
              {
                let mut num4: i32 = Math.Max(0, y1 - 5);
                let mut num5: i32 = Math.Min(y1 + 5, this.game.Data.MapObj[0].MapHeight);
                for (let mut y2: i32 = num4; y2 <= num5; y2 += 1)
                {
                  let mut num6: i32 = this.game.HandyFunctionsObj.Distance(x1, y1, 0, x2, y2, 0, 6) + 1;
                  let mut num7: i32 = num6 * num6;
                  let mut num8: i32 = 0;
                  if (num7 <= 36)
                    num8 =  Math.Round( num1 /  num7);
                  friendlyPowerDispersed: Vec<i32> = this.FriendlyPowerDispersed;
                  numArray: Vec<i32> = friendlyPowerDispersed;
                  let mut index1: i32 = x2;
                  let mut index2: i32 = index1;
                  let mut index3: i32 = y2;
                  let mut index4: i32 = index3;
                  let mut num9: i32 = friendlyPowerDispersed[index1, index3] + num8;
                  numArray[index2, index4] = num9;
                }
              }
            }
          }
        }
      }
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index5: i32 = 0; index5 <= moveMatrixCounter; index5 += 1)
      {
        let mut index6: i32 = this.MoveMatrixUnit[index5];
        let mut tempX: i32 = this.game.Data.UnitObj[index6].TempX;
        let mut tempY: i32 = this.game.Data.UnitObj[index6].TempY;
        if (tempX > -1 & tempY > -1)
        {
          let mut tempUnitPower: i32 = this.game.Data.UnitObj[index6].TempUnitPower;
          let mut num10: i32 = Math.Max(0, tempX - 5);
          let mut num11: i32 = Math.Min(tempX + 5, this.game.Data.MapObj[0].MapWidth);
          for (let mut x2: i32 = num10; x2 <= num11; x2 += 1)
          {
            let mut num12: i32 = Math.Max(0, tempY - 5);
            let mut num13: i32 = Math.Min(tempY + 5, this.game.Data.MapObj[0].MapHeight);
            for (let mut y2: i32 = num12; y2 <= num13; y2 += 1)
            {
              let mut num14: i32 = this.game.HandyFunctionsObj.Distance(tempX, tempY, 0, x2, y2, 0, 6) + 1;
              let mut num15: i32 = num14 * num14;
              let mut num16: i32 = 0;
              if (num15 <= 36)
                num16 =  Math.Round( tempUnitPower /  num15);
              friendlyPowerDispersed: Vec<i32> = this.FriendlyPowerDispersed;
              numArray: Vec<i32> = friendlyPowerDispersed;
              let mut index7: i32 = x2;
              let mut index8: i32 = index7;
              let mut index9: i32 = y2;
              let mut index10: i32 = index9;
              let mut num17: i32 = friendlyPowerDispersed[index7, index9] + num16;
              numArray[index8, index10] = num17;
            }
          }
        }
      }
    }

    pub fn GetCounterMoveScore( SimpleList tempMove, bool makelog) -> i32
    {
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      if (Operators.CompareString(this.GroupName[this.OpGroup], "IL Corps", false) == 0)
      {
        let mut num1: i32 = num1;
      }
      let mut num2: i32 = 6;
      this.MakeFriendlyPowerDispersed();
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
          this.pmatrix.Value[index1, index2] = false;
        }
      }
      if (makelog)
        this.AddLog("Enemy Counter Moves");
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[unr].AIGroup == this.OpGroup)
          {
            if (this.game.Data.UnitObj[unr].TempX > -1 && this.GetRegime(this.TempCounterOwner[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY]) == this.GetGameDataTurn() && this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr, true, false) > 10)
            {
              ptemp2: Vec<i32> = this.ptemp2;
              numArray: Vec<i32> = ptemp2;
              let mut tempX: i32 = this.game.Data.UnitObj[unr].TempX;
              let mut index3: i32 = tempX;
              let mut tempY: i32 = this.game.Data.UnitObj[unr].TempY;
              let mut index4: i32 = tempY;
              let mut num3: i32 = ptemp2[tempX, tempY] + 1;
              numArray[index3, index4] = num3;
              this.pmatrix.Value[this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY] = true;
            }
          }
          else if (this.game.Data.UnitObj[unr].X > -1 && this.GetRegime(this.TempCounterOwner[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y]) == this.GetGameDataTurn() && this.game.Data.UnitObj[unr].AIDefend == this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] | this.game.Data.UnitObj[unr].AIFallback == this.AreaMatrixNarrow[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] && this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr, true, false) > 10)
          {
            ptemp2: Vec<i32> = this.ptemp2;
            numArray: Vec<i32> = ptemp2;
            let mut x: i32 = this.game.Data.UnitObj[unr].X;
            let mut index5: i32 = x;
            let mut y: i32 = this.game.Data.UnitObj[unr].Y;
            let mut index6: i32 = y;
            let mut num4: i32 = ptemp2[x, y] + 1;
            numArray[index5, index6] = num4;
            this.pmatrix.Value[this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y] = true;
          }
        }
      }
      let mut enemyMatrixCounter1: i32 = this.EnemyMatrixCounter;
      unr1: i32;
      Coordinate coordinate1;
      counterMoveScore: i32;
      for (let mut index7: i32 = 1; index7 <= enemyMatrixCounter1; index7 += 1)
      {
        unr1 = this.EnemyMatrixUnit[index7];
        let mut num5: i32 = Math.Max(this.game.Data.UnitObj[unr1].X - num2, this.CMS1.x);
        let mut num6: i32 = Math.Min(this.game.Data.UnitObj[unr1].X + num2, this.CMS2.x);
        let mut num7: i32 = Math.Max(this.game.Data.UnitObj[unr1].Y - num2, this.CMS1.y);
        let mut num8: i32 = Math.Min(this.game.Data.UnitObj[unr1].Y + num2, this.CMS2.y);
        let mut num9: i32 = num5;
        let mut num10: i32 = num6;
        for (let mut index8: i32 = num9; index8 <= num10; index8 += 1)
        {
          let mut num11: i32 = num7;
          let mut num12: i32 = num8;
          for (let mut index9: i32 = num11; index9 <= num12; index9 += 1)
          {
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index8, index9].Regime) == this.GetGameDataTurn() & this.ptemp2[index8, index9] <= 0 && this.ptemp[index8, index9] == 0)
            {
              let mut num13: i32 = 0;
              if (this.AdvanceAxisMatrix[index8, index9] == 0)
                num13 = 1;
              if (this.game.Data.MapObj[0].HexObj[index8, index9].Location > -1 | this.game.HandyFunctionsObj.HasHexBridge(index8, index9, 0))
                num13 = 1;
              if (this.SupplyMatrix[index8, index9] > -1 & this.SupplyMatrixDistance[index8, index9] == 0)
                num13 = 1;
              if (this.FrontlineArea[index8, index9] == 1)
                num13 = 1;
              let mut num14: i32 = 1;
              coordinate1.x = index8;
              coordinate1.y = index9;
              coordinate1.onmap = true;
              let mut val1: i32 = this.EnemyPowerDispersed[index8, index9] <= this.FriendlyPowerDispersed[index8, index9] * 1 ? (this.EnemyPowerDispersed[index8, index9] <=  Math.Round( this.FriendlyPowerDispersed[index8, index9] * 0.75) ? (this.EnemyPowerDispersed[index8, index9] <=  Math.Round( this.FriendlyPowerDispersed[index8, index9] * 0.5) ? (this.EnemyPowerDispersed[index8, index9] <=  Math.Round( this.FriendlyPowerDispersed[index8, index9] * 0.4) ? (this.EnemyPowerDispersed[index8, index9] <=  Math.Round( this.FriendlyPowerDispersed[index8, index9] * 0.3) ? (this.EnemyPowerDispersed[index8, index9] <=  Math.Round( this.FriendlyPowerDispersed[index8, index9] * 0.2) ? (this.EnemyPowerDispersed[index8, index9] <=  Math.Round( this.FriendlyPowerDispersed[index8, index9] * 0.1) ? 75 : 100) : 125) : 150) : 175) : 200) : 250) : 300;
              let mut num15: i32 = (this.game.Data.UnitObj[unr1].SupplyConsume <= 80 ? (this.game.Data.UnitObj[unr1].SupplyConsume <= 50 ? Math.Max(10, this.game.HandyFunctionsObj.GetAverageRdn(unr1) - 50) : Math.Max(10, this.game.HandyFunctionsObj.GetAverageRdn(unr1) - 25)) : (!this.game.Data.UnitObj[unr1].DidAttack ? Math.Min(val1, this.game.HandyFunctionsObj.GetAverageRdn(unr1) + 25) : Math.Min(75, this.game.HandyFunctionsObj.GetAverageRdn(unr1) - 25))) + 15;
              if (this.EnemyMatrix[index7, index8, index9] > num15)
                num14 = 0;
              if (this.game.HandyFunctionsObj.HasUnitAirSF(unr1))
                num14 = 0;
              if (this.GetRegime(this.TempOwner[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y]) != this.GetGameDataTurn() | this.game.Data.MapObj[0].HexObj[index8, index9].Location > -1)
              {
                while (num14 == 1 & !(coordinate1.x == this.game.Data.UnitObj[unr1].X & coordinate1.y == this.game.Data.UnitObj[unr1].Y))
                {
                  num14 = 0;
                  if (this.EnemyMatrixCameFrom[index7, coordinate1.x, coordinate1.y].onmap)
                  {
                    sCoordinate sCoordinate = this.EnemyMatrixCameFrom[index7, coordinate1.x, coordinate1.y];
                    coordinate1.x =  sCoordinate.x;
                    coordinate1.y =  sCoordinate.y;
                    coordinate1.onmap = sCoordinate.onmap;
                    coordinate1.onmap = true;
                    num14 = 1;
                  }
                  else
                  {
                    coordinate1.onmap = false;
                    coordinate1.x = -1;
                  }
                  if (coordinate1.onmap && this.ptemp2[coordinate1.x, coordinate1.y] > 0)
                    num14 = 0;
                }
              }
              if (num14 == 1)
              {
                if (this.tArea[index8, index9] > 0)
                {
                  let mut d: i32 =  Math.Round(Math.Sqrt(num13 != 1 ? 10.0 :  this.GetTscore(index8, index9, IsCounterAttack: true)) * 4.0);
                  if (this.GetRegime(this.TempOwner[index8, index9]) != this.GetGameDataTurn())
                    d =  Math.Round( d / 2.0);
                  if (this.BottleNeckMatrix[index8, index9] > 0)
                    d *=  Math.Round(3.0 * Math.Sqrt(Math.Min(100.0,  this.BottleNeckMatrix[index8, index9] / 3.0)));
                  if ( this.game.Data.RuleVar[265] > 0.0 &&  (this.game.HandyFunctionsObj.GetRegimeVP(this.GetGameDataTurn()) - this.game.Data.MapObj[0].HexObj[index8, index9].VP) <  this.game.Data.RuleVar[265])
                    d = (d + 200) * 10;
                  let mut Number: i32 =  Math.Round(Math.Sqrt( d) * 10.0);
                  if (makelog)
                    this.AddLog("Enemy counter move on <" + Conversion.Str( index8) + "," + Conversion.Str( index9) + "> give " + Conversion.Str( Number) + "pts. with unit: " + this.game.Data.UnitObj[unr1].Name);
                  counterMoveScore += Number;
                }
                this.ptemp[index8, index9] = 1;
                this.TempCounterOwner[index8, index9] = this.game.Data.UnitObj[unr1].Regime;
              }
            }
          }
        }
      }
      if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
      {
        let mut enemyMatrixCounter2: i32 = this.EnemyMatrixCounter;
        for (let mut index10: i32 = 1; index10 <= enemyMatrixCounter2; index10 += 1)
        {
          unr1 = this.EnemyMatrixUnit[index10];
          let mut num16: i32 = this.game.HandyFunctionsObj.GetAverageRdn(unr1);
          if (this.game.Data.UnitObj[unr1].SupplyIn > 0)
            num16 += 30;
          if (num16 > 100)
            num16 = 100;
          handyFunctionsObj: HandyFunctionsclass = this.game.HandyFunctionsObj;
          let mut unr2: i32 = unr1;
          let mut x1: i32 = this.game.Data.UnitObj[unr1].X;
          let mut y1: i32 = this.game.Data.UnitObj[unr1].Y;
          MapMatrix2Boolean pmatrix = this.pmatrix;
          CustomDC2AICalls customDc2AiCalls = (CustomDC2AICalls) null;
           CustomDC2AICalls local =  customDc2AiCalls;
          handyFunctionsObj.MakeMovePrediction3(unr2, x1, y1, 0, TempUnitsMatrix: pmatrix, tcustomAi: ( local));
          let mut x2: i32 = this.CMS1.x;
          let mut x3: i32 = this.CMS2.x;
          for (let mut index11: i32 = x2; index11 <= x3; index11 += 1)
          {
            let mut y2: i32 = this.CMS1.y;
            let mut y3: i32 = this.CMS2.y;
            for (let mut index12: i32 = y2; index12 <= y3; index12 += 1)
            {
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index11, index12].Regime) == this.GetGameDataTurn() && this.ptemp[index11, index12] == 0 && this.game.EditObj.TempValue[0].Value[index11, index12] <= num16)
              {
                this.ptemp[index11, index12] = 1;
                this.TempCounterOwner[index11, index12] = this.game.Data.UnitObj[unr1].Regime;
                let mut Number: i32 =  Math.Round( this.GetTscore(index11, index12, IsCounterAttack: true) / 2.0);
                if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
                  Number =  Math.Round( Number * 1.5);
                if (makelog)
                  this.AddLog("Enemy counter move on (AI slow calc mode) <" + Conversion.Str( index11) + "," + Conversion.Str( index12) + "> give " + Conversion.Str( Number) + "pts. with unit: " + this.game.Data.UnitObj[unr1].Name);
                counterMoveScore += Number;
              }
            }
          }
        }
      }
      let mut x4: i32 = this.CMS1.x;
      let mut x5: i32 = this.CMS2.x;
      for (let mut cx: i32 = x4; cx <= x5; cx += 1)
      {
        let mut y4: i32 = this.CMS1.y;
        let mut y5: i32 = this.CMS2.y;
        for (let mut cy: i32 = y4; cy <= y5; cy += 1)
        {
          if (this.ptemp[cx, cy] == 1)
          {
            let mut tfacing1: i32 = 1;
            do
            {
              coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing1);
              if (coordinate1.onmap && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[coordinate1.map].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
              {
                let mut num17: i32 = 0;
                if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Location <= -1 & this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn())
                {
                  if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].UnitCounter > -1 | this.ptemp2[coordinate1.x, coordinate1.y] > 0)
                    num17 += 1;
                  let mut tfacing2: i32 = 1;
                  do
                  {
                    Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                    if (coordinate2.onmap && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime) == this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].UnitCounter > -1 | this.ptemp2[coordinate2.x, coordinate2.y] > 0)
                      num17 += 1;
                    tfacing2 += 1;
                  }
                  while (tfacing2 <= 6);
                  if (num17 == 0)
                    this.TempCounterOwner[coordinate1.x, coordinate1.y] = this.game.Data.UnitObj[unr1].Regime;
                }
              }
              tfacing1 += 1;
            }
            while (tfacing1 <= 6);
          }
        }
      }
      return counterMoveScore;
    }

    pub fn GetCounterAttackScore( SimpleList tempMove, bool makelog) -> i32
    {
      int[] numArray1 = new int[this.game.Data.UnitCounter + 1];
      int[] numArray2 = new int[this.game.Data.UnitCounter + 1];
      numArray3: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut Number1: i32 = 0;
      let mut num1: i32 = 1;
      do
      {
        let mut unitCounter1: i32 = this.game.Data.UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
          this.ptempb[index] = false;
        this.GetGroupHQ(this.OpGroup);
        let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          {
            this.ptemp[index1, index2] = 0;
            this.ptemp2[index1, index2] = 0;
          }
        }
        if (Operators.CompareString(this.GroupName[this.OpGroup], "III Hungarian Corps", false) == 0)
          ;
        if (makelog)
          this.AddLog("Enemy Counter Attacks");
        let mut unitCounter2: i32 = this.game.Data.UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter2; index += 1)
        {
          if (this.GetRegime(this.game.Data.UnitObj[index].Regime) != this.GetGameDataTurn())
          {
            this.game.Data.UnitObj[index].TempX = -1;
            this.game.Data.UnitObj[index].TempY = -1;
            this.game.Data.UnitObj[index].DidAttack = false;
          }
        }
        let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
        index3: i32;
        index4: i32;
        for (index3 = 0; index3 <= mapWidth2; index3 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (index4 = 0; index4 <= mapHeight; index4 += 1)
          {
            this.TempCounterOwner[index3, index4] = this.TempOwner[index3, index4];
            this.ptemp[index3, index4] = -1;
          }
        }
        let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
        for (let mut index5: i32 = 1; index5 <= moveMatrixCounter1; index5 += 1)
        {
          let mut index6: i32 = this.MoveMatrixUnit[index5];
          index3 = this.game.Data.UnitObj[index6].TempX;
          index4 = this.game.Data.UnitObj[index6].TempY;
          if (index3 == -1)
          {
            index3 = this.game.Data.UnitObj[index6].X;
            index4 = this.game.Data.UnitObj[index6].Y;
          }
          this.ptemp[index3, index4] = index6;
        }
        let mut unitCounter3: i32 = this.game.Data.UnitCounter;
        for (let mut index7: i32 = 0; index7 <= unitCounter3; index7 += 1)
        {
          let mut num2: i32 = 0;
          let mut index8: i32 = index7;
          if (this.game.Data.UnitObj[index8].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index8].PreDef == -1)
          {
            if (this.game.Data.UnitObj[index8].AIGroup == this.OpGroup)
            {
              num2 = 1;
              index3 = this.game.Data.UnitObj[index8].TempX;
              index4 = this.game.Data.UnitObj[index8].TempY;
            }
            else if (this.game.Data.UnitObj[index8].X > -1 && this.ptemp2[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] < 1 && this.tArea[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] == 2)
            {
              num2 = 2;
              index3 = -1;
            }
          }
          if (num2 >= 1)
          {
            this.ptemp2[this.game.Data.UnitObj[index8].X, this.game.Data.UnitObj[index8].Y] = 1;
            if (index3 == -1)
            {
              index3 = this.game.Data.UnitObj[index8].X;
              index4 = this.game.Data.UnitObj[index8].Y;
            }
            let mut Number2: i32 = 0;
            let mut num3: i32 = 0;
            let mut num4: i32 = 0;
            let mut unitCounter4: i32 = this.game.Data.UnitCounter;
            for (let mut index9: i32 = 0; index9 <= unitCounter4; index9 += 1)
              this.ptempb[index9] = false;
            if (index3 > -1 & index4 > -1 && numArray3[index3, index4] < num1)
            {
              let mut enemyMatrixCounter: i32 = this.EnemyMatrixCounter;
              unr: i32;
              for (let mut index10: i32 = 1; index10 <= enemyMatrixCounter; index10 += 1)
              {
                unr = this.EnemyMatrixUnit[index10];
                this.game.Data.UnitObj[unr].TempX = -1;
                this.game.Data.UnitObj[unr].TempY = -1;
                this.game.Data.UnitObj[unr].TempSlot = -1;
                let mut num5: i32 = 0;
                let mut num6: i32 = 0;
                let mut num7: i32 = this.game.Data.UnitObj[unr].SupplyConsume <= 80 ? Math.Max(10, this.game.HandyFunctionsObj.GetAverageRdn(unr)) : Math.Min(120, this.game.HandyFunctionsObj.GetAverageRdn(unr) + 30);
                if (index3 == 48 & index4 == 34)
                  index3 = index3;
                Coordinate coordinate;
                if (this.EnemyMatrix[index10, index3, index4] <= num7)
                {
                  num6 = 1;
                  coordinate.x = index3;
                  coordinate.y = index4;
                  coordinate.onmap = true;
                  if (this.game.HandyFunctionsObj.HasUnitAirSF(unr))
                    num6 = 0;
                  while (num6 == 1 & !(coordinate.x == this.game.Data.UnitObj[unr].X & coordinate.y == this.game.Data.UnitObj[unr].Y))
                  {
                    num6 = 0;
                    if (this.EnemyMatrixCameFrom[index10, coordinate.x, coordinate.y].onmap)
                    {
                      sCoordinate sCoordinate = this.EnemyMatrixCameFrom[index10, coordinate.x, coordinate.y];
                      coordinate.x =  sCoordinate.x;
                      coordinate.y =  sCoordinate.y;
                      coordinate.onmap = sCoordinate.onmap;
                      num6 = 1;
                      let mut index11: i32 = this.ptemp[coordinate.x, coordinate.y];
                      if (index11 > -1 & !(num1 == 2 & this.GetRegime(this.TempCounterOwner[coordinate.x, coordinate.y]) == this.GetGameDataTurn()))
                      {
                        num4 += this.game.Data.UnitObj[unr].TempUnitPower;
                        if (!this.ptempb[index11])
                        {
                          num5 += this.GetPrognosedAndRealDefendingPowerPointsOn(coordinate.x, coordinate.y, CounterAttack: true);
                          this.ptempb[index11] = true;
                          break;
                        }
                      }
                    }
                    else
                    {
                      coordinate.onmap = false;
                      coordinate.x = -1;
                    }
                  }
                }
                if (num6 == 1)
                {
                  sCoordinate sCoordinate = this.EnemyMatrixCameFrom[index10, index3, index4];
                  coordinate.x =  sCoordinate.x;
                  coordinate.y =  sCoordinate.y;
                  coordinate.onmap = sCoordinate.onmap;
                  this.game.Data.UnitObj[unr].TempX = coordinate.x;
                  this.game.Data.UnitObj[unr].TempY = coordinate.y;
                  this.game.Data.UnitObj[unr].TempSlot = index10;
                  Number2 += num5;
                  num3 += this.game.Data.UnitObj[unr].TempUnitPower;
                }
              }
              if (index3 == 46 & index4 == 35)
                index3 = index3;
              let mut Number3: i32 = this.GetPrognosedEnemyLandAttackPowerPointsOn(index3, index4, OptimisticStack: true, LeaveFrontLineEmptyPenalty: true);
              let mut num8: i32 = this.GetPrognosedEnemyStackPointsOn(index3, index4, OptimisticStack: true);
              if (makelog)
                this.AddLog("Tot enemy power on " + this.game.Data.UnitObj[index8].Name + "  = " + Conversion.Str( Number3) + ", block: " + Conversion.Str( Number2));
              if (Number3 > 100)
                Number3 = 100 +  Math.Round( (Number3 - 100) * 0.75);
              if (Number3 > 250)
                Number3 = 250 +  Math.Round( (Number3 - 250) * 0.66);
              if (Number3 > 500)
                Number3 = 500 +  Math.Round( (Number3 - 500) * 0.5);
              if (Number3 > 700)
                Number3 = 700 +  Math.Round( (Number3 - 700) * 0.5);
              if (Number3 > 900)
                Number3 = 900 +  Math.Round( (Number3 - 900) * 0.5);
              if (Number3 > 1300)
                Number3 = 1300 +  Math.Round( (Number3 - 1300) * 0.45);
              if (Number3 > 1700)
                Number3 = 1700 +  Math.Round( (Number3 - 1700) * 0.4);
              if (index3 == 47 & index4 == 34)
                index3 = index3;
              if (this.FrontlineArea[index3, index4] == 2)
              {
                num8 =  Math.Round( num8 / 1.5);
                Number3 *= 1;
              }
              if ( num8 >  this.game.Data.RuleVar[30] * 1.33)
                Number3 =  Math.Round( Number3 / ( num8 / ( this.game.Data.RuleVar[30] * 1.33)));
              if (!Information.IsNothing( this.game.EditObj.TempUnitList) && this.game.EditObj.TempUnitList.counter > 12)
                Number3 =  Math.Round( Number3 * ( this.game.EditObj.TempUnitList.counter / 12.0));
              if (index3 == 63 & index4 == 54)
                index3 = index3;
              Number4: i32;
              if (num3 > num4)
              {
                let mut num9: i32 =  Math.Round( Number3 * ( num4 /  num3)) - Number2 * 5;
                if (0 > num9)
                  num9 = 0;
                Number4 = num9 + Number3 *  Math.Round( (num3 - num4) /  num3);
              }
              else
                Number4 = Number3 - Number2 * 5;
              if (0 > Number4)
                Number4 = 0;
              let mut Number5: i32 = 0;
              let mut num10: i32 = 0;
              num11: i32;
              if (num2 == 2)
              {
                Number5 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyOpGroup: true, CounterAttack: true);
                num10 = Number5;
              }
              else
              {
                let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
                for (let mut index12: i32 = 0; index12 <= moveMatrixCounter2; index12 += 1)
                {
                  let mut OnlyUnit: i32 = this.MoveMatrixUnit[index12];
                  let mut num12: i32 = 0;
                  let mut num13: i32 = 0;
                  if (this.game.Data.UnitObj[OnlyUnit].TempX == index3 & this.game.Data.UnitObj[OnlyUnit].TempY == index4)
                  {
                    if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 2 | this.game.Data.UnitObj[OnlyUnit].TempCategory == 5 | this.game.Data.UnitObj[OnlyUnit].TempCategory == 3)
                    {
                      num12 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyOpGroup: true, OnlyUnit: OnlyUnit, CounterAttack: true);
                      num13 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, true, OnlyUnit, true);
                    }
                    else
                    {
                      num12 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyUnit: OnlyUnit, CounterAttack: true);
                      num13 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, OnlyUnit: OnlyUnit, CounterAttack: true);
                    }
                    let mut defendingPowerPointsOn: i32 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, true, OnlyUnit, true);
                    if (defendingPowerPointsOn <= num13 & num13 > 0)
                    {
                      if (this.game.Data.UnitObj[OnlyUnit].IsHQ)
                        num12 =  Math.Round( num12 * (1.0 -  defendingPowerPointsOn /  num13) + 0.2 *  num12 * ( defendingPowerPointsOn /  num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 2)
                        num12 =  Math.Round( num12 * (1.0 -  defendingPowerPointsOn /  num13) + 0.1 *  num12 * ( defendingPowerPointsOn /  num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 5)
                        num12 =  Math.Round( num12 * (1.0 -  defendingPowerPointsOn /  num13) + 0.1 *  num12 * ( defendingPowerPointsOn /  num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 4)
                        num12 =  Math.Round( num12 * (1.0 -  defendingPowerPointsOn /  num13) + 0.2 *  num12 * ( defendingPowerPointsOn /  num13));
                      if (this.game.Data.UnitObj[OnlyUnit].TempCategory == 3)
                        num12 =  Math.Round( num12 * (1.0 -  defendingPowerPointsOn /  num13) + 0.05 *  num12 * ( defendingPowerPointsOn /  num13));
                    }
                  }
                  if (num12 > 0)
                    num11 += this.game.Data.UnitObj[OnlyUnit].TempUnitPower;
                  Number5 += num12;
                  num10 += num13;
                }
                let mut unitCounter5: i32 = this.game.Data.MapObj[0].HexObj[index3, index4].UnitCounter;
                for (let mut index13: i32 = 0; index13 <= unitCounter5; index13 += 1)
                {
                  let mut unit: i32 = this.game.Data.MapObj[0].HexObj[index3, index4].UnitList[index13];
                  if (this.game.Data.UnitObj[unit].AIDefend == this.AreaMatrixNarrow[index3, index4] & this.game.Data.UnitObj[unit].AIGroup != this.OpGroup)
                  {
                    let mut defendingPowerPointsOn1: i32 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, OnlyOpGroup: true, OnlyUnit: unit, CounterAttack: true);
                    let mut defendingPowerPointsOn2: i32 = this.GetPrognosedDefendingPowerPointsOn(index3, index4, false, true, unit, true);
                    Number5 += defendingPowerPointsOn1;
                    num10 += defendingPowerPointsOn2;
                  }
                }
              }
              float num14 = 1f;
              if (Number5 == 0)
                Number5 = 1;
              if (num10 > Number5)
                num14 =  num10 /  Number5;
              if ( num14 > 3.0)
                num14 =  (2.0 + Math.Sqrt( num14 - 2.0));
              let mut Number6: i32 =  Math.Round(Math.Min(5.0,  Number4 /  Number5) * 20.0);
              let mut num15: i32 = this.BottleNeckMatrix[index3, index4] <= 20 ? (this.BottleNeckMatrix[index3, index4] <= 5 ? (this.FrontlineArea[index3, index4] != 2 ?  Math.Round( this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.66) :  Math.Round( this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.6)) :  Math.Round( this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.55)) :  Math.Round( this.ATTACK_MINIMUM_ACTUAL_ATTACK * 0.5);
              if (Number6 >= num15)
              {
                let mut num16: i32 =  Math.Round( this.game.Data.RuleVar[30]);
                let mut counter1: i32 = this.game.EditObj.TempUnitList.counter;
                for (let mut index14: i32 = 0; index14 <= counter1; index14 += 1)
                {
                  let mut num17: i32 = this.game.EditObj.TempUnitList.unr[index14];
                  if (num17 > -1)
                  {
                    int[] numArray4 = numArray1;
                    int[] numArray5 = numArray4;
                    let mut index15: i32 = num17;
                    let mut index16: i32 = index15;
                    let mut num18: i32 = numArray4[index15] + 1;
                    numArray5[index16] = num18;
                    if (num8 > num16)
                    {
                      int[] numArray6 = numArray2;
                      int[] numArray7 = numArray6;
                      let mut index17: i32 = num17;
                      let mut index18: i32 = index17;
                      let mut num19: i32 = numArray6[index17] + (num8 - num16);
                      numArray7[index18] = num19;
                    }
                  }
                }
                if (index3 == 42 & index4 == 29)
                  index3 = index3;
                if (this.BottleNeckMatrix[index3, index4] > 20)
                {
                  if (Number6 >=  Math.Round( num15 * 1.25))
                    this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                }
                else if (this.BottleNeckMatrix[index3, index4] > 5)
                {
                  if (Number6 >=  Math.Round( num15 * 1.4))
                    this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                }
                else if (this.FrontlineArea[index3, index4] == 2)
                {
                  if (Number6 >=  Math.Round( num15 * 1.55))
                    this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                }
                else if (Number6 >=  Math.Round( num15 * 1.7))
                  this.TempCounterOwner[index3, index4] = this.game.Data.UnitObj[unr].Regime;
                if (num11 > 0)
                {
                  let mut moveMatrixCounter3: i32 = this.MoveMatrixCounter;
                  for (let mut index19: i32 = 0; index19 <= moveMatrixCounter3; index19 += 1)
                  {
                    let mut index20: i32 = this.MoveMatrixUnit[index19];
                    if (this.game.Data.UnitObj[index20].TempX == index3 & this.game.Data.UnitObj[index20].TempY == index4)
                    {
                      if (this.game.Data.UnitObj[index20].IsHQ)
                        Number6 +=  Math.Round( (Number6 * 8) * ( this.game.Data.UnitObj[index20].TempUnitPower /  num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 2)
                        Number6 +=  Math.Round( (Number6 * 4) * ( this.game.Data.UnitObj[index20].TempUnitPower /  num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 5)
                        Number6 +=  Math.Round( (Number6 * 4) * ( this.game.Data.UnitObj[index20].TempUnitPower /  num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 4)
                        Number6 +=  Math.Round( (Number6 * 4) * ( this.game.Data.UnitObj[index20].TempUnitPower /  num11));
                      if (this.game.Data.UnitObj[index20].TempCategory == 3)
                        Number6 +=  Math.Round( (Number6 * 12) * ( this.game.Data.UnitObj[index20].TempUnitPower /  num11));
                    }
                  }
                }
                if (num1 == 2)
                  Number6 =  Math.Round( Number6 / 2.0);
                let mut Number7: i32 =  Math.Round( ( Number6 * num14));
                let mut pointsOnOnlyPower: i32 = this.GetPrognosedDefendingPowerPointsOnOnlyPower(index3, index4);
                let mut num20: i32 = 80;
                if ( this.game.Data.RuleVar[384] > 0.0)
                  num20 =  Math.Round( this.game.Data.RuleVar[384]);
                if (pointsOnOnlyPower > num20)
                {
                  Number7 =  Math.Round( Number7 * ( pointsOnOnlyPower /  num20));
                  if (makelog)
                    this.AddLog("Large Target Bonus. " + Conversion.Str( (100.0 * ( pointsOnOnlyPower /  num20) - 100.0)) + "% extra pts!");
                }
                if (this.BottleNeckMatrix[index3, index4] > 0)
                {
                  Number7 =  Math.Round( Number7 * Math.Sqrt(Math.Min(25.0,  this.BottleNeckMatrix[index3, index4] / 5.0)));
                  if (makelog)
                    this.AddLog("Multiply pts by: " + Math.Sqrt(Math.Min(100.0,  this.BottleNeckMatrix[index3, index4] / 3.0)).ToString() + " to make these more profitable to avoid .... Bottleneck Matrix Score was = " + this.BottleNeckMatrix[index3, index4].ToString());
                }
                if (makelog)
                  this.AddLog("EASY ROUTE Counterattack on <" + Conversion.Str( index3) + "," + Conversion.Str( index4) + ">.  With att = " + Conversion.Str( Number4) + " vs def = " + Conversion.Str( Number5) + ". Basicstack= " + num8.ToString() + "... Is " + Conversion.Str( Number7) + " points. ");
                if (makelog & this.game.EditObj.TempUnitList.counter > -1)
                {
                  let mut counter2: i32 = this.game.EditObj.TempUnitList.counter;
                  for (let mut index21: i32 = 0; index21 <= counter2; index21 += 1)
                  {
                    this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index21]].DidAttack = false;
                    this.AddLog("-WITH " + this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index21]].Name);
                  }
                }
                Number1 += Number7;
                this.CounterAttackPossible[index3, index4] =  Math.Round(100.0 * ( Number7 /  num15));
                numArray3[index3, index4] = num1;
              }
              else
              {
                if (makelog)
                  this.AddLog("NO easy counterattack on <" + Conversion.Str( index3) + "," + Conversion.Str( index4) + ">.  With att = " + Conversion.Str( Number4) + " vs def = " + Conversion.Str( Number5) + ". Basicstack= " + num8.ToString() + ". Is " + Conversion.Str( Number6) + " points. (tscore=" + Conversion.Str( this.GetTscore(index3, index4)) + ")");
                this.CounterAttackPossible[index3, index4] =  Math.Round(100.0 * ( Number6 /  num15));
                numArray3[index3, index4] = num1;
                if (!Information.IsNothing( this.game.EditObj.TempUnitList) && makelog & this.game.EditObj.TempUnitList.counter > -1)
                {
                  let mut counter: i32 = this.game.EditObj.TempUnitList.counter;
                  for (let mut index22: i32 = 0; index22 <= counter; index22 += 1)
                  {
                    if (this.game.EditObj.TempUnitList.unr[index22] <= this.game.Data.UnitCounter)
                    {
                      this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index22]].DidAttack = false;
                      this.AddLog("-WITH " + this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index22]].Name);
                    }
                  }
                }
              }
            }
          }
        }
        num1 += 1;
      }
      while (num1 <= 2);
      let mut unitCounter6: i32 = this.game.Data.UnitCounter;
      num21: i32;
      for (let mut index: i32 = 0; index <= unitCounter6; index += 1)
      {
        if (numArray1[index] > 0)
          num21 += this.game.Data.UnitObj[index].TempUnitPower;
      }
      if (makelog)
        this.AddLog("Counterattack score before reduction = " + Conversion.Str( Number1));
      let mut unitCounter7: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter7; index += 1)
      {
        if (numArray1[index] > 1)
        {
          float num22 =  this.game.Data.UnitObj[index].TempUnitPower /  num21;
          float num23 = 1f /  numArray1[index];
          float num24 =  (( numArray2[index] /  numArray1[index] + 100.0) / 100.0);
          let mut Number8: i32 =  Math.Round( ( Number1 * num22 * num23 / num24));
          if (Number8 == 0)
            Number8 = 1;
          if (makelog)
            this.AddLog("Reduction for " + this.game.Data.UnitObj[index].Name + " " + Conversion.Str( Number8));
          Number1 -= Number8;
          if (0 > Number1)
            Number1 = 0;
        }
      }
      if (makelog)
        this.AddLog("Counterattack score FINAL = " + Conversion.Str( Number1));
      return Number1;
    }

    pub fn GetScoreForMovingIn( SimpleList tempMove, bool makelog) -> i32
    {
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      let mut powerPointsAbsolute: i32 = this.GetAverageUnitPowerPointsAbsolute();
      let mut num1: i32 = 1;
      let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
      unr1: i32;
      for (let mut index: i32 = 0; index <= moveMatrixCounter1; index += 1)
      {
        unr1 = this.MoveMatrixUnit[index];
        if (!this.game.Data.UnitObj[unr1].IsHQ & this.game.Data.UnitObj[unr1].TempGroup == -1)
          num1 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr1);
      }
      let mut num2: i32 = 0;
      scoreForMovingIn: i32;
      do
      {
        SimpleList simpleList;
        if (num2 == 0)
          simpleList = this.MarkerList;
        if (num2 == 1)
          simpleList = this.ArtMarkerList;
        if (num2 == 2)
          simpleList = this.AirMarkerList;
        if (num2 == 3)
          simpleList = this.EngineerMarkerList;
        let mut counter1: i32 = simpleList.Counter;
        for (let mut Number1: i32 = 0; Number1 <= counter1; Number1 += 1)
        {
          let mut Number2: i32 = 0;
          let mut Number3: i32 = 0;
          let mut d: i32 = 0;
          let mut Number4: i32 = 0;
          let mut num3: i32 = 0;
          let mut counter2: i32 = tempMove.Counter;
          for (let mut index: i32 = 0; index <= counter2; index += 1)
          {
            unr1 = this.MoveMatrixUnit[tempMove.Data1[index]];
            let mut num4: i32 = 0;
            if (num2 == 0 && this.game.Data.UnitObj[unr1].TempCategory == 1 | this.EngineerMarkerList.Counter == -1 & this.game.Data.UnitObj[unr1].TempCategory == 4)
              num4 = 1;
            if (num2 == 1 & this.game.Data.UnitObj[unr1].TempCategory == 2)
              num4 = 1;
            if (num2 == 1 & this.game.Data.UnitObj[unr1].TempCategory == 5)
              num4 = 1;
            if (num2 == 2 & this.game.Data.UnitObj[unr1].TempCategory == 3)
              num4 = 1;
            if (num2 == 3 && this.game.Data.UnitObj[unr1].TempCategory == 4 & this.EngineerMarkerList.Counter > -1)
              num4 = 1;
            if (this.game.Data.UnitObj[unr1].TempStrategic & !this.game.HandyFunctionsObj.HasHexRoad(this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY, 0))
              num4 = 0;
            if (num4 == 1 && tempMove.Data2[index] == Number1 && !this.game.Data.UnitObj[unr1].TempAttacked)
            {
              let mut num5: i32 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y, 0, simpleList.Data1[Number1], simpleList.Data2[Number1], 0);
              let mut num6: i32 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY, 0, simpleList.Data1[Number1], simpleList.Data2[Number1], 0);
              d += 1;
              if (num5 > num6)
              {
                Number2 += num5;
                Number3 += num6;
                Number4 += 1;
                if (this.tArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] <= 0 && simpleList.Data5[Number1] > 0)
                  num3 += 1;
              }
            }
          }
          let mut num7: i32 = simpleList.Data5[Number1] <= -1 ? 0 :  Math.Round(Math.Sqrt( (simpleList.Data5[Number1] * 10) * Math.Sqrt( d)));
          if (num7 > 100)
            num7 = 100 +  Math.Round(Math.Sqrt( (num7 - 100)) * 3.0);
          if (num3 > 0)
            num7 *=  Math.Round(10.0 * ( num3 /  Number4));
          if (Number2 == 0)
            num7 = 0;
          else if (Number2 > Number3)
          {
            if (num7 > 0)
            {
              num7 =  Math.Round( num7 * (1.0 -  Number3 /  Number2));
              if (num7 == 0)
                num7 = 1;
            }
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
            {
              num7 =  Math.Round(Math.Sqrt( num7));
              if (this.game.Data.UnitObj[unr1].TempCategory != 3)
              {
                if (this.FrontlineArea[this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY] == 1 & this.FrontlineArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == 1)
                {
                  if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[simpleList.Data1[Number1], simpleList.Data2[Number1]].Regime))
                    num7 =  Math.Round(Math.Sqrt( (num7 * Math.Min(3, num7))));
                  num7 =  Math.Round( num7 / 8.0);
                }
                else if (this.FrontlineArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == 0)
                  num7 *= Math.Min(8, this.DistFromFrontline[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y]);
                if (this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIDefend & this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] != this.game.Data.UnitObj[groupHq].AIDefend)
                {
                  num7 *= 2;
                  if (this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] != this.game.Data.UnitObj[groupHq].AIDefend)
                    num7 *= 3;
                }
              }
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr1].TempX, this.game.Data.UnitObj[unr1].TempY].Regime) == this.GetRegime(this.game.Data.MapObj[0].HexObj[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y].Regime))
                num7 =  Math.Round( num7 / 2.0);
            }
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle != 3 & num7 > 0)
              num7 =  Math.Round(Math.Sqrt( num7));
            if (Number4 > 1)
              num7 *= Number4;
            if (this.tArea[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] < 1 && this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIDefend | this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIFallback)
              num7 *= 10;
            if (this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == this.game.Data.UnitObj[groupHq].AIFallback && this.AreaMatrixNarrow[simpleList.Data1[Number1], simpleList.Data2[Number1]] == this.game.Data.UnitObj[groupHq].AIDefend)
              num7 *= 5;
            if (makelog)
              this.AddLog("Normal Marker #" + Conversion.Str( Number1) + ", startsit=" + Conversion.Str( Number2) + "hex , enddist=" + Conversion.Str( Number3) + "hex, closecount=" + Conversion.Str( Number4) + " MOVING IN SCORE =" + Conversion.Str( num7));
          }
          if (num7 > 0)
            num7 = num7;
          scoreForMovingIn += num7;
        }
        num2 += 1;
      }
      while (num2 <= 3);
      let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
      Number5: i32;
      Number6: i32;
      Number7: i32;
      num8: i32;
      Number8: i32;
      Number9: i32;
      Number10: i32;
      num9: i32;
      for (let mut index1: i32 = 0; index1 <= moveMatrixCounter2; index1 += 1)
      {
        let mut index2: i32 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].TempCategory == 1 & !this.game.Data.UnitObj[index2].IsHQ & this.game.Data.UnitObj[index2].TempGroup == -1 && this.GetHexSpeedofUnit(index2, true) <= 6)
        {
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
          {
            if (this.game.Data.UnitObj[index2].X == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].Y == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y)
            {
              if (!(this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y))
              {
                Number5 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("DEFEND GARRISON: Unit Left = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
              if (this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y)
              {
                Number6 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("DEFEND GARRISON: Unit Stayed = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
            }
            if (this.game.Data.UnitObj[index2].FinalX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x & this.game.Data.UnitObj[index2].FinalY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y)
            {
              let mut num10: i32 =  Math.Round( this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].FinalX, this.game.Data.UnitObj[index2].FinalY, 0) / 3.0);
              if (num10 <= 0)
                num10 = 1;
              Number7 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
              num8 +=  Math.Round( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2) /  num10);
              if (makelog)
                this.AddLog("DEFEND GARRISON: Unit Approaches / Is present = " + this.game.Data.UnitObj[index2].Name.ToString());
            }
          }
          if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
          {
            if (this.game.Data.UnitObj[index2].X == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].Y == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
            {
              if (!(this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y))
              {
                Number8 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("FALLBACK GARRISON: Unit Left = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
              if (this.game.Data.UnitObj[index2].TempX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].TempY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
              {
                Number9 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
                if (makelog)
                  this.AddLog("FALLBACK GARRISON: Unit Stayed = " + this.game.Data.UnitObj[index2].Name.ToString());
              }
            }
            if (this.game.Data.UnitObj[index2].FinalX == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x & this.game.Data.UnitObj[index2].FinalY == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y)
            {
              let mut num11: i32 =  Math.Round( this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].FinalX, this.game.Data.UnitObj[index2].FinalY, 0) / 3.0);
              if (num11 <= 0)
                num11 = 1;
              Number10 += this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2);
              num9 +=  Math.Round( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(index2) /  num11);
              if (makelog)
                this.AddLog("FALLBACK GARRISON: Unit Approaches / Is present = " + this.game.Data.UnitObj[index2].Name.ToString());
            }
          }
        }
      }
      Number11: i32;
      if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
      {
        let mut num12: i32 =  Math.Round( num1 * 0.15);
        if ( num12 >  powerPointsAbsolute * 1.5)
          num12 =  Math.Round( powerPointsAbsolute * 1.5);
        if (num12 >= powerPointsAbsolute)
        {
          if (num12 < Number5)
            Number5 = num12;
          if (Number6 > 0)
          {
            Number5 -= Number6;
            if (0 > Number5)
              Number5 = 0;
          }
          let mut num13: i32 = Number7 - Number5;
          if (num13 > 0)
          {
            if (num13 > num12)
              num13 = num12;
            Number11 =  Math.Round(0.4 *  num1 * ( num13 /  num12) * ( num8 /  Number7));
            scoreForMovingIn += Number11;
          }
          if (makelog)
            this.AddLog("DEFEND GARRISON. pts leaving=" + Strings.Trim(Conversion.Str( Number5)) + ", pts targetting " + Strings.Trim(Conversion.Str( Number7)) + ", pts being there " + Strings.Trim(Conversion.Str( Number6)) + "... SCORE BONUS =" + Conversion.Str( Number11));
        }
      }
      if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
      {
        let mut num14: i32 =  Math.Round( num1 * 0.075);
        if (num14 > powerPointsAbsolute * 1)
          num14 = powerPointsAbsolute * 1;
        if (num14 >= powerPointsAbsolute)
        {
          if (num14 < Number8)
            Number8 = num14;
          if (Number9 > 0)
          {
            Number8 -= Number9;
            if (0 > Number8)
              Number8 = 0;
          }
          let mut num15: i32 = Number10 - Number8;
          if (num15 > 0)
          {
            if (num15 > num14)
              num15 = num14;
            Number11 =  Math.Round(0.2 *  num1 * ( num15 /  num14) * ( num9 /  Number10));
            scoreForMovingIn += Number11;
          }
          if (makelog)
            this.AddLog("FALLBACK GARRISON. pts leaving=" + Strings.Trim(Conversion.Str( Number8)) + ", pts targetting " + Strings.Trim(Conversion.Str( Number10)) + ", pts being there " + Strings.Trim(Conversion.Str( Number9)) + "... SCORE BONUS =" + Conversion.Str( Number11));
        }
      }
      if (makelog)
        this.AddLog("DIVISIONAL STAY-CLOSE BONUS REWARD");
      let mut moveMatrixCounter3: i32 = this.MoveMatrixCounter;
      for (let mut index: i32 = 0; index <= moveMatrixCounter3; index += 1)
      {
        let mut unr2: i32 = this.MoveMatrixUnit[index];
        let mut num16: i32 = this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr2);
        if (num16 > 0)
        {
          num16 =  Math.Round( num16 / 10.0 *  this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr2));
          if (makelog)
            this.AddLog(this.game.Data.UnitObj[unr2].Name + " gets +" + num16.ToString() + " DIV BONUS");
          scoreForMovingIn += num16;
        }
      }
      return scoreForMovingIn;
    }

    pub fn getscoreforhexoccupation_hq(pts: i32, bool makelog) -> i32
    {
      let mut index1: i32 = this.GetGroupHQ(this.OpGroup);
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index2: i32 = 1; index2 <= moveMatrixCounter; index2 += 1)
      {
        let mut index3: i32 = index2;
        if (index3 > -1)
        {
          let mut index4: i32 = this.MoveMatrixUnit[index3];
          let mut x: i32 = this.game.Data.UnitObj[index4].X;
          let mut y: i32 = this.game.Data.UnitObj[index4].Y;
          let mut tempX: i32 = this.game.Data.UnitObj[index4].TempX;
          let mut tempY: i32 = this.game.Data.UnitObj[index4].TempY;
          if (this.game.Data.UnitObj[index4].IsHQ & this.game.Data.UnitObj[index4].AIGroup > -1)
          {
            let mut num: i32 = 0;
            if ( this.SupplyMatrixReal[tempX, tempY] <=  this.game.Data.RuleVar[51])
              num +=  Math.Round( this.SupplyMatrixReal[tempX, tempY] / 2.0);
            if ( this.SupplyMatrixReal[tempX, tempY] >  this.game.Data.RuleVar[51])
              num += 200;
            if ( this.SupplyMatrixReal[tempX, tempY] >  this.game.Data.RuleVar[52])
              num += 500;
            if ( this.SupplyMatrixReal[tempX, tempY] >  this.game.Data.RuleVar[53])
              num += 1250;
            if (!this.game.HandyFunctionsObj.HasHexRoad(tempX, tempY, 0))
              num += 1000;
            if (this.AdvanceAxisMatrix[tempX, tempY] < 0)
              num += 50;
            if (this.AdvanceAxisMatrix[tempX, tempY] > 0)
              num += 50 * this.AdvanceAxisMatrix[tempX, tempY];
            if ( this.game.Data.RuleVar[365] > 0.0)
              num =  Math.Round( num *  this.game.Data.RuleVar[365] / 100.0);
            pts -= num;
            if (makelog)
              this.AddLog(" After supply+advance penalties = " + Conversion.Str( pts));
          }
        }
      }
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      num1: i32;
      Number1: i32;
      num2: i32;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].HQ == index1 && this.game.Data.UnitObj[unr].TempCategory != 3)
        {
          num1 += 1;
          let mut num3: i32 = this.game.HandyFunctionsObj.Gethqpow(unr, true);
          Number1 += num3;
          if (index1 > -1)
          {
            let mut num4: i32 = this.game.HandyFunctionsObj.Gethqpowifhqis(unr, index1, true);
            if (num4 < 1)
              num4 = -(10 * this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0));
            num2 += num4;
          }
        }
      }
      let mut num5: i32 = 0;
      if (this.OpGroup == 1)
        index1 = index1;
      let mut groupPowerPoints: i32 = this.game.HandyFunctionsObj.GetGroupPowerPoints(index1);
      this.TempAverageHQPower = 0;
      if (num1 > 0)
      {
        this.TempAverageHQPower =  Math.Round( Number1 /  num1);
        Number1 =  Math.Round( Number1 /  num1);
        num5 = Number1 >= 100 ? 0 : groupPowerPoints -  Math.Round( groupPowerPoints * ( Number1 / 100.0));
      }
      if ( this.game.Data.RuleVar[366] > 0.0)
        num5 =  Math.Round( num5 *  this.game.Data.RuleVar[366] / 100.0);
      pts -= num5;
      if (makelog)
        this.AddLog(Conversion.Str( pts) + " penalty points due to REAL HQ (" + Conversion.Str( Number1) + " average hqpow)");
      if (index1 > -1 & num1 > 0)
      {
        let mut num6: i32 =  Math.Round( groupPowerPoints / 2.0);
        let mut Number2: i32 =  Math.Round( num2 /  num1);
        let mut num7: i32 = Number2 >= 0 ? (Number2 >= 100 ? 0 : num6 -  Math.Round( num6 * ( Number2 / 100.0))) :  Math.Round( num6 +  num6 * ( Math.Abs(Number2) / 100.0));
        if ( this.game.Data.RuleVar[366] > 0.0)
          num7 =  Math.Round( num7 *  this.game.Data.RuleVar[366] / 100.0);
        pts -= num7;
        if (makelog)
          this.AddLog(Conversion.Str( pts) + " penalty points due to OPTIMAL OWN GROUP HQ (" + Conversion.Str( Number2) + " average hqpow)");
      }
      return pts;
    }

    [MethodImpl(MethodImplOptions.NoInlining | MethodImplOptions.NoOptimization)]
    pub fn getscoreforhexoccupation_setmove()
    {
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index1: i32 = 1; index1 <= moveMatrixCounter; index1 += 1)
      {
        let mut index2: i32 = index1;
        if (index2 > -1)
        {
          let mut index3: i32 = this.MoveMatrixUnit[index2];
          let mut x1: i32 = this.game.Data.UnitObj[index3].X;
          let mut y1: i32 = this.game.Data.UnitObj[index3].Y;
          let mut index4: i32 = this.game.Data.UnitObj[index3].TempX;
          let mut index5: i32 = this.game.Data.UnitObj[index3].TempY;
          if (index4 == -1)
          {
            index4 = this.game.Data.UnitObj[index3].X;
            index5 = this.game.Data.UnitObj[index3].Y;
            if (index4 == -1)
            {
              let mut num: i32 =  Interaction.MsgBox( "-1 in getscorehexoccup_setmove");
              ProjectData.EndApp();
            }
          }
          if (this.game.Data.UnitObj[index3].TempCategory != 3)
          {
            Coordinate coordinate1;
            Coordinate coordinate2;
            do
            {
              coordinate1 = Coordinate::new();
              coordinate2.onmap = false;
              if (this.GetRegime(this.game.Data.MapObj[0].HexObj[index4, index5].Regime) != this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[index4, index5].UnitCounter > -1)
              {
                coordinate2.x = index4;
                coordinate2.y = index5;
                coordinate2.onmap = true;
              }
              sCoordinate sCoordinate = this.MoveMatrixCameFrom[index2, index4, index5];
              coordinate1.x =  sCoordinate.x;
              coordinate1.y =  sCoordinate.y;
              coordinate1.onmap = sCoordinate.onmap;
              index4 = coordinate1.x;
              index5 = coordinate1.y;
            }
            while (coordinate1.onmap & this.MoveMatrixCameFrom[index2, index4, index5].onmap & !(x1 == index4 & y1 == index5));
            let mut cx: i32 = this.game.Data.UnitObj[index3].TempX;
            let mut cy: i32 = this.game.Data.UnitObj[index3].TempY;
            if (cx == -1)
            {
              cx = this.game.Data.UnitObj[index3].X;
              cy = this.game.Data.UnitObj[index3].Y;
              if (cx == -1)
              {
                let mut num: i32 =  Interaction.MsgBox( "-1 in getscorehexoccup_setmove 2");
                ProjectData.EndApp();
              }
            }
            do
            {
              if (!coordinate2.onmap)
              {
                if (this.GetRegime(this.game.Data.MapObj[0].HexObj[cx, cy].Regime) != this.GetGameDataTurn())
                {
                  hexOccupyMatrix: Vec<i32> = this.HexOccupyMatrix;
                  numArray: Vec<i32> = hexOccupyMatrix;
                  let mut index6: i32 = cx;
                  let mut index7: i32 = index6;
                  let mut index8: i32 = cy;
                  let mut index9: i32 = index8;
                  let mut num: i32 = hexOccupyMatrix[index6, index8] + 1;
                  numArray[index7, index9] = num;
                  this.TempOwner[cx, cy] = this.GetGameDataTurn();
                }
                let mut tfacing1: i32 = 1;
                do
                {
                  Coordinate coordinate3 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing1);
                  if (coordinate3.onmap && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate3.x, coordinate3.y].Regime) != this.GetGameDataTurn())
                  {
                    let mut defendingPowerPointsOn: i32 = this.GetCurrentDefendingPowerPointsOn(coordinate3.x, coordinate3.y);
                    let mut tfacing2: i32 = 1;
                    do
                    {
                      Coordinate coordinate4 = this.game.HandyFunctionsObj.HexNeighbour(coordinate3.x, coordinate3.y, 0, tfacing2);
                      if (coordinate3.onmap && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate4.x, coordinate4.y].Regime) != this.GetGameDataTurn())
                        defendingPowerPointsOn += this.GetCurrentDefendingPowerPointsOn(coordinate4.x, coordinate4.y);
                      tfacing2 += 1;
                    }
                    while (tfacing2 <= 6);
                    if (defendingPowerPointsOn == 0 & this.game.Data.MapObj[0].HexObj[coordinate3.x, coordinate3.y].Location <= -1)
                    {
                      hexOccupyMatrix: Vec<i32> = this.HexOccupyMatrix;
                      numArray: Vec<i32> = hexOccupyMatrix;
                      let mut x2: i32 = coordinate3.x;
                      let mut index10: i32 = x2;
                      let mut y2: i32 = coordinate3.y;
                      let mut index11: i32 = y2;
                      let mut num: i32 = hexOccupyMatrix[x2, y2] + 1;
                      numArray[index10, index11] = num;
                      this.TempOwner[coordinate3.x, coordinate3.y] = this.GetGameDataTurn();
                    }
                  }
                  tfacing1 += 1;
                }
                while (tfacing1 <= 6);
              }
              else if (cx == coordinate2.x & cy == coordinate2.y)
                coordinate2.onmap = false;
              sCoordinate sCoordinate = this.MoveMatrixCameFrom[index2, cx, cy];
              coordinate1.x =  sCoordinate.x;
              coordinate1.y =  sCoordinate.y;
              coordinate1.onmap = sCoordinate.onmap;
              cx = coordinate1.x;
              cy = coordinate1.y;
            }
            while (coordinate1.onmap & this.MoveMatrixCameFrom[index2, cx, cy].onmap & !(x1 == cx & y1 == cy));
          }
        }
      }
    }

    pub fn getscoreforhexoccupation_enemydistance(pts: i32, bool makelog) -> i32
    {
      let mut powerPointsAbsolute: i32 = this.GetAverageEnemyUnitPowerPointsAbsolute();
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index1: i32 = 1; index1 <= moveMatrixCounter; index1 += 1)
      {
        let mut index2: i32 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].IsHQ | this.game.Data.UnitObj[index2].TempCategory == 3)
        {
          num1: i32;
          if (this.game.Data.UnitObj[index2].AIGroup > -1)
          {
            if (this.GroupType[this.game.Data.UnitObj[index2].AIGroup] > 5)
              num1 = 10;
            else if (this.game.Data.UnitObj[index2].TempCategory == 3)
            {
              num1 = 6;
              if ( this.game.Data.RuleVar[361] > 0.0)
                num1 =  Math.Round( this.game.Data.RuleVar[361]);
            }
            else
            {
              num1 = 4;
              if ( this.game.Data.RuleVar[362] > 0.0)
                num1 =  Math.Round( this.game.Data.RuleVar[362]);
            }
          }
          else
          {
            num1 = 4;
            if ( this.game.Data.RuleVar[362] > 0.0)
              num1 =  Math.Round( this.game.Data.RuleVar[362]);
          }
          let mut Number: i32 = 99;
          let mut num2: i32 = this.game.Data.UnitObj[index2].TempX - num1;
          let mut num3: i32 = this.game.Data.UnitObj[index2].TempX + num1;
          for (let mut x2: i32 = num2; x2 <= num3; x2 += 1)
          {
            let mut num4: i32 = this.game.Data.UnitObj[index2].TempY - num1;
            let mut num5: i32 = this.game.Data.UnitObj[index2].TempY + num1;
            for (let mut y2: i32 = num4; y2 <= num5; y2 += 1)
            {
              if (x2 > -1 & y2 > -1 & x2 <= this.game.Data.MapObj[0].MapWidth & y2 <= this.game.Data.MapObj[0].MapHeight && this.GetRegime(this.game.Data.MapObj[0].HexObj[x2, y2].Regime) != this.GetGameDataTurn() && this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter > -1)
              {
                let mut num6: i32 = 0;
                let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x2, y2].UnitCounter;
                for (let mut index3: i32 = 0; index3 <= unitCounter; index3 += 1)
                {
                  if ( this.GetUnitPower(this.game.Data.MapObj[0].HexObj[x2, y2].UnitList[index3], false) >  powerPointsAbsolute / 10.0)
                  {
                    if (this.game.Data.UnitObj[this.game.Data.MapObj[0].HexObj[x2, y2].UnitList[index3]].SupplyConsume > 50)
                    {
                      num6 = 1;
                      break;
                    }
                    num6 = 0;
                  }
                  else if (this.game.Data.UnitObj[index2].AIGroup > -1 && this.game.Data.UnitObj[index2].AIGroup > 5)
                  {
                    num6 = 1;
                    break;
                  }
                }
                if (num6 == 1)
                {
                  let mut num7: i32 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, x2, y2, 0);
                  if (num7 < Number)
                    Number = num7;
                }
              }
            }
          }
          if (Number <= num1 && this.game.Data.UnitObj[index2].AIGroup > -1)
          {
            if (this.GroupType[this.game.Data.UnitObj[index2].AIGroup] > 5)
            {
              let mut num8: i32 = 600;
              if (this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIDefend & this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIFallback)
                num8 *= 2;
              if ( this.game.Data.RuleVar[363] > 0.0)
                num8 =  Math.Round( this.game.Data.RuleVar[363]);
              if (Number <= num1)
              {
                pts -= (num1 + 1 - Number) * num8;
                if (makelog)
                  this.AddLog("HQ Distance to Enemy penalty. dist= " + Conversion.Str( Number) + " , penalty = " + Conversion.Str( ((num1 + 1 - Number) * num8)));
              }
            }
            else
            {
              let mut num9: i32 = 400;
              if (this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIDefend & this.AreaMatrixNarrow[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] != this.game.Data.UnitObj[index2].AIFallback)
                num9 *= 3;
              if ( this.game.Data.RuleVar[363] > 0.0)
                num9 =  Math.Round( this.game.Data.RuleVar[363]);
              if (Number <= num1)
              {
                pts -= (num1 + 1 - Number) * num9;
                if (makelog)
                  this.AddLog("HQ/Air Distance to Enemy penalty. dist= " + Conversion.Str( Number) + " , penalty = " + Conversion.Str( ((num1 + 1 - Number) * num9)));
              }
            }
          }
          if (this.game.HandyFunctionsObj.IsHexPort(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0))
          {
            if (makelog)
              this.AddLog("HQ or Air unit in port hex. ");
            let mut num10: i32 = 100;
            if ( this.game.Data.RuleVar[364] > 0.0)
              num10 =  Math.Round( this.game.Data.RuleVar[364]);
            pts -= num10;
          }
        }
      }
      return pts;
    }

    pub fn getscoreforhexoccupation_movemarkers(pts: i32, bool makelog) -> i32
    {
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      Coordinate coordinate;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle != 1)
      {
        let mut counter: i32 = this.MarkerList.Counter;
        for (let mut index: i32 = 0; index <= counter; index += 1)
        {
          if (this.MarkerList.Weight[index] == 2)
          {
            coordinate.x = this.MarkerList.Data1[index];
            coordinate.y = this.MarkerList.Data2[index];
            if (this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime) != this.GetGameDataTurn() && this.HexOccupyMatrix[coordinate.x, coordinate.y] > 0)
            {
              let mut num: i32 =  Math.Round(Math.Sqrt( this.MarkerList.Data5[index]));
              if ( this.game.Data.RuleVar[266] > 0.0 &&  (this.game.HandyFunctionsObj.GetRegimeVP(this.GetGameDataTurn()) + this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].VP) >  this.game.Data.RuleVar[266])
                num = (num + 200) * 10;
              if ( this.game.Data.RuleVar[359] > 0.0)
                num =  Math.Round( num *  this.game.Data.RuleVar[359] / 100.0);
              pts += num;
              if (makelog)
                this.AddLog("(" + Conversion.Str( coordinate.x) + "," + Conversion.Str( coordinate.y) + ") = " + Conversion.Str( this.MarkerList.Data5[index]) + " pts");
            }
          }
        }
      }
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          this.ptemp[index1, index2] = 0;
      }
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
      {
        let mut counter: i32 = this.MarkerList.Counter;
        for (let mut index3: i32 = 0; index3 <= counter; index3 += 1)
        {
          if (this.MarkerList.Weight[index3] == 3)
          {
            coordinate.x = this.MarkerList.Data1[index3];
            coordinate.y = this.MarkerList.Data2[index3];
            if (this.ptemp[coordinate.x, coordinate.y] == 0)
            {
              let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
              for (let mut index4: i32 = 1; index4 <= moveMatrixCounter; index4 += 1)
              {
                let mut index5: i32 = this.MoveMatrixUnit[index4];
                if (this.ptemp[coordinate.x, coordinate.y] == 0 && this.game.Data.UnitObj[index5].TempX == coordinate.x & this.game.Data.UnitObj[index5].TempY == coordinate.y)
                {
                  let mut num: i32 =  Math.Round(Math.Sqrt( this.MarkerList.Data5[index3]));
                  if ( this.game.Data.RuleVar[360] > 0.0)
                    num =  Math.Round( num *  this.game.Data.RuleVar[360] / 100.0);
                  pts += num;
                  this.ptemp[coordinate.x, coordinate.y] = 1;
                  if (makelog)
                    this.AddLog("(" + Conversion.Str( coordinate.x) + "," + Conversion.Str( coordinate.y) + ") = " + Conversion.Str( this.MarkerList.Data5[index3]) + " SQRT");
                }
              }
            }
          }
        }
      }
      return pts;
    }

    pub fn GetScoreForHexOccupationAndHQ2( SimpleList TempMove, bool makelog) -> i32
    {
      if (this.HexOccupyMatrix.GetUpperBound(0) < this.game.Data.MapObj[0].MapWidth)
        this.HexOccupyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      else if (this.HexOccupyMatrix.GetUpperBound(1) < this.game.Data.MapObj[0].MapHeight)
        this.HexOccupyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut pts: i32 = 0;
      this.GetGroupHQ(this.OpGroup);
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.HexOccupyMatrix[index1, index2] = 0;
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
          this.TempOwner[index1, index2] = this.game.Data.MapObj[0].HexObj[index1, index2].Regime;
        }
      }
      this.getscoreforhexoccupation_setmove();
      let mut num: i32 = -1;
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index3: i32 = 1; index3 <= moveMatrixCounter; index3 += 1)
      {
        index4: i32;
        if (this.game.Data.UnitObj[index4].IsHQ & this.game.Data.UnitObj[index4].AIGroup > -1)
          num = index4;
      }
      return this.getscoreforhexoccupation_movemarkers(this.getscoreforhexoccupation_enemydistance(this.getscoreforhexoccupation_hq(pts, makelog), makelog), makelog);
    }

    pub fn GetScoreForEntrench( SimpleList TempMove, bool makelog) -> i32
    {
      if (this.HexOccupyMatrix.GetUpperBound(0) < this.game.Data.MapObj[0].MapWidth)
        this.HexOccupyMatrix = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.HexOccupyMatrix[index1, index2] = 0;
          this.ptemp[index1, index2] = 0;
          this.ptemp2[index1, index2] = 0;
        }
      }
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      let mut scoreForEntrench: i32 = 0;
      this.GetAverageEnemyUnitPowerPointsAbsolute();
      let mut powerPointsAbsolute: i32 = this.GetAverageUnitPowerPointsAbsolute();
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index3: i32 = 1; index3 <= moveMatrixCounter; index3 += 1)
      {
        let mut index4: i32 = index3;
        if (index4 > -1)
        {
          let mut unr: i32 = this.MoveMatrixUnit[index4];
          x1: i32;
          y1: i32;
          if (this.game.Data.UnitObj[unr].TempCategory == 1 | this.game.Data.UnitObj[unr].TempCategory == 2)
          {
            let mut x2: i32 = this.game.Data.UnitObj[unr].X;
            let mut y2: i32 = this.game.Data.UnitObj[unr].Y;
            x1 = this.game.Data.UnitObj[unr].TempX;
            y1 = this.game.Data.UnitObj[unr].TempY;
            if (x1 == -1)
            {
              x1 = this.game.Data.UnitObj[unr].X;
              y1 = this.game.Data.UnitObj[unr].Y;
            }
            num1: i32;
            if (x2 == x1 & y2 == y1)
            {
              num1 = this.game.HandyFunctionsObj.GetAverageEntrenchPredict(unr, true);
              if (this.game.Data.UnitObj[unr].TempAttacked)
                num1 = this.game.HandyFunctionsObj.GetAverageEntrenchPredict(unr, false);
            }
            else
              num1 = this.game.HandyFunctionsObj.GetAverageEntrenchPredict(unr, false);
            if (this.GetAverageUnitPowerPointsAbsolute() > 0)
              num1 =  Math.Round( num1 * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  powerPointsAbsolute));
            let mut d: i32 = num1 - this.game.HandyFunctionsObj.GetAverageEntrench(unr);
            if (!(this.tArea[x1, y1] == 2 | this.tArea[x1, y1] == 6))
              d = this.DistToTArea[x1, y1] <= 0 ? 0 :  Math.Round( d /  (2 * this.DistToTArea[x1, y1]));
            if (d > 0)
            {
              if (this.ptemp2[x1, y1] + d > 200)
              {
                if (this.ptemp2[x1, y1] < 200)
                {
                  let mut num2: i32 = 200 - this.ptemp2[x1, y1];
                  d = num2 +  Math.Round(Math.Sqrt(Math.Pow( Math.Max(0, d - num2), 1.5)));
                }
                else
                  d =  Math.Round(Math.Pow(Math.Sqrt( d), 1.5));
              }
              ptemp2: Vec<i32> = this.ptemp2;
              numArray: Vec<i32> = ptemp2;
              let mut index5: i32 = x1;
              let mut index6: i32 = index5;
              let mut index7: i32 = y1;
              let mut index8: i32 = index7;
              let mut num3: i32 = ptemp2[index5, index7] + d;
              numArray[index6, index8] = num3;
            }
            Number: i32;
            if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
            {
              Number =  this.game.Data.RuleVar[377] <= 0.0 ?  Math.Round( d * 0.1) :  Math.Round( d *  this.game.Data.RuleVar[377] / 100.0);
              if (this.CounterAttackPossible[x1, y1] < 100)
                Number =  Math.Round( Number * 0.25) +  Math.Round( Number * 0.75 * ( this.CounterAttackPossible[x1, y1] / 100.0));
            }
            else
              Number =  this.game.Data.RuleVar[378] <= 0.0 ?  Math.Round( d * 0.5) :  Math.Round( d *  this.game.Data.RuleVar[378] / 100.0);
            if (this.game.Data.UnitObj[unr].TempEncircled == 1)
              Number =  Math.Round( Number / 8.0);
            if (this.game.Data.UnitObj[unr].TempEncircled == 2)
              Number = 0;
            if (makelog)
              this.AddLog("<" + this.game.Data.UnitObj[unr].Name + "> get " + Conversion.Str( Number) + " for entrenchment");
            scoreForEntrench += Number;
          }
          let mut stackPtsPrognosed: i32 = this.game.HandyFunctionsObj.GetHexStackPtsPrognosed(x1, y1, this.game.Data.Turn);
          if ( stackPtsPrognosed >  this.game.Data.RuleVar[30] * 1.33)
          {
            let mut Number: i32 =  Math.Round(  Math.Round(  Math.Round( stackPtsPrognosed -  this.game.Data.RuleVar[30] * 1.33) * ( this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr) /  powerPointsAbsolute)) / 5.0);
            if (Number > 0 && this.game.Data.UnitObj[unr].TempX == this.game.Data.UnitObj[unr].FinalX & this.game.Data.UnitObj[unr].TempY == this.game.Data.UnitObj[unr].FinalY)
            {
              if ( this.game.Data.RuleVar[379] > 0.0)
                Number =  Math.Round( Number *  this.game.Data.RuleVar[379] / 100.0);
              if (makelog)
                this.AddLog("PENALTY <" + this.game.Data.UnitObj[unr].Name + "> get " + Conversion.Str( Number) + " for stacking");
              scoreForEntrench -= Number;
            }
          }
        }
      }
      return scoreForEntrench;
    }

    pub fn GetScoreForAttacks(bool Prognosis, bool MakeLog) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        this.game.Data.UnitObj[index].TempArtDam = 0;
        this.game.Data.UnitObj[index].TempAttacked = false;
      }
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          this.ptemp3[index1, index2] = 0;
      }
      let mut counter1: i32 = this.AirMarkerList.Counter;
      Coordinate coordinate;
      scoreForAttacks: i32;
      for (let mut index: i32 = 0; index <= counter1; index += 1)
      {
        if (this.AirMarkerList.Weight[index] == 1)
        {
          coordinate.x = this.AirMarkerList.Data3[index];
          coordinate.y = this.AirMarkerList.Data4[index];
          if (coordinate.x > -1 & coordinate.y > -1 && this.ptemp3[coordinate.x, coordinate.y] == 0)
          {
            this.ptemp3[coordinate.x, coordinate.y] = 1;
            let mut Number: i32 =  Math.Round( this.GetScoreForAirAttack(coordinate.x, coordinate.y, Prognosis, MakeLog) * ( this.AirMarkerList.Data5[index] / 100.0));
            if (Number > 0 && MakeLog)
              this.AddLog("After score modifcation air= " + Conversion.Str( Number));
            scoreForAttacks += Number;
          }
        }
      }
      let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
          this.ptemp3[index3, index4] = 0;
      }
      let mut counter2: i32 = this.ArtMarkerList.Counter;
      for (let mut index: i32 = 0; index <= counter2; index += 1)
      {
        if (this.ArtMarkerList.Weight[index] == 1)
        {
          coordinate.x = this.ArtMarkerList.Data3[index];
          coordinate.y = this.ArtMarkerList.Data4[index];
          if (this.ptemp3[coordinate.x, coordinate.y] == 0)
          {
            this.ptemp3[coordinate.x, coordinate.y] = 1;
            let mut Number: i32 =  Math.Round( this.GetScoreForArtAttack(coordinate.x, coordinate.y, Prognosis, MakeLog) * ( this.ArtMarkerList.Data5[index] / 100.0));
            if (Number > 0 & MakeLog)
              this.AddLog("After score modifcation art= " + Conversion.Str( Number));
            scoreForAttacks += Number;
          }
        }
      }
      let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index5: i32 = 0; index5 <= mapWidth3; index5 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index6: i32 = 0; index6 <= mapHeight; index6 += 1)
          this.ptemp3[index5, index6] = 0;
      }
      let mut counter3: i32 = this.MarkerList.Counter;
      for (let mut index7: i32 = 0; index7 <= counter3; index7 += 1)
      {
        if (this.MarkerList.Weight[index7] == 1 && this.MarkerList.Data5[index7] > 0)
        {
          coordinate.x = this.MarkerList.Data3[index7];
          coordinate.y = this.MarkerList.Data4[index7];
          if (this.ptemp3[coordinate.x, coordinate.y] == 0)
          {
            this.ptemp3[coordinate.x, coordinate.y] = 1;
            let mut num1: i32 = this.GetScoreForAttack(coordinate.x, coordinate.y, Prognosis, MakeLog);
            if (num1 == 0 &  this.SupplyMatrixEnemyReal[coordinate.x, coordinate.y] >  this.game.Data.RuleVar[3] & this.GetAverageSupplyConsume(coordinate.x, coordinate.y) > 90)
            {
              num1 = this.GetScoreForContainment(coordinate.x, coordinate.y, MakeLog);
              let mut counter4: i32 = this.game.EditObj.TempUnitList.counter;
              for (let mut index8: i32 = 0; index8 <= counter4; index8 += 1)
                this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index8]].TempAttacked = true;
            }
            if (num1 > 0)
            {
              let mut num2: i32 = this.MarkerList.Data5[index7];
              if (num2 > 300)
                num2 = 300 +  Math.Round(Math.Sqrt( (num2 - 300)));
              if (num2 < 30)
                num2 = 30;
              let mut Number: i32 =  Math.Round( num1 * ( num2 / 100.0)) +  Math.Round( num2 / 2.0);
              if (this.AreaMatrixNarrow[coordinate.x, coordinate.y] > 0 && this.AreaIsExtra[this.AreaMatrixNarrow[coordinate.x, coordinate.y]])
              {
                let mut num3: i32 = num2 + 75;
              }
              if (Number > 0 & MakeLog)
                this.AddLog("After score modifcation norm= " + Conversion.Str( Number));
              scoreForAttacks += Number;
            }
          }
        }
      }
      return scoreForAttacks;
    }

    pub fn GetScoreForContainment(ix: i32, iy: i32, bool makelog) -> i32
    {
      let mut Number: i32 = 0;
      let mut attackPowerPointsOn: i32 = this.GetPrognosedLandAttackPowerPointsOn(ix, iy, FullAp: true, ForContainment: true);
      let mut defendingPowerPointsOn: i32 = this.GetCurrentDefendingPowerPointsOn(ix, iy, WithoutEntrench: true);
      this.GetGroupHQ(this.OpGroup);
      if (attackPowerPointsOn > 0 & defendingPowerPointsOn > 0)
      {
        Number =  Math.Round(Math.Min(1.0,  attackPowerPointsOn /  defendingPowerPointsOn) * 50.0);
        if (makelog)
          this.AddLog("Containment on Hex <" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ">, Att= " + Conversion.Str( attackPowerPointsOn) + ", Def= " + Conversion.Str( defendingPowerPointsOn) + ". Gave points for hypothetical attack = " + Conversion.Str( Number));
      }
      return Number;
    }

    pub fn GetScoreForAttack(ix: i32, iy: i32, bool Prognosis, bool MakeLog) -> i32
    {
      let mut Number1: i32 = 0;
      let mut num1: i32 = 0;
      Coordinate landAttackStackOn;
      if (Prognosis)
      {
        Number1 = this.GetPrognosedLandAttackPowerPointsOn(ix, iy, true);
        landAttackStackOn = this.GetPrognosedLandAttackStackOn(ix, iy, true);
        num1 = this.GetPrognosedLandAttackPowerPointsOn(ix, iy, true);
      }
      else if (!Prognosis)
      {
        Number1 = this.GetRealLandAttackPowerPointsOn(ix, iy, true);
        landAttackStackOn = this.GetRealLandAttackStackOn(ix, iy, true);
        num1 = this.GetRealLandAttackPowerPointsOn(ix, iy, true);
      }
      let mut Number2: i32 = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis);
      let mut defendingPowerPointsOn: i32 = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis, true);
      this.GetCurrentDefendingStackOn(ix, iy, Prognosis);
      if (Number1 > 150 & landAttackStackOn.x < 40)
        Number1 = Number1;
      if (Number1 == 0)
        return 0;
      if (Number1 > 0)
        Number1 = Number1;
      if (this.AreaMatrixNarrow[ix, iy] > 0 && this.AreaIsExtra[this.AreaMatrixNarrow[ix, iy]])
        Number1 =  Math.Round( Number1 * 1.5);
      if (this.Attacker)
      {
        let mut pointstempdampercent: i32 = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, true);
        if (pointstempdampercent > 100)
          Number1 =  Math.Round( Number1 * ( pointstempdampercent / 100.0));
      }
      if (Number2 == 0 & this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter == -1)
      {
        if (MakeLog)
          this.AddLog("Attack on (" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ") Attacker = " + Conversion.Str( Number1) + ", Defender =" + Conversion.Str( Number2));
        if (MakeLog)
          this.AddLog("No Defenders. Attack gives 100 pts.");
        return 100;
      }
      this.CorpsTopRatio = (float[]) Utils.CopyArray((Array) this.CorpsTopRatio, (Array) new float[this.GroupCounter + 1]);
      if (this.Attacker &&  this.CorpsTopRatio[this.OpGroup] > 1.0)
        Number2 = Math.Max( Math.Round( (defendingPowerPointsOn + Number2) / 2.0),  Math.Round( Number2 / Math.Sqrt( this.CorpsTopRatio[this.OpGroup])));
      float num2 =  Number1 /  Number2;
      if ( num2 > 1.5)
        num2 = 1.5f +  Math.Sqrt( num2 - 1.5);
      if ( num2 > 8.0)
        num2 = 8f;
      let mut Number3: i32 =  Math.Round( Conversion.Int(num2 * 20f));
      float num3 =  num1 /  Number2;
      if ( num3 > 2.5)
        num3 =  (1.0 + Math.Sqrt( num3 - 2.5));
      if ( num3 > 8.0)
        num3 = 8f;
      let mut num4: i32 =  Math.Round( Conversion.Int(num3 * 20f));
      let mut val1: i32 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
        val1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
        val1 = this.ATTACK_MINIMUM_ACTUAL_ATTACK;
      if (this.Attacker)
      {
        if (this.GetPercentTempUnits() > 20)
          Number3 =  Math.Round( Number3 * 1.2);
        else if (this.GetPercentTempUnits() > 40)
          Number3 =  Math.Round( Number3 * 1.4);
        else if (this.GetPercentTempUnits() > 60)
          Number3 =  Math.Round( Number3 * 1.6);
      }
      if (this.Attacker &&  this.CorpsTopRatio[this.OpGroup] > 1.0)
        val1 =  Math.Round( val1 / Math.Sqrt( Math.Min(9f, this.CorpsTopRatio[this.OpGroup])));
      if (ix == 42 & iy == 29 & Number3 > 17)
        ix = ix;
      if (ix == 32 & iy == 70 & Number3 > 23)
        ix = ix;
      if (Number3 > 15)
        Number3 = Number3;
      if (Operators.CompareString(this.GroupName[this.OpGroup], "6th Army", false) == 0 & Number3 > 30)
        val1 = val1;
      if (Number1 > 150 & landAttackStackOn.x < 50)
        Number1 = Number1;
      if (Number3 >= Math.Min(val1,  Math.Round( val1 * ( this.AverageSupplyPercentage / 75.0))))
      {
        if (this.Attacker)
        {
          if ( this.CorpsTopRatio[this.OpGroup] > 10.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 3;
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 5;
          }
          else if ( this.CorpsTopRatio[this.OpGroup] > 7.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 4;
          }
          else if ( this.CorpsTopRatio[this.OpGroup] > 5.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
          }
          else if ( this.CorpsTopRatio[this.OpGroup] > 3.0)
          {
            if (Number3 < this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 =  Math.Round( Number3 * 1.25);
            if (Number3 >= this.ATTACK_MINIMUM_ACTUAL_ATTACK)
              Number3 *= 2;
          }
        }
        if (landAttackStackOn.x > landAttackStackOn.y && this.AverageSupplyPercentage > 50)
        {
          if (MakeLog)
            this.AddLog("Stacking mod " + Conversion.Str( ( landAttackStackOn.y /  landAttackStackOn.x)));
          Number3 =  Math.Round(0.2 *  Number3) +  Math.Round(0.8 * ( Number3 * ( landAttackStackOn.y /  landAttackStackOn.x)));
        }
        if (MakeLog)
          this.GetPrognosedLandUnitOn(ix, iy);
        if (MakeLog)
          this.AddLog("Attack on (" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ") Attacker = " + Conversion.Str( Number1) + ", Defender =" + Conversion.Str( Number2));
        if (MakeLog)
          this.AddLog("Attack gives " + Conversion.Str( Number3) + " pts.");
        let mut num5: i32 = MakeLog ? 1 : 0;
        let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter; index += 1)
        {
          let mut unit: i32 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index];
          if (this.game.Data.UnitObj[unit].TempCategory == 2 | this.game.Data.UnitObj[unit].TempCategory == 4)
          {
            Number3 =  Math.Round( Number3 * 1.25);
            if (MakeLog)
              this.AddLog("Attack pts *1.25 cause artillery here");
          }
          if (this.game.Data.UnitObj[unit].TempCategory == 3)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("Attack pts *2 cause air here");
          }
          if (this.game.Data.UnitObj[unit].IsHQ)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("Attack pts *2 cause HQ here");
          }
        }
        let mut pointstempdampercent: i32 = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, Prognosis);
        if (pointstempdampercent > 100)
        {
          Number3 =  Math.Round( Number3 * ( pointstempdampercent / 100.0));
          if (MakeLog)
            this.AddLog("Attack gets bonus for supporting an artillery/air attack " + Conversion.Str( pointstempdampercent) + "%");
        }
        let mut pointsOnOnlyPower: i32 = this.GetRealDefendingPowerPointsOnOnlyPower(ix, iy);
        let mut num6: i32 = 80;
        if ( this.game.Data.RuleVar[384] > 0.0)
          num6 =  Math.Round( this.game.Data.RuleVar[384]);
        if (pointsOnOnlyPower > num6)
        {
          Number3 =  Math.Round( Number3 * ( pointsOnOnlyPower /  num6));
          if (MakeLog)
            this.AddLog("Large Target Bonus. " + Conversion.Str( (100.0 * ( pointsOnOnlyPower /  num6) - 100.0)) + "% extra pts!");
        }
        else if ( pointsOnOnlyPower <  num6 / 8.0)
        {
          Number3 = Math.Max(val1 + 3,  Math.Round( Number3 * 0.2));
          if (MakeLog)
            this.AddLog("Super small bigunit/8 unit. -80% of pts. ");
        }
        else if ( pointsOnOnlyPower <  num6 / 4.0)
        {
          Number3 = Math.Max(val1 + 1,  Math.Round( Number3 * 0.2));
          if (MakeLog)
            this.AddLog("small bigunit/4 unit. -50% of pts. ");
        }
        if (this.DistanceFromSuppliedHex[ix, iy] <= 1)
        {
          if (this.AverageSupplyPercentage < 10)
          {
            Number3 *= 8;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *8");
          }
          else if (this.AverageSupplyPercentage < 30)
          {
            Number3 *= 4;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *4");
          }
          else if (this.AverageSupplyPercentage < 50)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *2");
          }
        }
        else if (this.DistanceFromSuppliedHex[ix, iy] <= 2)
        {
          if (this.AverageSupplyPercentage < 10)
          {
            Number3 *= 4;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *4");
          }
          else if (this.AverageSupplyPercentage < 30)
          {
            Number3 *= 2;
            if (MakeLog)
              this.AddLog("points multiplied due to out of supply situation *2");
          }
        }
        else if (this.DistanceFromSuppliedHex[ix, iy] <= 3 && this.AverageSupplyPercentage < 10)
        {
          Number3 *= 2;
          if (MakeLog)
            this.AddLog("points multiplied due to out of supply situation *2");
        }
        if (MakeLog)
          this.AddLog("Attack after mods gives " + Conversion.Str( Number3) + " pts.");
        if (Number3 == 0 && MakeLog)
          this.AddLog("ATTACK CANCELLED. 0 PTS.");
        let mut counter: i32 = this.game.EditObj.TempUnitList.counter;
        for (let mut index: i32 = 0; index <= counter; index += 1)
          this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].TempAttacked = true;
        if (Prognosis &  num4 >=  val1 * 1.5)
        {
          this.TempOwner[ix, iy] = this.GetGameDataTurn();
          if (MakeLog)
            this.AddLog("****** attack leads to conquest of hex!");
        }
      }
      else
      {
        if (Number3 > 0)
        {
          if (MakeLog)
            this.AddLog("To little forces for attack on (" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ") Attacker = " + Conversion.Str( Number1) + ", Defender =" + Conversion.Str( Number2));
          let mut counter: i32 = this.game.EditObj.TempUnitList.counter;
          for (let mut index: i32 = 0; index <= counter; index += 1)
          {
            if (MakeLog)
              this.AddLog("-" + this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].Name);
          }
        }
        Number3 = 0;
      }
      return Number3;
    }

    pub float IsDefendingAndAttackingAtRightPlace(ophq: i32, ix: i32, iy: i32, UnitList UL)
    {
      num1: i32;
      if (this.game.Data.UnitObj[ophq].AIAttack > -1)
      {
        num1 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
        if (num1 == 0)
          num1 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
      }
      num2: i32;
      if (this.game.Data.UnitObj[ophq].AIDefend > -1)
      {
        num2 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
        if (num2 == 0)
          num2 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
      }
      let mut num3: i32 = this.AreaMatrixNarrow[ix, iy];
      if (num3 == 0)
        num3 = this.AreaMatrixWide[ix, iy];
      num4: i32;
      num5: i32;
      if (num2 > 0 & num3 > 0)
      {
        let mut counter: i32 = UL.counter;
        for (let mut index: i32 = 0; index <= counter; index += 1)
        {
          let mut num6: i32 = this.AreaMatrixNarrow[this.game.Data.UnitObj[UL.unr[index]].X, this.game.Data.UnitObj[UL.unr[index]].Y];
          if (num6 == 0)
          {
            let mut num7: i32 = this.AreaMatrixWide[this.game.Data.UnitObj[UL.unr[index]].X, this.game.Data.UnitObj[UL.unr[index]].Y];
          }
          if (num6 != num2 & num6 != num1)
          {
            num4 += this.GetUnitPower(UL.unr[index], true);
          }
          else
          {
            num4 += this.GetUnitPower(UL.unr[index], true);
            num5 += this.GetUnitPower(UL.unr[index], true);
          }
        }
      }
      return num4 <= 0 ? 0.0f :  num5 /  num4;
    }

    pub float IsMovingAtRightPlace(ophq: i32, ix: i32, iy: i32)
    {
      num1: i32;
      if (this.game.Data.UnitObj[ophq].AIAttack > -1)
      {
        num1 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
        if (num1 == 0)
          num1 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIAttack].y];
      }
      num2: i32;
      if (this.game.Data.UnitObj[ophq].AIDefend > -1)
      {
        num2 = this.AreaMatrixNarrow[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
        if (num2 == 0)
          num2 = this.AreaMatrixWide[this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[ophq].AIDefend].y];
      }
      let mut num3: i32 = this.AreaMatrixNarrow[ix, iy];
      if (num3 == 0)
        num3 = this.AreaMatrixWide[ix, iy];
      return num2 > 0 & num3 > 0 && num3 != num2 & !(num3 == num1 & num1 > 0) ? 0.0f : 1f;
    }

    pub fn GetScoreForArtAttack(ix: i32, iy: i32, bool Prognosis, bool MakeLog) -> i32
    {
      let mut num1: i32 = 0;
      attackPowerPointsOn: i32;
      if (Prognosis)
        num1 += this.GetPrognosedLandArtAttackPowerPointsOn(ix, iy, true);
      else if (!Prognosis)
      {
        attackPowerPointsOn = this.GetPrognosedLandArtAttackPowerPointsOn(ix, iy, true);
        num1 += this.GetRealLandArtAttackPowerPointsOn(ix, iy, true);
      }
      let mut defendingPowerPointsOn: i32 = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis);
      if (num1 == 0 & attackPowerPointsOn > 0)
        num1 = num1;
      if (num1 == 0)
        return 0;
      if (defendingPowerPointsOn == 0)
      {
        if (MakeLog)
          this.AddLog("ARTILLERY Attack on (" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ") Attacker = " + Conversion.Str( num1) + ", Defender =" + Conversion.Str( defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("No Defenders. Attack gives 100 pts.");
        return 100;
      }
      let mut Number: i32 = Math.Min(num1, 30000);
      if (Number > 0)
      {
        if (MakeLog)
          this.AddLog("ARTILLERY Attack on (" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ") Attacker = " + Conversion.Str( num1) + ", Defender =" + Conversion.Str( defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("ARTILLERY Attack gives " + Conversion.Str( Number) + " pts.");
        let mut num2: i32 = 0;
        let mut unitCounter1: i32 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
          num2 += this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index], false);
        let mut unitCounter2: i32 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (let mut index1: i32 = 0; index1 <= unitCounter2; index1 += 1)
        {
          let mut unitPower: i32 = this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index1], false);
          UnitClass[] unitObj = this.game.Data.UnitObj;
          UnitClass[] unitClassArray = unitObj;
          int[] unitList = this.game.Data.MapObj[0].HexObj[ix, iy].UnitList;
          int[] numArray = unitList;
          let mut index2: i32 = index1;
          let mut index3: i32 = index2;
          let mut index4: i32 = numArray[index3];
          unitClassArray[index4].TempArtDam = unitObj[unitList[index2]].TempArtDam +  Math.Round( Number * ( unitPower /  num2));
          if (MakeLog)
            this.AddLog(Conversion.Str(  Math.Round( Number * ( unitPower /  num2))) + " dam on " + Conversion.Str( ix) + "," + Conversion.Str( iy));
        }
        let mut tscore: i32 = this.GetTscore(ix, iy);
        Number = tscore <= 0 ? 0 :  Math.Round( Number * ( tscore / 100.0));
        let mut counter: i32 = this.game.EditObj.TempUnitList.counter;
        for (let mut index: i32 = 0; index <= counter; index += 1)
          this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].TempAttacked = true;
        let mut pointstempdampercent: i32 = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, Prognosis);
        if (pointstempdampercent > 100)
        {
          Number =  Math.Round( Number * ( pointstempdampercent / 100.0));
          if (MakeLog)
            this.AddLog("Attack gets bonus for supporting an artillery/air attack " + Conversion.Str( pointstempdampercent) + "%");
        }
      }
      return  Math.Round( ( Number / (8f * this.CONST_ARTMULTI)));
    }

    pub fn GetScoreForAirAttack(ix: i32, iy: i32, bool Prognosis, bool MakeLog) -> i32
    {
      let mut num1: i32 = 0;
      if (ix == -1 | iy == -1)
        return 0;
      if (Prognosis)
        num1 += this.GetPrognosedAirAttackPowerPointsOn(ix, iy, true);
      else if (!Prognosis)
        num1 += this.GetRealAirAttackPowerPointsOn(ix, iy, true);
      let mut defendingPowerPointsOn: i32 = this.GetCurrentDefendingPowerPointsOn(ix, iy, Prognosis);
      if (num1 > 0)
        MakeLog = MakeLog;
      if (num1 == 0)
        return 0;
      let mut fighterPowerPointsOn: i32 = this.GetPrognosedorRealFighterPowerPointsOn(ix, iy, true, Prognosis: Prognosis);
      if (this.Attacker)
      {
        if ( this.FighterMatrix[ix, iy] * 0.5 >  fighterPowerPointsOn)
          return 0;
      }
      else if (this.FighterMatrix[ix, iy] * 1 > fighterPowerPointsOn)
        return 0;
      if (defendingPowerPointsOn == 0)
      {
        if (MakeLog)
          this.AddLog("AIR Attack on (" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ") Attacker = " + Conversion.Str( num1) + ", Defender =" + Conversion.Str( defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("No Defenders. Attack gives 100 pts.");
        return 0;
      }
      let mut Number: i32 = Math.Min(num1, 100000);
      if (Number > 0)
      {
        if (MakeLog)
          this.AddLog("AIR Attack on (" + Conversion.Str( ix) + "," + Conversion.Str( iy) + ") Attacker = " + Conversion.Str( num1) + ", Defender =" + Conversion.Str( defendingPowerPointsOn));
        if (MakeLog)
          this.AddLog("AIR Attack gives " + Conversion.Str( Number) + " pts.");
        let mut num2: i32 = 0;
        let mut unitCounter1: i32 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
          num2 += this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index], false);
        let mut unitCounter2: i32 = this.game.Data.MapObj[0].HexObj[ix, iy].UnitCounter;
        for (let mut index1: i32 = 0; index1 <= unitCounter2; index1 += 1)
        {
          let mut unitPower: i32 = this.GetUnitPower(this.game.Data.MapObj[0].HexObj[ix, iy].UnitList[index1], false);
          UnitClass[] unitObj = this.game.Data.UnitObj;
          UnitClass[] unitClassArray = unitObj;
          int[] unitList = this.game.Data.MapObj[0].HexObj[ix, iy].UnitList;
          int[] numArray = unitList;
          let mut index2: i32 = index1;
          let mut index3: i32 = index2;
          let mut index4: i32 = numArray[index3];
          unitClassArray[index4].TempArtDam = unitObj[unitList[index2]].TempArtDam +  Math.Round( Number * ( unitPower /  num2));
          if (MakeLog)
            this.AddLog(Conversion.Str(  Math.Round( Number * ( unitPower /  num2))) + " air dam on " + Conversion.Str( ix) + "," + Conversion.Str( iy));
        }
        let mut tscore: i32 = this.GetTscore(ix, iy);
        Number = tscore <= 0 ? 0 :  Math.Round( Number * (100.0 /  tscore));
        let mut counter: i32 = this.game.EditObj.TempUnitList.counter;
        for (let mut index: i32 = 0; index <= counter; index += 1)
          this.game.Data.UnitObj[this.game.EditObj.TempUnitList.unr[index]].TempAttacked = true;
        let mut pointstempdampercent: i32 = this.GetCurrentDefendingPowerPointstempdampercent(ix, iy, Prognosis);
        if (pointstempdampercent > 100)
        {
          Number =  Math.Round( Number * ( pointstempdampercent / 100.0));
          if (MakeLog)
            this.AddLog("Attack gets bonus for supporting an artillery/air attack " + Conversion.Str( pointstempdampercent) + "%");
        }
      }
      return  Math.Round( ( Number / (8f * this.CONST_AIRMULTI)));
    }

    pub fn GetFreeAP(bool ModifiedForStrength) -> i32
    {
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut unr: i32 = 0; unr <= unitCounter1; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup & this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].PreDef == -1)
        {
          num1 += this.game.HandyFunctionsObj.GetPower(unr, this.game.Data.Turn);
          num2 += 1;
        }
      }
      if (num2 < 1)
        return 0;
      let mut num3: i32 =  Math.Round(Conversion.Int( num1 /  num2));
      let mut num4: i32 = 0;
      let mut unitCounter2: i32 = this.game.Data.UnitCounter;
      for (let mut unr: i32 = 0; unr <= unitCounter2; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup & this.game.Data.UnitObj[unr].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr].PreDef == -1)
        {
          let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(unr);
          let mut num5: i32 = this.game.Data.UnitObj[unr].TempX <= -1 ? lowestAp : lowestAp - this.MoveMatrix[this.game.Data.UnitObj[unr].TempSlot, this.game.Data.UnitObj[unr].TempX, this.game.Data.UnitObj[unr].TempY];
          if (ModifiedForStrength)
            num5 =  Math.Round( ( num5 * ( this.game.HandyFunctionsObj.GetPower(unr, this.game.Data.Turn) /  num3)));
          num4 += num5;
        }
      }
      return  Math.Round(Conversion.Int( num4 /  num2));
    }

    pub float GetAverageCombatScore(
      attsftype: i32,
      x: i32,
      y: i32,
      bool isArtilleryattack = false,
      bool EnemyVersusTempLocs = false)
    {
      float num1 = 0.0f;
      let mut num2: i32 = 0;
      if (!EnemyVersusTempLocs)
      {
        let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
        for (let mut index1: i32 = 0; index1 <= unitCounter; index1 += 1)
        {
          let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index1];
          let mut sfCount: i32 = this.game.Data.UnitObj[unit].SFCount;
          for (let mut index2: i32 = 0; index2 <= sfCount; index2 += 1)
          {
            let mut index3: i32 = this.game.Data.UnitObj[unit].SFList[index2];
            let mut type: i32 = this.game.Data.SFObj[index3].Type;
            if (attsftype == 68)
              index3 = index3;
            let mut num3: i32 =  Math.Round( ( (this.game.Data.SFObj[index3].Qty * this.game.Data.SFTypeObj[type].PowerPts) * this.CombatMatrix[attsftype, type]));
            if (isArtilleryattack)
              num3 =  Math.Round( num3 / ( (this.game.Data.SFObj[index3].CurrentEntrench + 70) / 70.0));
            if (this.game.Data.SFTypeObj[type].BackBench)
            {
              num1 +=   Math.Round( num3 / 4.0);
              num2 +=  Math.Round( (this.game.Data.SFObj[index3].Qty * this.game.Data.SFTypeObj[type].PowerPts) / 4.0);
            }
            else
            {
              num1 +=  num3;
              num2 += this.game.Data.SFObj[index3].Qty * this.game.Data.SFTypeObj[type].PowerPts;
            }
          }
        }
      }
      else
      {
        let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
        for (let mut index4: i32 = 0; index4 <= moveMatrixCounter; index4 += 1)
        {
          let mut index5: i32 = this.MoveMatrixUnit[index4];
          if (index5 > -1 && this.game.Data.UnitObj[index5].TempX == x & this.game.Data.UnitObj[index5].TempY == y)
          {
            let mut sfCount: i32 = this.game.Data.UnitObj[index5].SFCount;
            for (let mut index6: i32 = 0; index6 <= sfCount; index6 += 1)
            {
              let mut sf: i32 = this.game.Data.UnitObj[index5].SFList[index6];
              let mut type: i32 = this.game.Data.SFObj[sf].Type;
              let mut num4: i32 =  Math.Round( ( (this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts) * this.CombatMatrix[attsftype, type]));
              if (this.game.Data.SFTypeObj[type].BackBench)
              {
                num1 +=   Math.Round( num4 / 4.0);
                num2 +=  Math.Round( (this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts) / 4.0);
              }
              else
              {
                num1 +=  num4;
                num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
              }
            }
          }
        }
      }
      return num2 == 0 |  num1 == 0.0 ? 1f : num1 /  num2;
    }

    pub fn GetDivisionalPower(unr: i32, grp: i32) -> i32
    {
      let mut divisionalPower: i32 = 0;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr1: i32 = 0; unr1 <= unitCounter; unr1 += 1)
      {
        if (this.game.Data.UnitObj[unr1].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr1].PreDef == -1 & this.game.Data.UnitObj[unr1].X > -1 && this.game.Data.UnitObj[unr].Historical == this.game.Data.UnitObj[unr1].Historical && this.game.Data.UnitObj[unr1].AIGroup == grp | grp == -1)
          divisionalPower += this.GetUnitPower(unr1, false);
      }
      return divisionalPower;
    }

    pub GetCurrentDefendingPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool Prognosis = false,
      bool WithoutEntrench = false,
      bool DontCountAir = false)
    {
      let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      defendingPowerPointsOn: i32;
      num1: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        num2: i32;
        if (!DontCountAir | !this.game.HandyFunctionsObj.HasUnitAirSF(unit))
        {
          if (WithoutEntrench)
          {
            num2 = this.GetUnitPower(unit, false, WithoutEntrench: WithoutEntrench);
          }
          else
          {
            num2 = this.game.Data.UnitObj[unit].TempUnitPower;
            let mut num3: i32 =  Math.Round( num2 / (1.0 +  this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 100.0));
            if (num3 <= 0)
              num3 = 1;
            if (Prognosis && this.game.Data.UnitObj[unit].TempArtDam > 0)
            {
              let mut num4: i32 =  Math.Round( this.game.Data.UnitObj[unit].TempArtDam / (1.0 +  this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 100.0));
              num2 =  Math.Round(( Math.Max(0, num3 - num4) * ( num4 /  num3) * 2.0 +  (Math.Max(0, num2 - num4) * 1)) / (1.0 + 2.0 * ( num4 /  num3)));
              if ( num3 * 0.33 >  num2)
                num2 =  Math.Round( num3 / 3.0);
            }
          }
        }
        defendingPowerPointsOn += num2;
        num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unit);
      }
      if ( num1 >  this.game.Data.RuleVar[30])
        defendingPowerPointsOn =  Math.Round( Conversion.Int( defendingPowerPointsOn * (this.game.Data.RuleVar[30] /  num1)));
      return defendingPowerPointsOn;
    }

    pub fn GetAverageSupplyConsume(x: i32, y: i32) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        let mut unitPower: i32 = this.GetUnitPower(unit, false);
        num1 += unitPower;
        num2 += unitPower * this.game.Data.UnitObj[unit].SupplyConsume;
      }
      if (num1 == 0)
        num1 = 1;
      if (num2 == 0)
        num2 = 100;
      return  Math.Round( num2 /  num1);
    }

    pub fn GetCurrentDefendingStackOn(x: i32, y: i32, bool Prognosis = false, bool WithoutEntrench = false) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      defendingStackOn: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        let mut num1: i32 = this.GetUnitPower(unit, false, WithoutEntrench: WithoutEntrench);
        let mut num2: i32 =  Math.Round( num1 / (1.0 +  this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 100.0));
        if (num2 <= 1)
          num2 = 1;
        if (Prognosis && this.game.Data.UnitObj[unit].TempArtDam > 0)
        {
          let mut num3: i32 = this.game.Data.UnitObj[unit].TempArtDam;
          if (num3 > 80)
            num3 = num3;
          let mut num4: i32 =  Math.Round( num3 / (1.0 +  this.game.HandyFunctionsObj.GetAverageEntrench(unit) / 2.0 / 100.0));
          num1 =  Math.Round(( Math.Max(0, num2 - num4) * ( num4 /  num2) * 2.0 +  (Math.Max(0, num1 - num4) * 1)) / (1.0 + 2.0 * ( num4 /  num2)));
          if ( num2 * 0.5 >  num1)
            num1 =  Math.Round( num2 / 2.0);
        }
        num5: i32;
        num5 += num1;
        defendingStackOn += this.game.HandyFunctionsObj.GetUnitStackPts(unit);
      }
      return defendingStackOn;
    }

    pub fn GetCurrentDefendingPowerPointstempdampercent(x: i32, y: i32, bool Prognosis = false) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      num1: i32;
      num2: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        let mut unitPower: i32 = this.GetUnitPower(unit, false);
        let mut num3: i32 = 0;
        if (Prognosis && this.game.Data.UnitObj[unit].TempArtDam > 0)
          num3 = this.game.Data.UnitObj[unit].TempArtDam * 2;
        num1 += unitPower;
        num2 += num3;
      }
      if (num1 == 0)
        return 0;
      let mut pointstempdampercent: i32 =  Math.Round(100.0 * ( num2 /  num1));
      if (pointstempdampercent > 160)
        pointstempdampercent = 160;
      return pointstempdampercent;
    }

    pub fn GetPrognosedDefendingPowerPointsOnOnlyPower(x: i32, y: i32) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      pointsOnOnlyPower: i32;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].TempX == x & this.game.Data.UnitObj[unr].TempY == y && this.game.Data.UnitObj[unr].AIGroup == this.OpGroup & this.GetRegime(this.game.Data.UnitObj[unr].Regime) == this.GetGameDataTurn())
        {
          let mut powerPtsAbsolute: i32 = this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          pointsOnOnlyPower += powerPtsAbsolute;
        }
      }
      return pointsOnOnlyPower;
    }

    pub fn GetRealDefendingPowerPointsOnOnlyPower(x: i32, y: i32) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      pointsOnOnlyPower: i32;
      for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
      {
        if (this.game.Data.UnitObj[unr].PreDef == -1 && this.game.Data.UnitObj[unr].X == x & this.game.Data.UnitObj[unr].Y == y)
        {
          let mut powerPtsAbsolute: i32 = this.game.HandyFunctionsObj.GetPowerPtsAbsolute(unr);
          pointsOnOnlyPower += powerPtsAbsolute;
        }
      }
      return pointsOnOnlyPower;
    }

    pub GetPrognosedDefendingPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool WithStack = true,
      bool OnlyOpGroup = false,
      let mut OnlyUnit: i32 = -1,
      bool CounterAttack = false)
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      defendingPowerPointsOn: i32;
      num1: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].TempX == x & this.game.Data.UnitObj[index].TempY == y | this.game.Data.UnitObj[index].X == x & this.game.Data.UnitObj[index].Y == y && OnlyUnit == -1 | OnlyUnit == index)
        {
          let mut num2: i32 = 0;
          if (!OnlyOpGroup | this.game.Data.UnitObj[index].AIGroup == this.OpGroup & this.game.Data.UnitObj[index].TempX == x & this.game.Data.UnitObj[index].TempY == y)
            num2 = 1;
          else if (this.game.Data.UnitObj[index].AIGroup != this.OpGroup)
          {
            num2 = this.game.Data.UnitObj[index].AIDefend != this.AreaMatrixNarrow[x, y] ? 2 : 1;
            if (this.game.Data.UnitObj[index].IsHQ)
              num2 = 0;
          }
          if (num2 >= 1)
          {
            let mut unr: i32 = index;
            let mut num3: i32 = !(CounterAttack & this.game.Data.UnitObj[unr].TempX > -1) ? this.game.Data.UnitObj[unr].TempUnitPower : this.GetUnitPower(unr, false, UseTempCoords: true);
            if (num2 == 2)
              num3 = -( num3 ==  num3 / 3.0 ? 1 : 0);
            let mut num4: i32 =  Math.Round( num3 * ( (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num4;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
        }
      }
      if ( num1 >  this.game.Data.RuleVar[30] & WithStack)
        defendingPowerPointsOn =  Math.Round(Conversion.Int( defendingPowerPointsOn * 0.33) + Conversion.Int( defendingPowerPointsOn * 0.66 * ( this.game.Data.RuleVar[30] /  num1)));
      return defendingPowerPointsOn;
    }

    pub GetPrognosedAndRealDefendingPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool WithStack = true,
      bool CounterAttack = false)
    {
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      defendingPowerPointsOn: i32;
      num1: i32;
      for (let mut index1: i32 = 0; index1 <= moveMatrixCounter; index1 += 1)
      {
        let mut index2: i32 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index2].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[index2].TempX == x & this.game.Data.UnitObj[index2].TempY == y)
          {
            let mut unr: i32 = index2;
            let mut num2: i32 =  Math.Round((!(CounterAttack & this.game.Data.UnitObj[unr].TempX > -1) ?  this.game.Data.UnitObj[unr].TempUnitPower :  this.GetUnitPower(unr, false, UseTempCoords: true)) * ( (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num2;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
          else if (this.game.Data.UnitObj[index2].TempX == -1 && this.game.Data.UnitObj[index2].X == x & this.game.Data.UnitObj[index2].Y == y)
          {
            let mut unr: i32 = index2;
            let mut num3: i32 =  Math.Round((!(CounterAttack & this.game.Data.UnitObj[unr].TempX > -1) ?  this.game.Data.UnitObj[unr].TempUnitPower :  this.GetUnitPower(unr, false, UseTempCoords: true)) * ( (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num3;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
        }
      }
      let mut unitCounter: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        let mut unit: i32 = this.game.Data.MapObj[0].HexObj[x, y].UnitList[index];
        if (this.game.Data.UnitObj[unit].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unit].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[unit].TempX == x & this.game.Data.UnitObj[unit].TempY == y)
          {
            let mut unr: i32 = unit;
            let mut num4: i32 =  Math.Round( this.game.Data.UnitObj[unr].TempUnitPower * ( (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num4;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
          else if (this.game.Data.UnitObj[unit].TempX == -1 && this.game.Data.UnitObj[unit].X == x & this.game.Data.UnitObj[unit].Y == y)
          {
            let mut unr: i32 = unit;
            let mut num5: i32 =  Math.Round( this.game.Data.UnitObj[unr].TempUnitPower * ( (100 + this.game.HandyFunctionsObj.GetDivBonusPrognosis(unr)) / 100.0));
            defendingPowerPointsOn += num5;
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
          }
        }
      }
      if ( num1 >  this.game.Data.RuleVar[30] & WithStack)
        defendingPowerPointsOn =  Math.Round(Conversion.Int( defendingPowerPointsOn * 0.33) + Conversion.Int( defendingPowerPointsOn * 0.66 * ( this.game.Data.RuleVar[30] /  num1)));
      return defendingPowerPointsOn;
    }

    pub float GetRiverMod(unr: i32, riv: i32)
    {
      let mut sfCount: i32 = this.game.Data.UnitObj[unr].SFCount;
      float num1;
      num2: i32;
      for (let mut index: i32 = 0; index <= sfCount; index += 1)
      {
        let mut sf: i32 = this.game.Data.UnitObj[unr].SFList[index];
        let mut unitGroup: i32 = this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].UnitGroup;
        float num3 = 1f - this.game.Data.RiverTypeObj[riv].AttackPenalty[unitGroup];
        num1 += num3 *  this.game.Data.SFObj[sf].Qty *  this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
        num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[this.game.Data.SFObj[sf].Type].PowerPts;
      }
      return num1 /  num2;
    }

    pub GetPrognosedEnemyLandAttackPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool UseTempCoord = false,
      bool OptimisticStack = false,
      bool LeaveFrontLineEmptyPenalty = false)
    {
      UnitList unitList = UnitList::new();
      if (x == -1 | y == -1 | x > this.game.Data.MapObj[0].MapWidth | y > this.game.Data.MapObj[0].MapHeight)
        return 0;
      let mut attackPowerPointsOn: i32 = 0;
      num1: i32;
      if (UseTempCoord)
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut index: i32 = 0; index <= unitCounter; index += 1)
        {
          if (this.game.Data.UnitObj[index].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index].Regime) != this.GetGameDataTurn() & this.game.Data.UnitObj[index].TempSlot > -1)
          {
            Coordinate coordinate1;
            coordinate1.x = this.game.Data.UnitObj[index].TempX;
            coordinate1.y = this.game.Data.UnitObj[index].TempY;
            if (coordinate1.x > -1 & coordinate1.y > -1)
            {
              let mut tfacing: i32 = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
                if (coordinate2.onmap && coordinate1.x == coordinate2.x & coordinate1.y == coordinate2.y && Math.Min(120, this.game.HandyFunctionsObj.GetAverageRdn(index) + 30) - this.EnemyMatrix[this.game.Data.UnitObj[index].TempSlot, x, y] >= 0)
                {
                  let mut unitPower: i32 = this.GetUnitPower(index, true, x, y, tfacing - 1, EnemyAttack: true);
                  num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                  attackPowerPointsOn += unitPower;
                  unitList.add(index);
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      else
      {
        let mut enemyMatrixCounter: i32 = this.EnemyMatrixCounter;
        for (let mut index1: i32 = 1; index1 <= enemyMatrixCounter; index1 += 1)
        {
          let mut index2: i32 = this.EnemyMatrixUnit[index1];
          if (Math.Min(120, this.game.HandyFunctionsObj.GetAverageRdn(index2) + 30) - this.EnemyMatrix[index1, x, y] >= 0)
          {
            num2: i32;
            let mut num3: i32 = this.GetUnitPower(index2, true, x, y, num2 - 1, EnemyAttack: true);
            num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index2);
            this.game.Data.UnitObj[index2].TempX =  this.EnemyMatrixCameFrom[index1, x, y].x;
            this.game.Data.UnitObj[index2].TempY =  this.EnemyMatrixCameFrom[index1, x, y].y;
            if (this.game.Data.UnitObj[index2].TempX != this.game.Data.UnitObj[index2].X & this.game.Data.UnitObj[index2].TempY != this.game.Data.UnitObj[index2].Y)
            {
              let mut num4: i32 = this.EnemyMatrix[index1, x, y] - this.EnemyMatrix[index1, this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] + 30;
              if (num4 > 0 & num4 < 70)
                num3 -=  Math.Round( num3 * ( num4 / 70.0));
              else
                num3 = 0;
              if (LeaveFrontLineEmptyPenalty && this.EnemyFrontlineArea[this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY] > 0)
                num3 =  Math.Round( num3 / 3.0);
            }
            if (num3 > 0)
            {
              attackPowerPointsOn += num3;
              unitList.add(index2);
            }
          }
        }
      }
      if (attackPowerPointsOn > 0)
      {
        this.game.EditObj.OrderX = x;
        this.game.EditObj.OrderY = y;
        this.game.EditObj.TargetX = x;
        this.game.EditObj.TargetY = y;
        this.game.EditObj.TempUnitList = unitList;
        attackPowerPointsOn =  Math.Round( ( attackPowerPointsOn * this.game.HandyFunctionsObj.GetConcentricBonus2Prognosis(false)));
        let mut num5: i32 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
        this.game.EditObj.TargetX = -1;
        this.game.EditObj.TargetY = -1;
        if (num1 > num5)
        {
          if (!OptimisticStack)
            attackPowerPointsOn =  Math.Round(0.15 *  attackPowerPointsOn + 0.85 *   Math.Round( attackPowerPointsOn * ( num5 /  num1)));
          else if (num1 > num5)
            attackPowerPointsOn =  Math.Round(0.25 *  attackPowerPointsOn + 0.75 *   Math.Round( attackPowerPointsOn * ( num5 /  num1)));
        }
      }
      return attackPowerPointsOn;
    }

    pub GetPrognosedEnemyStackPointsOn: i32(
      x: i32,
      y: i32,
      bool UseTempCoord = false,
      bool OptimisticStack = false)
    {
      UnitList unitList = UnitList::new();
      if (x == -1 | y == -1 | x > this.game.Data.MapObj[0].MapWidth | y > this.game.Data.MapObj[0].MapHeight)
        return 0;
      enemyStackPointsOn: i32;
      if (UseTempCoord)
      {
        let mut unitCounter: i32 = this.game.Data.UnitCounter;
        for (let mut unr: i32 = 0; unr <= unitCounter; unr += 1)
        {
          if (this.game.Data.UnitObj[unr].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr].Regime) != this.GetGameDataTurn() & this.game.Data.UnitObj[unr].TempSlot > -1)
          {
            Coordinate coordinate1;
            coordinate1.x = this.game.Data.UnitObj[unr].TempX;
            coordinate1.y = this.game.Data.UnitObj[unr].TempY;
            if (coordinate1.x > -1 & coordinate1.y > -1)
            {
              let mut tfacing: i32 = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
                if (coordinate2.onmap && coordinate1.x == coordinate2.x & coordinate1.y == coordinate2.y && this.game.HandyFunctionsObj.GetAverageRdn(unr) - this.EnemyMatrix[this.game.Data.UnitObj[unr].TempSlot, x, y] >= 0)
                  enemyStackPointsOn += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      else
      {
        let mut enemyMatrixCounter: i32 = this.EnemyMatrixCounter;
        for (let mut index: i32 = 1; index <= enemyMatrixCounter; index += 1)
        {
          let mut unr: i32 = this.EnemyMatrixUnit[index];
          if (this.game.HandyFunctionsObj.GetAverageRdn(unr) - this.EnemyMatrix[index, x, y] >= 0)
            enemyStackPointsOn += this.game.HandyFunctionsObj.GetUnitStackPts(unr);
        }
      }
      return enemyStackPointsOn;
    }

    pub fn GetAIRolePercent(unr: i32, rolenr: i32) -> i32
    {
      let mut sfCount: i32 = this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 = 0; index <= sfCount; index += 1)
      {
        let mut sf: i32 = this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 = this.game.Data.SFObj[sf].Type;
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
        if (this.game.Data.SFTypeObj[type].AIRoleScore[rolenr] > 0)
          num2 +=  Math.Round( (this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts) * ( this.game.Data.SFTypeObj[type].AIRoleScore[rolenr] / 100.0));
      }
      return num1 == 0 ? 0 :  Math.Round(Conversion.Int( (100 * num2) /  num1));
    }

    pub fn GetReinforcementTypePercent(unr: i32, rolenr: i32) -> i32
    {
      let mut sfCount: i32 = this.game.Data.UnitObj[unr].SFCount;
      num1: i32;
      num2: i32;
      for (let mut index: i32 = 0; index <= sfCount; index += 1)
      {
        let mut sf: i32 = this.game.Data.UnitObj[unr].SFList[index];
        let mut type: i32 = this.game.Data.SFObj[sf].Type;
        num1 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
        if (this.game.Data.SFTypeObj[type].ReinforcementType == rolenr)
          num2 += this.game.Data.SFObj[sf].Qty * this.game.Data.SFTypeObj[type].PowerPts;
      }
      return num1 == 0 ? 0 :  Math.Round(Conversion.Int( (100 * num2) /  num1));
    }

    pub GetPrognosedLandAttackPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = UnitList::new();
      let mut tfacing: i32 = 1;
      num1: i32;
      attackPowerPointsOn: i32;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
          for (let mut index1: i32 = 1; index1 <= moveMatrixCounter; index1 += 1)
          {
            let mut index2: i32 = this.MoveMatrixUnit[index1];
            if (this.game.Data.UnitObj[index2].TempX == coordinate.x & this.game.Data.UnitObj[index2].TempY == coordinate.y && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 1 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup & !this.game.Data.UnitObj[index2].IsHQ)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ( this.game.HandyFunctionsObj.GetAverageRdn(index2) >= 70.0 * ((1.0 +  Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index2].SupplyIn == 0)
              {
                let mut num2: i32 = FullAp ? this.game.Data.UnitObj[index2].SupplyConsume : this.game.HandyFunctionsObj.GetLowestAp(index2) - this.MoveMatrix[this.game.Data.UnitObj[index2].TempSlot, coordinate.x, coordinate.y];
                let mut x1: i32 = this.game.HandyFunctionsObj.MoveApCostPreview(index2, coordinate.x, coordinate.y, coordinate.x, coordinate.y, 0, x, y, 0, true).x;
                if (num2 >= x1)
                {
                  let mut num3: i32 = this.GetUnitPower(index2, true, x, y, tfacing - 1);
                  num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index2);
                  if (AdjustedForAp)
                  {
                    let mut num4: i32 = num2;
                    num3 = num4 > 25 ?  Math.Round( num3 * ( (num4 - 25) /  num4)) : 0;
                  }
                  if (ForContainment && this.game.Data.UnitObj[index2].SupplyConsume > 0 &&  this.game.Data.UnitObj[index2].SupplyIn <  this.game.Data.UnitObj[index2].SupplyInReq * 0.25)
                    num3 *= 10;
                  attackPowerPointsOn += num3;
                  unitList.add(index2);
                }
              }
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      if (attackPowerPointsOn > 0)
      {
        this.game.EditObj.OrderX = x;
        this.game.EditObj.OrderY = y;
        this.game.EditObj.TargetX = x;
        this.game.EditObj.TargetY = y;
        this.game.EditObj.TempUnitList = unitList;
        attackPowerPointsOn =  Math.Round(  Math.Round( ( attackPowerPointsOn * this.game.HandyFunctionsObj.GetConcentricBonus2Prognosis(false))) * ( (100 + this.game.HandyFunctionsObj.GetDivBonusForAttackPrognosis(x, y)) / 100.0));
        let mut num5: i32 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
        this.game.EditObj.TargetX = -1;
        this.game.EditObj.TargetY = -1;
        let mut num6: i32 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
        if (num6 > num5)
          attackPowerPointsOn =  this.CorpsTopRatio[this.OpGroup] <= 9.0 ? ( this.CorpsTopRatio[this.OpGroup] <= 6.0 ? ( this.CorpsTopRatio[this.OpGroup] <= 4.0 ? ( this.CorpsTopRatio[this.OpGroup] <= 3.0 ? ( this.CorpsTopRatio[this.OpGroup] <= 2.0 ? ( this.CorpsTopRatio[this.OpGroup] <= 1.5 ?  Math.Round(0.4 *  attackPowerPointsOn + 0.6 *  attackPowerPointsOn * ( num5 /  num6)) :  Math.Round(0.45 *  attackPowerPointsOn + 0.55 *  attackPowerPointsOn * ( num5 /  num6))) :  Math.Round(0.5 *  attackPowerPointsOn + 0.5 *  attackPowerPointsOn * ( num5 /  num6))) :  Math.Round(0.55 *  attackPowerPointsOn + 0.45 *  attackPowerPointsOn * ( num5 /  num6))) :  Math.Round(0.6 *  attackPowerPointsOn + 0.4 *  attackPowerPointsOn * ( num5 /  num6))) :  Math.Round(0.7 *  attackPowerPointsOn + 0.3 *  attackPowerPointsOn * ( num5 /  num6))) :  Math.Round(0.8 *  attackPowerPointsOn + 0.2 *  attackPowerPointsOn * ( num5 /  num6));
      }
      return attackPowerPointsOn;
    }

    pub fn GetPrognosedLandUnitOn(x: i32, y: i32)
    {
      UnitList unitList = UnitList::new();
      s: String = "PARTICIPANTS: ";
      let mut tfacing: i32 = 1;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut index: i32 = 0; index <= unitCounter; index += 1)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].TempX == coordinate.x & this.game.Data.UnitObj[index].TempY == coordinate.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & !this.game.Data.UnitObj[index].IsHQ)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ( this.game.HandyFunctionsObj.GetAverageRdn(index) >= 70.0 * ((1.0 +  Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index].SupplyIn == 0)
              {
                let mut Number: i32 = this.game.HandyFunctionsObj.GetLowestAp(index) - this.MoveMatrix[this.game.Data.UnitObj[index].TempSlot, coordinate.x, coordinate.y];
                handyFunctionsObj: HandyFunctionsclass = this.game.HandyFunctionsObj;
                let mut unr: i32 = index;
                let mut x1: i32 = coordinate.x;
                let mut y1: i32 = coordinate.y;
                let mut x2: i32 = x;
                let mut y2: i32 = y;
                CustomDC2AICalls customDc2AiCalls = (CustomDC2AICalls) null;
                 CustomDC2AICalls local =  customDc2AiCalls;
                let mut num1: i32 = handyFunctionsObj.MoveApCostPreview3(unr, x1, y1, 0, x2, y2, 0, true, tcustomAi: ( local));
                if (Number > num1)
                {
                  let mut unitPower: i32 = this.GetUnitPower(index, true, x, y, tfacing - 1);
                  num2: i32;
                  num2 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                  s = s + this.game.Data.UnitObj[index].Name + " (" + Conversion.Str( Number) + "ap), ";
                  num3: i32;
                  num3 += unitPower;
                  unitList.add(index);
                }
              }
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      this.AddLog(s);
    }

    pub Coordinate GetPrognosedLandAttackStackOn(
      x: i32,
      y: i32,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = UnitList::new();
      let mut tfacing: i32 = 1;
      Coordinate landAttackStackOn;
      num1: i32;
      do
      {
        landAttackStackOn = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (landAttackStackOn.onmap)
        {
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut index: i32 = 0; index <= unitCounter; index += 1)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].TempX == landAttackStackOn.x & this.game.Data.UnitObj[index].TempY == landAttackStackOn.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & !this.game.Data.UnitObj[index].IsHQ)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ( this.game.HandyFunctionsObj.GetAverageRdn(index) >= 70.0 * ((1.0 +  Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index].SupplyIn == 0 && (FullAp ? this.game.Data.UnitObj[index].SupplyConsume : this.game.HandyFunctionsObj.GetLowestAp(index) - this.MoveMatrix[this.game.Data.UnitObj[index].TempSlot, landAttackStackOn.x, landAttackStackOn.y]) >= this.game.HandyFunctionsObj.MoveApCostPreview(index, landAttackStackOn.x, landAttackStackOn.y, landAttackStackOn.x, landAttackStackOn.y, 0, x, y, 0, true).x)
              {
                let mut num2: i32 = this.GetUnitPower(index, true, x, y, tfacing - 1);
                num1 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                if (AdjustedForAp)
                {
                  let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(index);
                  num2 = lowestAp > 25 ?  Math.Round( num2 * ( (lowestAp - 25) /  lowestAp)) : 0;
                }
                if (ForContainment && this.game.Data.UnitObj[index].SupplyConsume > 0 &&  this.game.Data.UnitObj[index].SupplyIn <  this.game.Data.UnitObj[index].SupplyInReq * 0.25)
                  num2 *= 10;
                num3: i32;
                num3 += num2;
                unitList.add(index);
              }
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      this.game.EditObj.TargetX = x;
      this.game.EditObj.TargetY = y;
      this.game.EditObj.TempUnitList = unitList;
      let mut num4: i32 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
      let mut num5: i32 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
      landAttackStackOn.x = num5;
      landAttackStackOn.y = num4;
      return landAttackStackOn;
    }

    pub GetPrognosedAirAttackPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = UnitList::new();
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      num1: i32;
      num2: i32;
      num3: i32;
      attackPowerPointsOn: i32;
      for (let mut index1: i32 = 1; index1 <= moveMatrixCounter; index1 += 1)
      {
        let mut index2: i32 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].TempCategory == 3 && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 3 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup)
        {
          float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
          if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0)
            val2 = 1f;
          if ( this.game.HandyFunctionsObj.GetAverageAirRdn(index2) >= 80.0 * ((2.0 +  Math.Min(1f, val2)) / 3.0))
          {
            num4: i32;
            if (!FullAp)
            {
              let mut num5: i32 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, 0) * this.GetSlowestAirSpeed(index2);
              num4 = this.game.HandyFunctionsObj.GetLowestAirAp(index2) - num5;
            }
            else
              num4 = this.game.Data.UnitObj[index2].SupplyConsume;
            let mut num6: i32 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, x, y, 0) * this.GetSlowestAirSpeed(index2);
            if (num4 >= num6)
            {
              let mut num7: i32 = this.GetUnitPower(index2, true, x, y, IsArtilleryAttack: true, LimitCombatmod: 2f);
              num1 +=  Math.Round( num7 * ( this.GetAIRolePercent(index2, 13) / 100.0));
              num2 = num2 +  Math.Round( num7 * ( this.GetAIRolePercent(index2, 14) / 100.0)) +  Math.Round( num7 * ( this.GetAIRolePercent(index2, 15) / 100.0));
              if (AdjustedForAp)
              {
                let mut lowestAirAp: i32 = this.game.HandyFunctionsObj.GetLowestAirAp(index2);
                num7 = lowestAirAp > 10 ?  Math.Round( num7 * ( (lowestAirAp - 10) /  lowestAirAp)) : 0;
              }
              num3 += this.game.HandyFunctionsObj.GetUnitairStackPts(index2);
              attackPowerPointsOn += num7;
              unitList.add(index2);
            }
          }
        }
      }
      this.game.EditObj.TempUnitList = unitList;
      this.GetCurrentDefendingPowerPointsOn(x, y);
      if (attackPowerPointsOn > 0 & num3 > 0 &  this.game.Data.RuleVar[833] > 0.0)
      {
        let mut num8: i32 =  Math.Round( this.game.Data.RuleVar[834]);
        let mut num9: i32 = num3 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStackAir(this.game.Data.Turn);
        if (num9 > num8)
          attackPowerPointsOn =  Math.Round(0.3 *  attackPowerPointsOn + 0.7 *  attackPowerPointsOn * ( num8 /  num9));
      }
      if (num2 > 0 & this.FighterMatrix[x, y] > 0)
        attackPowerPointsOn =  Math.Round( attackPowerPointsOn * Math.Min(1.0,  num1 /  num2));
      return attackPowerPointsOn;
    }

    pub GetPrognosedorRealFighterPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false,
      bool Prognosis = true)
    {
      UnitList unitList = UnitList::new();
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      fighterPowerPointsOn: i32;
      num1: i32;
      num2: i32;
      for (let mut index1: i32 = 1; index1 <= moveMatrixCounter; index1 += 1)
      {
        let mut index2: i32 = this.MoveMatrixUnit[index1];
        if (this.game.Data.UnitObj[index2].TempCategory == 3 && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 3 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup && this.game.HandyFunctionsObj.GetAverageAirRdn(index2) >= 66)
        {
          num3: i32;
          if (!FullAp)
          {
            if (Prognosis)
            {
              let mut num4: i32 = this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, 0) * this.GetSlowestAirSpeed(index2);
              num3 = this.game.HandyFunctionsObj.GetLowestAirAp(index2) - num4;
            }
            else
              num3 = this.game.HandyFunctionsObj.GetLowestAirAp(index2);
          }
          else
            num3 = this.game.Data.UnitObj[index2].SupplyConsume;
          let mut num5: i32 = !Prognosis ? this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].X, this.game.Data.UnitObj[index2].Y, 0, x, y, 0) * this.GetSlowestAirSpeed(index2) : this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index2].TempX, this.game.Data.UnitObj[index2].TempY, 0, x, y, 0) * this.GetSlowestAirSpeed(index2);
          if (num3 >= num5)
          {
            let mut num6: i32 = this.GetUnitPower(index2, true, x, y, IsArtilleryAttack: true);
            if (AdjustedForAp)
            {
              let mut lowestAirAp: i32 = this.game.HandyFunctionsObj.GetLowestAirAp(index2);
              num6 = lowestAirAp > 10 ?  Math.Round( num6 * ( (lowestAirAp - 10) /  lowestAirAp)) : 0;
            }
            fighterPowerPointsOn +=  Math.Round( num6 * ( this.GetAIRolePercent(index2, 13) / 100.0));
            num1 = num1 +  Math.Round( num6 * ( this.GetAIRolePercent(index2, 14) / 100.0)) +  Math.Round( num6 * ( this.GetAIRolePercent(index2, 15) / 100.0));
            num2 += num6;
            unitList.add(index2);
          }
        }
      }
      let mut defendingPowerPointsOn: i32 = this.GetCurrentDefendingPowerPointsOn(x, y);
      if (defendingPowerPointsOn > num2 & num2 > 0)
        num2 =  Math.Round( num2 * 0.25 +  num2 * 0.75 * ( num2 /  defendingPowerPointsOn));
      if (num1 > 0)
      {
        let mut num7: i32 =  Math.Round( num2 * Math.Min(1.0,  fighterPowerPointsOn /  num1));
      }
      return fighterPowerPointsOn;
    }

    pub GetRealAirAttackPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = UnitList::new();
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      attackPowerPointsOn: i32;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 3 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup)
        {
          float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
          if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0)
            val2 = 1f;
          if ( this.game.HandyFunctionsObj.GetAverageAirRdn(index) >= 80.0 * ((2.0 +  Math.Min(1f, val2)) / 3.0) && (FullAp ? this.game.Data.UnitObj[index].SupplyConsume : this.game.HandyFunctionsObj.GetLowestAirAp(index)) >= this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y, 0, x, y, 0) * this.GetSlowestAirSpeed(index))
          {
            let mut num: i32 = this.GetUnitPower(index, true, x, y, LimitCombatmod: 2f);
            if (AdjustedForAp)
            {
              let mut lowestAirAp: i32 = this.game.HandyFunctionsObj.GetLowestAirAp(index);
              num = lowestAirAp > 10 ?  Math.Round( num * ( (lowestAirAp - 10) /  lowestAirAp)) : 0;
            }
            attackPowerPointsOn += num;
            unitList.add(index);
          }
        }
      }
      if (!(x > -1 & y > -1))
        return 0;
      this.GetCurrentDefendingPowerPointsOn(x, y);
      return attackPowerPointsOn;
    }

    pub fn GetSlowestAirSpeed(unr: i32) -> i32
    {
      let mut num1: i32 = -1;
      let mut sfCount: i32 = this.game.Data.UnitObj[unr].SFCount;
      for (let mut index: i32 = 0; index <= sfCount; index += 1)
      {
        let mut type: i32 = this.game.Data.SFObj[this.game.Data.UnitObj[unr].SFList[index]].Type;
        if (this.game.Data.SFTypeObj[type].Theater == 2)
        {
          let mut num2: i32 =  Math.Round( this.game.Data.LandscapeTypeObj[0].MoveCost[this.game.Data.SFTypeObj[type].MoveType] * ( this.game.Data.MoveTypePenalty[this.game.Data.SFTypeObj[type].MoveType] / 100.0));
          if (num2 > num1)
            num1 = num2;
        }
      }
      return num1 == -1 ? 999 : num1;
    }

    pub fn GetRealLandAttackPowerPointsOn(x: i32, y: i32, bool adjustedforap = false) -> i32
    {
      UnitList unitList1 = UnitList::new();
      let mut attackPowerPointsOn: i32 = 0;
      UnitList unitList2 = UnitList::new();
      let mut tfacing: i32 = 1;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
          for (let mut index1: i32 = 1; index1 <= moveMatrixCounter; index1 += 1)
          {
            let mut index2: i32 = this.MoveMatrixUnit[index1];
            if (index2 > -1 && this.game.Data.UnitObj[index2].X == coordinate.x & this.game.Data.UnitObj[index2].Y == coordinate.y && this.IsUnitPartOfMarker(index2, x, y) & !this.game.Data.UnitObj[index2].IsHQ && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup & this.game.Data.UnitObj[index2].TempCategory == 1)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ( this.game.HandyFunctionsObj.GetAverageRdn(index2) >= 70.0 * ((1.0 +  Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index2].SupplyIn == 0 && this.game.HandyFunctionsObj.GetLowestAp(index2) >= this.game.HandyFunctionsObj.MoveApCostPreview(index2, coordinate.x, coordinate.y, coordinate.x, coordinate.y, 0, x, y, 0, true).x)
              {
                unitList2.add(index2);
                let mut num: i32 = this.GetUnitPower(index2, true, x, y, tfacing - 1);
                if (adjustedforap)
                {
                  let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(index2);
                  num = lowestAp > 25 ?  Math.Round( num * ( (lowestAp - 25) /  lowestAp)) : 0;
                }
                attackPowerPointsOn += num;
              }
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      if (attackPowerPointsOn > 0)
      {
        this.game.EditObj.OrderX = x;
        this.game.EditObj.OrderY = y;
        this.game.EditObj.TargetX = x;
        this.game.EditObj.TargetY = y;
        this.game.EditObj.TempUnitList = unitList2;
        attackPowerPointsOn =  Math.Round(  Math.Round( ( attackPowerPointsOn * this.game.HandyFunctionsObj.GetConcentricBonus2())) * ( (100 + this.game.HandyFunctionsObj.GetDivBonusForAttack(x, y, 0)) / 100.0));
        let mut num1: i32 = this.game.HandyFunctionsObj.maxAttackStack();
        this.game.EditObj.TargetX = -1;
        this.game.EditObj.TargetY = -1;
        num2: i32;
        let mut num3: i32 = num2 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
        if (num3 > num1)
          attackPowerPointsOn =  Math.Round(0.3 *  attackPowerPointsOn + 0.7 *  attackPowerPointsOn * ( num1 /  num3));
      }
      return attackPowerPointsOn;
    }

    pub Coordinate GetRealLandAttackStackOn(x: i32, y: i32, bool adjustedforap = false)
    {
      UnitList unitList1 = UnitList::new();
      let mut num1: i32 = 0;
      UnitList unitList2 = UnitList::new();
      let mut tfacing: i32 = 1;
      Coordinate landAttackStackOn;
      num2: i32;
      do
      {
        landAttackStackOn = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (landAttackStackOn.onmap)
        {
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut index: i32 = 0; index <= unitCounter; index += 1)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == landAttackStackOn.x & this.game.Data.UnitObj[index].Y == landAttackStackOn.y && this.game.Data.UnitObj[index].TempSlot > -1 && this.IsUnitPartOfMarker(index, x, y) & !this.game.Data.UnitObj[index].IsHQ && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & this.game.Data.UnitObj[index].TempCategory == 1)
            {
              float val2 = this.game.Data.RegimeObj[this.GetGameDataTurn()].AIConservative;
              if ( this.game.Data.RuleVar[813] == 0.0 |  this.game.Data.RuleVar[813] == 2.0)
                val2 = 1f;
              if ( this.game.HandyFunctionsObj.GetAverageRdn(index) >= 70.0 * ((1.0 +  Math.Min(1f, val2)) / 2.0) | this.game.Data.UnitObj[index].SupplyIn == 0 && this.game.HandyFunctionsObj.GetLowestAp(index) >= this.game.HandyFunctionsObj.MoveApCostPreview(index, landAttackStackOn.x, landAttackStackOn.y, landAttackStackOn.x, landAttackStackOn.y, 0, x, y, 0, true).x)
              {
                unitList2.add(index);
                let mut num3: i32 = this.GetUnitPower(index, true, x, y, tfacing - 1);
                num2 += this.game.HandyFunctionsObj.GetUnitStackPts(index);
                if (adjustedforap)
                {
                  let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(index);
                  num3 = lowestAp > 10 ?  Math.Round( num3 * ( (lowestAp - 10) /  lowestAp)) : 0;
                }
                num1 += num3;
              }
            }
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      this.game.EditObj.TargetX = x;
      this.game.EditObj.TargetY = y;
      this.game.EditObj.TempUnitList = unitList2;
      let mut num4: i32 = this.game.HandyFunctionsObj.maxAttackStackPrognosis();
      let mut num5: i32 = num2 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStack(this.game.Data.Turn);
      landAttackStackOn.x = num5;
      landAttackStackOn.y = num4;
      return landAttackStackOn;
    }

    pub GetPrognosedLandArtAttackPowerPointsOn: i32(
      x: i32,
      y: i32,
      bool AdjustedForAp = false,
      bool FullAp = false,
      bool ForContainment = false)
    {
      UnitList unitList = UnitList::new();
      Coordinate target;
      target.onmap = true;
      target.x = x;
      target.y = y;
      let mut attackPowerPointsOn: i32 = 0;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
        this.ptempb[index] = false;
      let mut tfacing1: i32 = 1;
      num1: i32;
      do
      {
        Coordinate coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing1);
        if (coordinate1.onmap)
        {
          let mut tfacing2: i32 = 1;
          do
          {
            Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
            if (coordinate2.onmap)
            {
              let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
              for (let mut index1: i32 = 1; index1 <= moveMatrixCounter; index1 += 1)
              {
                let mut index2: i32 = this.MoveMatrixUnit[index1];
                if (index2 > -1 && this.game.Data.UnitObj[index2].TempX == coordinate2.x & this.game.Data.UnitObj[index2].TempY == coordinate2.y | this.game.Data.UnitObj[index2].TempX == coordinate1.x & this.game.Data.UnitObj[index2].TempY == coordinate1.y && !this.ptempb[index2] && this.IsUnitPartOfMarker(index2, x, y) & this.game.Data.UnitObj[index2].TempSlot > -1 & this.game.Data.UnitObj[index2].TempCategory == 2 && this.game.Data.UnitObj[index2].AIGroup == this.OpGroup & this.game.HandyFunctionsObj.CanDoArtAttack(index2, target, true))
                {
                  let mut num2: i32 = FullAp ? this.game.Data.UnitObj[index2].SupplyConsume : this.game.HandyFunctionsObj.GetLowestlandartAp(index2, this.game.HandyFunctionsObj.GetMaxArtRange(index2, 0)) - this.MoveMatrix[this.game.Data.UnitObj[index2].TempSlot, coordinate2.x, coordinate2.y];
                  let mut num3: i32 = 10;
                  if (num2 >= num3)
                  {
                    let mut num4: i32 = this.GetUnitPower(index2, true, x, y, IsArtilleryAttack: true);
                    this.ptempb[index2] = true;
                    if (AdjustedForAp)
                      num4 =  Math.Round( num4 * ( num2 / 100.0));
                    attackPowerPointsOn += num4;
                    unitList.add(index2);
                    num1 += this.game.HandyFunctionsObj.GetUnitartStackPts(index2);
                  }
                }
              }
            }
            tfacing2 += 1;
          }
          while (tfacing2 <= 6);
        }
        tfacing1 += 1;
      }
      while (tfacing1 <= 6);
      let mut num5: i32 =  Math.Round( this.GetCurrentDefendingPowerPointsOn(x, y) / 2.0);
      if (attackPowerPointsOn > 0 & num1 > 0 &  this.game.Data.RuleVar[834] > 0.0)
      {
        let mut num6: i32 =  Math.Round( this.game.Data.RuleVar[834]);
        let mut num7: i32 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStackArt(this.game.Data.Turn);
        if (num7 > num6)
          attackPowerPointsOn =  Math.Round(0.3 *  attackPowerPointsOn + 0.7 *  attackPowerPointsOn * ( num6 /  num7));
      }
      this.game.EditObj.TempUnitList = unitList;
      return attackPowerPointsOn;
    }

    pub fn GetRealLandArtAttackPowerPointsOn(x: i32, y: i32, bool adjustedforap = false) -> i32
    {
      UnitList unitList = UnitList::new();
      bool[] flagArray = new bool[this.game.Data.UnitCounter + 1];
      let mut tfacing1: i32 = 1;
      num1: i32;
      attackPowerPointsOn: i32;
      do
      {
        Coordinate coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing1);
        if (coordinate1.onmap)
        {
          let mut tfacing2: i32 = 1;
          do
          {
            Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
            if (coordinate2.onmap)
            {
              let mut unitCounter: i32 = this.game.Data.UnitCounter;
              for (let mut index: i32 = 0; index <= unitCounter; index += 1)
              {
                if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == coordinate2.x & this.game.Data.UnitObj[index].Y == coordinate2.y && this.game.Data.UnitObj[index].TempSlot > -1 & this.game.Data.UnitObj[index].TempCategory == 2 && this.IsUnitPartOfMarker(index, x, y) & !flagArray[index] && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.HandyFunctionsObj.GetLowestAp(index) >= 10 & this.game.HandyFunctionsObj.Distance(x, y, 0, coordinate2.x, coordinate2.y, 0) <= 2)
                {
                  let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(index);
                  let mut num2: i32 = 10;
                  if (lowestAp >= num2)
                  {
                    flagArray[index] = true;
                    let mut num3: i32 = this.GetUnitPower(index, true, x, y, IsArtilleryAttack: true);
                    num1 += this.game.HandyFunctionsObj.GetUnitartStackPts(index);
                    if (adjustedforap)
                      num3 =  Math.Round( num3 * ( lowestAp / 100.0));
                    attackPowerPointsOn += num3;
                    unitList.add(index);
                  }
                }
              }
            }
            tfacing2 += 1;
          }
          while (tfacing2 <= 6);
        }
        tfacing1 += 1;
      }
      while (tfacing1 <= 6);
      let mut num4: i32 =  Math.Round( this.GetCurrentDefendingPowerPointsOn(x, y) / 2.0);
      if (attackPowerPointsOn > 0 & num1 > 0 &  this.game.Data.RuleVar[834] > 0.0)
      {
        let mut num5: i32 =  Math.Round( this.game.Data.RuleVar[834]);
        let mut num6: i32 = num1 + this.game.Data.MapObj[0].HexObj[x, y].get_BattleStackArt(this.game.Data.Turn);
        if (num6 > num5)
          attackPowerPointsOn =  Math.Round(0.3 *  attackPowerPointsOn + 0.7 *  attackPowerPointsOn * ( num5 /  num6));
      }
      this.game.EditObj.TempUnitList = unitList;
      return attackPowerPointsOn;
    }

    pub fn JoinUnitsInLandAttack(x: i32, y: i32,  UnitList TempUnitList) -> i32
    {
      let mut tfacing: i32 = 1;
      do
      {
        Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing);
        if (coordinate.onmap)
        {
          let mut unitCounter: i32 = this.game.Data.UnitCounter;
          for (let mut index: i32 = 0; index <= unitCounter; index += 1)
          {
            if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == coordinate.x & this.game.Data.UnitObj[index].Y == coordinate.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.Data.UnitObj[index].TempCategory == 1 && this.game.HandyFunctionsObj.GetLowestAp(index) >= this.game.HandyFunctionsObj.MoveApCostPreview(index, coordinate.x, coordinate.y, coordinate.x, coordinate.y, 0, x, y, 0, true).x)
              TempUnitList.add(index);
          }
        }
        tfacing += 1;
      }
      while (tfacing <= 6);
      num: i32;
      return num;
    }

    pub fn JoinUnitsArtilleryAttack(x: i32, y: i32,  UnitList TempUnitList) -> i32
    {
      let mut tfacing1: i32 = 1;
      do
      {
        Coordinate coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(x, y, 0, tfacing1);
        if (coordinate1.onmap)
        {
          let mut tfacing2: i32 = 1;
          do
          {
            Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
            if (coordinate2.onmap)
            {
              let mut unitCounter: i32 = this.game.Data.UnitCounter;
              for (let mut index: i32 = 0; index <= unitCounter; index += 1)
              {
                if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].X == coordinate2.x & this.game.Data.UnitObj[index].Y == coordinate2.y && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.Data.UnitObj[index].TempCategory == 2 && this.game.HandyFunctionsObj.GetLowestAp(index) >= 10 & this.game.HandyFunctionsObj.Distance(coordinate1.x, coordinate1.y, 0, x, y, 0) <= 2 && !TempUnitList.CheckIfPresent(index))
                  TempUnitList.add(index);
              }
            }
            tfacing2 += 1;
          }
          while (tfacing2 <= 6);
        }
        tfacing1 += 1;
      }
      while (tfacing1 <= 6);
      num: i32;
      return num;
    }

    pub fn JoinUnitsAirAttack(x: i32, y: i32,  UnitList TempUnitList) -> i32
    {
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.IsUnitPartOfMarker(index, x, y) & this.game.Data.UnitObj[index].TempSlot > -1 && this.game.Data.UnitObj[index].AIGroup == this.OpGroup && this.game.Data.UnitObj[index].TempCategory == 3 && this.game.HandyFunctionsObj.GetLowestAirAp(index) >= this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y, 0, x, y, 0) * this.GetSlowestAirSpeed(index) && !TempUnitList.CheckIfPresent(index))
          TempUnitList.add(index);
      }
      num: i32;
      return num;
    }

    pub IsUnitPartOfMarker: bool(unr: i32, x: i32, y: i32)
    {
      if (this.game.Data.UnitObj[unr].Regime != this.game.Data.Turn)
        return false;
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      for (let mut index: i32 = 1; index <= moveMatrixCounter; index += 1)
      {
        if (this.MoveMatrixUnit[index] == unr && this.MoveMatrixUnitMarker[index] > -1)
        {
          if (this.game.Data.UnitObj[unr].TempCategory == 1)
          {
            if (this.MoveMatrixUnitMarker[index] > this.MarkerList.Counter)
              return false;
            if (this.MarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.MarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
              return true;
          }
          else if (this.game.Data.UnitObj[unr].TempCategory == 2 | this.game.Data.UnitObj[unr].TempCategory == 5)
          {
            if (this.MoveMatrixUnitMarker[index] > this.ArtMarkerList.Counter)
              return false;
            if (this.ArtMarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.ArtMarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
              return true;
          }
          else if (this.game.Data.UnitObj[unr].TempCategory == 3)
          {
            if (this.MoveMatrixUnitMarker[index] > this.AirMarkerList.Counter)
              return false;
            if (this.AirMarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.AirMarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
              return true;
          }
          else if (this.game.Data.UnitObj[unr].TempCategory == 4)
          {
            if (this.EngineerMarkerList.Counter > -1)
            {
              if (this.MoveMatrixUnitMarker[index] > this.EngineerMarkerList.Counter)
                return false;
              if (this.EngineerMarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.EngineerMarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
                return true;
            }
            else
            {
              if (this.MoveMatrixUnitMarker[index] > this.MarkerList.Counter)
                return false;
              if (this.MarkerList.Data3[this.MoveMatrixUnitMarker[index]] == x && this.MarkerList.Data4[this.MoveMatrixUnitMarker[index]] == y)
                return true;
            }
          }
        }
      }
      return false;
    }

    pub Coordinate MarkerHasCoord(slot: i32)
    {
      Coordinate coordinate;
      coordinate.onmap = false;
      if (slot == -1)
        return coordinate;
      let mut index: i32 = this.MoveMatrixUnit[slot];
      if (this.MoveMatrixUnitMarker[slot] > -1)
      {
        if (this.game.Data.UnitObj[index].TempCategory == 1)
        {
          coordinate.x = this.MarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.MarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
        if (this.game.Data.UnitObj[index].TempCategory == 2 | this.game.Data.UnitObj[index].TempCategory == 5)
        {
          coordinate.x = this.ArtMarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.ArtMarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
        if (this.game.Data.UnitObj[index].TempCategory == 3)
        {
          coordinate.x = this.AirMarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.AirMarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
        if (this.game.Data.UnitObj[index].TempCategory == 4)
        {
          if (this.EngineerMarkerList.Counter > -1)
          {
            coordinate.x = this.EngineerMarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
            coordinate.y = this.EngineerMarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
            coordinate.onmap = true;
            return coordinate;
          }
          coordinate.x = this.MarkerList.Data1[this.MoveMatrixUnitMarker[slot]];
          coordinate.y = this.MarkerList.Data2[this.MoveMatrixUnitMarker[slot]];
          coordinate.onmap = true;
          return coordinate;
        }
      }
      coordinate.onmap = false;
      return coordinate;
    }

    pub fn MakeMoveMatrix(bool OnlyOutside, bool OnlyInside)
    {
      let mut Slot: i32 = 0;
      let mut upperBound: i32 = this.MoveMatrixUnit.GetUpperBound(0);
      this.MoveMatrixCounter = 0;
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut unr1: i32 = 0; unr1 <= unitCounter; unr1 += 1)
      {
        if (this.game.Data.UnitObj[unr1].PreDef == -1 && this.game.Data.UnitObj[unr1].AIGroup == this.OpGroup & this.game.Data.UnitObj[unr1].Regime == this.game.Data.Turn & this.game.Data.UnitObj[unr1].X > -1)
        {
          let mut num: i32 = 1;
          if (OnlyInside)
            num = 0;
          if (this.game.Data.UnitObj[unr1].AIAttack == -1 & this.game.Data.UnitObj[unr1].AIDefend > -1 && this.AreaMatrixNarrow[this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y] == this.game.Data.UnitObj[unr1].AIDefend)
          {
            num = 0;
            if (!OnlyOutside)
              num = 1;
          }
          if (num == 1 && Slot < upperBound)
          {
            Slot += 1;
            this += 1.MoveMatrixCounter;
            this.MoveMatrixUnit[Slot] = unr1;
            this.game.Data.UnitObj[unr1].TempSlot = Slot;
            this.MoveMatrixUnitMarker[Slot] = -1;
            if (this.game.Data.UnitObj[unr1].IsHQ)
              unr1 = unr1;
            Coordinate closeFriendlyRoadHex;
            if (this.game.Data.UnitObj[unr1].TempStrategic)
              closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[unr1].X, this.game.Data.UnitObj[unr1].Y, 4);
            this.MoveMatrixCloseRoad[Slot] = closeFriendlyRoadHex;
            handyFunctionsObj: HandyFunctionsclass = this.game.HandyFunctionsObj;
            let mut unr2: i32 = unr1;
            let mut x: i32 = this.game.Data.UnitObj[unr1].X;
            let mut y: i32 = this.game.Data.UnitObj[unr1].Y;
            CustomDC2AICalls customDc2AiCalls = (CustomDC2AICalls) null;
             CustomDC2AICalls local =  customDc2AiCalls;
            handyFunctionsObj.MakeMovePrediction3(unr2, x, y, 0, ismove: true, tcustomAi: ( local));
            let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
            for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
            {
              let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
              for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
              {
                this.MoveMatrix[Slot, index1, index2] = this.game.EditObj.TempValue[0].Value[index1, index2];
                this.MoveMatrixCameFrom[Slot, index1, index2].x = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].x;
                this.MoveMatrixCameFrom[Slot, index1, index2].y = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].y;
                this.MoveMatrixCameFrom[Slot, index1, index2].map = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].map;
                this.MoveMatrixCameFrom[Slot, index1, index2].onmap = this.game.EditObj.TempCameFrom[0].Value[index1, index2].onmap;
                if (this.game.EditObj.TempCameFrom[0].Value[index1, index2].onmap)
                  index1 = index1;
              }
            }
            if (!this.game.HandyFunctionsObj.HasUnitAirSF(unr1))
              this.CompleteMoveMatrix(Slot);
          }
        }
      }
    }

    pub fn MakeEnemyMoveMatrix()
    {
      this.EnemyMatrixUnit.GetUpperBound(0);
      this.EnemyMatrixCounter = 0;
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[index].Regime) != this.GetGameDataTurn())
        {
          this.game.Data.UnitObj[index].TempSlot = -1;
          this.game.Data.UnitObj[index].TempX = -1;
          this.game.Data.UnitObj[index].TempY = -1;
        }
      }
      if (this.GroupType[this.OpGroup] >= 5 & this.MoveMatrixCounter <= 1)
        this.SetEnemyMatrixUnits(4);
      else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 250)
        this.SetEnemyMatrixUnits(16);
      else if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus >= 100)
        this.SetEnemyMatrixUnits(10);
      else
        this.SetEnemyMatrixUnits(8);
      let mut unitCounter2: i32 = this.game.Data.UnitCounter;
      for (let mut unr1: i32 = 0; unr1 <= unitCounter2; unr1 += 1)
      {
        if (this.game.Data.UnitObj[unr1].PreDef == -1 && this.GetRegime(this.game.Data.UnitObj[unr1].Regime) != this.GetGameDataTurn() && this.game.Data.UnitObj[unr1].TempSlot > -1)
        {
          let mut tempSlot: i32 = this.game.Data.UnitObj[unr1].TempSlot;
          let mut sfCount: i32 = this.game.Data.UnitObj[unr1].SFCount;
          for (let mut index: i32 = 0; index <= sfCount; index += 1)
            this.game.Data.SFObj[this.game.Data.UnitObj[unr1].SFList[index]].Ap = 0;
          handyFunctionsObj1: HandyFunctionsclass = this.game.HandyFunctionsObj;
          let mut unr2: i32 = unr1;
          let mut x1: i32 = this.game.Data.UnitObj[unr1].X;
          let mut y1: i32 = this.game.Data.UnitObj[unr1].Y;
          let mut increaseap1: i32 = Math.Min(this.game.Data.UnitObj[unr1].SupplyConsume, this.game.HandyFunctionsObj.GetAverageRdn(unr1));
          CustomDC2AICalls customDc2AiCalls1 = (CustomDC2AICalls) null;
           CustomDC2AICalls local1 =  customDc2AiCalls1;
          handyFunctionsObj1.MakeMovePrediction3(unr2, x1, y1, 0, attack: true, increaseap: increaseap1, gothroughenemy: 999999, tcustomAi: ( local1));
          let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
            {
              this.EnemyMatrix[tempSlot, index1, index2] = this.game.EditObj.TempValue[0].Value[index1, index2];
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].x = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].x;
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].y = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].y;
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].map = (byte) this.game.EditObj.TempCameFrom[0].Value[index1, index2].map;
              this.EnemyMatrixCameFrom[tempSlot, index1, index2].onmap = this.game.EditObj.TempCameFrom[0].Value[index1, index2].onmap;
            }
          }
          this.CompleteEnemyMoveMatrix(tempSlot);
          handyFunctionsObj2: HandyFunctionsclass = this.game.HandyFunctionsObj;
          let mut unr3: i32 = unr1;
          let mut x2: i32 = this.game.Data.UnitObj[unr1].X;
          let mut y2: i32 = this.game.Data.UnitObj[unr1].Y;
          let mut increaseap2: i32 = Math.Min(this.game.Data.UnitObj[unr1].SupplyConsume, this.game.HandyFunctionsObj.GetAverageRdn(unr1));
          CustomDC2AICalls customDc2AiCalls2 = (CustomDC2AICalls) null;
           CustomDC2AICalls local2 =  customDc2AiCalls2;
          handyFunctionsObj2.MakeMovePrediction3(unr3, x2, y2, 0, attack: true, increaseap: increaseap2, gothroughenemy: 999999, ExtraForEnemyHex: 15, tcustomAi: ( local2));
          let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut index3: i32 = 0; index3 <= mapWidth2; index3 += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
            {
              this.EnemyMatrix2[tempSlot, index3, index4] = this.game.EditObj.TempValue[0].Value[index3, index4];
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].x = (byte) this.game.EditObj.TempCameFrom[0].Value[index3, index4].x;
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].y = (byte) this.game.EditObj.TempCameFrom[0].Value[index3, index4].y;
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].map = (byte) this.game.EditObj.TempCameFrom[0].Value[index3, index4].map;
              this.EnemyMatrix2CameFrom[tempSlot, index3, index4].onmap = this.game.EditObj.TempCameFrom[0].Value[index3, index4].onmap;
            }
          }
        }
      }
    }

    pub SetEnemyMatrixUnits: bool(dist: i32)
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      int[] numArray2 = new int[100];
      let mut upperBound: i32 = this.EnemyMatrixUnit.GetUpperBound(0);
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
          numArray1[index1, index2] = -1;
      }
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 & this.game.Data.UnitObj[index].X > -1 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].AIGroup == this.OpGroup & (this.game.Data.UnitObj[index].IsHQ | this.tArea[this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y] > 0))
          numArray1[this.game.Data.UnitObj[index].X, this.game.Data.UnitObj[index].Y] = 0;
      }
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      if (groupHq == -1)
        return true;
      if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
        numArray1[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y] = 0;
      if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
        numArray1[this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x, this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y] = 0;
      let mut num1: i32 = 1;
      let mut num2: i32 = -1;
      while (num1 >= 0 & num2 < dist)
      {
        --num1;
        num2 += 1;
        let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (numArray1[cx, cy] == num2)
            {
              let mut tfacing: i32 = 1;
              do
              {
                Coordinate coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && numArray1[coordinate.x, coordinate.y] == -1)
                {
                  numArray1[coordinate.x, coordinate.y] = this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] <= -1 ? num2 + 1 : num2 + 1;
                  num1 = 1;
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
      let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index3: i32 = 0; index3 <= mapWidth3; index3 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
        {
          if (numArray1[index3, index4] > 0)
          {
            let mut unitCounter2: i32 = this.game.Data.MapObj[0].HexObj[index3, index4].UnitCounter;
            for (let mut index5: i32 = 0; index5 <= unitCounter2; index5 += 1)
            {
              let mut unit: i32 = this.game.Data.MapObj[0].HexObj[index3, index4].UnitList[index5];
              if (this.GetRegime(this.game.Data.UnitObj[unit].Regime) != this.GetGameDataTurn() & !this.game.HandyFunctionsObj.HasUnitAirSF(unit) && this.EnemyMatrixCounter < upperBound & this.game.Data.UnitObj[unit].TempType > -1)
              {
                if (this.game.Data.UnitObj[unit].IsVirtual)
                  this.MakeTempMovementType(unit);
                let mut num3: i32 = this.game.Data.LandscapeTypeObj[ Math.Round( this.game.Data.RuleVar[38])].MoveCost[this.game.Data.SFTypeObj[this.game.Data.UnitObj[unit].TempType].MoveType];
                let mut num4: i32 =  Math.Round(60.0 +  (dist * 5) /  num3);
                if (numArray1[index3, index4] <= num4)
                {
                  this += 1.EnemyMatrixCounter;
                  this.EnemyMatrixUnit[this.EnemyMatrixCounter] = unit;
                  this.game.Data.UnitObj[unit].TempSlot = this.EnemyMatrixCounter;
                }
              }
            }
          }
        }
      }
      bool flag;
      return flag;
    }

    pub fn CompleteMoveMatrix(Slot: i32)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth1; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          if (this.MoveMatrix[Slot, index1, index2] < 9999)
            numArray[index1, index2] = 1;
        }
      }
      let mut index: i32 = this.MoveMatrixUnit[Slot];
      let mut num1: i32 = 30;
      Math.Max(this.game.Data.UnitObj[index].X - num1, this.CMS1.x);
      Math.Min(this.game.Data.UnitObj[index].X + num1, this.CMS2.x);
      Math.Max(this.game.Data.UnitObj[index].Y - num1, this.CMS1.y);
      Math.Min(this.game.Data.UnitObj[index].Y + num1, this.CMS2.y);
      let mut num2: i32 = 1;
      while (num2 == 1)
      {
        num2 = 0;
        num3: i32;
        num3 += 1;
        let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            Coordinate coordinate1;
            coordinate1.x = cx;
            coordinate1.y = cy;
            coordinate1.map = 0;
            coordinate1.onmap = true;
            if (numArray[cx, cy] == num3)
            {
              let mut tfacing: i32 = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate2.onmap)
                {
                  num4: i32;
                  if (this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime), this.GetGameDataTurn()))
                    num4 = this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] <= -1 ? (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType != 6 ? (!this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea ? Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 20) : 9999) : Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 100)) : Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 5);
                  else if (this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime))
                  {
                    if (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].UnitCounter > -1)
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 125);
                    else if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea)
                      num4 = 9999;
                    else if (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] > -1)
                    {
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 33);
                      if (num4 > 300 & this.FullAdvanceMatrix[cx, cy] == 0 & this.TscoreMatrix[cx, cy] <= 0)
                        num4 = 9999;
                    }
                    else if (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType == 6)
                    {
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 100);
                      if (num4 > 300 & this.FullAdvanceMatrix[cx, cy] == 0 & this.TscoreMatrix[cx, cy] <= 0)
                        num4 = 9999;
                    }
                    else
                    {
                      num4 = Math.Max(105, this.MoveMatrix[Slot, cx, cy] + 50);
                      if (num4 > 300 & this.FullAdvanceMatrix[cx, cy] == 0 & this.TscoreMatrix[cx, cy] <= 0)
                        num4 = 9999;
                    }
                  }
                  else
                    num4 = 9999;
                  if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Bridge[tfacing - 1])
                    num4 += 140;
                  if (num4 < this.MoveMatrix[Slot, coordinate2.x, coordinate2.y] & num4 < 9999)
                  {
                    this.MoveMatrix[Slot, coordinate2.x, coordinate2.y] = num4;
                    this.MoveMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].x = (byte) coordinate1.x;
                    this.MoveMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].y = (byte) coordinate1.y;
                    this.MoveMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].onmap = coordinate1.onmap;
                    num2 = 1;
                    numArray[coordinate2.x, coordinate2.y] = num3 + 1;
                  }
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
    }

    pub fn CompleteEnemyMoveMatrix(Slot: i32)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          if (this.EnemyMatrix[Slot, index1, index2] < 9999)
            numArray[index1, index2] = 1;
        }
      }
      let mut index: i32 = this.EnemyMatrixUnit[Slot];
      let mut num1: i32 = 10;
      let mut num2: i32 = Math.Max(this.game.Data.UnitObj[index].X - num1, 0);
      let mut num3: i32 = Math.Min(this.game.Data.UnitObj[index].X + num1, this.game.Data.MapObj[0].MapWidth);
      let mut num4: i32 = Math.Max(this.game.Data.UnitObj[index].Y - num1, 0);
      let mut num5: i32 = Math.Min(this.game.Data.UnitObj[index].Y + num1, this.game.Data.MapObj[0].MapHeight);
      let mut num6: i32 = 1;
      while (num6 == 1)
      {
        num6 = 0;
        num7: i32;
        num7 += 1;
        let mut num8: i32 = num2;
        let mut num9: i32 = num3;
        for (let mut cx: i32 = num8; cx <= num9; cx += 1)
        {
          let mut num10: i32 = num4;
          let mut num11: i32 = num5;
          for (let mut cy: i32 = num10; cy <= num11; cy += 1)
          {
            Coordinate coordinate1;
            coordinate1.x = cx;
            coordinate1.y = cy;
            coordinate1.map = 0;
            coordinate1.onmap = true;
            if (numArray[cx, cy] == num7)
            {
              let mut tfacing: i32 = 1;
              do
              {
                Coordinate coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate2.onmap)
                {
                  let mut num12: i32 = !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea ? (this.game.Data.MapObj[0].HexObj[cx, cy].RoadType[tfacing - 1] <= -1 ? (this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType != 6 ? Math.Max(105, this.EnemyMatrix[Slot, cx, cy] + 40) : Math.Max(105, this.EnemyMatrix[Slot, cx, cy] + 100)) : Math.Max(105, this.EnemyMatrix[Slot, cx, cy] + 25)) : 9999;
                  if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].RiverType[tfacing - 1] > -1 & !this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Bridge[tfacing - 1])
                    num12 += 40;
                  if (num12 < this.EnemyMatrix[Slot, coordinate2.x, coordinate2.y] & num12 < 9999)
                  {
                    this.EnemyMatrix[Slot, coordinate2.x, coordinate2.y] = num12;
                    this.EnemyMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].x = (byte) coordinate1.x;
                    this.EnemyMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].y = (byte) coordinate1.y;
                    this.EnemyMatrixCameFrom[Slot, coordinate2.x, coordinate2.y].onmap = coordinate1.onmap;
                    num6 = 1;
                    numArray[coordinate2.x, coordinate2.y] = num7 + 1;
                  }
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
      }
    }

    pub fn SetTArea()
    {
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      this.DistToTArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.DistFromTArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.FrontlineArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.EnemyFrontlineArea = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.DistFromFrontline = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      this.FrontlineCount = 0;
      let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
      Coordinate coordinate;
      for (let mut cx: i32 = 0; cx <= mapWidth1; cx += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
        {
          this.tArea[cx, cy] = 0;
          this.DistToTArea[cx, cy] = 9999;
          this.DistFromFrontline[cx, cy] = 9999;
          if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIAttack)
          {
            this.tArea[cx, cy] = 1;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIDefend)
          {
            this.tArea[cx, cy] = 2;
            this.DistToTArea[cx, cy] = 0;
            let mut num: i32 = 0;
            let mut tfacing: i32 = 1;
            do
            {
              coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate.onmap && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Regime, this.game.Data.Turn) && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
              {
                num += 1;
                this.EnemyFrontlineArea[coordinate.x, coordinate.y] = 1;
              }
              tfacing += 1;
            }
            while (tfacing <= 6);
            if (num > 0 & num <= 3)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                this += 1.FrontlineCount;
              this.FrontlineArea[cx, cy] = 1;
              this.DistFromFrontline[cx, cy] = 0;
            }
            else if (num >= 4)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                this += 1.FrontlineCount;
              this.FrontlineArea[cx, cy] = 2;
              this.DistFromFrontline[cx, cy] = 0;
            }
          }
          else if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIFollowup)
          {
            this.tArea[cx, cy] = 5;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixNarrow[cx, cy] == this.game.Data.UnitObj[groupHq].AIFallback)
          {
            this.tArea[cx, cy] = 6;
            this.DistToTArea[cx, cy] = 0;
            let mut num: i32 = 0;
            let mut tfacing: i32 = 1;
            do
            {
              coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
              if (coordinate.onmap && this.AreaMatrixNarrow[coordinate.x, coordinate.y] == this.game.Data.UnitObj[groupHq].AIAttack && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].LandscapeType].IsSea)
                num += 1;
              tfacing += 1;
            }
            while (tfacing <= 6);
            if (num > 0 & num <= 3)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                this += 1.FrontlineCount;
              this.FrontlineArea[cx, cy] = 1;
              this.DistFromFrontline[cx, cy] = 0;
            }
            else if (num >= 4)
            {
              if (this.FrontlineArea[cx, cy] == 0)
                this += 1.FrontlineCount;
              this.FrontlineArea[cx, cy] = 2;
              this.DistFromFrontline[cx, cy] = 0;
            }
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIAttack)
          {
            this.tArea[cx, cy] = 1;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIDefend)
          {
            this.tArea[cx, cy] = 2;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIFollowup)
          {
            this.tArea[cx, cy] = 5;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.AreaMatrixWide[cx, cy] == this.game.Data.UnitObj[groupHq].AIFallback)
          {
            this.tArea[cx, cy] = 6;
            this.DistToTArea[cx, cy] = 0;
          }
          else if (this.SupplyMatrix[cx, cy] == this.OpGroup)
          {
            this.tArea[cx, cy] = 3;
            this.DistToTArea[cx, cy] = 0;
          }
        }
      }
      let mut num1: i32 = 0;
      do
      {
        let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth2; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (this.DistToTArea[cx, cy] == num1)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.DistToTArea[coordinate.x, coordinate.y] > num1)
                {
                  this.DistToTArea[coordinate.x, coordinate.y] = num1 + 1;
                  this.DistFromTArea[coordinate.x, coordinate.y] = num1 <= 0 ? this.tArea[cx, cy] : this.DistFromTArea[cx, cy];
                }
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
        num1 += 1;
      }
      while (num1 <= 9);
      let mut num2: i32 = 0;
      do
      {
        let mut mapWidth3: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut cx: i32 = 0; cx <= mapWidth3; cx += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut cy: i32 = 0; cy <= mapHeight; cy += 1)
          {
            if (this.DistFromFrontline[cx, cy] == num2)
            {
              let mut tfacing: i32 = 1;
              do
              {
                coordinate = this.game.HandyFunctionsObj.HexNeighbour(cx, cy, 0, tfacing);
                if (coordinate.onmap && this.DistFromFrontline[coordinate.x, coordinate.y] > num2)
                  this.DistFromFrontline[coordinate.x, coordinate.y] = num2 + 1;
                tfacing += 1;
              }
              while (tfacing <= 6);
            }
          }
        }
        num2 += 1;
      }
      while (num2 <= 9);
    }

    pub fn GetLoseHexScore(ix: i32, iy: i32) -> i32 => 0;

    pub fn GetTscore(ix: i32, iy: i32, let mut j: i32 = -1, bool IsCounterAttack = false, bool MakeLog = false) -> i32
    {
      let mut tscore: i32 = !IsCounterAttack ? this.TscoreMatrix[ix, iy] : this.TscoreCounterMatrix[ix, iy];
      if (j > -1 && this.game.Data.MapObj[0].HexObj[ix, iy].RiverType[j] > -1)
        tscore =  Math.Round( tscore * 0.25);
      return tscore;
    }

    pub fn GetTScore2(ix: i32, iy: i32, bool IsCounterAttack = false, bool MakeLog = false) -> i32
    {
      let mut index1: i32 = this.TempGroupHQ[this.OpGroup];
      let mut Number: i32 = 0;
      if (this.game.Data.UnitObj[index1].AIAttackStyle == 3 | this.game.Data.UnitObj[index1].AIAttackStyle == 2)
      {
        if (this.FrontlineArea[ix, iy] > 0)
          ix = ix;
        if (this.tArea[ix, iy] == 1)
          Number = 100;
        if (this.tArea[ix, iy] == 5)
          Number = !IsCounterAttack ? 50 : 100;
        if (this.tArea[ix, iy] == 2)
        {
          if (this.game.Data.UnitObj[index1].AIDefend > -1)
            Number = !IsCounterAttack ? 50 : 150;
          if (this.MoveMatrixCounter > 0 & this.FrontlineCount > 0 && this.FrontlineArea[ix, iy] == 1)
            Number +=  Math.Round( Number * ( this.MoveMatrixCounter /  this.FrontlineCount));
        }
        if (this.tArea[ix, iy] == 6)
          Number = !IsCounterAttack ? 35 : 225;
        if (this.tArea[ix, iy] == 3)
          Number =  Math.Round(50.0 /  (this.SupplyMatrixDistance[ix, iy] + 1));
        if (this.AdvanceAxisMatrix[ix, iy] > 0 & Number < 100)
          Number = 100;
        if (this.tArea[ix, iy] == 0 & this.DistToTArea[ix, iy] < 10 & this.DistToTArea[ix, iy] > 0 && !IsCounterAttack)
        {
          if (this.DistFromTArea[ix, iy] == 1)
            Number =  Math.Round(100.0 /  this.DistToTArea[ix, iy]);
          if (this.DistFromTArea[ix, iy] == 5)
            Number =  Math.Round(50.0 /  this.DistToTArea[ix, iy]);
          if (this.DistFromTArea[ix, iy] == 2)
            Number =  Math.Round(50.0 /  this.DistToTArea[ix, iy]);
        }
      }
      else if (this.game.Data.UnitObj[index1].AIAttackStyle == 1)
      {
        if (this.tArea[ix, iy] == 2)
          Number = 50;
        if (this.tArea[ix, iy] == 6)
          Number = 20;
        if (this.game.Data.UnitObj[index1].AIDefend > -1 & this.game.Data.UnitObj[index1].AIDefend <= this.AreaCount && this.AreaCenter[this.game.Data.UnitObj[index1].AIDefend].x == ix && this.AreaCenter[this.game.Data.UnitObj[index1].AIDefend].y == iy)
          Number = 100;
        if (this.tArea[ix, iy] == 3)
          Number =  Math.Round(24.0 /  (this.SupplyMatrixDistance[ix, iy] + 1));
        if (this.tArea[ix, iy] == 0 & this.DistToTArea[ix, iy] < 10 & this.DistToTArea[ix, iy] > 0 && !IsCounterAttack)
        {
          if (this.DistFromTArea[ix, iy] == 6)
            Number =  Math.Round(20.0 /  this.DistToTArea[ix, iy]);
          if (this.DistFromTArea[ix, iy] == 2)
            Number =  Math.Round(50.0 /  this.DistToTArea[ix, iy]);
        }
      }
      if (Number > 0)
      {
        Coordinate coordinate;
        if (this.game.Data.UnitObj[index1].AIAttackStyle == 1 & this.tArea[ix, iy] == 2)
        {
          let mut num1: i32 = 0;
          let mut num2: i32 = 0;
          let mut index2: i32 = 0;
          do
          {
            if (this.game.Data.MapObj[0].HexObj[ix, iy].RoadType[index2] > -1)
              num1 = 1;
            coordinate = this.game.HandyFunctionsObj.HexNeighbour(ix, iy, 0, index2 + 1);
            if (coordinate.onmap)
            {
              let mut num3: i32 = 0;
              do
              {
                if (this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].RoadType[index2] > -1)
                  num2 = 1;
                num3 += 1;
              }
              while (num3 <= 5);
            }
            index2 += 1;
          }
          while (index2 <= 5);
          if (num1 == 1)
          {
            if (Number < 50)
              Number = 50;
            Number =  Math.Round( Number * 1.5);
          }
          else if (num2 == 1)
          {
            if (Number < 25)
              Number = 25;
            Number =  Math.Round( Number * 1.25);
          }
        }
        if (this.game.Data.MapObj[0].HexObj[ix, iy].Location > -1 | this.game.HandyFunctionsObj.HasHexBridge(ix, iy, 0))
        {
          Number =  Math.Round( Number * 1.5);
          if (IsCounterAttack)
            Number =  Math.Round( Number * 2.5);
        }
        else
        {
          let mut num4: i32 = 0;
          do
          {
            coordinate = this.game.HandyFunctionsObj.HexNeighbour(ix, iy, 0, num4 + 1);
            if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].Location > -1)
            {
              let mut num5: i32 =  Math.Round( Number * 1.25);
              let mut num6: i32 = this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[coordinate.x, coordinate.y];
              Number = !(num6 > this.AverageVP & num5 > 0) ? num5 * 1 :  Math.Round( num5 * (1.0 +  num6 /  this.AverageVP));
              if (IsCounterAttack)
                Number *= 1;
            }
            num4 += 1;
          }
          while (num4 <= 5);
        }
        if (this.game.Data.MapObj[0].HexObj[ix, iy].Location > -1)
          Number *= 2;
        if (this.game.Data.MapObj[0].HexObj[ix, iy].VP > 0 | this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[ix, iy] > 0)
        {
          let mut num: i32 = this.game.Data.MapObj[0].HexObj[ix, iy].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[ix, iy];
          if (num > this.AverageVP & Number > 0)
            Number =  Math.Round( Number * (2.0 +  num /  this.AverageVP * 2.0));
          else
            Number *= 2;
        }
        let mut aiAttack: i32 = this.game.Data.UnitObj[index1].AIAttack;
        if (aiAttack > -1 & aiAttack <= this.AreaCount && this.AreaCenter[aiAttack].x == ix & this.AreaCenter[aiAttack].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        let mut aiDefend: i32 = this.game.Data.UnitObj[index1].AIDefend;
        if (aiDefend > -1 & aiDefend <= this.AreaCount && this.AreaCenter[aiDefend].x == ix & this.AreaCenter[aiDefend].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        let mut aiFollowup: i32 = this.game.Data.UnitObj[index1].AIFollowup;
        if (aiFollowup > -1 & aiFollowup <= this.AreaCount && this.AreaCenter[aiFollowup].x == ix & this.AreaCenter[aiFollowup].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        let mut aiFallback: i32 = this.game.Data.UnitObj[index1].AIFallback;
        if (aiFallback > -1 & aiFallback <= this.AreaCount && this.AreaCenter[aiFallback].x == ix & this.AreaCenter[aiFallback].y == iy)
          Number = this.game.Data.UnitObj[index1].AIAttackStyle != 1 ? Number * 2 + 1000 : Number * 2 + 200;
        if (this.game.Data.UnitObj[index1].AIAttackStyle == 3)
        {
          if (this.AdvanceAxisMatrix[ix, iy] == 0)
            Number *= 1;
          if (this.AdvanceAxisMatrix[ix, iy] == 1)
            Number *= 2;
          if (this.AdvanceAxisMatrix[ix, iy] == 2)
            Number =  Math.Round( Number * 1.8);
          if (this.AdvanceAxisMatrix[ix, iy] >= 3)
            Number =  Math.Round( Number * 1.6);
        }
        else if (this.game.Data.UnitObj[index1].AIAttackStyle == 2)
        {
          if (this.AdvanceAxisMatrix[ix, iy] == 0)
            Number =  Math.Round( Number * 1.25);
          if (this.AdvanceAxisMatrix[ix, iy] == 1)
            Number *= 4;
          if (this.AdvanceAxisMatrix[ix, iy] == 2)
            Number *= 3;
          if (this.AdvanceAxisMatrix[ix, iy] >= 3)
            Number =  Math.Round( Number * 1.5);
        }
        else if (this.game.Data.UnitObj[index1].AIAttackStyle != 1)
          ;
        if (IsCounterAttack && this.AdvanceAxisMatrix[ix, iy] == 0)
          Number *= 2;
        if ( this.game.Data.RuleVar[53] <  this.SupplyMatrixPrognosisEasyRoads[ix, iy])
          Number = 0;
        else if ( this.game.Data.RuleVar[52] <  this.SupplyMatrixPrognosisEasyRoads[ix, iy])
          Number =  Math.Round( Number * 0.75);
        else if ( this.game.Data.RuleVar[51] <  this.SupplyMatrixPrognosisEasyRoads[ix, iy])
          Number =  Math.Round( Number * 0.5);
      }
      if (MakeLog)
        this.AddLog("Final score = " + Conversion.Str( Number));
      return Number;
    }

    pub fn AddMarkers()
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray3: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray4: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray5: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray6: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      SimpleList simpleList = SimpleList::new();
      this.MarkerList = SimpleList::new();
      this.ArtMarkerList = SimpleList::new();
      this.AirMarkerList = SimpleList::new();
      this.EngineerMarkerList = SimpleList::new();
      Coordinate averageCorpsUnitCoord = this.GetAverageCorpsUnitCoord(this.OpGroup);
      if (this.MoveAndAttackRound != 1)
        ;
      let mut groupHq: i32 = this.GetGroupHQ(this.OpGroup);
      let mut moveMatrixCounter: i32 = this.MoveMatrixCounter;
      num1: i32;
      num2: i32;
      for (let mut index: i32 = 1; index <= moveMatrixCounter; index += 1)
      {
        if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 1)
          numArray4[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 2)
        {
          numArray5[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
          num1 += 1;
        }
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 5)
          numArray5[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
        else if (this.game.Data.UnitObj[this.MoveMatrixUnit[index]].TempCategory == 3)
        {
          numArray6[this.game.Data.UnitObj[this.MoveMatrixUnit[index]].X, this.game.Data.UnitObj[this.MoveMatrixUnit[index]].Y] = 1;
          num2 += 1;
        }
      }
      Coordinate coordinate1;
      tid1: i32;
      tdata5: i32;
      if (num2 > 0)
      {
        if (groupHq > -1)
        {
          bool[] flagArray = new bool[1000];
          let mut num3: i32 = -1;
          index1: i32;
          if (this.game.Data.UnitObj[groupHq].AIAttack > -1)
            index1 = this.game.Data.UnitObj[groupHq].AIAttack;
          if (this.game.Data.UnitObj[groupHq].AIDefend > -1)
            index1 = this.game.Data.UnitObj[groupHq].AIDefend;
          if (this.game.Data.UnitObj[groupHq].AIFallback > -1)
            index1 = this.game.Data.UnitObj[groupHq].AIFallback;
          if (index1 > -1)
          {
            let mut areaCount: i32 = this.AreaCount;
            for (let mut index2: i32 = 0; index2 <= areaCount; index2 += 1)
            {
              if (this.AreaBorder[index1, index2] > 0)
              {
                num3 += 1;
                flagArray[index2] = true;
              }
            }
          }
          let mut tid2: i32 = 0;
          let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut index3: i32 = 0; index3 <= mapWidth; index3 += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut index4: i32 = 0; index4 <= mapHeight; index4 += 1)
            {
              let mut num4: i32 = 0;
              if (this.game.HandyFunctionsObj.IsHexAirfield(index3, index4, 0) & this.GetRegime(this.game.Data.MapObj[0].HexObj[index3, index4].Regime) == this.GetGameDataTurn() && this.GetRegime(this.game.Data.MapObj[0].HexObj[index3, index4].Regime) == this.GetGameDataTurn())
              {
                if (this.AreaMatrixNarrow[index3, index4] == this.game.Data.UnitObj[groupHq].AIDefend)
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] == this.game.Data.UnitObj[groupHq].AIAttack)
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] == this.game.Data.UnitObj[groupHq].AIFallback)
                  num4 = 1;
                if (numArray6[index3, index4] > 0)
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] > -1 && flagArray[this.AreaMatrixNarrow[index3, index4]])
                  num4 = 1;
                if (this.AreaMatrixNarrow[index3, index4] < 0)
                  num4 = 0;
                if (this.AreaMatrixNarrow[index3, index4] > 0 & this.game.Data.UnitObj[groupHq].AIDefend > -1 && this.AreaSteps[this.AreaMatrixNarrow[index3, index4], this.game.Data.UnitObj[groupHq].AIDefend] <= 2)
                  num4 = 1;
                if (num4 == 1 | numArray6[index3, index4] > 0)
                {
                  coordinate1 = averageCorpsUnitCoord;
                  let mut tweight: i32 = this.game.HandyFunctionsObj.Distance(index3, index4, 0, coordinate1.x, coordinate1.y, 0);
                  if ( tweight <= 20.0)
                    tweight = 20;
                  if (this.AreaMatrixNarrow[index3, index4] > -1 && this.AreaClosestEnemy[this.AreaMatrixNarrow[index3, index4]] < 9)
                    tweight += (10 - this.AreaClosestEnemy[this.AreaMatrixNarrow[index3, index4]]) * 1000;
                  coordinate1 = averageCorpsUnitCoord;
                  if (coordinate1.onmap)
                    tweight += this.game.HandyFunctionsObj.Distance(index3, index4, 0, coordinate1.x, coordinate1.y, 0);
                  tid2 += 1;
                  simpleList.Add(tid2, tweight, index3, index4);
                }
              }
            }
          }
        }
        simpleList.Sort();
        let mut num5: i32 = Math.Min(5, simpleList.Counter);
        for (let mut index: i32 = 0; index <= num5; index += 1)
        {
          tid1 += 1;
          tdata5 = this.GetTscore(simpleList.Data1[index], simpleList.Data2[index]);
          this.AirMarkerList.Add(tid1, 1, simpleList.Data1[index], simpleList.Data2[index], -1, -1, tdata5);
        }
      }
      if (this.CorpsEngineer[this.OpGroup])
      {
        let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut index5: i32 = 0; index5 <= mapWidth; index5 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut index6: i32 = 0; index6 <= mapHeight; index6 += 1)
          {
            let mut num6: i32 = 0;
            if (this.SupplyMatrix[index5, index6] == this.OpGroup & this.SupplyMatrixDistance[index5, index6] == 0)
              num6 = 1;
            if (this.AdvanceAxisMatrix[index5, index6] >= 0)
              num6 = 1;
            if (num6 == 1)
            {
              let mut index7: i32 = 0;
              do
              {
                coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index5, index6, 0, index7 + 1);
                if (coordinate1.onmap && this.game.Data.MapObj[0].HexObj[index5, index6].RoadType[index7] > -1 & this.game.Data.MapObj[0].HexObj[index5, index6].RiverType[index7] > -1 && !this.game.Data.MapObj[0].HexObj[index5, index6].Bridge[index7])
                {
                  let mut num7: i32 = 0;
                  if (this.SupplyMatrix[index5, index6] == this.OpGroup & this.SupplyMatrixDistance[index5, index6] == 0)
                    num7 = 1;
                  if (this.AdvanceAxisMatrix[index5, index6] >= 0)
                    num7 = 1;
                  if (num7 == 1)
                  {
                    tid1 += 1;
                    this.EngineerMarkerList.Add(tid1, 6, index5, index6, coordinate1.x, coordinate1.y, 100);
                  }
                }
                index7 += 1;
              }
              while (index7 <= 5);
            }
          }
        }
      }
      let mut num8: i32 = 0;
      do
      {
        let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
        for (let mut index8: i32 = 0; index8 <= mapWidth; index8 += 1)
        {
          let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
          for (let mut index9: i32 = 0; index9 <= mapHeight; index9 += 1)
          {
            if (index8 == 49 & index9 == 33)
              index8 = index8;
            Coordinate coordinate2;
            if (this.BottleNeckMatrix[index8, index9] > 0 | this.tArea[index8, index9] > 0 | numArray4[index8, index9] > 0 | numArray5[index8, index9] > 0 | numArray6[index8, index9] > 0)
            {
              if (this.game.Data.MapObj[0].HexObj[index8, index9].UnitCounter > -1 & num8 == 0)
              {
                if (this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index8, index9].Regime))
                {
                  if (simpleList.Counter > -1)
                  {
                    if (this.game.Data.MapObj[0].HexObj[index8, index9].MaxRecon > 0)
                    {
                      tid1 += 1;
                      tdata5 = this.GetTscore(index8, index9);
                      this.AirMarkerList.Add(tid1, 1, simpleList.Data1[0], simpleList.Data2[0], index8, index9, tdata5);
                      if (simpleList.Counter > 0)
                      {
                        tid1 += 1;
                        this.AirMarkerList.Add(tid1, 1, simpleList.Data1[1], simpleList.Data2[1], index8, index9, tdata5);
                      }
                      if (simpleList.Counter > 1)
                      {
                        tid1 += 1;
                        this.AirMarkerList.Add(tid1, 1, simpleList.Data1[2], simpleList.Data2[2], index8, index9, tdata5);
                      }
                      numArray7: Vec<i32> = numArray3;
                      numArray8: Vec<i32> = numArray7;
                      let mut x: i32 = coordinate1.x;
                      let mut index10: i32 = x;
                      let mut y: i32 = coordinate1.y;
                      let mut index11: i32 = y;
                      let mut num9: i32 = numArray7[x, y] + 1;
                      numArray8[index10, index11] = num9;
                    }
                    else if (numArray3[simpleList.Data1[2], simpleList.Data2[2]] == 0)
                    {
                      this.AirMarkerList.Add(tid1, 1, simpleList.Data1[2], simpleList.Data2[2], -1, -1, tdata5);
                      numArray9: Vec<i32> = numArray3;
                      numArray10: Vec<i32> = numArray9;
                      int[] data1 = simpleList.Data1;
                      int[] numArray11 = data1;
                      let mut index12: i32 = 2;
                      let mut index13: i32 = index12;
                      let mut index14: i32 = numArray11[index13];
                      int[] data2 = simpleList.Data2;
                      int[] numArray12 = data2;
                      let mut index15: i32 = 2;
                      let mut index16: i32 = index15;
                      let mut index17: i32 = numArray12[index16];
                      let mut num10: i32 = numArray9[data1[index12], data2[index15]] + 1;
                      numArray10[index14, index17] = num10;
                    }
                  }
                  let mut tfacing1: i32 = 1;
                  do
                  {
                    coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index8, index9, 0, tfacing1);
                    if (coordinate1.onmap && this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].UnitCounter == -1 | this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].Regime) == this.GetGameDataTurn() && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].LandscapeType].IsSea)
                    {
                      tdata5 =  Math.Round( (this.GetTscore(index8, index9, tfacing1 - 1) + this.GetTscore(coordinate1.x, coordinate1.y)) / 2.0);
                      if (tdata5 > 0)
                      {
                        tid1 += 1;
                        this.MarkerList.Add(tid1, 1, coordinate1.x, coordinate1.y, index8, index9, tdata5);
                        numArray13: Vec<i32> = numArray1;
                        numArray14: Vec<i32> = numArray13;
                        let mut index18: i32 = index8;
                        let mut index19: i32 = index18;
                        let mut index20: i32 = index9;
                        let mut index21: i32 = index20;
                        let mut num11: i32 = numArray13[index18, index20] + 1;
                        numArray14[index19, index21] = num11;
                        this.ArtMarkerList.Add(tid1, 1, coordinate1.x, coordinate1.y, index8, index9,  Math.Round( tdata5 * 0.66));
                        numArray15: Vec<i32> = numArray2;
                        numArray16: Vec<i32> = numArray15;
                        let mut index22: i32 = index8;
                        let mut index23: i32 = index22;
                        let mut index24: i32 = index9;
                        let mut index25: i32 = index24;
                        let mut num12: i32 = numArray15[index22, index24] + 1;
                        numArray16[index23, index25] = num12;
                        tdata5 = this.GetTscore(index8, index9, tfacing1 - 1);
                        if (num1 > 0)
                        {
                          let mut tfacing2: i32 = 1;
                          do
                          {
                            coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing2);
                            if (coordinate2.onmap && this.game.HandyFunctionsObj.Distance(index8, index9, 0, coordinate2.x, coordinate2.y, 0) == 2 && this.GetRegime(this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].Regime) == this.GetGameDataTurn() | this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].UnitCounter == -1 && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea)
                            {
                              tid1 += 1;
                              this.ArtMarkerList.Add(tid1, 1, coordinate2.x, coordinate2.y, index8, index9, tdata5);
                              numArray17: Vec<i32> = numArray2;
                              numArray18: Vec<i32> = numArray17;
                              let mut x: i32 = coordinate2.x;
                              let mut index26: i32 = x;
                              let mut y: i32 = coordinate2.y;
                              let mut index27: i32 = y;
                              let mut num13: i32 = numArray17[x, y] + 1;
                              numArray18[index26, index27] = num13;
                            }
                            tfacing2 += 1;
                          }
                          while (tfacing2 <= 6);
                        }
                      }
                    }
                    tfacing1 += 1;
                  }
                  while (tfacing1 <= 6);
                  index8 = index8;
                }
                else
                {
                  let mut unit: i32 = this.game.Data.MapObj[0].HexObj[index8, index9].UnitList[0];
                  if (this.game.Data.UnitObj[unit].AIGroup == this.OpGroup | this.game.Data.UnitObj[unit].HQ == groupHq | unit == groupHq | numArray6[index8, index9] > 0 & numArray4[index8, index9] > 0 | numArray5[index8, index9] > 0)
                  {
                    tdata5 = this.GetTscore(index8, index9) + this.BottleNeckMatrix[index8, index9] * 2;
                    if (numArray4[index8, index9] > 0 & numArray1[index8, index9] == 0)
                    {
                      tid1 += 1;
                      this.MarkerList.Add(tid1, 5, index8, index9, -1, -1, tdata5);
                      numArray19: Vec<i32> = numArray1;
                      numArray20: Vec<i32> = numArray19;
                      let mut index28: i32 = index8;
                      let mut index29: i32 = index28;
                      let mut index30: i32 = index9;
                      let mut index31: i32 = index30;
                      let mut num14: i32 = numArray19[index28, index30] + 1;
                      numArray20[index29, index31] = num14;
                    }
                    if (numArray5[index8, index9] > 0 & numArray2[index8, index9] == 0)
                    {
                      tdata5 =  Math.Round( tdata5 / 2.0);
                      tid1 += 1;
                      this.ArtMarkerList.Add(tid1, 5, index8, index9, -1, -1, tdata5);
                      numArray21: Vec<i32> = numArray2;
                      numArray22: Vec<i32> = numArray21;
                      let mut index32: i32 = index8;
                      let mut index33: i32 = index32;
                      let mut index34: i32 = index9;
                      let mut index35: i32 = index34;
                      let mut num15: i32 = numArray21[index32, index34] + 1;
                      numArray22[index33, index35] = num15;
                    }
                  }
                }
              }
              else if (num8 == 1)
              {
                let mut num16: i32 = 0;
                num17: i32;
                if (this.game.Data.MapObj[0].HexObj[index8, index9].Location > -1 | this.game.HandyFunctionsObj.HasHexBridge(index8, index9, 0))
                  num17 = 0;
                else if (this.game.HandyFunctionsObj.HasHexRoad(index8, index9, 0))
                  num17 = 0;
                else if (this.FrontlineArea[index8, index9] == 1)
                  num17 = 0;
                else if (this.BottleNeckMatrix[index8, index9] > 0)
                {
                  num17 = 0;
                }
                else
                {
                  num17 = 0;
                  if (this.game.Data.MapObj[0].HexObj[index8, index9].LandscapeType == 6)
                    num17 = 1;
                  if (this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[index8, index9].LandscapeType].IsSea)
                    num17 = 1;
                  let mut tfacing3: i32 = 1;
                  do
                  {
                    coordinate1 = this.game.HandyFunctionsObj.HexNeighbour(index8, index9, 0, tfacing3);
                    if (coordinate1.onmap)
                    {
                      if (this.game.Data.MapObj[0].HexObj[coordinate1.x, coordinate1.y].VP > 0 & this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
                      {
                        num17 = 0;
                        break;
                      }
                      if (numArray1[coordinate1.x, coordinate1.y] > 0)
                      {
                        num17 = 1;
                        let mut tfacing4: i32 = 1;
                        do
                        {
                          coordinate2 = this.game.HandyFunctionsObj.HexNeighbour(coordinate1.x, coordinate1.y, 0, tfacing4);
                          if (coordinate2.onmap && !this.game.Data.LandscapeTypeObj[this.game.Data.MapObj[0].HexObj[coordinate2.x, coordinate2.y].LandscapeType].IsSea && numArray1[coordinate2.x, coordinate2.y] > 0)
                            num17 = 1;
                          tfacing4 += 1;
                        }
                        while (tfacing4 <= 6);
                      }
                    }
                    tfacing3 += 1;
                  }
                  while (tfacing3 <= 6);
                }
                if (groupHq > -1 && this.game.Data.UnitObj[groupHq].AIDefend > -1 && index8 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].x && index9 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIDefend].y && numArray1[index8, index9] == 0)
                {
                  num17 = 0;
                  num16 = 1;
                }
                if (groupHq > -1 && this.game.Data.UnitObj[groupHq].AIFallback > -1 && index8 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].x && index9 == this.AreaCenter[this.game.Data.UnitObj[groupHq].AIFallback].y && numArray1[index8, index9] == 0)
                {
                  num17 = 0;
                  num16 = 1;
                }
                if (num17 == 0)
                {
                  tdata5 =  Math.Round( this.GetTscore(index8, index9) / 2.0);
                  if (this.BottleNeckMatrix[index8, index9] > 0)
                  {
                    num16 = 1;
                    tdata5 += this.BottleNeckMatrix[index8, index9] * 2;
                  }
                  if (index8 == 29 & index9 == 7)
                    index8 = index8;
                  if (tdata5 > 0)
                  {
                    tid1 += 1;
                    if (!this.game.HandyFunctionsObj.IsHostileNotSelf2(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[index8, index9].Regime))
                    {
                      if (numArray1[index8, index9] == 0 && num16 == 1 | this.game.Data.UnitObj[groupHq].AIAttackStyle == 1)
                      {
                        this.MarkerList.Add(tid1, 3, index8, index9, -1, -1, tdata5);
                        numArray23: Vec<i32> = numArray1;
                        numArray24: Vec<i32> = numArray23;
                        let mut index36: i32 = index8;
                        let mut index37: i32 = index36;
                        let mut index38: i32 = index9;
                        let mut index39: i32 = index38;
                        let mut num18: i32 = numArray23[index36, index38] + 1;
                        numArray24[index37, index39] = num18;
                        this.ArtMarkerList.Add(tid1, 3, index8, index9, -1, -1, tdata5);
                        numArray25: Vec<i32> = numArray2;
                        numArray26: Vec<i32> = numArray25;
                        let mut index40: i32 = index8;
                        let mut index41: i32 = index40;
                        let mut index42: i32 = index9;
                        let mut index43: i32 = index42;
                        let mut num19: i32 = numArray25[index40, index42] + 1;
                        numArray26[index41, index43] = num19;
                      }
                    }
                    else if (numArray2[index8, index9] == 0)
                    {
                      this.MarkerList.Add(tid1, 2, index8, index9, -1, -1, tdata5);
                      numArray27: Vec<i32> = numArray1;
                      numArray28: Vec<i32> = numArray27;
                      let mut index44: i32 = index8;
                      let mut index45: i32 = index44;
                      let mut index46: i32 = index9;
                      let mut index47: i32 = index46;
                      let mut num20: i32 = numArray27[index44, index46] + 1;
                      numArray28[index45, index47] = num20;
                      if (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3)
                      {
                        this.ArtMarkerList.Add(tid1, 2, index8, index9, -1, -1, tdata5);
                        numArray29: Vec<i32> = numArray2;
                        numArray30: Vec<i32> = numArray29;
                        let mut index48: i32 = index8;
                        let mut index49: i32 = index48;
                        let mut index50: i32 = index9;
                        let mut index51: i32 = index50;
                        let mut num21: i32 = numArray29[index48, index50] + 1;
                        numArray30[index49, index51] = num21;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        num8 += 1;
      }
      while (num8 <= 1);
    }

    pub fn AddExtraMarkers()
    {
      numArray1: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray2: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray3: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray4: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray5: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      numArray6: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      SimpleList simpleList = SimpleList::new();
      let mut counter1: i32 = this.MarkerList.Counter;
      for (let mut index: i32 = 0; index <= counter1; index += 1)
        numArray1[this.MarkerList.Data1[index], this.MarkerList.Data2[index]] = 1;
      let mut counter2: i32 = this.ArtMarkerList.Counter;
      for (let mut index: i32 = 0; index <= counter2; index += 1)
        numArray2[this.ArtMarkerList.Data1[index], this.ArtMarkerList.Data2[index]] = 1;
      this.SetTArea();
      let mut tid: i32 = 9999;
      let mut moveMatrixCounter1: i32 = this.MoveMatrixCounter;
      for (let mut index1: i32 = 1; index1 <= moveMatrixCounter1; index1 += 1)
      {
        let mut unr: i32 = this.MoveMatrixUnit[index1];
        if (unr > -1 && this.game.Data.UnitObj[unr].TempCategory == 1)
        {
          let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(unr);
          let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut index2: i32 = 0; index2 <= mapWidth; index2 += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut index3: i32 = 0; index3 <= mapHeight; index3 += 1)
            {
              if (numArray1[index2, index3] == 0 && this.MoveMatrix[index1, index2, index3] >= lowestAp)
              {
                numArray1[index2, index3] = 1;
                tid += 1;
                let mut tscore: i32 = this.GetTscore(index2, index3);
                if (tscore > 0)
                  this.MarkerList.Add(tid, 2, index2, index3, -1, -1, tscore);
              }
            }
          }
        }
      }
      let mut moveMatrixCounter2: i32 = this.MoveMatrixCounter;
      for (let mut index4: i32 = 1; index4 <= moveMatrixCounter2; index4 += 1)
      {
        let mut unr: i32 = this.MoveMatrixUnit[index4];
        if (unr > -1 && this.game.Data.UnitObj[unr].TempCategory == 2)
        {
          let mut lowestAp: i32 = this.game.HandyFunctionsObj.GetLowestAp(unr);
          let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
          for (let mut index5: i32 = 0; index5 <= mapWidth; index5 += 1)
          {
            let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
            for (let mut index6: i32 = 0; index6 <= mapHeight; index6 += 1)
            {
              if (numArray2[index5, index6] == 0 && this.MoveMatrix[index4, index5, index6] >= lowestAp)
              {
                numArray2[index5, index6] = 1;
                tid += 1;
                let mut tscore: i32 = this.GetTscore(index5, index6);
                if (tscore > 0)
                  this.ArtMarkerList.Add(tid, 2, index5, index6, -1, -1, tscore);
              }
            }
          }
        }
      }
    }

    pub fn Screenshot(typ: i32, fileextension: String,  tObj: Vec<i32>)
    {
      FileStream fileStream;
      try
      {
        fileStream = new FileStream(this.game.AppPath + "logs/screenshot_typ" + Strings.Trim(Conversion.Str( typ)) + "_pl" + Strings.Trim(Conversion.Str( this.game.Data.Turn)) + fileextension + ".jpg", FileMode.Create);
      }
      catch (Exception ex)
      {
        ProjectData.SetProjectError(ex);
        fileextension = "name error";
        fileStream = new FileStream(this.game.AppPath + "logs/screenshot_typ" + Strings.Trim(Conversion.Str( typ)) + "_pl" + Strings.Trim(Conversion.Str( this.game.Data.Turn)) + fileextension + ".jpg", FileMode.Create);
        ProjectData.ClearProjectError();
      }
      bitmap: Bitmap = new Bitmap(this.game.Data.MapObj[0].MapWidth * 40 + 80, this.game.Data.MapObj[0].MapHeight * 32 + 68, PixelFormat.Format24bppRgb);
      bitmap.SetResolution( DrawMod.DPIx,  DrawMod.DPIy);
      Graphics Expression = Graphics.FromImage((Image) bitmap);
      if (typ == 1)
      {
        DrawMod.DrawText( Expression, "Matrix", Font::new("Times New Roman", 11f, FontStyle.Bold, GraphicsUnit.Pixel), 10, bitmap.Height - 15);
        this.Screenshotgrid( Expression);
        this.Screenshot1( Expression,  tObj);
      }
      if (!Information.IsNothing( Expression))
        Expression.Dispose();
      bitmap.Save((Stream) fileStream, ImageFormat.Jpeg);
      fileStream.Close();
    }

    pub fn Screenshotgrid( Graphics g)
    {
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          customBitmapObj: CustomBitmapClass = this.game.CustomBitmapObj;
          let mut cx: i32 = index1;
          let mut cy: i32 = index2;
          bitmap: Bitmap = (Bitmap) null;
           let mut local1: &Bitmap = &bitmap;
          bool flag = false;
           bool local2 =  flag;
          objBitmap: Bitmap = customBitmapObj.DrawHex(cx, cy, 0, neverusehistory: true, gBitmap: ( local1), tFromMapPopup: ( local2));
          if (index1 == 0 | index1 % 2 == 0)
          {
            DrawMod.DrawScaled( g,  objBitmap, index1 * 40, index2 * 32, 40, 32);
            DrawMod.DrawRectangle( g, index1 * 40, index2 * 32, 40, 32,  byte.MaxValue,  byte.MaxValue,  byte.MaxValue,  byte.MaxValue);
          }
          else
          {
            DrawMod.DrawScaled( g,  objBitmap, index1 * 40, index2 * 32 + 16, 40, 32);
            DrawMod.DrawRectangle( g, index1 * 40, index2 * 32 + 16, 40, 32,  byte.MaxValue,  byte.MaxValue,  byte.MaxValue,  byte.MaxValue);
          }
        }
      }
    }

    pub fn Screenshot1( Graphics g,  tObj: Vec<i32>)
    {
      numArray: Vec<i32> = new int[this.game.Data.MapObj[0].MapWidth + 1, this.game.Data.MapObj[0].MapHeight + 1];
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          if (tObj[index1, index2] > -1)
          {
            if (index1 == 0 | index1 % 2 == 0)
              DrawMod.DrawTextOutline( g, Conversion.Str( tObj[index1, index2]), Font::new("Times New Roman", 13f, FontStyle.Bold, GraphicsUnit.Pixel), index1 * 40 + 2, index2 * 32 + 2);
            else
              DrawMod.DrawTextOutline( g, Conversion.Str( tObj[index1, index2]), Font::new("Times New Roman", 13f, FontStyle.Bold, GraphicsUnit.Pixel), index1 * 40 + 2, index2 * 32 + 2 + 16);
          }
        }
      }
    }

    pub fn CloseAI()
    {
      this.game.Data.RegimeObj[this.GetGameDataTurn()].OldAINarrow[0] = new MapMatrix2(this.game.Data.MapObj[0].MapWidth, this.game.Data.MapObj[0].MapHeight);
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          this.game.Data.RegimeObj[this.GetGameDataTurn()].OldAINarrow[0].Value[index1, index2] = this.AreaMatrixNarrow[index1, index2] <= this.RealAreaCount ? 0 : this.AreaMatrixNarrow[index1, index2];
          this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerAbove = 0;
          this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerMulti = 0;
        }
      }
      let mut historicalUnitCounter: i32 = this.game.Data.HistoricalUnitCounter;
      for (let mut index: i32 = 0; index <= historicalUnitCounter; index += 1)
      {
        this.game.Data.HistoricalUnitObj[index].TempAttack = -1;
        this.game.Data.HistoricalUnitObj[index].TempDefend = -1;
        this.game.Data.HistoricalUnitObj[index].TempStance = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetX = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetY = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetAttackX = -1;
        this.game.Data.HistoricalUnitObj[index].TempTargetAttackY = -1;
      }
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
        this.game.Data.UnitObj[index].TempUnitSelectable = false;
      this.game.EditObj.TargetX = -1;
      this.game.EditObj.TargetY = -1;
      this.WriteLog();
      this.WriteLog2();
    }

    pub fn AddLog2(s: String)
    {
      this += 1.LogCounter2;
      this.LogTxt2 = (string[]) Utils.CopyArray((Array) this.LogTxt2, (Array) new string[this.LogCounter2 + 1]);
      this.LogTxt2[this.LogCounter2] = s;
    }

    pub fn WriteLog2()
    {
      let mut num1: i32 = this.game.HandyFunctionsObj.CheckDiskSpace(Strings.Left(this.game.AppPath, Strings.InStr(this.game.AppPath, ":")));
      if (num1 > 0 & num1 < 50)
      {
        let mut num2: i32 =  Interaction.MsgBox( "Not of space left to write to disk.");
      }
      else
      {
        StreamWriter text = File.CreateText(this.game.AppPath + "logs/AItimer.txt");
        let mut logCounter2: i32 = this.LogCounter2;
        for (let mut index: i32 = 0; index <= logCounter2; index += 1)
          text.WriteLine(this.LogTxt2[index]);
        text.Close();
      }
    }

    pub fn AddLog(s: String)
    {
      this += 1.LogCounter;
      if (this.LogTxt.GetUpperBound(0) < this.LogCounter)
        this.LogTxt = (string[]) Utils.CopyArray((Array) this.LogTxt, (Array) new string[this.LogCounter + 1000 + 1]);
      this.LogTxt[this.LogCounter] = s;
    }

    pub fn WriteLog()
    {
      let mut num1: i32 = this.game.HandyFunctionsObj.CheckDiskSpace(Strings.Left(this.game.AppPath, Strings.InStr(this.game.AppPath, ":")));
      if (num1 > 0 & num1 < 50)
      {
        let mut num2: i32 =  Interaction.MsgBox( "Not of space left to write to disk.");
      }
      else
      {
        StreamWriter text = File.CreateText(this.game.AppPath + "logs/AIlog_" + Conversion.Str( this.game.Data.Turn) + ".txt");
        let mut logCounter: i32 = this.LogCounter;
        for (let mut index: i32 = 0; index <= logCounter; index += 1)
          text.WriteLine(this.LogTxt[index]);
        text.Close();
      }
    }

    pub fn WriteLog(name: String)
    {
      let mut num1: i32 = this.game.HandyFunctionsObj.CheckDiskSpace(Strings.Left(this.game.AppPath, Strings.InStr(this.game.AppPath, ":")));
      if (num1 > 0 & num1 < 50)
      {
        let mut num2: i32 =  Interaction.MsgBox( "Not of space left to write to disk.");
      }
      else
      {
        StreamWriter text = File.CreateText(this.game.AppPath + "logs/FullAILog_" + Conversion.Str( this.game.Data.Turn) + "_" + name + ".txt");
        let mut logCounter: i32 = this.LogCounter;
        for (let mut index: i32 = 0; index <= logCounter; index += 1)
          text.WriteLine(this.LogTxt[index]);
        text.Close();
      }
    }

    pub IsDefinedArea: bool(ix: i32, iy: i32, area: i32) => area != -1 && this.game.Data.AreaObj[area].Code == this.game.Data.MapObj[0].HexObj[ix, iy].AreaCode[this.game.Data.AreaObj[area].Slot];

    pub IsAIArea: bool(ix: i32, iy: i32, area: i32) => area != -1 && this.AreaMatrixWide[ix, iy] == area;

    ~NewAIClass() => base.Finalize();

    pub fn InitStrategicTransfers(bool makelog)
    {
      if (makelog)
        this.AddLog("INIT STRATEGIC TRANSFERS");
      let mut unitCounter1: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter1; index += 1)
        this.game.Data.UnitObj[index].TempStrategic = false;
      let mut Number1: i32 = 0;
      do
      {
        if (makelog)
          this.AddLog("==>CAPTYPE: " + Conversion.Str( Number1));
        let mut unitCounter2: i32 = this.game.Data.UnitCounter;
        for (let mut index1: i32 = 0; index1 <= unitCounter2; index1 += 1)
        {
          if (this.game.Data.UnitObj[index1].IsHQ & this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].Regime == this.game.Data.Turn)
          {
            let mut num1: i32 = 0;
            theater: i32;
            if (Number1 == 0 & this.game.Data.UnitObj[index1].LandCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (Number1 == 1 & this.game.Data.UnitObj[index1].NavyCap > 0)
            {
              num1 = 1;
              theater = 1;
            }
            if (Number1 == 2 & this.game.Data.UnitObj[index1].AirCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (num1 == 1)
            {
              if (makelog)
                this.AddLog("==>INIT SHQ: " + this.game.Data.UnitObj[index1].Name);
              let mut mapWidth1: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut index2: i32 = 0; index2 <= mapWidth1; index2 += 1)
              {
                let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut index3: i32 = 0; index3 <= mapHeight; index3 += 1)
                  this.SupplyMatrixReal[index2, index3] = 9999;
              }
              this.game.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.Turn,  Math.Round( this.game.Data.RuleVar[Number1]), theater,  Math.Round( this.game.Data.RuleVar[78]), this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0);
              let mut mapWidth2: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut index4: i32 = 0; index4 <= mapWidth2; index4 += 1)
              {
                let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut index5: i32 = 0; index5 <= mapHeight; index5 += 1)
                {
                  this.SupplyMatrixReal[index4, index5] = this.game.EditObj.TempValue[0].Value[index4, index5];
                  this.SupplyMatrixRealCameFrom[index4, index5] = this.game.EditObj.TempCameFrom[0].Value[index4, index5];
                }
              }
              SimpleList simpleList = SimpleList::new();
              let mut unitCounter3: i32 = this.game.Data.UnitCounter;
              Coordinate closeFriendlyRoadHex;
              for (let mut index6: i32 = 0; index6 <= unitCounter3; index6 += 1)
              {
                if (!this.game.Data.UnitObj[index6].TempStrategic && this.game.Data.UnitObj[index6].AIGroup > 0 & this.game.Data.UnitObj[index6].X > -1 & this.game.Data.UnitObj[index6].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn())
                {
                  let mut index7: i32 = this.game.Data.UnitObj[index6].AIAttackStyle != 3 ? this.game.Data.UnitObj[index6].AIDefend : this.game.Data.UnitObj[index6].AIAttack;
                  if (index7 > -1 & index7 <= this.AreaCount)
                  {
                    this.game.Data.UnitObj[index6].FinalX = this.AreaCenter[index7].x;
                    this.game.Data.UnitObj[index6].FinalY = this.AreaCenter[index7].y;
                    if (this.game.Data.UnitObj[index6].PreDef == -1 && this.game.Data.UnitObj[index6].AIGroup > -1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index6].PreDef == -1 & this.game.Data.UnitObj[index6].X > -1 && index6 != index1 & !this.game.HandyFunctionsObj.HasUnitAirSF(index6) & !this.game.HandyFunctionsObj.HasUnitNavySF(index6) && this.game.Data.UnitObj[index6].X != this.game.Data.UnitObj[index6].FinalX & this.game.Data.UnitObj[index6].Y != this.game.Data.UnitObj[index6].FinalY && this.game.Data.UnitObj[index6].FinalX > -1 & this.game.Data.UnitObj[index6].FinalY > -1)
                    {
                      closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y, 3);
                      if (closeFriendlyRoadHex.onmap)
                      {
                        closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[index6].FinalX, this.game.Data.UnitObj[index6].FinalY, 4);
                        if (closeFriendlyRoadHex.onmap)
                        {
                          let mut num2: i32 = this.game.HandyFunctionsObj.Distance(closeFriendlyRoadHex.x, closeFriendlyRoadHex.y, 0, this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y, 0);
                          let mut num3: i32 = this.SupplyMatrixReal[closeFriendlyRoadHex.x, closeFriendlyRoadHex.y];
                          this.game.HandyFunctionsObj.Distance(this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0, this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y, 0);
                          let mut num4: i32 = this.SupplyMatrixReal[this.game.Data.UnitObj[index6].X, this.game.Data.UnitObj[index6].Y];
                          let mut index8: i32 = this.game.Data.UnitObj[index6].AIAttackStyle != 3 ? this.game.Data.UnitObj[index6].AIDefend : this.game.Data.UnitObj[index6].AIAttack;
                          if (index8 > -1 & num3 < 9999 & num4 < 9999 &  this.GetHexSpeedofUnit(index6, true) * 3.5 <  num2)
                          {
                            let mut tweight: i32 =  Math.Round( ((this.AreaFuzzyVP[index8] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index8].x, this.AreaCenter[index8].y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[index8].x, this.AreaCenter[index8].y].VP) * 1000) / ( num2 / 2.0));
                            simpleList.Add(index6, tweight);
                          }
                        }
                      }
                    }
                  }
                }
              }
              if (simpleList.Counter > -1)
              {
                simpleList.Sort();
                for (let mut counter: i32 = simpleList.Counter; counter >= 0; counter += -1)
                {
                  if (makelog)
                    this.AddLog(this.game.Data.UnitObj[simpleList.Id[counter]].Name + " , PRIORITY = " + Conversion.Str( simpleList.Weight[counter]));
                }
                Number2: i32;
                if (Number1 == 0)
                  Number2 = this.game.Data.UnitObj[index1].LandCap;
                if (Number1 == 1)
                  Number2 = this.game.Data.UnitObj[index1].NavyCap;
                if (Number1 == 2)
                  Number2 = this.game.Data.UnitObj[index1].AirCap;
                if ( this.game.Data.RuleVar[802] == 1.0)
                  Number2 = 9999999;
                for (let mut counter: i32 = simpleList.Counter; counter >= 0; counter += -1)
                {
                  let mut unr: i32 = simpleList.Id[counter];
                  closeFriendlyRoadHex = this.GetCloseFriendlyRoadHex(this.game.Data.UnitObj[unr].FinalX, this.game.Data.UnitObj[unr].FinalY, 4);
                  if (closeFriendlyRoadHex.onmap)
                  {
                    DrawMod.TGame.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.UnitObj[index1].Regime,  Math.Round( this.game.Data.RuleVar[Number1]), theater,  Math.Round( this.game.Data.RuleVar[78]), this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0, overruleRoadType: 0);
                    this.game.EditObj.TargetX = closeFriendlyRoadHex.x;
                    this.game.EditObj.TargetY = closeFriendlyRoadHex.y;
                    this.game.EditObj.OrderUnit = unr;
                    this.game.EditObj.OrderTarget = index1;
                    let mut num5: i32 = (this.game.EditObj.TempValue[0].Value[this.game.EditObj.TargetX, this.game.EditObj.TargetY] +  Math.Round( this.game.Data.RuleVar[351])) * this.game.HandyFunctionsObj.GetUnitWeight(unr, true);
                    if (num5 <= Number2)
                    {
                      if (makelog)
                        this.AddLog(this.game.Data.UnitObj[unr].Name + " PROGNOSED MOVED FROM " + Conversion.Str( this.game.Data.UnitObj[unr].X) + "," + Conversion.Str( this.game.Data.UnitObj[unr].Y) + " TO " + Conversion.Str( this.game.EditObj.TargetX) + "," + Conversion.Str( this.game.EditObj.TargetY));
                      this.game.Data.UnitObj[unr].TempStrategic = true;
                      this.game.Data.UnitObj[unr].TempCapHQ = index1;
                      this.game.Data.UnitObj[unr].TempCapType = Number1;
                      Number2 -= num5;
                      if (makelog)
                        this.AddLog("PROGNOSED RAIL CAP LEFT AT HIGHHQ = " + Conversion.Str( Number2));
                    }
                    else
                    {
                      num6: i32;
                      num6 += 1;
                      if (num6 > 2)
                        break;
                    }
                  }
                }
                this.game.EditObj.TargetX = -1;
                this.game.EditObj.TargetY = -1;
                this.game.EditObj.OrderTarget = -1;
                this.game.EditObj.OrderUnit = -1;
              }
            }
          }
        }
        Number1 += 1;
      }
      while (Number1 <= 2);
    }

    pub fn ExecuteStrategicTransfers(bool makelog)
    {
      if (makelog)
        this.AddLog("EXECUTE STRATEGIC TRANSFERS");
      this.TempGroupHQ[this.OpGroup] = this.GetGroupHQ(this.OpGroup);
      let mut Number: i32 = 0;
      do
      {
        if (makelog)
          this.AddLog("==>CAPTYPE: " + Conversion.Str( Number));
        let mut unitCounter1: i32 = this.game.Data.UnitCounter;
        for (let mut index1: i32 = 0; index1 <= unitCounter1; index1 += 1)
        {
          if (this.game.Data.UnitObj[index1].IsHQ & this.game.Data.UnitObj[index1].PreDef == -1 & this.game.Data.UnitObj[index1].Regime == this.game.Data.Turn)
          {
            let mut num1: i32 = 0;
            theater: i32;
            if (Number == 0 & this.game.Data.UnitObj[index1].LandCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (Number == 1 & this.game.Data.UnitObj[index1].NavyCap > 0)
            {
              num1 = 1;
              theater = 1;
            }
            if (Number == 2 & this.game.Data.UnitObj[index1].AirCap > 0)
            {
              num1 = 1;
              theater = 0;
            }
            if (num1 == 1)
            {
              if (makelog)
                this.AddLog("==>SHQ: " + this.game.Data.UnitObj[index1].Name);
              SimpleList simpleList = SimpleList::new();
              DrawMod.TGame.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.UnitObj[index1].Regime,  Math.Round( this.game.Data.RuleVar[Number]), theater,  Math.Round( this.game.Data.RuleVar[78]), this.game.Data.UnitObj[index1].X, this.game.Data.UnitObj[index1].Y, 0);
              let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
              for (let mut index2: i32 = 0; index2 <= mapWidth; index2 += 1)
              {
                let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
                for (let mut index3: i32 = 0; index3 <= mapHeight; index3 += 1)
                  this.SupplyMatrixReal[index2, index3] = this.game.EditObj.TempValue[0].Value[index2, index3];
              }
              let mut unitCounter2: i32 = this.game.Data.UnitCounter;
              Coordinate coordinate;
              for (let mut index4: i32 = 0; index4 <= unitCounter2; index4 += 1)
              {
                if (this.game.Data.UnitObj[index4].TempStrategic & this.game.Data.UnitObj[index4].TempCapType == Number && this.game.Data.UnitObj[index4].PreDef == -1 & this.game.Data.UnitObj[index4].TempCapHQ == index1 && this.game.Data.UnitObj[index4].AIGroup > -1 & this.game.Data.UnitObj[index4].Regime == this.game.Data.Turn & this.game.Data.UnitObj[index4].PreDef == -1 & this.game.Data.UnitObj[index4].X > -1 && index4 != index1 & !this.game.HandyFunctionsObj.HasUnitAirSF(index4) & !this.game.HandyFunctionsObj.HasUnitNavySF(index4) && this.game.Data.UnitObj[index4].X != this.game.Data.UnitObj[index4].FinalX & this.game.Data.UnitObj[index4].Y != this.game.Data.UnitObj[index4].FinalY && this.game.HandyFunctionsObj.HasHexRoad(this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0) && this.game.Data.UnitObj[index4].FinalX > -1 & this.game.Data.UnitObj[index4].FinalY > -1 && this.game.HandyFunctionsObj.HasHexRoad(this.game.Data.UnitObj[index4].FinalX, this.game.Data.UnitObj[index4].FinalY, 0))
                {
                  coordinate.x = this.game.Data.UnitObj[index4].FinalX;
                  coordinate.y = this.game.Data.UnitObj[index4].FinalY;
                  let mut num2: i32 = this.game.HandyFunctionsObj.Distance(coordinate.x, coordinate.y, 0, this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0);
                  let mut num3: i32 = this.SupplyMatrixReal[coordinate.x, coordinate.y];
                  if (num3 >= 999 && this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend > -1)
                  {
                    coordinate.x = this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].x;
                    coordinate.y = this.AreaCenter[this.game.Data.UnitObj[this.TempGroupHQ[this.OpGroup]].AIDefend].y;
                    num2 = this.game.HandyFunctionsObj.Distance(coordinate.x, coordinate.y, 0, this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0);
                    num3 = this.SupplyMatrixReal[coordinate.x, coordinate.y];
                  }
                  this.game.HandyFunctionsObj.Distance(coordinate.x, coordinate.y, 0, this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y, 0);
                  let mut num4: i32 = this.SupplyMatrixReal[this.game.Data.UnitObj[index4].X, this.game.Data.UnitObj[index4].Y];
                  let mut index5: i32 = this.game.Data.UnitObj[index4].AIAttackStyle != 3 ? this.game.Data.UnitObj[index4].AIDefend : this.game.Data.UnitObj[index4].AIAttack;
                  if (index5 > -1 & num3 < 9999 & num4 < 9999 &  this.GetHexSpeedofUnit(index4, true) * 2.0 <  num2 && this.CanBeStrategiclyTransferred(index4))
                  {
                    let mut num5: i32 = this.AreaFuzzyVP[index5] + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index5].x, this.AreaCenter[index5].y] + this.game.Data.MapObj[0].HexObj[this.AreaCenter[index5].x, this.AreaCenter[index5].y].VP;
                    if (this.game.Data.UnitObj[index4].TempStrategic)
                      num5 *= 10;
                    let mut tweight: i32 =  Math.Round( (num5 * 1000) / ( num2 / 2.0));
                    simpleList.Add(index4, tweight, coordinate.x, coordinate.y);
                  }
                }
              }
              if (simpleList.Counter > -1)
              {
                simpleList.Sort();
                for (let mut counter: i32 = simpleList.Counter; counter >= 0; counter += -1)
                {
                  if (makelog)
                    this.AddLog(this.GroupName[this.game.Data.UnitObj[simpleList.Id[counter]].AIGroup] + " : " + this.game.Data.UnitObj[simpleList.Id[counter]].Name + " , PRIORITY = " + Conversion.Str( simpleList.Weight[counter]));
                }
                for (let mut counter: i32 = simpleList.Counter; counter >= 0; counter += -1)
                {
                  let mut unr: i32 = simpleList.Id[counter];
                  coordinate.x = simpleList.Data1[counter];
                  coordinate.y = simpleList.Data2[counter];
                  coordinate.map = 0;
                  coordinate.onmap = true;
                  if (coordinate.onmap && this.game.Data.MapObj[0].HexObj[coordinate.x, coordinate.y].UnitCounter <= 14)
                  {
                    DrawMod.TGame.HandyFunctionsObj.MakeMovePrediction2(this.game.Data.UnitObj[index1].Regime,  Math.Round( this.game.Data.RuleVar[Number]), theater,  Math.Round( this.game.Data.RuleVar[78]), this.game.Data.UnitObj[unr].X, this.game.Data.UnitObj[unr].Y, 0);
                    this.game.EditObj.TargetX = coordinate.x;
                    this.game.EditObj.TargetY = coordinate.y;
                    this.game.EditObj.OrderUnit = unr;
                    this.game.EditObj.OrderTarget = index1;
                    let mut num6: i32 = (this.game.EditObj.TempValue[0].Value[this.game.EditObj.TargetX, this.game.EditObj.TargetY] +  Math.Round( this.game.Data.RuleVar[351])) * this.game.HandyFunctionsObj.GetUnitWeight(unr, true);
                    num7: i32;
                    if (Number == 0)
                      num7 = this.game.Data.UnitObj[index1].LandCap;
                    if (Number == 1)
                      num7 = this.game.Data.UnitObj[index1].NavyCap;
                    if (Number == 2)
                      num7 = this.game.Data.UnitObj[index1].AirCap;
                    if ( this.game.Data.RuleVar[802] == 1.0)
                    {
                      num7 = 9999999;
                      this.game.Data.UnitObj[index1].LandCap = num7;
                      this.game.Data.UnitObj[index1].NavyCap = num7;
                      this.game.Data.UnitObj[index1].AirCap = num7;
                    }
                    if (num6 <= num7)
                    {
                      if (makelog)
                        this.AddLog(this.game.Data.UnitObj[unr].Name + " MOVED FROM " + Conversion.Str( this.game.Data.UnitObj[unr].X) + "," + Conversion.Str( this.game.Data.UnitObj[unr].Y) + " TO " + Conversion.Str( this.game.EditObj.TargetX) + "," + Conversion.Str( this.game.EditObj.TargetY));
                      this.game.ProcessingObj.DoStrategicTransfer(this.game.EditObj.OrderTarget, this.game.EditObj.OrderUnit, 2, this.game.EditObj.TargetX, this.game.EditObj.TargetY, this.game.EditObj.TargetMap);
                      if (makelog)
                      {
                        if (Number == 0)
                          this.AddLog("LAND-CAP LEFT AT HIGHHQ = " + Conversion.Str( this.game.Data.UnitObj[index1].AirCap));
                        if (Number == 1)
                          this.AddLog("NAVY-CAP LEFT AT HIGHHQ = " + Conversion.Str( this.game.Data.UnitObj[index1].AirCap));
                        if (Number == 2)
                          this.AddLog("RAIL-CAP LEFT AT HIGHHQ = " + Conversion.Str( this.game.Data.UnitObj[index1].AirCap));
                      }
                    }
                    else
                    {
                      num8: i32;
                      num8 += 1;
                      if (num8 > 2)
                        break;
                    }
                  }
                }
                this.game.EditObj.TargetX = -1;
                this.game.EditObj.TargetY = -1;
                this.game.EditObj.OrderTarget = -1;
                this.game.EditObj.OrderUnit = -1;
              }
            }
          }
        }
        Number += 1;
      }
      while (Number <= 2);
    }

    pub fn FindBestStrategy(bool alllog, bool OnlyOneRound)
    {
      SimpleList[] simpleListArray = new SimpleList[100];
      this.AreaIsHistoricalArea = (int[]) Utils.CopyArray((Array) this.AreaIsHistoricalArea, (Array) new int[this.AreaCount + 1]);
      VBMath.Randomize( (this.game.Data.Turn + this.game.Data.Round + this.game.Data.MapObj[0].MapWidth));
      this.AreaGroupRound = 0;
      if (alllog)
      {
        this.AddLog("");
        this.AddLog("FIND STRATEGY");
        this.AddLog("");
      }
      this.SetFindBestStrategyStuff(alllog);
      this.SetInitialAreaGroups(alllog);
      if (this.AreaGroupCount == 0)
      {
        let mut num1: i32 =  Interaction.MsgBox( "No areas definied. See rulevar 267. This will probably result in crash of DC1 AI", Title: ( "Vics message"));
      }
      int[] numArray = new int[this.AreaCount + 1];
      if (this.FullLog)
        this.WriteLog("10_FindBestStrategy_01_setup");
      this.LogCounter = -1;
      num2: i32;
      Number1: i32;
      Number2: i32;
      num3: i32;
      index1: i32;
      index2: i32;
      tdata1: i32;
      index3: i32;
      while (this.AreaGroupCount > 1 | this.AreaGroupRound == 0 && !(this.AreaGroupRound == 1 & OnlyOneRound))
      {
        this += 1.AreaGroupRound;
        simpleListArray[this.AreaGroupRound] = SimpleList::new();
        if (this.AreaGroupRound > 1)
        {
          this.MergeAreaGroups();
          if (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 250 && this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 100 && this.AreaGroupCount > 1)
            this.MergeAreaGroups();
        }
        num2 = this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 250 ? (this.game.Data.RegimeObj[this.game.Data.Turn].ProdBonus < 100 ? 2 : 3) : 4;
        let mut areaGroupCount: i32 = this.AreaGroupCount;
        for (this.CurrentAreaGroup = 1; this.CurrentAreaGroup <= areaGroupCount; this += 1.CurrentAreaGroup)
        {
          this.SetAreaExtraVP(alllog);
          this.TempGroupTarget = new int[this.GroupCounter + 1];
          this.CorpsLoc = (int[]) Utils.CopyArray((Array) this.CorpsLoc, (Array) new int[this.GroupCounter + 1]);
          Number1 = 0;
          this.BestStrategy = (SimpleList) null;
          this.HistoryMove = new SimpleList[9000];
          this.HistoryMoveCounter = 0;
          this.HistoryScoreList = SimpleList::new();
          Random random = new Random(this.CurrentAreaGroup * 20 + this.game.Data.Round * 1000 + this.game.Data.Turn + this.game.Data.MapObj[0].MapWidth + this.game.Data.MapObj[0].MapHeight);
          Number2 = -999999;
          this.OpGroup = -1;
          let mut num4: i32 = 99999;
          let mut num5: i32 = 99999;
          num3 =  Math.Round( this.DIFFICULTY_LEVEL_STRATEGY_MOVES /  this.AreaGroupCount);
          if (!this.Attacker)
            num3 =  Math.Round( num3 / 2.0);
          let mut num6: i32 = 0;
          let mut groupCounter1: i32 = this.GroupCounter;
          for (let mut index4: i32 = 0; index4 <= groupCounter1; index4 += 1)
          {
            if (this.AreaGroup[this.CorpsStartLoc[index4]] == this.CurrentAreaGroup)
              num6 += 1;
          }
          if (alllog)
            this.AddLog("AREAGROUP ROUND " + this.AreaGroupRound.ToString() + ", AREAGROUP " + Conversion.Str( this.CurrentAreaGroup));
          Number3: i32;
          Number3 += 1;
          while (Number1 < num3)
          {
            if (alllog)
              this.AddLog("");
            if (alllog)
              this.AddLog("Step: " + Number1.ToString() + " of " + num3.ToString());
            if (Number1 % 80 == 0)
              GC.Collect();
            if (Number1 % 10 == 0)
            {
              this.game.EditObj.AIProgressMax = num3;
              this.game.EditObj.AIProgressNow = Number1;
              this.game.EditObj.TempAIString = this.AreaGroupCount <= 1 ? "Final initialization" : "Prelimenary initializations. Round " + Strings.Trim(Conversion.Str( Number3));
            }
            Number1 += 1;
            SimpleList Straty = SimpleList::new();
            this.AreaOwner = new int[this.AreaCount + 1];
            let mut areaCount1: i32 = this.AreaCount;
            for (let mut index5: i32 = 1; index5 <= areaCount1; index5 += 1)
              this.AreaOwner[index5] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index5].x, this.AreaCenter[index5].y].Regime;
            this.FriendlySupply = new int[this.AreaCount + 1];
            this.GetStrategyScore_FriendlySupply(false, 0);
            this.StartFriendlySupply = new int[this.AreaCount + 1];
            let mut areaCount2: i32 = this.AreaCount;
            for (let mut index6: i32 = 1; index6 <= areaCount2; index6 += 1)
              this.StartFriendlySupply[index6] = this.FriendlySupply[index6];
            let mut groupCounter2: i32 = this.GroupCounter;
            for (let mut index7: i32 = 0; index7 <= groupCounter2; index7 += 1)
            {
              if (this.AreaGroup[this.CorpsStartLoc[index7]] == this.CurrentAreaGroup & this.TempGroupHQ[index7] >= -1)
              {
                let mut num7: i32 = 0;
                let mut index8: i32 = 0;
                index1 = 0;
                index2 = 0;
                let mut num8: i32 = 0;
                let mut tdata5: i32 = 0;
                tdata1 = 0;
                let mut num9: i32 = index7;
                let mut num10: i32 = 0;
                if (this.TempGroupHQ[index7] > -1)
                {
                  let mut historical1: i32 = this.game.Data.UnitObj[this.TempGroupHQ[index7]].Historical;
                  if (historical1 > -1 && this.game.Data.HistoricalUnitObj[historical1].TempAttack > -1 | this.game.Data.HistoricalUnitObj[historical1].TempDefend > -1)
                    num10 = 1;
                  if (this.CorpsTopGroup[index7] > -1 && this.TempGroupHQ[this.CorpsTopGroup[index7]] > -1)
                  {
                    let mut historical2: i32 = this.game.Data.UnitObj[this.TempGroupHQ[this.CorpsTopGroup[index7]]].Historical;
                    if (historical2 > -1 && this.game.Data.HistoricalUnitObj[historical2].TempAttack > -1 | this.game.Data.HistoricalUnitObj[historical2].TempDefend > -1)
                      num10 = 1;
                  }
                }
                if (num10 == 1)
                {
                  if (alllog)
                    this.AddLog("event override: " + this.GroupName[index7]);
                  let mut historical: i32 = this.game.Data.UnitObj[this.GetGroupHQ(index7)].Historical;
                  if (historical > -1)
                  {
                    num7 = this.CorpsStartLoc[index7];
                    if (num7 > 0)
                    {
                      index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      if (index8 > 0)
                      {
                        index1 = this.GetRandomAreaNeighbour(index8, num7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        if (index1 > 0)
                        {
                          index2 = this.GetRandomAreaNeighbour(index1, num7, index8, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          if (index2 > 0)
                          {
                            num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, tAreaGroup: this.CurrentAreaGroup);
                            if (num8 > 0)
                              tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, tAreaGroup: this.CurrentAreaGroup);
                          }
                        }
                      }
                    }
                    tdata1 = random.Next(0, 100) <= 50 ? 3 : (random.Next(0, 100) <= 50 ? 2 : 1);
                    num4 = Number1;
                    if (historical > -1)
                    {
                      if (this.game.Data.HistoricalUnitObj[historical].TempAttack == -1)
                      {
                        if (this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                        {
                          SimpleList areaToAreaPath = this.GetAreaToAreaPath(num7, this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend));
                          if (areaToAreaPath.Counter > -1)
                          {
                            if (areaToAreaPath.Counter == 0)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = index8;
                              index2 = index8;
                              num8 = index8;
                              tdata5 = index8;
                            }
                            if (areaToAreaPath.Counter == 1)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = index1;
                              num8 = index2;
                              tdata5 = num8;
                            }
                            if (areaToAreaPath.Counter == 2)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = areaToAreaPath.Id[2];
                              num8 = index2;
                              tdata5 = num8;
                            }
                            if (areaToAreaPath.Counter == 3)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = areaToAreaPath.Id[2];
                              num8 = areaToAreaPath.Id[3];
                              tdata5 = num8;
                            }
                            if (areaToAreaPath.Counter > 3)
                            {
                              index8 = areaToAreaPath.Id[0];
                              index1 = areaToAreaPath.Id[1];
                              index2 = areaToAreaPath.Id[2];
                              num8 = areaToAreaPath.Id[3];
                              tdata5 = areaToAreaPath.Id[4];
                            }
                          }
                          else
                          {
                            index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend);
                            index1 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend);
                            index2 = index1;
                            num8 = index1;
                            tdata5 = index1;
                          }
                        }
                      }
                      else if (num7 != this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend) & this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                      {
                        SimpleList areaToAreaPath = this.GetAreaToAreaPath(num7, this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend));
                        if (areaToAreaPath.Counter > -1)
                        {
                          if (areaToAreaPath.Counter == 0)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                            index2 = index1;
                            num8 = index1;
                            tdata5 = index1;
                          }
                          if (areaToAreaPath.Counter == 1)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                            num8 = index2;
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 2)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                          }
                          if (areaToAreaPath.Counter > 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = areaToAreaPath.Id[4];
                          }
                        }
                        else
                        {
                          index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend);
                          index1 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                          if (index1 == -1)
                            index1 = index8;
                          index2 = index1;
                          num8 = index1;
                          tdata5 = index1;
                        }
                      }
                      else if (num7 == this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempDefend) & this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                      {
                        index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                        index1 = index8;
                        index2 = index1;
                        num8 = index1;
                        tdata5 = index1;
                      }
                      else
                      {
                        SimpleList areaToAreaPath = this.GetAreaToAreaPath(num7, this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack));
                        if (areaToAreaPath.Counter > -1)
                        {
                          if (areaToAreaPath.Counter == 0)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = index8;
                            index2 = index8;
                            num8 = index8;
                            tdata5 = index8;
                          }
                          if (areaToAreaPath.Counter == 1)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = index1;
                            num8 = index2;
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 2)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = index2;
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter == 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = num8;
                          }
                          if (areaToAreaPath.Counter > 3)
                          {
                            index8 = areaToAreaPath.Id[0];
                            index1 = areaToAreaPath.Id[1];
                            index2 = areaToAreaPath.Id[2];
                            num8 = areaToAreaPath.Id[3];
                            tdata5 = areaToAreaPath.Id[4];
                          }
                        }
                        else
                        {
                          index8 = this.GetHisAreaAsAIArea(this.game.Data.HistoricalUnitObj[historical].TempAttack);
                          index1 = index8;
                          index2 = index1;
                          num8 = index1;
                          tdata5 = index1;
                        }
                      }
                    }
                    if (this.game.Data.HistoricalUnitObj[historical].TempStance > -1)
                      tdata1 = this.game.Data.HistoricalUnitObj[historical].TempStance;
                  }
                }
                else if (num10 == 0 & num5 >= Number1 & Number1 > 1)
                {
                  if (alllog)
                    this.AddLog("stayput: " + this.GroupName[index7]);
                  num5 = Number1;
                  num7 = this.CorpsStartLoc[index7];
                  index8 = num7;
                  index1 = num7;
                  index2 = num7;
                  num8 = num7;
                  tdata1 = 1;
                }
                else if ( Number1 < Math.Min(100.0,  num3 / 4.0) & this.AreaGroupRound == 1 | num4 == 1)
                {
                  if (alllog)
                    this.AddLog("random movement: " + this.GroupName[index7]);
                  num7 = this.CorpsStartLoc[index7];
                  if (num7 > 0)
                  {
                    index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                    if (index8 > 0)
                    {
                      index1 = this.GetRandomAreaNeighbour(index8, num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      if (index1 > 0)
                      {
                        index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        if (index2 > 0)
                        {
                          num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          if (num8 > 0)
                            tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        }
                      }
                    }
                  }
                  tdata1 = random.Next(0, 100) <= 50 ? 3 : (random.Next(0, 100) <= 50 ? 2 : 1);
                  if (this.Attacker)
                    tdata1 = 3;
                  if (!this.Attacker & random.Next(0, 100) > 40)
                    tdata1 = random.Next(0, 100) <= 50 ? 2 : 1;
                  if (!this.Attacker & random.Next(0, 100) > 90)
                  {
                    index8 = num7;
                    tdata1 = 1;
                  }
                  if (num7 == index8)
                    tdata1 = 1;
                }
                else
                {
                  if (alllog)
                    this.AddLog("take move from previous strategy: " + this.GroupName[index7]);
                  num7 = this.CorpsStartLoc[index7];
                  random = new Random(Number1 + this.game.Data.Round * 6540 * (this.game.Data.Turn * 500));
                  float num11 =  Math.Sqrt(Math.Sqrt( random.Next(0, 100000) / 100000.0));
                  let mut num12: i32 = 0;
                  if (random.Next(0, 100) < 20)
                  {
                    if ( VBMath.Rnd() > 0.5)
                      num11 = 1f;
                    if (alllog)
                      this.AddLog("MODE: Mix old record with top record");
                  }
                  else if (random.Next(0, 100) > 20)
                  {
                    num11 = 1f;
                    if (alllog)
                      this.AddLog("MODE: Mutate top record");
                  }
                  else
                  {
                    num11 =  Math.Sqrt(Math.Sqrt( random.Next(0, 100) / 100.0));
                    if (alllog)
                      this.AddLog("MODE: Mix old record with other old record");
                  }
                  for (let mut counter: i32 = this.HistoryScoreList.Counter; counter >= 0; counter += -1)
                  {
                    let mut num13: i32 = this.HistoryScoreList.Weight[this.HistoryScoreList.Counter] - this.HistoryScoreList.Weight[0];
                    if ((num13 <= 0 ? 0.0 :  ( (this.HistoryScoreList.Weight[counter] - this.HistoryScoreList.Weight[0]) /  num13)) <=  num11)
                    {
                      if (alllog)
                        this.AddLog("historic record number " + Conversion.Str( counter) + " with score = " + Conversion.Str( this.HistoryScoreList.Weight[counter]));
                      let mut index9: i32 = this.HistoryScoreList.Id[counter];
                      if (index9 > -1)
                      {
                        let mut nr: i32 = this.HistoryMove[index9].FindNr(index7 + 99000);
                        this.HistoryMove[index9].FindNr(index7 + 199000);
                        tdata1 = !(nr > -1 & random.Next(0, 100) < 80) ? ( VBMath.Rnd() <= 0.5 ? 3 : ( VBMath.Rnd() <= 0.5 ? 2 : 1)) : this.HistoryMove[index9].Data1[nr];
                        if (this.Attacker & random.Next(0, 100) > 80)
                          tdata1 = 3;
                        if (!this.Attacker & random.Next(0, 100) > 90)
                          tdata1 = 1;
                        let mut index10: i32 = this.HistoryMove[index9].FindNr(index7);
                        if (index10 > -1)
                        {
                          if (this.AreaGroupCount == 1)
                            index10 = index10;
                          if ( VBMath.Rnd() * 100.0 > Math.Min(50.0, 200.0 * (1.0 /  num6)))
                          {
                            if (alllog)
                              this.AddLog("copies full move");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            index2 = this.HistoryMove[index9].Data3[index10];
                            num8 = this.HistoryMove[index9].Data4[index10];
                            tdata5 = this.HistoryMove[index9].Data5[index10];
                          }
                          else if ( VBMath.Rnd() * 100.0 < 50.0 /  this.AreaGroupRound | num12 == 1)
                          {
                            if (alllog)
                              this.AddLog("random/scripted");
                            index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                            if (num7 == index8)
                              tdata1 = 1;
                            if (index8 > 0)
                            {
                              index1 = this.GetRandomAreaNeighbour(index8, num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (index1 > 0)
                              {
                                index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                if (index2 > 0)
                                {
                                  num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                  if (num8 > 0)
                                    tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                }
                              }
                            }
                          }
                          else if ( VBMath.Rnd() * 100.0 < 50.0 / Math.Max(1.0,  this.AreaGroupRound / 2.0))
                          {
                            if (alllog)
                              this.AddLog("copies 1 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            if (index8 > 0)
                            {
                              index1 = this.GetRandomAreaNeighbour(index8, num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (index1 > 0)
                              {
                                index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                if (index2 > 0)
                                {
                                  num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                  if (num8 > 0)
                                    tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                }
                              }
                            }
                          }
                          else if ( VBMath.Rnd() * 100.0 < 50.0 / Math.Max(1.0,  this.AreaGroupRound / 3.0))
                          {
                            if (alllog)
                              this.AddLog("copies 2 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            if (index1 > 0)
                            {
                              index2 = this.GetRandomAreaNeighbour(index1, num7, index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (index2 > 0)
                              {
                                num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                                if (num8 > 0)
                                  tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              }
                            }
                          }
                          else if (random.Next(0, 100) < 50)
                          {
                            if (alllog)
                              this.AddLog("copies 3 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            index2 = this.HistoryMove[index9].Data3[index10];
                            if (index2 > 0)
                            {
                              num8 = this.GetRandomAreaNeighbour(index2, num7, index8, index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                              if (num8 > 0)
                                tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                            }
                          }
                          else
                          {
                            if (alllog)
                              this.AddLog("copies 4 moves from previous");
                            index8 = this.HistoryMove[index9].Data1[index10];
                            index1 = this.HistoryMove[index9].Data2[index10];
                            index2 = this.HistoryMove[index9].Data3[index10];
                            num8 = this.HistoryMove[index9].Data4[index10];
                            if (num8 > 0)
                              tdata5 = this.GetRandomAreaNeighbour(num8, num7, index8, index1, index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          }
                          if (!this.Attacker & random.Next(0, 100) > 90)
                          {
                            index8 = num7;
                            tdata1 = 1;
                            break;
                          }
                          break;
                        }
                        break;
                      }
                      break;
                    }
                  }
                }
                if (num10 == 0 & (Number1 == 1 & this.AreaGroupRound == 1 | Number1 == 2 & this.AreaGroupRound > 1))
                {
                  if (alllog)
                    this.AddLog("give previous round moves: " + this.GroupName[index7]);
                  let mut groupHq: i32 = this.GetGroupHQ(index7);
                  if (groupHq > -1 && this.game.Data.UnitObj[groupHq].AIAttack <= this.AreaCount && this.game.Data.UnitObj[groupHq].AIDefend <= this.AreaCount & this.game.Data.UnitObj[groupHq].AIFollowup <= this.AreaCount)
                  {
                    if (this.game.Data.UnitObj[groupHq].AIAttack > -1)
                    {
                      if (!this.AreaIsExtra[this.game.Data.UnitObj[groupHq].AIAttack])
                      {
                        if (this.GetRegime(this.AreaOwner[this.game.Data.UnitObj[groupHq].AIAttack]) == this.GetGameDataTurn())
                        {
                          if (this.CorpsStartLoc[index7] == this.game.Data.UnitObj[groupHq].AIAttack)
                          {
                            index8 = this.game.Data.UnitObj[groupHq].AIFollowup;
                            if (index8 > -1 && this.AreaIsExtra[index8])
                              index8 = -1;
                            if (index8 == -1)
                              index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                            index1 = this.GetRandomAreaNeighbour(index8, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          }
                          else
                          {
                            index8 = this.game.Data.UnitObj[groupHq].AIAttack;
                            index1 = this.game.Data.UnitObj[groupHq].AIFollowup;
                            if (index1 > -1 && this.AreaIsExtra[index1])
                              index1 = -1;
                            if (index1 == -1)
                              index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                          }
                        }
                        else
                        {
                          index8 = this.game.Data.UnitObj[groupHq].AIAttack;
                          index1 = this.game.Data.UnitObj[groupHq].AIFollowup;
                          if (index1 > -1 && this.AreaIsExtra[index1])
                            index1 = -1;
                          if (index1 == -1)
                            index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        }
                      }
                    }
                    else if (this.game.Data.UnitObj[groupHq].AIDefend > -1 && !this.AreaIsExtra[this.game.Data.UnitObj[groupHq].AIDefend])
                    {
                      if (this.GetRegime(this.AreaOwner[this.game.Data.UnitObj[groupHq].AIDefend]) == this.GetGameDataTurn())
                      {
                        index8 = this.game.Data.UnitObj[groupHq].AIDefend;
                        index1 = this.game.Data.UnitObj[groupHq].AIDefend;
                      }
                      else if (3 == this.game.Data.UnitObj[groupHq].AIAttackStyle)
                      {
                        index8 = this.game.Data.UnitObj[groupHq].AIDefend;
                        index1 = this.game.Data.UnitObj[groupHq].AIAttack;
                        if (index1 > -1 && this.AreaIsExtra[index1])
                          index1 = -1;
                        if (index1 == -1)
                          index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      }
                      else
                      {
                        index8 = this.GetRandomAreaNeighbour(num7, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        index1 = this.GetRandomAreaNeighbour(index8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      }
                    }
                    if (index1 > 0)
                    {
                      index2 = this.GetRandomAreaNeighbour(index1, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      if (index2 > 0)
                      {
                        num8 = this.GetRandomAreaNeighbour(index2, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                        if (num8 > 0)
                          tdata5 = this.GetRandomAreaNeighbour(num8, grp: index7, allowsame: true, tAreaGroup: this.CurrentAreaGroup);
                      }
                    }
                    tdata1 = this.game.Data.UnitObj[groupHq].AIAttackStyle;
                    if (tdata1 < 1)
                      tdata1 = 1;
                  }
                }
                else if (num10 == 0 & Number1 == 1 & this.AreaGroupRound > 1)
                {
                  if (alllog)
                    this.AddLog("from last areagroupround: " + this.GroupName[index7]);
                  let mut nr1: i32 = simpleListArray[this.AreaGroupRound - 1].FindNr(index7);
                  if (nr1 > -1)
                  {
                    index8 = simpleListArray[this.AreaGroupRound - 1].Data1[nr1];
                    index1 = simpleListArray[this.AreaGroupRound - 1].Data2[nr1];
                    index2 = simpleListArray[this.AreaGroupRound - 1].Data3[nr1];
                    num8 = simpleListArray[this.AreaGroupRound - 1].Data4[nr1];
                    tdata5 = simpleListArray[this.AreaGroupRound - 1].Data5[nr1];
                  }
                  let mut nr2: i32 = simpleListArray[this.AreaGroupRound - 1].FindNr(index7 + 99000);
                  if (nr2 > -1)
                    tdata1 = simpleListArray[this.AreaGroupRound - 1].Data1[nr2];
                  let mut nr3: i32 = simpleListArray[this.AreaGroupRound - 1].FindNr(index7 + 199000);
                  if (nr3 > -1)
                    num9 = simpleListArray[this.AreaGroupRound - 1].Data1[nr3];
                }
                if (this.GroupType[index7] > 5)
                  tdata1 = 1;
                if (index8 > -1 & num7 != index8)
                {
                  if (this.AreaOwner[index8] == -1)
                    tdata1 = 3;
                  if (index8 > -1 && this.AreaOwner[index8] == this.game.Data.Turn & index8 != index1)
                  {
                    if (this.AreaOwner[index1] == -1)
                      tdata1 = 3;
                    if (this.AreaOwner[index1] == this.game.Data.Turn && index2 > -1 && this.AreaOwner[index2] == -1)
                      tdata1 = 3;
                  }
                }
                if (index8 == 0)
                  index8 = num7;
                if (index1 == 0)
                  index1 = index8;
                if (index2 == 0)
                  index2 = index1;
                if (num8 == 0)
                  num8 = index2;
                if (tdata5 == 0)
                  tdata5 = num8;
                this.TempGroupTarget[index7] = index8;
                let mut index11: i32 = this.CorpsStartLoc[index7];
                if ((this.AreaSteps[index11, index8] == 0 | this.AreaSteps[index11, index8] > 99) & index11 != index8)
                {
                  if (alllog)
                    this.AddLog("error override. stay put: " + this.GroupName[index7]);
                  index8 = index11;
                  index1 = index11;
                  index2 = index11;
                  num8 = index11;
                  tdata5 = index11;
                  this.TempGroupTarget[index7] = index11;
                }
                if (index11 == index8)
                  tdata1 = 1;
                Straty.Add(index7, 1, index8, index1, index2, num8, tdata5, false);
                Straty.Add(index7 + 99000, 1, tdata1, CheckExistence: false);
              }
            }
            let mut groupCounter3: i32 = this.GroupCounter;
            for (let mut forgroup: i32 = 0; forgroup <= groupCounter3; forgroup += 1)
            {
              if (this.AreaGroup[this.CorpsStartLoc[forgroup]] == this.CurrentAreaGroup)
              {
                let mut highestFuzzyVpGroup: i32 = this.GetHighestFuzzyVPGroup(forgroup);
                Straty.Add(forgroup + 199000, 1, highestFuzzyVpGroup, CheckExistence: false);
              }
            }
            let mut strategyScore: i32 = this.GetStrategyScore( Straty, false,  Number1 /  num3);
            if (alllog)
              this.AddLog("SCORE ====> " + Conversion.Str( strategyScore));
            if (strategyScore != Number2)
            {
              this.HistoryMove[this.HistoryMoveCounter] = Straty;
              this.HistoryScoreList.Add(this.HistoryMoveCounter, strategyScore, CheckExistence: false);
            }
            this += 1.HistoryMoveCounter;
            this.HistoryScoreList.Sort();
            index3 =  Math.Round( random.Next(0, 100) / 100.0 * 0.5 *  this.HistoryScoreList.Counter);
            let mut num14: i32 = this.HistoryScoreList.Id[index3];
            if (this.HistoryScoreList.Counter > 450)
            {
              if (alllog)
                this.AddLog("REMOVING NR " + Conversion.Str( num14) + " with score " + Conversion.Str( this.HistoryScoreList.Weight[index3]));
              this.HistoryScoreList.Remove(num14);
            }
            if (strategyScore > Number2)
            {
              if (alllog)
                this.AddLog("NEW BEST SCORE = " + Conversion.Str( strategyScore));
              this.BestStrategy = Straty;
              Number2 = strategyScore;
            }
            else if (alllog)
              this.AddLog("OLD BEST SCORE = " + Conversion.Str( Number2));
            if (Number1 % 20 == 0)
              this.AddLog(Conversion.Str( Number1) + ") Bestscore=" + Conversion.Str( Number2) + ", CurrentScore = " + Conversion.Str( strategyScore));
          }
          if (!Information.IsNothing( this.BestStrategy))
          {
            let mut counter: i32 = this.BestStrategy.Counter;
            for (let mut index12: i32 = 0; index12 <= counter; index12 += 1)
              simpleListArray[this.AreaGroupRound].Add(this.BestStrategy.Id[index12], this.BestStrategy.Weight[index12], this.BestStrategy.Data1[index12], this.BestStrategy.Data2[index12], this.BestStrategy.Data3[index12], this.BestStrategy.Data4[index12], this.BestStrategy.Data5[index12], false);
          }
          if (this.FullLog)
            this.WriteLog("10_FindBestStrategy_02_arearound" + this.AreaGroupRound.ToString() + "_" + this.CurrentAreaGroup.ToString());
          this.LogCounter = -1;
        }
      }
      if (num2 > 0)
      {
        this.AddLog("START SYSTEMATICAL CORTEX");
        this.CorpsStrategic = new bool[this.GroupCounter + 1];
        let mut bestCapHq: i32 = this.GetBestCapHQ(this.game.Data.Turn);
        airCap: i32;
        if (bestCapHq > -1)
          airCap = this.game.Data.UnitObj[bestCapHq].AirCap;
        bool[] flagArray = new bool[this.GroupCounter + 1];
        let mut num15: i32 = num2;
        for (let mut Number4: i32 = 1; Number4 <= num15; Number4 += 1)
        {
          let mut tid: i32 = -1;
          let mut Number5: i32 = -1;
          let mut Number6: i32 = 0;
          let mut num16: i32 = 1;
          while (num16 == 1)
          {
            num16 = 0;
            SimpleList Straty = SimpleList::new();
            let mut counter: i32 = this.BestStrategy.Counter;
            for (let mut index13: i32 = 0; index13 <= counter; index13 += 1)
              Straty.Add(this.BestStrategy.Id[index13], this.BestStrategy.Weight[index13], this.BestStrategy.Data1[index13], this.BestStrategy.Data2[index13], this.BestStrategy.Data3[index13], this.BestStrategy.Data4[index13], this.BestStrategy.Data5[index13], false);
            if (tid == -1)
              tid += 1;
            let mut nr4: i32 = Straty.FindNr(tid);
            if (nr4 > -1)
            {
              if (Number4 == 1)
                Number6 = 1 + this.AreaSupplyBorderCount[this.CorpsStartLoc[tid]];
              if (Number4 == 2)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data1[nr4]];
              if (Number4 == 3)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data2[nr4]];
              if (Number4 == 4)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data3[nr4]];
              if (Number4 == 5)
                Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data4[nr4]];
              if (Number5 >= Number6)
              {
                tid += 1;
                if (tid <= this.GroupCounter)
                {
                  if (Number4 == 1)
                    Number6 = 1 + this.AreaSupplyBorderCount[this.CorpsStartLoc[tid]];
                  if (Number4 == 2)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data1[nr4]];
                  if (Number4 == 3)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data2[nr4]];
                  if (Number4 == 4)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data3[nr4]];
                  if (Number4 == 5)
                    Number6 = 1 + this.AreaSupplyBorderCount[Straty.Data4[nr4]];
                }
                Number5 = -1;
              }
              if (tid <= this.GroupCounter & nr4 > -1)
              {
                let mut num17: i32 = 0;
                if (this.TempGroupHQ[tid] > -1)
                {
                  let mut historical: i32 = this.game.Data.UnitObj[this.TempGroupHQ[tid]].Historical;
                  if (historical > -1 && this.game.Data.HistoricalUnitObj[historical].TempAttack > -1 | this.game.Data.HistoricalUnitObj[historical].TempDefend > -1)
                    num17 = 1;
                }
                if (num17 == 0 & !(Number4 > 1 & this.CorpsStartLoc[tid] == Straty.Data1[nr4] | Number4 > 2 & Straty.Data2[nr4] == Straty.Data1[nr4]) && !(Number4 > 3 & Straty.Data2[tid] == Straty.Data3[nr4] | Number4 > 4 & Straty.Data3[nr4] == Straty.Data4[nr4]))
                {
                  Number5 += 1;
                  num18: i32;
                  if (Number5 > Number6 - 1 & nr4 > -1)
                  {
                    if (Number4 == 1)
                      bestCapHq = this.CorpsStartLoc[tid];
                    if (Number4 == 2)
                      index3 = Straty.Data1[nr4];
                    if (Number4 == 3)
                      index1 = Straty.Data2[nr4];
                    if (Number4 == 4)
                      index2 = Straty.Data3[nr4];
                    if (Number4 == 5)
                      num18 = Straty.Data4[nr4];
                    if (Number4 == 1)
                      tdata1 = 1;
                  }
                  else
                  {
                    if (Number4 == 1)
                      bestCapHq = this.AreaSupplyBorder[this.CorpsStartLoc[tid], Number5];
                    if (Number4 >= 2)
                      nr4 = Straty.FindNr(tid);
                    if (nr4 > -1)
                    {
                      if (Number4 == 2)
                        index3 = this.AreaSupplyBorder[Straty.Data1[nr4], Number5];
                      if (Number4 == 3)
                        index1 = this.AreaSupplyBorder[Straty.Data2[nr4], Number5];
                      if (Number4 == 4)
                        index2 = this.AreaSupplyBorder[Straty.Data2[nr4], Number5];
                      if (Number4 == 5)
                        num18 = this.AreaSupplyBorder[Straty.Data2[nr4], Number5];
                    }
                    if (Number4 == 1)
                      tdata1 = 3;
                  }
                  if (nr4 > -1)
                  {
                    if (Number4 == 1)
                    {
                      Straty.Data1[nr4] = bestCapHq;
                      Straty.Data2[nr4] = bestCapHq;
                      Straty.Data3[nr4] = bestCapHq;
                      Straty.Data4[nr4] = bestCapHq;
                      Straty.Data5[nr4] = bestCapHq;
                    }
                    else if (Number4 == 2)
                    {
                      Straty.Data2[nr4] = index3;
                      Straty.Data3[nr4] = index3;
                      Straty.Data4[nr4] = index3;
                      Straty.Data5[nr4] = index3;
                    }
                    else if (Number4 == 3)
                    {
                      Straty.Data3[nr4] = index1;
                      Straty.Data4[nr4] = index1;
                      Straty.Data5[nr4] = index1;
                    }
                    else if (Number4 == 4)
                    {
                      Straty.Data4[nr4] = index2;
                      Straty.Data5[nr4] = index2;
                    }
                    else if (Number4 == 5)
                      Straty.Data5[nr4] = num18;
                    if (Number4 == 1)
                    {
                      let mut nr5: i32 = Straty.FindNr(tid + 99000);
                      if (nr5 > -1)
                        Straty.Data1[nr5] = tdata1;
                    }
                    this.CurrentAreaGroup = 1;
                    this.CorpsStrategic = new bool[this.GroupCounter + 1];
                    let mut num19: i32 =  Math.Round( airCap / 50.0);
                    if ( VBMath.Rnd() < 0.5)
                    {
                      let mut groupCounter: i32 = this.GroupCounter;
                      for (let mut index14: i32 = 0; index14 <= groupCounter; index14 += 1)
                        this.CorpsStrategic[index14] = flagArray[index14];
                      num19 = -1;
                    }
                    let mut num20: i32 = 0;
                    let mut num21: i32 =  Math.Round( (VBMath.Rnd() * 99f));
                    if ( VBMath.Rnd() < 0.5)
                    {
                      while (num20 < num21)
                      {
                        num20 += 1;
                        let mut index15: i32 =  Math.Round( Conversion.Int(VBMath.Rnd() *  (this.GroupCounter + 1)));
                        if (this.corpsstartStrength[index15] < num19 & this.GroupType[index15] <= 5)
                        {
                          this.CorpsStrategic[index15] = true;
                          num19 -= this.corpsstartStrength[index15];
                        }
                      }
                    }
                    let mut strategyScore: i32 = this.GetStrategyScore( Straty, false,  Number1 /  num3);
                    if (strategyScore > Number2)
                    {
                      this.AddLog("GROUP " + this.GroupName[tid] + " MOVE = " + Conversion.Str( Number5) + "/" + Conversion.Str( Number6));
                      this.AddLog(Conversion.Str( Number1) + ") New Bestscore=" + Conversion.Str( Number2) + ", CurrentScore = " + Conversion.Str( strategyScore));
                      this.BestStrategy = Straty;
                      Number2 = strategyScore;
                      let mut groupCounter: i32 = this.GroupCounter;
                      for (let mut index16: i32 = 0; index16 <= groupCounter; index16 += 1)
                      {
                        if (this.CorpsStrategic[index16])
                          this.AddLog("GROUP " + this.GroupName[index16] + " is STRATEGIC");
                        flagArray[index16] = this.CorpsStrategic[index16];
                      }
                    }
                    if (Number5 == 0 & tid % 5 == 0)
                    {
                      this.game.EditObj.AIProgressMax = this.GroupCounter;
                      this.game.EditObj.AIProgressNow = tid;
                      this.game.EditObj.TempAIString = this.AreaGroupCount <= 1 ? "Systematical finetuning. Round " + Conversion.Str( Number4) : "Systematical finetuning. Round " + Conversion.Str( Number4);
                    }
                    num16 = 1;
                  }
                }
              }
            }
          }
        }
        let mut groupCounter4: i32 = this.GroupCounter;
        for (let mut index17: i32 = 0; index17 <= groupCounter4; index17 += 1)
          this.CorpsStrategic[index17] = flagArray[index17];
        simpleListArray[this.AreaGroupRound] = SimpleList::new();
        let mut counter1: i32 = this.BestStrategy.Counter;
        for (let mut index18: i32 = 0; index18 <= counter1; index18 += 1)
          simpleListArray[this.AreaGroupRound].Add(this.BestStrategy.Id[index18], this.BestStrategy.Weight[index18], this.BestStrategy.Data1[index18], this.BestStrategy.Data2[index18], this.BestStrategy.Data3[index18], this.BestStrategy.Data4[index18], this.BestStrategy.Data5[index18], false);
        if (this.FullLog)
          this.WriteLog("10_FindBestStrategy_03_systematical_cortex");
        this.LogCounter = -1;
      }
      this.BestStrategy = SimpleList::new();
      if (!Information.IsNothing( simpleListArray[this.AreaGroupRound]))
      {
        let mut counter: i32 = simpleListArray[this.AreaGroupRound].Counter;
        for (let mut index19: i32 = 0; index19 <= counter; index19 += 1)
          this.BestStrategy.Add(simpleListArray[this.AreaGroupRound].Id[index19], simpleListArray[this.AreaGroupRound].Weight[index19], simpleListArray[this.AreaGroupRound].Data1[index19], simpleListArray[this.AreaGroupRound].Data2[index19], simpleListArray[this.AreaGroupRound].Data3[index19], simpleListArray[this.AreaGroupRound].Data4[index19], simpleListArray[this.AreaGroupRound].Data5[index19], false);
      }
      this.CurrentAreaGroup = 1;
    }

    pub fn SetFindBestStrategyStuff(bool tlog)
    {
      int[] numArray = new int[this.AreaCount + 1];
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("SET FIND BEST STRATEGY STUFF");
      }
      this.Meeting = false;
      this.Attacker = this.GetRegime(this.GetLargestArmy()) == this.GetGameDataTurn();
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 1)
        this.Attacker = true;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 2)
        this.Attacker = false;
      if (this.game.Data.RegimeObj[this.GetGameDataTurn()].AIStance == 3)
      {
        this.Attacker = true;
        this.Meeting = true;
      }
      if (tlog)
        this.AddLog("Attacker = " + this.Attacker.ToString() + ", Meeting = " + this.Meeting.ToString());
      this.AreaOwner = new int[this.AreaCount + 1];
      let mut areaCount1: i32 = this.AreaCount;
      for (let mut index: i32 = 1; index <= areaCount1; index += 1)
        this.AreaOwner[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].Regime;
      this.CorpsStrategic = new bool[this.GroupCounter + 1];
      this.CorpsPowerLeft = new int[this.GroupCounter + 1];
      this.GetStrategyScore_Prepare_TroopsPlace();
      this.AreaGroup = new int[this.AreaCount + 1];
      let mut areaCount2: i32 = this.AreaCount;
      for (let mut index: i32 = 0; index <= areaCount2; index += 1)
        this.AreaGroup[index] = 1;
      this.TempTotVP = this.GetTotalVPonMap();
      this.TempCurVP = this.GetStartVPonMap();
      if (tlog)
        this.AddLog("TempTotalVP = " + this.TempTotVP.ToString() + " , TempStartVP= " + this.TempCurVP.ToString());
      this.TempPowerAbove = SimpleList::new();
      let mut mapWidth: i32 = this.game.Data.MapObj[0].MapWidth;
      for (let mut index1: i32 = 0; index1 <= mapWidth; index1 += 1)
      {
        let mut mapHeight: i32 = this.game.Data.MapObj[0].MapHeight;
        for (let mut index2: i32 = 0; index2 <= mapHeight; index2 += 1)
        {
          if (this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerAbove > 0)
          {
            let mut tid: i32 = this.AreaMatrixNarrow[index1, index2];
            if (tid > 0 && numArray[tid] == 0)
            {
              numArray[tid] = 1;
              this.TempPowerAbove.Add(tid, 1, this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerAbove, this.game.Data.MapObj[0].HexObj[index1, index2].TempPowerMulti);
            }
          }
        }
      }
    }

    pub fn SetInitialAreaGroups(bool tlog)
    {
      this.AreaGroup = new int[this.AreaCount + 1];
      int[] numArray1 = new int[this.AreaCount + 1];
      this.AreaGroupRound = 0;
      this.CurrentAreaGroup = 0;
      this.AreaGroupCount = 0;
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("INITIAL AREAGROUPS SETTING : ");
      }
      if ( this.game.Data.RuleVar[267] > 0.0)
      {
        if (tlog)
          this.AddLog("Predefined areagroups are used (rulevar 267)");
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 1; index <= areaCount; index += 1)
        {
          if (this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[ Math.Round( this.game.Data.RuleVar[267])] > 0)
          {
            if (this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[ Math.Round( this.game.Data.RuleVar[267])] > this.AreaGroupCount)
              this.AreaGroupCount = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[ Math.Round( this.game.Data.RuleVar[267])];
            this.AreaGroup[index] = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index].x, this.AreaCenter[index].y].AreaCode[ Math.Round( this.game.Data.RuleVar[267])];
          }
          else
            this.AreaGroup[index] = 0;
        }
      }
      if ( this.game.Data.RuleVar[267] < 1.0)
      {
        if (tlog)
          this.AddLog("Dynamic areagroups are used. Created on the fly.");
        let mut num1: i32 = 1;
        let mut num2: i32 = 4;
        let mut num3: i32 = 0;
        while (num1 == 1)
        {
          num1 = 0;
          SimpleList simpleList = SimpleList::new();
          let mut areaCount1: i32 = this.AreaCount;
          for (let mut index1: i32 = 1; index1 <= areaCount1; index1 += 1)
          {
            if (this.GetRegime(this.AreaOwner[index1]) == this.GetGameDataTurn() & this.AreaGroup[index1] == 0)
            {
              let mut areaCount2: i32 = this.AreaCount;
              for (let mut index2: i32 = 1; index2 <= areaCount2; index2 += 1)
              {
                if (this.GetAreaNarrowBorderSteps(index1, index2, 1) == 1 && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.AreaOwner[index2]) & this.AreaGroup[index2] == 0)
                {
                  simpleList.Add(index1, 0);
                  simpleList.Add(index2, 0);
                  num1 = 1;
                  num3 += 1;
                  this.AreaGroupCount = num3;
                  this.AreaGroup[index1] = num3;
                  this.AreaGroup[index2] = num3;
                  break;
                }
              }
              if (num1 == 1)
              {
                let mut num4: i32 = 1;
                let mut maxstep: i32 = 1;
                while (num4 == 1)
                {
                  num4 = 0;
                  maxstep += 1;
                  if (maxstep <= num2)
                  {
                    let mut areaCount3: i32 = this.AreaCount;
                    for (let mut index3: i32 = 1; index3 <= areaCount3; index3 += 1)
                    {
                      if (this.AreaGroup[index3] == 0 && simpleList.FindNr(index3) == -1 && this.GetAreaNarrowBorderSteps(index1, index3, maxstep) <= maxstep)
                      {
                        let mut num5: i32 = 1;
                        let mut counter: i32 = simpleList.Counter;
                        for (let mut index4: i32 = 0; index4 <= counter; index4 += 1)
                        {
                          if (this.GetAreaNarrowBorderSteps(index3, simpleList.Id[index4], maxstep) > maxstep)
                            num5 = 0;
                        }
                        if (num5 == 1)
                        {
                          num4 = 1;
                          simpleList.Add(index3, 0);
                          this.AreaGroup[index3] = num3;
                        }
                      }
                    }
                  }
                }
                break;
              }
            }
          }
        }
        if (this.AreaGroupCount == 0)
        {
          let mut areaCount: i32 = this.AreaCount;
          for (let mut index: i32 = 1; index <= areaCount; index += 1)
          {
            this.AreaGroup[index] = 1;
            this.AreaGroupCount = 1;
          }
        }
        int[] numArray2 = new int[this.AreaCount + 1];
        let mut areaCount4: i32 = this.AreaCount;
        for (let mut from: i32 = 1; from <= areaCount4; from += 1)
        {
          if (this.GetRegime(this.AreaOwner[from]) != this.GetGameDataTurn() && this.AreaGroup[from] == 0)
          {
            SimpleList simpleList = SimpleList::new();
            let mut areaCount5: i32 = this.AreaCount;
            for (let mut index: i32 = 1; index <= areaCount5; index += 1)
            {
              if (this.AreaGroup[index] > 0 & numArray2[index] == 0 && this.GetAreaNarrowBorderSteps(from, index, 3) <= 3)
                simpleList.Add(index, this.GetAreaNarrowBorderSteps(from, index, 3));
            }
            simpleList.Sort();
            if (simpleList.Counter > -1)
            {
              this.AreaGroup[from] = this.AreaGroup[simpleList.Id[0]];
              numArray2[from] = 1;
            }
          }
        }
        int[] numArray3 = new int[this.AreaCount + 1];
        let mut areaCount6: i32 = this.AreaCount;
        for (let mut index: i32 = 1; index <= areaCount6; index += 1)
        {
          if (this.AreaGroup[index] == 0)
          {
            SimpleList simpleList = SimpleList::new();
            let mut areaCount7: i32 = this.AreaCount;
            for (let mut tid: i32 = 1; tid <= areaCount7; tid += 1)
            {
              if (this.AreaGroup[tid] > 0 & numArray3[tid] == 0)
                simpleList.Add(tid, this.AreaSteps[index, tid]);
            }
            simpleList.Sort();
            if (simpleList.Counter > -1)
            {
              this.AreaGroup[index] = this.AreaGroup[simpleList.Id[0]];
              numArray3[index] = 1;
            }
          }
        }
      }
      if (!tlog)
        return;
      let mut areaGroupCount: i32 = this.AreaGroupCount;
      for (let mut Number: i32 = 0; Number <= areaGroupCount; Number += 1)
      {
        this.AddLog("");
        this.AddLog("AREAGROUP " + Conversion.Str( Number));
        let mut areaCount: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount; nr += 1)
        {
          if (this.AreaGroup[nr] == Number)
            this.AddLog("-" + this.GetAreaName(nr));
        }
      }
    }

    pub fn MergeAreaGroups()
    {
      let mut num1: i32 = 0;
      while (num1 < this.AreaGroupCount)
      {
        num1 += 1;
        SimpleList simpleList = SimpleList::new();
        let mut areaGroupCount: i32 = this.AreaGroupCount;
        for (let mut tid: i32 = 1; tid <= areaGroupCount; tid += 1)
        {
          if (num1 != tid)
          {
            let mut areaCount1: i32 = this.AreaCount;
            for (let mut index1: i32 = 1; index1 <= areaCount1; index1 += 1)
            {
              if (this.AreaGroup[index1] == num1)
              {
                let mut areaCount2: i32 = this.AreaCount;
                for (let mut index2: i32 = 1; index2 <= areaCount2; index2 += 1)
                {
                  if (this.AreaGroup[index2] == tid)
                  {
                    if (this.AreaNarrowBorder[index1, index2] > 0)
                    {
                      let mut nr: i32 = simpleList.FindNr(tid);
                      let mut tweight: i32 = 100;
                      if (tid < num1)
                        tweight = 10;
                      if (nr == -1)
                      {
                        simpleList.Add(tid, tweight);
                      }
                      else
                      {
                        int[] weight = simpleList.Weight;
                        int[] numArray = weight;
                        let mut index3: i32 = nr;
                        let mut index4: i32 = index3;
                        let mut num2: i32 = weight[index3] + tweight;
                        numArray[index4] = num2;
                      }
                    }
                    if (this.AreaBroadBorder[index1, index2] > 0)
                    {
                      let mut nr: i32 = simpleList.FindNr(tid);
                      let mut tweight: i32 = 20;
                      if (tid < num1)
                        tweight = 2;
                      if (nr == -1)
                      {
                        simpleList.Add(tid, tweight);
                      }
                      else
                      {
                        int[] weight = simpleList.Weight;
                        int[] numArray = weight;
                        let mut index5: i32 = nr;
                        let mut index6: i32 = index5;
                        let mut num3: i32 = weight[index5] + tweight;
                        numArray[index6] = num3;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (simpleList.Counter > -1)
        {
          simpleList.Sort();
          let mut num4: i32 = simpleList.Id[simpleList.Counter];
          let mut num5: i32 = num1;
          if (num5 > this.AreaGroupCount - 1)
            num5 = this.AreaGroupCount - 1;
          let mut areaCount3: i32 = this.AreaCount;
          for (let mut index7: i32 = 1; index7 <= areaCount3; index7 += 1)
          {
            if (this.AreaGroup[index7] == num4)
              this.AreaGroup[index7] = num5;
            if (this.AreaGroup[index7] > num1)
            {
              int[] areaGroup = this.AreaGroup;
              int[] numArray = areaGroup;
              let mut index8: i32 = index7;
              let mut index9: i32 = index8;
              let mut num6: i32 = areaGroup[index8] - 1;
              numArray[index9] = num6;
            }
          }
          --this.AreaGroupCount;
          if (this.AreaGroupCount <= 1)
          {
            let mut areaCount4: i32 = this.AreaCount;
            for (let mut index: i32 = 1; index <= areaCount4; index += 1)
              this.AreaGroup[index] = 1;
          }
        }
        else
        {
          this.AreaGroupCount = 1;
          let mut areaCount: i32 = this.AreaCount;
          for (let mut index: i32 = 1; index <= areaCount; index += 1)
            this.AreaGroup[index] = 1;
        }
      }
      this.AddLog("AFTER MERGE - AREAGROUPS INFO : ");
      let mut areaGroupCount1: i32 = this.AreaGroupCount;
      for (let mut Number: i32 = 0; Number <= areaGroupCount1; Number += 1)
      {
        this.AddLog("AREAGROUP " + Conversion.Str( Number));
        let mut areaCount: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount; nr += 1)
        {
          if (this.AreaGroup[nr] == Number)
            this.AddLog("-" + this.GetAreaName(nr));
        }
      }
      this.WriteLog();
    }

    pub fn SetAreaExtraVP(bool tlog)
    {
      this.AreaExtraVP = new int[this.AreaCount + 1];
      SimpleList[] simpleListArray = new SimpleList[this.AreaCount + 1];
      int[] numArray1 = new int[this.AreaCount + 1];
      bool[] flagArray1 = new bool[this.AreaCount + 1];
      bool[] flagArray2 = new bool[this.AreaCount + 1];
      int[] numArray2 = new int[this.AreaCount + 1];
      this.OldExtraVP = (int[]) Utils.CopyArray((Array) this.OldExtraVP, (Array) new int[this.AreaCount + 1]);
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("SET AREA EXTRA VP");
        this.AddLog("");
      }
      if (!this.Attacker)
      {
        let mut areaCount: i32 = this.AreaCount;
        for (let mut index: i32 = 1; index <= areaCount; index += 1)
        {
          this.AreaExtraVP[index] = 0;
          simpleListArray[index] = SimpleList::new();
        }
      }
      else
      {
        if (this.AreaGroupRound > 1)
        {
          let mut areaCount: i32 = this.AreaCount;
          for (let mut index: i32 = 1; index <= areaCount; index += 1)
          {
            simpleListArray[index] = SimpleList::new();
            this.AreaExtraVP[index] = this.AreaGroup[index] != this.CurrentAreaGroup ? 0 :  Math.Round( this.OldExtraVP[index] / 3.0);
          }
        }
        else
        {
          let mut areaCount: i32 = this.AreaCount;
          for (let mut index: i32 = 1; index <= areaCount; index += 1)
          {
            this.AreaExtraVP[index] = 0;
            simpleListArray[index] = SimpleList::new();
          }
        }
        let mut areaCount1: i32 = this.AreaCount;
        for (let mut index1: i32 = 1; index1 <= areaCount1; index1 += 1)
        {
          let mut num1: i32 = this.game.Data.MapObj[0].HexObj[this.AreaCenter[index1].x, this.AreaCenter[index1].y].VP + this.game.Data.RegimeObj[this.GetGameDataTurn()].AIVP[0].Value[this.AreaCenter[index1].x, this.AreaCenter[index1].y];
          if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index1].x, this.AreaCenter[index1].y].Regime) && this.AreaGroup[index1] != this.CurrentAreaGroup & num1 > 0)
          {
            int[] numArray3 = new int[this.AreaCount + 1];
            bool[] flagArray3 = new bool[this.AreaCount + 1];
            bool[] flagArray4 = new bool[this.AreaCount + 1];
            let mut num2: i32 = 1;
            let mut num3: i32 = 0;
            numArray3[index1] = num1;
            flagArray3[index1] = true;
            flagArray4[index1] = true;
            while (num2 == 1 & num3 == 0)
            {
              num2 = 0;
              let mut areaCount2: i32 = this.AreaCount;
              for (let mut index2: i32 = 1; index2 <= areaCount2; index2 += 1)
              {
                if (flagArray3[index2])
                {
                  let mut num4: i32 = 0;
                  let mut areaCount3: i32 = this.AreaCount;
                  for (let mut index3: i32 = 1; index3 <= areaCount3; index3 += 1)
                  {
                    if (this.AreaGroup[index3] == this.CurrentAreaGroup && this.AreaNarrowBorder[index2, index3] > 0)
                      num4 += 1;
                  }
                  if (num4 > 0)
                  {
                    let mut num5: i32 = Math.Max( Math.Round(Conversion.Int( num1 /  num4)), 1);
                    let mut areaCount4: i32 = this.AreaCount;
                    for (let mut index4: i32 = 1; index4 <= areaCount4; index4 += 1)
                    {
                      if (this.AreaGroup[index4] == this.CurrentAreaGroup && this.AreaNarrowBorder[index2, index4] > 0 && num5 > this.AreaExtraVP[index4])
                      {
                        this.AreaExtraVP[index4] = num5;
                        numArray2[index4] = index1;
                      }
                    }
                    num3 = 1;
                    break;
                  }
                  let mut areaCount5: i32 = this.AreaCount;
                  for (let mut index5: i32 = 1; index5 <= areaCount5; index5 += 1)
                  {
                    if (!flagArray4[index5] & !flagArray3[index5] && this.AreaNarrowBorder[index2, index5] > 0)
                    {
                      if (this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index2].x, this.AreaCenter[index2].y].Regime) == this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.Turn, this.game.Data.MapObj[0].HexObj[this.AreaCenter[index5].x, this.AreaCenter[index5].y].Regime))
                      {
                        flagArray3[index5] = true;
                        num2 = 1;
                      }
                      else
                        index5 = index5;
                    }
                  }
                  flagArray3[index2] = false;
                  flagArray4[index2] = true;
                }
              }
            }
          }
        }
        if (!tlog)
          return;
        let mut areaCount6: i32 = this.AreaCount;
        for (let mut nr: i32 = 1; nr <= areaCount6; nr += 1)
        {
          if (this.AreaExtraVP[nr] > this.OldExtraVP[nr])
            this.OldExtraVP[nr] = this.AreaExtraVP[nr];
          this.AddLog(this.GetAreaName(nr) + " => ExtraVP= " + this.AreaExtraVP[nr].ToString() + ", OldExtraVP = " + this.OldExtraVP[nr].ToString());
        }
      }
    }

    pub fn ImplementBestStrategy(bool tlog)
    {
      this.CorpsSource = new int[this.GroupCounter + 1];
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("IMPLEMENT BEST STRATEGY");
        this.AddLog("");
      }
      let mut groupCounter1: i32 = this.GroupCounter;
      for (let mut index1: i32 = 0; index1 <= groupCounter1; index1 += 1)
      {
        this.TempGroupHQ[index1] = this.GetGroupHQ(index1);
        if (this.TempGroupHQ[index1] > -1)
        {
          if (tlog)
          {
            this.AddLog("");
            if (tlog)
              this.AddLog(this.GroupName[index1] + ":");
          }
          let mut nr1: i32 = this.BestStrategy.FindNr(index1);
          if (nr1 > -1)
          {
            let mut unitCounter1: i32 = this.game.Data.UnitCounter;
            for (let mut index2: i32 = 0; index2 <= unitCounter1; index2 += 1)
            {
              if (this.game.Data.UnitObj[index2].PreDef == -1 && this.game.Data.UnitObj[index2].X > -1 & this.game.Data.UnitObj[index2].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index2].Regime) == this.GetGameDataTurn())
              {
                this.game.Data.UnitObj[index2].AIDefend = -1;
                this.game.Data.UnitObj[index2].AIAttack = -1;
                this.game.Data.UnitObj[index2].AIFollowup = -1;
                this.game.Data.UnitObj[index2].AIFallback = -1;
                this.game.Data.UnitObj[index2].AIRightFlank = -1;
                this.game.Data.UnitObj[index2].AILeftFlank = -1;
              }
            }
            let mut groupHq1: i32 = this.GetGroupHQ(index1);
            Coordinate coordinate;
            num1: i32;
            if (groupHq1 > -1)
            {
              let mut nr2: i32 = -1;
              coordinate.onmap = true;
              coordinate.x = this.game.Data.UnitObj[groupHq1].X;
              coordinate.y = this.game.Data.UnitObj[groupHq1].Y;
              let mut startArea: i32 = this.GetStartArea(index1);
              this.CorpsStartLoc[index1] = startArea;
              if (startArea > 0 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[startArea].x, this.AreaCenter[startArea].y].Regime), this.GetGameDataTurn()))
              {
                nr2 = startArea;
                if (tlog)
                  this.AddLog("CorpsStartLoc is friendly = " + this.GetAreaName(nr2));
              }
              if (nr2 == -1)
              {
                coordinate.onmap = true;
                let mut groupHq2: i32 = this.GetGroupHQ(index1);
                coordinate.x = this.game.Data.UnitObj[groupHq2].X;
                coordinate.y = this.game.Data.UnitObj[groupHq2].Y;
                for (; nr2 == -1 & coordinate.onmap; coordinate = this.SupplyMatrixPrognosisCameFrom[coordinate.x, coordinate.y])
                {
                  let mut index3: i32 = this.AreaMatrixWide[coordinate.x, coordinate.y];
                  if (index3 > 0 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index3].x, this.AreaCenter[index3].y].Regime), this.GetGameDataTurn()))
                  {
                    nr2 = index3;
                    if (tlog)
                      this.AddLog("First Friendly Area we can trace SupplyMatrixPrognosisCameFrom came from: " + this.GetAreaName(nr2));
                  }
                }
              }
              if (nr2 == -1)
              {
                let mut num2: i32 = this.AreaMatrixWide[coordinate.x, coordinate.y];
                if (num2 > 0)
                {
                  nr2 = num2;
                  if (tlog)
                    this.AddLog("Just set to current AreaMatrixWide = " + this.GetAreaName(nr2));
                }
              }
              if (nr2 > -1)
              {
                let mut x: i32 = coordinate.x;
                let mut y: i32 = coordinate.y;
                let mut unitCounter2: i32 = this.game.Data.UnitCounter;
                for (let mut index4: i32 = 0; index4 <= unitCounter2; index4 += 1)
                {
                  if (this.game.Data.UnitObj[index4].X > -1 & this.game.Data.UnitObj[index4].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index4].Regime) == this.GetGameDataTurn())
                    this.game.Data.UnitObj[index4].AIDefend = nr2;
                }
                num1 = -1;
              }
              else if (tlog)
                this.AddLog("Defend has not been set.");
            }
            let mut num3: i32 = 0;
            let mut groupHq3: i32 = this.GetGroupHQ(index1);
            let mut num4: i32 = 5;
            if (this.game.Data.UnitObj[groupHq3].AIAttackStyle == 2)
              ;
            if (this.game.Data.UnitObj[groupHq3].AIAttackStyle == 1)
              num4 = 3;
            let mut num5: i32 = num4;
            for (let mut index5: i32 = 1; index5 <= num5; index5 += 1)
            {
              if (tlog)
                this.AddLog("For-Next Step " + index5.ToString() + "/" + num4.ToString());
              let mut nr3: i32 = -1;
              let mut nr4: i32 = -1;
              let mut nr5: i32 = -1;
              if (index5 == 1)
              {
                nr3 = this.BestStrategy.Data1[nr1];
                nr4 = this.BestStrategy.Data2[nr1];
                nr5 = this.CorpsStartLoc[index1];
              }
              if (index5 == 1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data1[nr1])
                num4 = 6;
              if (index5 == 2)
              {
                nr3 = this.BestStrategy.Data2[nr1];
                nr4 = this.BestStrategy.Data3[nr1];
                nr5 = this.BestStrategy.Data1[nr1];
              }
              if (index5 == 2 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data2[nr1])
                num4 = 6;
              if (index5 == 3)
              {
                nr3 = this.BestStrategy.Data3[nr1];
                nr4 = this.BestStrategy.Data4[nr1];
                nr5 = this.BestStrategy.Data2[nr1];
              }
              if (index5 == 3 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data3[nr1])
                num4 = 6;
              if (index5 == 4)
              {
                nr3 = this.BestStrategy.Data4[nr1];
                nr4 = this.BestStrategy.Data5[nr1];
                nr5 = this.BestStrategy.Data3[nr1];
              }
              if (index5 == 4 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data4[nr1])
                num4 = 6;
              if (index5 == 5)
              {
                nr3 = this.BestStrategy.Data5[nr1];
                nr4 = -1;
                nr5 = this.BestStrategy.Data4[nr1];
              }
              if (index5 == 1 & nr3 == this.CorpsStartLoc[index1])
              {
                let mut unitCounter3: i32 = this.game.Data.UnitCounter;
                for (let mut index6: i32 = 0; index6 <= unitCounter3; index6 += 1)
                {
                  if (this.game.Data.UnitObj[index6].PreDef == -1 && this.game.Data.UnitObj[index6].X > -1 & this.game.Data.UnitObj[index6].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index6].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index6].AIAttack = -1;
                    this.game.Data.UnitObj[index6].AIFollowup = -1;
                  }
                }
                num3 = 1;
                if (tlog)
                  this.AddLog("FIRST Target Area == CorpsStartLoc => Pure defensive. No Attack or Followup.");
                if (tlog)
                {
                  this.AddLog("Exit For");
                  break;
                }
                break;
              }
              if (nr3 == nr4 & this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr3].x, this.AreaCenter[nr3].y].Regime), this.GetGameDataTurn()))
              {
                let mut unitCounter4: i32 = this.game.Data.UnitCounter;
                for (let mut index7: i32 = 0; index7 <= unitCounter4; index7 += 1)
                {
                  if (this.game.Data.UnitObj[index7].PreDef == -1 && this.game.Data.UnitObj[index7].X > -1 & this.game.Data.UnitObj[index7].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index7].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index7].AIDefend = nr3;
                    this.game.Data.UnitObj[index7].AIAttack = -1;
                    this.game.Data.UnitObj[index7].AIFollowup = -1;
                  }
                }
                if (tlog)
                  this.AddLog("Current step Target == Next step Target & FRIENDLY AREA => defensive on this target.");
                if (tlog)
                  this.AddLog("Exit For");
                num3 = 1;
                break;
              }
              if (nr3 > 0 && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr3].x, this.AreaCenter[nr3].y].Regime), this.GetGameDataTurn()))
              {
                let mut unitCounter5: i32 = this.game.Data.UnitCounter;
                for (let mut index8: i32 = 0; index8 <= unitCounter5; index8 += 1)
                {
                  if (this.game.Data.UnitObj[index8].PreDef == -1 && this.game.Data.UnitObj[index8].X > -1 & this.game.Data.UnitObj[index8].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index8].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index8].AIFollowup = -1;
                    if (tlog)
                      this.AddLog("A target area thats enemy");
                    if (nr4 > -1 && !this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[nr3].x, this.AreaCenter[nr3].y].Regime), this.GetGameDataTurn()))
                    {
                      this.game.Data.UnitObj[index8].AIFollowup = nr4;
                      if (tlog)
                        this.AddLog("Set follow up to next target = " + this.GetAreaName(nr4));
                    }
                    this.game.Data.UnitObj[index8].AIAttack = nr3;
                    this.game.Data.UnitObj[index8].AIDefend = nr5;
                    if (tlog)
                      this.AddLog("Set attack to current target = " + this.GetAreaName(nr3));
                    if (tlog)
                      this.AddLog("Set defend to corps location = " + this.GetAreaName(nr5));
                  }
                }
                num3 = 1;
                if (tlog)
                {
                  this.AddLog("Exit För");
                  break;
                }
                break;
              }
            }
            if (num3 == 0)
            {
              if (tlog)
                this.AddLog("Not found yet... but must be only friendly targets in list");
              let mut nr6: i32 = this.BestStrategy.Data5[nr1];
              if (tlog)
                this.AddLog("Move Target step 5: " + this.GetAreaName(nr6));
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data4[nr1])
              {
                nr6 = this.BestStrategy.Data4[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data4[nr1];
                if (tlog)
                  this.AddLog("Move Target step 4: " + this.GetAreaName(nr6));
              }
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data3[nr1])
              {
                nr6 = this.BestStrategy.Data3[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data3[nr1];
                if (tlog)
                  this.AddLog("Move Target step 3: " + this.GetAreaName(nr6));
              }
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data2[nr1])
              {
                nr6 = this.BestStrategy.Data2[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data2[nr1];
                if (tlog)
                  this.AddLog("Move Target step 2: " + this.GetAreaName(nr6));
              }
              if (nr6 > -1 & this.CorpsFirstAreaBattle[index1] == this.BestStrategy.Data1[nr1])
              {
                nr6 = this.BestStrategy.Data1[nr1];
                if (tlog)
                  this.AddLog("First battle spotted in: " + this.GetAreaName(nr6));
              }
              if (nr6 == -1)
              {
                nr6 = this.BestStrategy.Data1[nr1];
                if (tlog)
                  this.AddLog("Move Target step 1: " + this.GetAreaName(nr6));
              }
              if (nr6 > 0)
              {
                let mut unitCounter6: i32 = this.game.Data.UnitCounter;
                for (let mut index9: i32 = 0; index9 <= unitCounter6; index9 += 1)
                {
                  if (this.game.Data.UnitObj[index9].PreDef == -1 && this.game.Data.UnitObj[index9].X > -1 & this.game.Data.UnitObj[index9].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index9].Regime) == this.GetGameDataTurn())
                  {
                    this.game.Data.UnitObj[index9].AIFallback = -1;
                    this.game.Data.UnitObj[index9].AIDefend = nr6;
                    this.game.Data.UnitObj[index9].AIAttack = -1;
                    if (tlog)
                      this.AddLog("attack=-1 and defend has been set to: " + this.GetAreaName(nr6));
                    num1 = 1;
                  }
                }
              }
            }
            let mut unitCounter7: i32 = this.game.Data.UnitCounter;
            for (let mut index10: i32 = 0; index10 <= unitCounter7; index10 += 1)
            {
              if (this.game.Data.UnitObj[index10].PreDef == -1 && this.game.Data.UnitObj[index10].X > -1 & this.game.Data.UnitObj[index10].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index10].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index10].AIAttack > -1 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.game.Data.UnitObj[index10].AIAttack].x, this.AreaCenter[this.game.Data.UnitObj[index10].AIAttack].y].Regime), this.GetGameDataTurn()))
              {
                if (tlog)
                  this.AddLog("Error found. Attacking friendly. Attack set to -1, Defend to " + this.GetAreaName(this.game.Data.UnitObj[index10].AIAttack));
                this.game.Data.UnitObj[index10].AIDefend = this.game.Data.UnitObj[index10].AIAttack;
                this.game.Data.UnitObj[index10].AIAttack = -1;
                this.game.Data.UnitObj[index10].AIFollowup = -1;
              }
            }
            if (tlog)
              this.AddLog("finding fallback...");
            if (Operators.CompareString(this.GroupName[index1], "6th Army", false) == 0)
              index1 = index1;
            let mut groupHq4: i32 = this.GetGroupHQ(index1);
            if (groupHq4 > -1 && this.game.Data.UnitObj[groupHq4].AIDefend > -1)
            {
              coordinate.onmap = true;
              coordinate.x = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].x;
              coordinate.y = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].y;
              let mut nr7: i32 = -1;
              let mut aiDefend: i32 = this.game.Data.UnitObj[groupHq4].AIDefend;
              for (; nr7 == -1 & coordinate.onmap; coordinate = this.SupplyMatrixRealCameFrom[coordinate.x, coordinate.y])
              {
                let mut index11: i32 = this.AreaMatrixNarrow[coordinate.x, coordinate.y];
                if (index11 > 0 & aiDefend != index11 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index11].x, this.AreaCenter[index11].y].Regime), this.GetGameDataTurn()))
                {
                  nr7 = index11;
                  if (tlog)
                    this.AddLog("tracing back over friendly hexes through supplymatrixrealcamefrom we found fallback region = " + this.GetAreaName(nr7));
                }
              }
              if (nr7 == -1)
              {
                coordinate.onmap = true;
                coordinate.x = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].x;
                coordinate.y = this.AreaCenter[this.game.Data.UnitObj[groupHq4].AIDefend].y;
                for (nr7 = -1; nr7 == -1 & coordinate.onmap; coordinate = this.SupplyMatrixPrognosisCameFrom[coordinate.x, coordinate.y])
                {
                  let mut index12: i32 = this.AreaMatrixWide[coordinate.x, coordinate.y];
                  if (index12 > 0 & aiDefend != index12 && this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[index12].x, this.AreaCenter[index12].y].Regime), this.GetGameDataTurn()))
                  {
                    nr7 = index12;
                    if (tlog)
                      this.AddLog("tracing back over ENEMY hexes through supplymatrixprognosiscamefrom we found fallback region = " + this.GetAreaName(nr7));
                  }
                }
              }
              if (nr7 > -1)
              {
                let mut unitCounter8: i32 = this.game.Data.UnitCounter;
                for (let mut index13: i32 = 0; index13 <= unitCounter8; index13 += 1)
                {
                  if (this.game.Data.UnitObj[index13].PreDef == -1 && this.game.Data.UnitObj[index13].X > -1 & this.game.Data.UnitObj[index13].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index13].Regime) == this.GetGameDataTurn())
                    this.game.Data.UnitObj[index13].AIFallback = nr7;
                }
              }
            }
          }
          let mut unitCounter9: i32 = this.game.Data.UnitCounter;
          for (let mut index14: i32 = 0; index14 <= unitCounter9; index14 += 1)
          {
            if (this.game.Data.UnitObj[index14].PreDef == -1 && this.game.Data.UnitObj[index14].X > -1 & this.game.Data.UnitObj[index14].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index14].Regime) == this.GetGameDataTurn())
              this.game.Data.UnitObj[index14].AIAttackStyle = 2;
          }
          let mut nr8: i32 = this.BestStrategy.FindNr(index1 + 99000);
          if (nr8 > -1)
          {
            let mut unitCounter10: i32 = this.game.Data.UnitCounter;
            for (let mut index15: i32 = 0; index15 <= unitCounter10; index15 += 1)
            {
              if (this.game.Data.UnitObj[index15].PreDef == -1 && this.game.Data.UnitObj[index15].X > -1 & this.game.Data.UnitObj[index15].AIGroup == index1 & this.GetRegime(this.game.Data.UnitObj[index15].Regime) == this.GetGameDataTurn())
              {
                this.game.Data.UnitObj[index15].AIAttackStyle = this.BestStrategy.Data1[nr8];
                if (tlog)
                  this.AddLog("Attack Style = " + this.game.Data.UnitObj[index15].AIAttackStyle.ToString());
              }
            }
          }
        }
      }
      let mut unitCounter11: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter11; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn())
        {
          if (this.game.Data.UnitObj[index].AIAttack > -1)
          {
            let mut aiAttack: i32 = this.game.Data.UnitObj[index].AIAttack;
            if (!this.game.HandyFunctionsObj.IsAlliedOrSelf(this.GetRegime(this.game.Data.MapObj[0].HexObj[this.AreaCenter[aiAttack].x, this.AreaCenter[aiAttack].y].Regime), this.GetGameDataTurn()) && this.game.Data.UnitObj[index].AIAttackStyle == 1)
            {
              if (tlog)
                this.AddLog("Switched attack style from defensive to offensive because the group is ordered to attack enemy hex instead of hold own.");
              this.game.Data.UnitObj[index].AIAttackStyle = 3;
            }
          }
          else
          {
            if (tlog)
              this.AddLog("No Attack target specified so style is overriden with defensive.");
            this.game.Data.UnitObj[index].AIAttackStyle = 1;
          }
        }
        if (this.game.Data.UnitObj[index].AIAttackStyle == 1)
        {
          if (tlog)
            this.AddLog("If defensive style then remove attack target.");
          if (this.game.Data.UnitObj[index].AIAttack > -1 & this.game.Data.UnitObj[index].AIDefend == -1)
            this.game.Data.UnitObj[index].AIDefend = this.game.Data.UnitObj[index].AIAttack;
          this.game.Data.UnitObj[index].AIAttack = -1;
          this.game.Data.UnitObj[index].AIFollowup = -1;
        }
        if (this.game.Data.UnitObj[index].AIFollowup == this.game.Data.UnitObj[index].AIDefend)
        {
          this.game.Data.UnitObj[index].AIFollowup = -1;
          if (tlog)
            this.AddLog("removed followup because it was same as defend area");
        }
        if (this.game.Data.UnitObj[index].AIFollowup == this.game.Data.UnitObj[index].AIFallback)
        {
          this.game.Data.UnitObj[index].AIFollowup = -1;
          if (tlog)
            this.AddLog("removed followup because it was same as fallback area");
        }
        if (this.game.Data.UnitObj[index].AIFollowup == this.game.Data.UnitObj[index].AIAttack)
        {
          this.game.Data.UnitObj[index].AIFollowup = -1;
          if (tlog)
            this.AddLog("removed followup because it was same as attack area");
        }
        if (this.game.Data.UnitObj[index].AIFallback == this.game.Data.UnitObj[index].AIDefend)
        {
          if (tlog)
            this.AddLog("removed fallback because it was same as defend area");
          this.game.Data.UnitObj[index].AIFallback = -1;
        }
      }
      let mut groupCounter2: i32 = this.GroupCounter;
      for (let mut grp: i32 = 0; grp <= groupCounter2; grp += 1)
      {
        let mut groupHq: i32 = this.GetGroupHQ(grp);
        if (groupHq > -1)
        {
          if (tlog)
            this.AddLog(this.GroupName[grp] + " ... FALLBACK = " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIFallback) + ", DEF = " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIDefend) + ", ATTACK = " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIAttack) + ", FOLLOWUP= " + this.GetAreaName(this.game.Data.UnitObj[groupHq].AIFollowup) + ", STANCE = " + Conversion.Str( this.game.Data.UnitObj[groupHq].AIAttackStyle));
          this.CorpsSource[grp] = this.game.Data.UnitObj[groupHq].AIDefend;
          this.CorpsTarget[grp] = this.game.Data.UnitObj[groupHq].AIAttack;
          if (this.CorpsSource[grp] == -1)
            this.CorpsSource[grp] = this.GetStartArea(grp);
        }
      }
      bool[] flagArray1 = new bool[this.GroupCounter + 1];
      bool[] flagArray2 = new bool[this.GroupCounter + 1];
      let mut groupCounter3: i32 = this.GroupCounter;
      for (let mut index16: i32 = 0; index16 <= groupCounter3; index16 += 1)
      {
        flagArray1[index16] = true;
        flagArray2[index16] = true;
        if (this.GroupType[index16] <= 5 & this.CorpsStartLoc[index16] > 0)
        {
          let mut groupCounter4: i32 = this.GroupCounter;
          for (let mut index17: i32 = 0; index17 <= groupCounter4; index17 += 1)
          {
            if (this.GroupType[index17] <= 5 & this.CorpsStartLoc[index17] == this.CorpsStartLoc[index16] && this.CorpsStrength[index17] > this.CorpsStrength[index16])
              flagArray1[index16] = false;
            if (this.GroupType[index17] <= 5 & this.game.Data.UnitObj[index16].AIAttack == this.game.Data.UnitObj[index17].AIAttack && this.CorpsStrength[index17] > this.CorpsStrength[index16])
              flagArray2[index16] = false;
          }
        }
      }
      SimpleList simpleList = SimpleList::new();
      bool[] flagArray3 = new bool[this.game.Data.UnitCounter + 1];
      let mut groupCounter5: i32 = this.GroupCounter;
      for (let mut forgroup: i32 = 0; forgroup <= groupCounter5; forgroup += 1)
      {
        let mut nr: i32 = this.BestStrategy.FindNr(forgroup + 199000);
        if (nr > -1 && this.BestStrategy.Data1[nr] > -1)
        {
          let mut grp: i32 = this.BestStrategy.Data1[nr];
          this.WriteLog();
          if (grp > -1)
          {
            let mut Hqnr: i32 = this.GetGroupHQ(grp);
            if (Hqnr > -1)
            {
              if (!this.game.Data.UnitObj[Hqnr].IsHQ)
                Hqnr = this.game.Data.UnitObj[Hqnr].HQ;
              if (Hqnr > -1)
              {
                let mut unitCounter12: i32 = this.game.Data.UnitCounter;
                for (let mut index: i32 = 0; index <= unitCounter12; index += 1)
                {
                  if (this.game.Data.UnitObj[index].PreDef == -1 && !flagArray3[index] & this.game.Data.UnitObj[index].AIGroup == forgroup & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index].X > -1 && this.game.HandyFunctionsObj.HasUnitAirSF(index))
                  {
                    this.GetHighestFuzzyVPGroup(forgroup);
                    this.game.ProcessingObj.SetUnitHq(index, Hqnr);
                    if (tlog)
                      this.AddLog("Air from " + this.GroupName[forgroup] + " too " + this.GroupName[grp]);
                    this.game.Data.UnitObj[index].AIGroup = grp;
                    flagArray3[index] = true;
                  }
                }
              }
            }
          }
        }
      }
      if ( this.game.Data.RuleVar[832] > 0.0 & this.game.Data.Round > 1)
      {
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("INERTIA:");
          this.AddLog("");
        }
        let mut groupCounter6: i32 = this.GroupCounter;
        for (let mut grp: i32 = 0; grp <= groupCounter6; grp += 1)
        {
          let mut groupHq: i32 = this.GetGroupHQ(grp);
          if (groupHq > -1)
          {
            let mut aiAttack: i32 = this.game.Data.UnitObj[groupHq].AIAttack;
            let mut aiDefend: i32 = this.game.Data.UnitObj[groupHq].AIDefend;
            let mut aiFollowup: i32 = this.game.Data.UnitObj[groupHq].AIFollowup;
            let mut aiFallback: i32 = this.game.Data.UnitObj[groupHq].AIFallback;
            if (this.GroupAttack[grp] > 0 & this.GroupAttack[grp] != this.game.Data.UnitObj[groupHq].AIAttack && (this.game.Data.UnitObj[groupHq].AIAttackStyle == 3 | this.Attacker) & this.GroupAttack[grp] <= this.AreaCount && this.game.Data.UnitObj[groupHq].AIAttack != this.GroupFollowUp[grp] && !this.AreaIsExtra[this.GroupAttack[grp]] && this.game.HandyFunctionsObj.IsHostileNotSelf(this.game.Data.MapObj[0].HexObj[this.AreaCenter[this.GroupAttack[grp]].x, this.AreaCenter[this.GroupAttack[grp]].y].Regime, this.game.Data.Turn))
            {
              let mut unitCounter13: i32 = this.game.Data.UnitCounter;
              for (let mut index: i32 = 0; index <= unitCounter13; index += 1)
              {
                if (this.game.Data.UnitObj[index].PreDef == -1 && this.game.Data.UnitObj[index].AIGroup == grp & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() & this.game.Data.UnitObj[index].X > -1)
                {
                  if (this.GroupAttack[grp] <= this.AreaCount & this.GroupDefend[grp] <= this.AreaCount & this.GroupFollowUp[grp] <= this.AreaCount & this.GroupFallBack[grp] <= this.AreaCount)
                  {
                    if (tlog)
                      this.AddLog("Inertia called on " + this.GroupName[grp] + ". new defend=" + this.GetAreaName(this.GroupDefend[grp]) + ", new attack=" + this.GetAreaName(this.GroupAttack[grp]));
                    this.game.Data.UnitObj[index].AIAttack = this.GroupAttack[grp];
                    this.game.Data.UnitObj[index].AIDefend = this.GroupDefend[grp];
                    this.game.Data.UnitObj[index].AIFollowup = this.GroupFollowUp[grp];
                    this.game.Data.UnitObj[index].AIFallback = this.GroupFallBack[grp];
                  }
                  else
                    index = index;
                }
              }
            }
            this.GetGroupHQ(grp);
            this.GroupAttack[grp] = aiAttack;
            this.GroupDefend[grp] = aiDefend;
            this.GroupFollowUp[grp] = aiFollowup;
            this.GroupFallBack[grp] = aiFallback;
          }
        }
      }
      else if ( this.game.Data.RuleVar[832] == 1.0)
      {
        if (tlog)
        {
          this.AddLog("");
          this.AddLog("INERTIA: active. but this is round 1");
          this.AddLog("");
        }
        let mut groupCounter7: i32 = this.GroupCounter;
        for (let mut grp: i32 = 0; grp <= groupCounter7; grp += 1)
        {
          let mut groupHq: i32 = this.GetGroupHQ(grp);
          if (groupHq > -1)
          {
            this.GroupAttack[grp] = this.game.Data.UnitObj[groupHq].AIAttack;
            this.GroupDefend[grp] = this.game.Data.UnitObj[groupHq].AIDefend;
            this.GroupFollowUp[grp] = this.game.Data.UnitObj[groupHq].AIFollowup;
            this.GroupFallBack[grp] = this.game.Data.UnitObj[groupHq].AIFallback;
          }
        }
      }
      else if (tlog)
      {
        this.AddLog("");
        this.AddLog("INERTIA: not active. you can set with rulevar if you want.");
        this.AddLog("");
      }
      if (tlog)
      {
        this.AddLog("");
        this.AddLog("TEMPORARY TRANSFERS:");
        this.AddLog("");
      }
      let mut unitCounter14: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter14; index += 1)
        this.game.Data.UnitObj[index].TempGroup = -1;
      let mut groupCounter8: i32 = this.GroupCounter;
      for (let mut grp1: i32 = 0; grp1 <= groupCounter8; grp1 += 1)
      {
        let mut groupCounter9: i32 = this.GroupCounter;
        for (let mut grp2: i32 = 0; grp2 <= groupCounter9; grp2 += 1)
        {
          let mut groupHq5: i32 = this.GetGroupHQ(grp1);
          let mut groupHq6: i32 = this.GetGroupHQ(grp2);
          if (groupHq5 > -1 & groupHq6 > -1 && this.CorpsStartLoc[grp1] == this.CorpsStartLoc[grp2] && this.game.Data.UnitObj[groupHq5].AIAttack == this.game.Data.UnitObj[groupHq6].AIAttack && this.game.Data.UnitObj[groupHq5].AIDefend == this.game.Data.UnitObj[groupHq6].AIDefend && this.game.Data.UnitObj[groupHq5].AIFollowup == this.game.Data.UnitObj[groupHq6].AIFollowup && this.CorpsLandStrength[grp1] > this.CorpsLandStrength[grp2])
          {
            let mut unitCounter15: i32 = this.game.Data.UnitCounter;
            for (let mut index: i32 = 0; index <= unitCounter15; index += 1)
            {
              if (this.game.Data.UnitObj[index].AIGroup == grp2 & this.GetRegime(this.game.Data.UnitObj[index].Regime) == this.GetGameDataTurn() && this.game.Data.UnitObj[index].X > -1 & this.game.Data.UnitObj[index].PreDef == -1)
              {
                if (this.GetGroupUnits(grp1) < 50 & !(this.game.Data.UnitObj[index].TempCategory == 2 | this.game.Data.UnitObj[index].TempCategory == 3))
                {
                  if (index != groupHq6 | !this.game.Data.UnitObj[groupHq6].IsHQ)
                  {
                    this.game.Data.UnitObj[index].AIGroup = grp1;
                    if (this.game.Data.UnitObj[index].TempGroup == -1)
                      this.game.Data.UnitObj[index].TempGroup = grp2;
                    if (tlog)
                      this.AddLog("TEMPORARILY TRANSFER " + this.game.Data.UnitObj[index].Name + ", ORIGNAL FROM= " + this.GroupName[this.game.Data.UnitObj[index].TempGroup] + ", NOW FROM " + this.GroupName[grp2] + " TO " + this.GroupName[grp1]);
                  }
                }
                else if (this.GetGroupUnits(grp1) < 60 & (this.game.Data.UnitObj[index].TempCategory == 2 | this.game.Data.UnitObj[index].TempCategory == 3) && index != groupHq6 | !this.game.Data.UnitObj[groupHq6].IsHQ)
                {
                  this.game.Data.UnitObj[index].AIGroup = grp1;
                  if (this.game.Data.UnitObj[index].TempGroup == -1)
                    this.game.Data.UnitObj[index].TempGroup = grp2;
                  if (tlog)
                    this.AddLog("TEMPORARILY TRANSFER " + this.game.Data.UnitObj[index].Name + ", ORIGNAL FROM= " + this.GroupName[this.game.Data.UnitObj[index].TempGroup] + ", NOW FROM " + this.GroupName[grp2] + " TO " + this.GroupName[grp1]);
                }
              }
            }
          }
        }
      }
    }

    pub fn MakeTempMovementTypes(bool tlog)
    {
      if (tlog)
        this.AddLog("MAKETEMPMOVEMENTTYPES");
      if (tlog)
        this.AddLog("");
      let mut unitCounter: i32 = this.game.Data.UnitCounter;
      for (let mut index: i32 = 0; index <= unitCounter; index += 1)
      {
        if (this.game.Data.UnitObj[index].PreDef == -1)
        {
          this.MakeTempMovementType(index);
          if (tlog)
          {
            str1: String = Strings.Trim(Conversion.Str( index)) + ", " + this.game.Data.UnitObj[index].Name;
            str2: String = this.game.Data.UnitObj[index].TempType <= -1 ? str1 + "TempType = -1 " : str1 + "TempType = " + this.game.Data.TempString[this.game.Data.UnitObj[index].TempType];
            this.AddLog((this.game.Data.UnitObj[index].TempTypeRoad <= -1 ? str2 + ", TempTypeRoad = -1 " : str2 + ", TempTypeRoad = " + this.game.Data.TempString[this.game.Data.UnitObj[index].TempTypeRoad]) + " TempTheater = " + Strings.Trim(Conversion.Str( this.game.Data.UnitObj[index].TempTheater)));
          }
        }
      }
    }

    pub fn MakeTempMovementType(unr: i32)
    {
      if (this.game.Data.UnitObj[unr].PreDef > -1)
        return;
      let mut num1: i32 = !this.game.HandyFunctionsObj.HasUnitNavySF(unr) ? (!this.game.HandyFunctionsObj.HasUnitAirSF(unr) ? (!this.game.HandyFunctionsObj.HasUnitlandSF(unr) ? -1 : 0) : 2) : 1;
      if (this.game.Data.UnitObj[unr].IsHQ)
        num1 = num1;
      if (num1 == -1)
        num1 = 0;
      let mut num2: i32 = this.game.HandyFunctionsObj.GetLowestSpeed(unr, -1);
      if (num2 == -1)
        num2 = 0;
      this.game.Data.UnitObj[unr].TempType = num2;
      let mut num3: i32 = this.game.HandyFunctionsObj.GetLowestSpeedOnRoad(unr, -1);
      if (num3 == -1)
        num3 = 0;
      this.game.Data.UnitObj[unr].TempTypeRoad = num3;
      this.game.Data.UnitObj[unr].TempTheater = num1;
    }
  }
}
